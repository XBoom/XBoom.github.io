<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XBoom Dove</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xboom.github.io/"/>
  <updated>2023-04-05T03:33:14.176Z</updated>
  <id>http://xboom.github.io/</id>
  
  <author>
    <name>XBoom Dove</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go入门15-SyncMap</title>
    <link href="http://xboom.github.io/2023/04/04/Go/Go%E5%85%A5%E9%97%A815-SyncMap/"/>
    <id>http://xboom.github.io/2023/04/04/Go/Go%E5%85%A5%E9%97%A815-SyncMap/</id>
    <published>2023-04-04T13:01:05.349Z</published>
    <updated>2023-04-05T03:33:14.176Z</updated>
    
    <content type="html"><![CDATA[<p>一开始以为 <code>Sync.Map</code> 仅仅是封装的了一层，后来在与同事的讨论中发现并不是这样，这里重新学习一下源码</p><h3 id="线程安全"><a class="markdownIt-Anchor" href="#线程安全"></a> 线程安全</h3><p>首先搞清楚一个问题，什么是并发安全。由于没有完整的解释，我找了一段Java中的表达</p><blockquote><p>当多个线程访问某个类时，不管运行环境采用何种调度方式或者这些进程将如何交替执行，并且在主调代码中不需要任何额外的协同或者同步，这个类都能表现出正确的行为，那么这个类是线程安全的</p></blockquote><p>大致抓住两点 <strong>无论如何交替执行</strong> <strong>表现出正确的行为</strong>，有点抽象，反过来问 <strong>什么情况会导致线程不安全</strong>？<strong>怎样才能保证线程安全？</strong></p><p><u>当前的一个操作可能不是原子的，执行过程中会被打断，其他线程有能力修改共享变量的值，同时存在线程修改的值不是立即对其他线程可见的，因为线程有自己的执行空间，另外一点就是存在程序可能存在乱序执行的情况，单线程没问题，但是多个线程同时执行，线程共享的数据会出现错乱</u>。那么保证线程安全的三个特征：</p><ul><li><strong>原子性</strong>：提供互斥访问、同一时刻只能有一个线程在操作</li><li><strong>可见性</strong>：一个线程对主内容的修改可以及时被其他线程看到</li><li><strong>有序性</strong>：程序在执行的时候，程序的代码执行顺序和语句的顺序是一致的有序性<ul><li>多个协程并发执行，那么<strong>几个协程之间是没有有序性的</strong>，但是协程里面的代码是有序的</li><li>什么情况下代码的执行顺序与语句顺序不一致？比如指令重排序，将多次访问主存合并到一起执行</li></ul></li></ul><p>这样就好理解为啥普通的map会存在并发安全问题了，因为一个协程的修改对于另外一个协程可能是不可见的。另外当map并发读写时候触发的panic是map内部实现的，结构体的并发读写只会报错不会panic。</p><h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3><p>普通的map并发处理实践</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="keyword">struct</span>&#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)&#125;</span><br></pre></td></tr></table></figure><p>使用 sync.Map 则可以</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter sync.Map</span><br></pre></td></tr></table></figure><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>源码：<code>src/sync/map.go</code></p><p>为了实现并发安全的Map，<code>Sync.Map</code>实现了一种读写分离的方式</p><ol><li>空间换时间。 通过冗余的两个数据结构(read、dirty),实现加锁对性能的影响。</li><li>动态调整，miss次数多了之后，将dirty数据提升为read。</li><li>double-checking，因为是判断与获取并不是原子操作，所以会出现 double-checking</li><li>延迟删除。 删除一个键值只是打标记，只有在提升dirty的时候才清理删除的数据。</li><li>优先从read读取、更新、删除，因为对read的读取不需要锁。</li></ol><p><strong>问题1</strong>：如何在并发情况下修改或删除已经存在的Key？</p><p>答：通过将 key 映射到 val 的地址，然后 val 指针指向真正的值，那么只需要保证 <code>address</code> 指针的原子操作，就能解决并发安全问题</p><blockquote><p>key -&gt; &amp;地址 --&gt; 真正的值</p></blockquote><p><strong>问题2</strong>：如何在写的同时保证读的准确性</p><p>答：读写指向的是同一个指针，首先在写时会通过互斥锁防止并发操作 <code>dirty</code>，其次就是用到了<code>atomic</code>原子操作<code>value</code>指针</p><p><strong>问题3</strong>：如果读写分离，如何将写入的数据同步到读中</p><p>答： 第一种是当<code>misses == len(dirty)</code>的时候就会升级<code>dirty</code>到<code>read</code>中；第二种就是在遍历的如果<code>dirty</code>有<code>read</code>中没有的数据；</p><p>第三其实也不是读写分离，而是乐观锁，因为如果<code>read</code>中已经有key/val，也会尝试去更新<code>read</code>，发现已经删除，则去dirty中更新</p><p>最后的实现就变成了下面这个样子</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/20200505120255.png" alt="sync.map 整体结构" style="zoom:50%;" /><p><strong>问题4</strong>：指向的是同一个<code>entry</code>，不还是一样需要加锁吗？内部 的<code>mutex</code> 与 <code>atomic.pointer</code>的区别跟作用又是什么？</p><p><code>mutex</code> 与 <code>atomic</code> 的区别是：<code>mutex</code> 通过阻塞其他协程起到了原子操作的功能，是用来保护 dirty 的读写的。而<code>atomic</code>是通过CPU指令，来达到值操作的原子性，所以 <code>atomic</code>与<code>mutex</code>并不是一个层面的东西，<code>atomic</code>也比<code>mutex</code>更快。</p><p>所以才会出现 <code>mutex</code> 保护的是 <code>dirty</code>，而 <code>atomic</code> 保护的是 <code>entry</code> 具体值</p><h4 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h4><p>定义的 <code>Map</code> 中 除普通的map 与 互斥锁，还增加了两个字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">//当涉及到dirty的操作的时候，需要使用这个锁</span></span><br><span class="line">   mu Mutex</span><br><span class="line">  <span class="comment">// 一个只读结构(实际也会更新这个数据的entries，标记为未删除的unexpunger)</span></span><br><span class="line">   read atomic.Pointer[readOnly]</span><br><span class="line">  <span class="comment">// dirty包含最新的entries(包括read中未删除的数据,虽有冗余，但也提升dirty字段为read的时候非常快，不用一个一个的复制，而是直接将这个数据结构作为read字段的一部分),有些数据还可能没有移动到read字段中。</span></span><br><span class="line"><span class="comment">// 对于dirty的操作需要加锁，因为对它的操作可能会有读写竞争。</span></span><br><span class="line"><span class="comment">// 当dirty为空的时候， 比如初始化或者刚提升完，下一次的写操作会复制read字段中未删除的数据到这个数据中。</span></span><br><span class="line">   dirty <span class="keyword">map</span>[any]*entry</span><br><span class="line">  <span class="comment">// 当从Map中读取entry的时候，如果read中不包含这个entry,会尝试从dirty中读取，这个时候会将misses加一，</span></span><br><span class="line"><span class="comment">// 当misses累积到 dirty的长度的时候， 就会将dirty提升为read,避免从dirty中miss太多次。因为操作dirty需要加锁</span></span><br><span class="line">   misses <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中存在两个结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">m       <span class="keyword">map</span>[any]*entry</span><br><span class="line">amended <span class="keyword">bool</span> <span class="comment">// 如果Map.dirty有些数据不在中的时候，这个值为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基本"><a class="markdownIt-Anchor" href="#基本"></a> 基本</h4><ol><li><code>read</code> 与 <code>dirty</code> 的转换</li><li><code>entry</code>的操作</li></ol><h5 id="entry"><a class="markdownIt-Anchor" href="#entry"></a> entry</h5><p><code>entry</code> 代表的是每个 key 在<code>Map</code>中对应的一个 <code>entry</code>，并且还记录了 <strong>其他信息</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">p atomic.Pointer[any]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> expunged = <span class="built_in">new</span>(any) <span class="comment">//</span></span><br></pre></td></tr></table></figure><p><code>p</code> 一共记录林 <code>entry</code> 的三种状态</p><ol><li><code>nil</code>: <code>entry</code>已被删除了，并且<code>m.dirty</code>为<code>nil</code></li><li><code>expunged</code>: <code>entry</code>已被删除了，并且<code>m.dirty</code>不为<code>nil</code>，而且这个<code>entry</code>不存在于<code>m.dirty</code>中</li><li>其它： <code>entry</code>是一个正常的值</li></ol><p>构建一个 <code>entry</code> 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newEntry</span><span class="params">(i any)</span> *<span class="title">entry</span></span> &#123;</span><br><span class="line">   e := &amp;entry&#123;&#125;</span><br><span class="line">   e.p.Store(&amp;i)</span><br><span class="line">   <span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">load</span><span class="params">()</span> <span class="params">(value any, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">p := e.p.Load()</span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;<span class="comment">//表示不存在</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *p, <span class="literal">true</span><span class="comment">//表示存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>entry</code> 使用 <code>atomic.Pointer[n]</code> 的作用在后面才体现出来, <code>atomic.Pointer</code> 原子地读取和存储指针类型的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">trySwap</span><span class="params">(i *any)</span> <span class="params">(*any, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      p := e.p.Load()</span><br><span class="line">      <span class="keyword">if</span> p == expunged &#123;<span class="comment">//如果已经被删除则返回false</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> e.p.CompareAndSwap(p, i) &#123;<span class="comment">//否则不断的CAS更新</span></span><br><span class="line">         <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h4><p>操作与正常的map类似，包含 存储、获取、删除、遍历。除此之外还增加的 交换、比较交换、比较删除</p><h5 id="获取"><a class="markdownIt-Anchor" href="#获取"></a> 获取</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Load</span><span class="params">(key any)</span> <span class="params">(value any, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1.首先从m.read中得到只读readOnly,从它的map中查找，不需要加锁</span></span><br><span class="line">  read := m.loadReadOnly()</span><br><span class="line">e, ok := read.m[key]</span><br><span class="line">  <span class="comment">//2. 如果没找到，并且m.dirty中有新数据，需要从m.dirty查找，这个时候需要加锁</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123; <span class="comment">// a 操作</span></span><br><span class="line">m.mu.Lock()  <span class="comment">//b 操作</span></span><br><span class="line">    <span class="comment">//双检查，避免加锁的时候m.dirty提升为m.read,这个时候m.read可能被替换了。</span></span><br><span class="line">read = m.loadReadOnly()</span><br><span class="line">e, ok = read.m[key]</span><br><span class="line">    <span class="comment">// 如果m.read中还是不存在，并且m.dirty中有新数据</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">      <span class="comment">// 从m.dirty查找</span></span><br><span class="line">e, ok = m.dirty[key]</span><br><span class="line">      <span class="comment">// 不管m.dirty中存不存在，都将misses计数加一</span></span><br><span class="line"><span class="comment">// missLocked()中满足条件后就会提升m.dirty</span></span><br><span class="line">m.missLocked()</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个注意事项</p><ol><li><p>出现double-check，是因为在执行 <code>if !ok &amp;&amp; read.amended</code> 的过程中，dirty可能升级为read，所以还是需要锁操作</p></li><li><p>不管 m.dirty中是否存在，都需要misses+1，表明 read中不存在才到 dirty中获取</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">missLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">m.misses++</span><br><span class="line"><span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">m.read.Store(&amp;readOnly&#123;m: m.dirty&#125;)<span class="comment">//直接将dirty升级到read中，然后</span></span><br><span class="line">m.dirty = <span class="literal">nil</span></span><br><span class="line">m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>什么时候讲dirty提升为 read，当 <code>misses &gt;= len(m.dirty)</code></p><h5 id="存储"><a class="markdownIt-Anchor" href="#存储"></a> 存储</h5><p>从接口实现可以看出，存储 k/v 内部使用的其实 Swap 接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Store</span><span class="params">(key, value any)</span></span> &#123;</span><br><span class="line">   _, _ = m.Swap(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接查看 <code>Swap</code> 的实现原理</p><p>根据描述，<code>Swap</code> 的作用是 将 <code>newValue</code> 更新入 <code>key</code> 所对应的 <code>value</code>中，并将 <code>oldValue</code> 返回。另外一个返回值<code>loaded</code>表示 <code>key</code> 是否存在</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Swap</span><span class="params">(key, value any)</span> <span class="params">(previous any, loaded <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 如果m.read存在这个键，并且这个entry没有被标记删除，尝试直接存储。</span></span><br><span class="line"><span class="comment">// 因为m.dirty也指向这个entry,所以m.dirty也保持最新的entry。</span></span><br><span class="line">   read := m.loadReadOnly()</span><br><span class="line">   <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;<span class="comment">//如果只读存在</span></span><br><span class="line">      <span class="keyword">if</span> v, ok := e.trySwap(&amp;value); ok &#123;<span class="comment">//尝试去更新value，如果未 标记删除</span></span><br><span class="line">         <span class="keyword">if</span> v == <span class="literal">nil</span> &#123;<span class="comment">//value为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> *v, <span class="literal">true</span><span class="comment">//更新成功 返回 true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   m.mu.Lock()<span class="comment">// 加锁，如果`m.read`不存在或者已经被标记删除</span></span><br><span class="line">   read = m.loadReadOnly()</span><br><span class="line">   <span class="keyword">if</span> e, ok := read.m[key]; ok &#123; <span class="comment">//只读存在</span></span><br><span class="line">     <span class="keyword">if</span> e.unexpungeLocked() &#123;<span class="comment">//如果未标记删除则删除read,然后存入dirty(写数据到dirty中)</span></span><br><span class="line">         m.dirty[key] = e<span class="comment">//存入 dirty</span></span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">if</span> v := e.swapLocked(&amp;value); v != <span class="literal">nil</span> &#123;<span class="comment">//未标记删除则直接更新read</span></span><br><span class="line">         loaded = <span class="literal">true</span></span><br><span class="line">         previous = *v</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;<span class="comment">//只读不存在但是dirty存在</span></span><br><span class="line">      <span class="keyword">if</span> v := e.swapLocked(&amp;value); v != <span class="literal">nil</span> &#123;</span><br><span class="line">         loaded = <span class="literal">true</span></span><br><span class="line">         previous = *v</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;<span class="comment">//都不存在</span></span><br><span class="line">      <span class="keyword">if</span> !read.amended &#123;<span class="comment">//dirty中没有新值</span></span><br><span class="line">         m.dirtyLocked()<span class="comment">//如果dirty为空，从 m.read中复制未删除的数据</span></span><br><span class="line">         m.read.Store(&amp;readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;) <span class="comment">//read中存储</span></span><br><span class="line">      &#125;</span><br><span class="line">      m.dirty[key] = newEntry(value)<span class="comment">//dirty 存储一个新的 value地址</span></span><br><span class="line">   &#125;</span><br><span class="line">   m.mu.Unlock()</span><br><span class="line">   <span class="keyword">return</span> previous, loaded</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>dirtyLocked的</code>作用是将未删除的复制到<code>dirty</code>中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">dirtyLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;<span class="comment">//如果不为空直接返回</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   read := m.loadReadOnly()</span><br><span class="line">   m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[any]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line">   <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">      <span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">         m.dirty[k] = e</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">tryExpungeLocked</span><span class="params">()</span> <span class="params">(isExpunged <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   p := e.p.Load()<span class="comment">//加载entry中的地址</span></span><br><span class="line">   <span class="keyword">for</span> p == <span class="literal">nil</span> &#123;<span class="comment">//如果为空</span></span><br><span class="line">      <span class="keyword">if</span> e.p.CompareAndSwap(<span class="literal">nil</span>, expunged) &#123;<span class="comment">//尝试使用 expunged更新状态</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      p = e.p.Load()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> p == expunged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Delete</span><span class="params">(key any)</span></span> &#123;</span><br><span class="line">m.LoadAndDelete(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">LoadAndDelete</span><span class="params">(key any)</span> <span class="params">(value any, loaded <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//先从read中加载</span></span><br><span class="line">read := m.loadReadOnly()</span><br><span class="line">e, ok := read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;<span class="comment">//read没有且dirty中有新数据</span></span><br><span class="line">    <span class="comment">//开启锁</span></span><br><span class="line">m.mu.Lock()</span><br><span class="line">read = m.loadReadOnly()</span><br><span class="line">e, ok = read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;<span class="comment">//如果read没有，则dirty中有新数据</span></span><br><span class="line">e, ok = m.dirty[key]</span><br><span class="line"><span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">      m.missLocked()<span class="comment">//当misses数量达到 len(m.dirty),dirty升级为read</span></span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">return</span> e.<span class="built_in">delete</span>()<span class="comment">//如果read存在则标记删除</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果read中存在，那么仅会标记删除</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">delete</span><span class="params">()</span> <span class="params">(value any, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      p := e.p.Load()</span><br><span class="line">      <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;<span class="comment">//如果为空或者标记删除，返回没有数据</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> e.p.CompareAndSwap(p, <span class="literal">nil</span>) &#123;<span class="comment">//标记为nil，并不会直接删除</span></span><br><span class="line">         <span class="keyword">return</span> *p, <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遍历"><a class="markdownIt-Anchor" href="#遍历"></a> 遍历</h5><p>因为是读写分离，所以在遍历的过程中</p><ol><li>如果dirty中没有新数据，那么就使用read遍历</li><li>如果dirty中有新数据，那么就将dirty升级为read，然后遍历read</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Range</span><span class="params">(f <span class="keyword">func</span>(key, value any)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">   <span class="comment">//判断dirty是否有新值</span></span><br><span class="line">   read := m.loadReadOnly()</span><br><span class="line">   <span class="keyword">if</span> read.amended &#123;</span><br><span class="line">      m.mu.Lock()<span class="comment">//开锁</span></span><br><span class="line">      read = m.loadReadOnly()</span><br><span class="line">      <span class="keyword">if</span> read.amended &#123;<span class="comment">//dirty是否有新值</span></span><br><span class="line">         read = readOnly&#123;m: m.dirty&#125;</span><br><span class="line">         m.read.Store(&amp;read)<span class="comment">//升级dirty为read</span></span><br><span class="line">         m.dirty = <span class="literal">nil</span></span><br><span class="line">         m.misses = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">      m.mu.Unlock()</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//遍历read</span></span><br><span class="line">   <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">      v, ok := e.load()</span><br><span class="line">      <span class="keyword">if</span> !ok &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> !f(k, v) &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3><ol><li><p>该map仅针对特定的场景</p><ul><li>Key 读多写少的情况，例如只增长的缓存</li><li>多个协程针对不同的key合集进行读写更新时候可以用</li><li>sync.Map 不能在第一次使用后复制</li></ul></li><li><p>由于dirty达到一定条件就需要升级为read，所以适用读多写少的场景</p></li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://www.cnblogs.com/qcrao-2018/p/12833787.html" target="_blank" rel="noopener">https://www.cnblogs.com/qcrao-2018/p/12833787.html</a></li><li><a href="https://colobu.com/2017/07/11/dive-into-sync-Map/#sync-Map%E7%9A%84%E6%80%A7%E8%83%BD" target="_blank" rel="noopener">https://colobu.com/2017/07/11/dive-into-sync-Map/#sync-Map的性能</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一开始以为 &lt;code&gt;Sync.Map&lt;/code&gt; 仅仅是封装的了一层，后来在与同事的讨论中发现并不是这样，这里重新学习一下源码&lt;/p&gt;
&lt;h3 id=&quot;线程安全&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线程安全&quot;&gt;&lt;/a&gt; 线程安全&lt;
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go入门24-协程池问题</title>
    <link href="http://xboom.github.io/2023/03/05/Go/Go%E5%85%A5%E9%97%A824-%E5%8D%8F%E7%A8%8B%E6%B1%A0%E9%97%AE%E9%A2%98/"/>
    <id>http://xboom.github.io/2023/03/05/Go/Go%E5%85%A5%E9%97%A824-%E5%8D%8F%E7%A8%8B%E6%B1%A0%E9%97%AE%E9%A2%98/</id>
    <published>2023-03-05T06:46:45.000Z</published>
    <updated>2023-04-05T04:17:47.389Z</updated>
    
    <content type="html"><![CDATA[<p>之前在整理 <a href="https://www.yuankang.top/2022/07/06/GoZero/GoZero4-%E5%8D%8F%E7%A8%8B%E6%B1%A01/" target="_blank" rel="noopener">GoZero4-协程池</a>的过程中发现 <a href="https://github.com/bytedance/gopkg/tree/develop/util/gopool" target="_blank" rel="noopener">字节跳动开源的协程池</a>在使用中需要注意的地方：</p><p>​<strong>使用双向链表存储任务，表示它理论上支持无限个任务。后面的任务可能存在长时间等待的情况，并不存在任务过期处理逻辑</strong></p><p>没想到在实际应用中真的没注意踩了一遍，这里记录一下这个原因与后续的解决思路，排查过程就不赘述了。</p><p>伪代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Send</span><span class="params">(conn *grpc.ClientConn)</span></span> &#123;</span><br><span class="line">c := pb.NewGreeterClient(conn)</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">3</span>*time.Second)</span><br><span class="line"></span><br><span class="line">gopool.CtxGo(ctx, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="comment">//1. 通信消息自定义处理</span></span><br><span class="line">Handle(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 发送消息</span></span><br><span class="line">_, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: *name&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"could not greet: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="comment">//log.Printf("end success")</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">5</span>):</span><br><span class="line">log.Printf(<span class="string">"time out"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题原因</strong>：负责底层通信的 grpc-go(进行过二次开发) 使用了上述的协程池进行发送接口的超时控制。当突然大量的消息进入，消息接受速率 大于 消息发送-响应速率。导致过量的消息全部堆积到这个双向链表中，而本身消息是有超时时间的，就导致堆积的消息越来越多，消息等到发送的时候已经超时了，所以就出现了服务OOM，消息也无法发送出去。</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/%E5%8D%8F%E7%A8%8B%E6%B1%A0%E9%97%AE%E9%A2%982.png" alt="协程池问题2" style="zoom:50%;" /><p>类似上图所示，模拟客户端通过协程池的发送协程 <strong>work</strong> 实现超时控制消息任务 <strong>t</strong> 的发送</p><ul><li>第一阶段，发送协程 <strong>work</strong> 的消费速率 大于 消息任务 <strong>t</strong> 的生产速率，一切正常</li><li>第二阶段，发送协程 <strong>work</strong> 的消费速率 小于 消息任务 <strong>t</strong> 的生产速率的时候，消息开始在双向链表中堆积，出现内存快速增长</li><li>第三阶段，当 消息任务 <strong>t</strong> 的堆积 超过自定义超时时间的时候，所有消息都发送超时失败</li><li>第四阶段，当 双向链表中的任务堆积导致内存超时服务上限的时候，服务OOM</li></ul><p>这里产生了如下几个思考</p><ol><li>能否在任务双向链表中限制数量大小当发送超过限制的时候直接失败?</li><li>为什么不直接使用管道来代替底层的双向链表？</li><li>能否自动丢弃超时的消息并返回结果，注意这个时候是在协程里面运行的</li><li>如何像linux一样保存 pod因为OOM而产生的core方便后续分析</li></ol><p>第一个问题是可以解决的，协程池对象存在 taskCount 记录当前任务数量，也就是说可以增加协程池容量判断来达到限制目的</p><ul><li>增加协程池任务容量字段 <code>taskCap</code></li><li>增加接口，协程失败返回错误 error</li><li>添加协程池容量判断</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pool)</span> <span class="title">CtxGo2</span><span class="params">(ctx context.Context, f <span class="keyword">func</span>()</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">  cur := atomic.AddInt32(&amp;p.taskCount, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> cur &gt; p.taskCap &#123;<span class="comment">//当前任务容量判断</span></span><br><span class="line"><span class="keyword">return</span> errors.New</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个问题管道的缺点是管道数量是固定的，也就是达不到根据任务数量动态扩容 <code>work</code> 的功效</p><p>第三个问题由于任务放入协程中相当于异步处理，并不能直接将任务待执行超时的情况返回给客户端，可以通过自定义处理函数或者内部的panic处理任务超时的情况；但又能如何发现任务超时，时间轮貌似是个好东西</p><p>第四个问题找到<a href="https://juejin.cn/post/6844903792136159239" target="_blank" rel="noopener">一篇实践</a>，实操之后再单独记录</p><p>总结：</p><ol><li>我在使用过程中忽视了双向队列任务堆积的情况，令牌桶的使用也可能存在这样的情况(正常情况不会配置速率上千万的情况)，注意异常情况下的配置范围</li><li>上述需要改进与实操的部分尝试解决之后再来补充这边文章</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在整理 &lt;a href=&quot;https://www.yuankang.top/2022/07/06/GoZero/GoZero4-%E5%8D%8F%E7%A8%8B%E6%B1%A01/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GoZero4-协
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>算法-E10C-最大公约数</title>
    <link href="http://xboom.github.io/2023/02/02/Algorithms%20To%20Live%20By/%E7%AE%97%E6%B3%95-E10C-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"/>
    <id>http://xboom.github.io/2023/02/02/Algorithms%20To%20Live%20By/%E7%AE%97%E6%B3%95-E10C-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</id>
    <published>2023-02-02T12:25:25.494Z</published>
    <updated>2023-02-15T13:39:32.337Z</updated>
    
    <content type="html"><![CDATA[<p>今天碰到一道有意思的题目，学到了很多东西，所以记录一下</p><p><a href="https://leetcode.cn/problems/check-if-it-is-a-good-array/" target="_blank" rel="noopener">检查好数组</a></p><p>碰到之后完全不知道如何入手，最后通过看解答才弄明白，但是中间有很多知识点可以记录一下</p><p><strong>首先</strong> 需要知道裴蜀定理，又称贝祖定理，是一个最大公约数定理：设 a, b 是不全为零的整数，则存在整数 x , y , 使得</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ax + by = gcd(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span></p><ol><li><p>若任何一个等于0，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">gcd(a, b) == a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span></p></li><li><p>对任何整数a、b和它们的最大公约数d，关于未知数x和y的线性丢番图方程</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">ax + by = m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span></span></p><p>有解当前仅当 m 是 d 的倍数</p></li></ol><blockquote><p>这里有一个奇特的点 0 因为没有因数，所以 0 不与其他数存在最大公约数，等我看了 类欧几里德算法 再补充</p></blockquote><p>所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ax + by = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 有解，那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(a, b) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><p>其次 我们如何求一个两个数的最大公约数，经典的 <strong>辗转相除法</strong>(又称 <strong>欧几里德算法</strong>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以使用现有函数 gcd(a, b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b ? GCD(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>证明 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a, b) = gcd(b, a \% b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 过程如下</p><ol><li><p>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi><mi>k</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a = bk + c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>，所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">c = a \% b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span></span></span></span></p></li><li><p>设 d 是 a , b 的公约数</p></li><li><p>所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>=</mo><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>∗</mo><mi>k</mi><mo>+</mo><mi>c</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">a / d = b / d * k + c / d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span></p></li><li><p>因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">a / d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">b / d * k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 是整数，所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">c / d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span> 也是整数</p></li><li><p>将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">c = a \% b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span></span></span></span> 带入第3步得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>−</mo><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>∗</mo><mi>k</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">a / d - b / d * k = a \% b / d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span>，因为 左边是整数，所有等式右边也是整数</p></li><li><p>那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>+</mo><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">a / d = a \% b / d + b / d * k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，那么 d 也是  b, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">a \% b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span></span></span></span> 的约数，也是 a, b 的约数</p></li><li><p>尽然两式的公约数是相同的，那么最大公约数也会相同</p></li><li><p>所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a, b) = gcd(b, a mod b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p></li></ol><p>最后就是这个题目的解答</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b ? Gcd(b, a % b) : a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isGoodArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//1与任意正整数的最大公约数是1</span></span><br><span class="line">            v = Gcd(nums[i], v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://oi-wiki.org/math/number-theory/gcd/" target="_blank" rel="noopener">https://oi-wiki.org/math/number-theory/gcd/</a></li><li><a href="https://leetcode.cn/problems/check-if-it-is-a-good-array/" target="_blank" rel="noopener">https://leetcode.cn/problems/check-if-it-is-a-good-array/</a></li><li><a href="https://oi-wiki.org/math/number-theory/bezouts/" target="_blank" rel="noopener">https://oi-wiki.org/math/number-theory/bezouts/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天碰到一道有意思的题目，学到了很多东西，所以记录一下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/check-if-it-is-a-good-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;检查好
      
    
    </summary>
    
    
      <category term="Algorithms To Live By" scheme="http://xboom.github.io/categories/Algorithms-To-Live-By/"/>
    
    
      <category term="Algorithms To Live By" scheme="http://xboom.github.io/tags/Algorithms-To-Live-By/"/>
    
  </entry>
  
  <entry>
    <title>Go入门23-arena</title>
    <link href="http://xboom.github.io/2023/01/10/Go/Go%E5%85%A5%E9%97%A823-arena/"/>
    <id>http://xboom.github.io/2023/01/10/Go/Go%E5%85%A5%E9%97%A823-arena/</id>
    <published>2023-01-10T08:00:20.000Z</published>
    <updated>2023-04-05T04:17:42.941Z</updated>
    
    <content type="html"><![CDATA[<p>最近 <code>Go1.20</code> 更新，中间讲到了一个特性 <code>arena</code> ，这里看看加入 <code>arena</code> 的作用</p><blockquote><p>在Go的内存管理中，<code>arena</code> 其实就是所谓的堆区，然后将这个区域分割成 <code>8KB</code> 大小的页，组合起来称为 <code>mspan</code>，<code>mspan</code>就是Go中内存管理的基本单元，是由一片连续的 8KB 的页组成的大块内存。其实 <code>mspan</code> 是一个包含起始地址、规格、页的数量等内容的双端链表</p></blockquote><p>虽然 Go 的垃圾回收机制能够正常的进行内存管理，但是存在以下问题</p><ol><li>垃圾回收机制需要花费大量CPU进行垃圾回收操作</li><li>垃圾回收机制有一定的延迟性，导致花费的内存比实际的内存要大</li></ol><p>而 <code>arena</code> 的优势 <strong>允许从连续的内存空间中分配对象并一次性进行释放</strong></p><p>注意：在 <a href="https://github.com/golang/go/issues/51317" target="_blank" rel="noopener">github arena 的话题</a>中，有一个最新的笔记提醒, 即处在测试阶段的 arena 功能随时可能被去除掉</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Note, 2023-01-17. This proposal is on hold indefinitely due to serious API concerns. The GOEXPERIMENT=arena code may be changed incompatibly or removed at any time, and we do not recommend its use in production.</span><br></pre></td></tr></table></figure><p>带着问题看世界：</p><ol><li>它跟内存池的区别</li><li>由于需要连续的内存空间，那么当需要分配的内存比较多，没有这么大的连续内存空间怎么办？</li><li>如果它分配的对象有一部分存在内存逃逸，那么该如何处理？</li><li>能支持并发吗</li></ol><h3 id="基础功能"><a class="markdownIt-Anchor" href="#基础功能"></a> 基础功能</h3><p>由于是实验功能，所以需要配置环境变量 <code>GOEXPERIMENT=arenas</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"arena"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;</span><br><span class="line">Foo <span class="keyword">string</span></span><br><span class="line">Bar [<span class="number">16</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processRequest</span><span class="params">(req *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// Create an arena in the beginning of the function.</span></span><br><span class="line">mem := arena.NewArena()</span><br><span class="line"><span class="comment">// Free the arena in the end.</span></span><br><span class="line"><span class="keyword">defer</span> mem.Free()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a bunch of objects from the arena.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">obj := arena.New[T](mem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or a slice with length and capacity.</span></span><br><span class="line">slice := arena.MakeSlice[T](mem, <span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想在arena释放时候继续使用它分配的对象，则可以通过 Clone 从堆中浅拷贝一个对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj1 := arena.New[T](mem) <span class="comment">// arena-allocated</span></span><br><span class="line">obj2 := arena.Clone(obj1) <span class="comment">// heap-allocated</span></span><br><span class="line">fmt.Println(obj2 == obj1) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">mem.Free()</span><br></pre></td></tr></table></figure><p>其他接口包括</p><ul><li><code>NewArena</code>：创建一个新的 arena 内存空间。</li><li><code>Free</code>：释放 arena 及其关联对象。</li><li><code>New</code>：基于 arena，创建新对象。</li><li><code>MakeSlice</code>：基于 arena，创建新切片。</li><li><code>Clone</code>：克隆一个 arena 的对象，并移动到内存堆上。<strong>只能是指针、slice或者字符串</strong></li></ul><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>代码路径：</p><ol><li><code>src/runtime/arena.go</code></li><li><code>src/arena/arena.go</code></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arena 表示多个Go一起分配与释放的内存集合，当其中的对象不在被引用那么将会自动释放</span></span><br><span class="line"><span class="keyword">type</span> Arena <span class="keyword">struct</span> &#123;</span><br><span class="line">a unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewArena allocates a new arena.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewArena</span><span class="params">()</span> *<span class="title">Arena</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Arena&#123;a: runtime_arena_newArena()&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据描述这里注意点有两个：</p><ol><li>arena 分配的对象需要及时释放</li><li>既然是自动释放，然后在使用中 <code>defer arena.Free()</code> 可以任务是，不用等到二次垃圾回收，直接将资源释放，并将可重复使用的mspan放入<code>reused</code>中</li></ol><p>查看Arena 内部结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> userArena <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 表示一系列没有足够空心内存的 mspan,当arena被释放他们也会被释放</span></span><br><span class="line">fullList *mspan  <span class="comment">//内存组件 mspan</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 未满的mspan</span></span><br><span class="line">active *mspan   </span><br><span class="line"></span><br><span class="line">  <span class="comment">//arena 对象引用报活</span></span><br><span class="line">refs []unsafe.Pointer</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果arena被释放，那么 defunct=true,避免重复释放</span></span><br><span class="line">defunct atomic.Bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Arena 如果重复释放也没有关系，判断释放过则直接结束</li></ul><p>**第一步：**分配一个 <code>Arena</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newUserArena creates a new userArena ready to be used.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newUserArena</span><span class="params">()</span> *<span class="title">userArena</span></span> &#123;</span><br><span class="line">a := <span class="built_in">new</span>(userArena)</span><br><span class="line">SetFinalizer(a, <span class="function"><span class="keyword">func</span><span class="params">(a *userArena)</span></span> &#123; <span class="comment">//g</span></span><br><span class="line"><span class="comment">// If arena handle is dropped without being freed, then call</span></span><br><span class="line"><span class="comment">// free on the arena, so the arena chunks are never reclaimed</span></span><br><span class="line"><span class="comment">// by the garbage collector.</span></span><br><span class="line">a.free()</span><br><span class="line">&#125;)</span><br><span class="line">a.refill()</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *userArena)</span> <span class="title">refill</span><span class="params">()</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line"><span class="comment">// If there's an active chunk, assume it's full.</span></span><br><span class="line">s := a.active</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the partially-used list.</span></span><br><span class="line">lock(&amp;userArenaState.lock)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(userArenaState.reuse) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">//当前存在可重用的就使用重用的</span></span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;userArenaState.lock)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Allocate a new one. 否则分配一个新的mspan</span></span><br><span class="line">x, s = newUserArenaChunk()</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"out of memory"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a.refs = <span class="built_in">append</span>(a.refs, x)<span class="comment">//记录mspan.base()，报活mspan</span></span><br><span class="line">a.active = s<span class="comment">//记录当前使用的mspan</span></span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>SetFinalizer</code> 函数可参考<a href="https://www.yuankang.top/2023/01/04/Go/Go%E5%85%A5%E9%97%A821-SetFinalizer/" target="_blank" rel="noopener">文章</a>，当gc检测到unreachable对象有关联的SetFinalizer函数时，会执行关联的SetFinalizer函数， 同时取消关联。 这样当下一次gc的时候，对象重新处于unreachable状态并且没有SetFinalizer关联， 就会被回收。</li></ul><p>**第二步：**从 arena 中分配具体类型的对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *userArena)</span> <span class="title">refill</span><span class="params">()</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line"><span class="comment">// If there's an active chunk, assume it's full.</span></span><br><span class="line">s := a.active<span class="comment">//上次分配了mspan</span></span><br><span class="line"><span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> s.userArenaChunkFree.size() &gt; userArenaChunkMaxAllocBytes &#123;</span><br><span class="line"><span class="comment">// It's difficult to tell when we're actually out of memory</span></span><br><span class="line"><span class="comment">// in a chunk because the allocation that failed may still leave</span></span><br><span class="line"><span class="comment">// some free space available. However, that amount of free space</span></span><br><span class="line"><span class="comment">// should never exceed the maximum allocation size.</span></span><br><span class="line">throw(<span class="string">"wasted too much memory in an arena chunk"</span>)</span><br><span class="line">&#125;</span><br><span class="line">s.next = a.fullList <span class="comment">//将这个mspan放到fullList的链表头部</span></span><br><span class="line">a.fullList = s</span><br><span class="line">a.active = <span class="literal">nil</span><span class="comment">//active置为空</span></span><br><span class="line">s = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the partially-used list.</span></span><br><span class="line">lock(&amp;userArenaState.lock)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(userArenaState.reuse) &gt; <span class="number">0</span> &#123;<span class="comment">//</span></span><br><span class="line"><span class="comment">//如果有可以重用的mspan则放到s中</span></span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;userArenaState.lock)</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Allocate a new one.</span></span><br><span class="line">x, s = newUserArenaChunk()<span class="comment">//否则新分配一个新的</span></span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"out of memory"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a.refs = <span class="built_in">append</span>(a.refs, x)</span><br><span class="line">a.active = s</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**第三步：**释放的核心是这块代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s := a.fullList<span class="comment">//获取这个mspan</span></span><br><span class="line">i := <span class="built_in">len</span>(a.refs) - <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> s != <span class="literal">nil</span> &#123;<span class="comment">//不为空</span></span><br><span class="line">  a.fullList = s.next<span class="comment">//指向下一个节点</span></span><br><span class="line">  s.next = <span class="literal">nil</span></span><br><span class="line">  freeUserArenaChunk(s, a.refs[i])<span class="comment">//释放这个mspan</span></span><br><span class="line">  s = a.fullList<span class="comment">//指向下一个节点</span></span><br><span class="line">  i--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>释放的时候仅仅是将fullList中所有的都释放掉了，而active中的则会进去到全局reuse对象中用于下次使用</li></ul><p>这个全局变量就是 <code>userArenaState</code> 用于存放可重复使用的mspan以及回收的mspan</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> userArenaState <span class="keyword">struct</span> &#123;</span><br><span class="line">lock mutex</span><br><span class="line"></span><br><span class="line">  <span class="comment">//可重复使用</span></span><br><span class="line">reuse []liveUserArenaChunk</span><br><span class="line"></span><br><span class="line">  <span class="comment">//回收释放的</span></span><br><span class="line">fault []liveUserArenaChunk</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对比syncpool"><a class="markdownIt-Anchor" href="#对比syncpool"></a> 对比Sync.Pool</h3><p>arena 与 Sync.Pool 同样都是为了解决频繁分配对象和大量对象GC带来的开销</p><p><code>Sync.Pool</code>相同类型的对象，使用完后暂时缓存不GC，下次再有相同的对象分配时直接用之前的缓存的对象，避免频繁创建大量对象。不承诺这些缓存对象的生命周期，GC时会释放之前的缓存，适合解决频繁创建相同对象带来的压力，短时间(两次GC之间)大量创建可能还是会有较大冲击，使用相对简单，但只能用于相同结构创建，不能创建slice等复杂结构</p><p><code>arena</code>手动管理连续内容并统一释放，对象的生命周期完全自己控制，使用相对复杂，支持slice等复杂结构，也不是一个真正意义的连续超大空间，而是通过管理不同的mspan实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"arena"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyObj <span class="keyword">struct</span> &#123;</span><br><span class="line">Index <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkCreateObj</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *MyObj</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++ &#123;</span><br><span class="line">p = <span class="built_in">new</span>(MyObj)</span><br><span class="line">p.Index = j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">objPool = sync.Pool&#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;MyObj&#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkCreateObj_SyncPool</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *MyObj</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++ &#123;</span><br><span class="line">p = objPool.Get().(*MyObj)</span><br><span class="line">p.Index = <span class="number">23</span></span><br><span class="line">objPool.Put(p)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkCreateObj_Arena</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *MyObj</span><br><span class="line"></span><br><span class="line">a := arena.NewArena()</span><br><span class="line"><span class="keyword">defer</span> a.Free()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++ &#123;</span><br><span class="line">p = arena.New[MyObj](a)</span><br><span class="line">p.Index = <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性能对比的结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cpu: Intel(R) Core(TM) i7-8559U CPU @ 2.70GHz</span><br><span class="line">BenchmarkCreateObj-8                      100518             11370 ns/op            8000 B/op       1000 allocs/op</span><br><span class="line">BenchmarkCreateObj_SyncPool-8             110017             11523 ns/op               0 B/op          0 allocs/op</span><br><span class="line">BenchmarkCreateObj_Arena-8                 80409             15340 ns/op            8032 B/op          0 allocs/op</span><br></pre></td></tr></table></figure><p><code>Sync.Pool</code> 不需要重复分配且每次操作时间短，而<code>Arena</code>执行时间会长一点且每次还是需要分配内存的，因为需要引入新的 <code>mspan</code></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li><code>Arena</code> 不支持并发，可以看出操作同一个 arena的时候并不存在锁操作</li><li>Arena 强制 Free()之后的对象无法继续使用</li><li>优点：<ul><li>一旦被释放但仍然被访问则会显示的导致程序错误</li><li>arena 地址空间除非没有指针指向，否则将不能被重用</li><li>arena 永远不会被垃圾回收机制回收(如果GC不可达它会执行 <code>SetFinalizer</code> 自己释放掉，那我们手动free的意义在哪里 --&gt; 也就是构建arena的目的，提前释放内存，降低GC扫描频率)</li></ul></li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://uptrace.dev/blog/golang-memory-arena.html" target="_blank" rel="noopener">https://uptrace.dev/blog/golang-memory-arena.html</a></li><li><a href="https://colobu.com/2022/10/17/a-first-look-at-arena/" target="_blank" rel="noopener">https://colobu.com/2022/10/17/a-first-look-at-arena/</a></li><li><a href="https://zhuanlan.zhihu.com/p/604686258" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/604686258</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近 &lt;code&gt;Go1.20&lt;/code&gt; 更新，中间讲到了一个特性 &lt;code&gt;arena&lt;/code&gt; ，这里看看加入 &lt;code&gt;arena&lt;/code&gt; 的作用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在Go的内存管理中，&lt;code&gt;arena&lt;/code&gt; 其实
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go入门21-SetFinalizer</title>
    <link href="http://xboom.github.io/2023/01/04/Go/Go%E5%85%A5%E9%97%A821-SetFinalizer/"/>
    <id>http://xboom.github.io/2023/01/04/Go/Go%E5%85%A5%E9%97%A821-SetFinalizer/</id>
    <published>2023-01-04T13:45:13.344Z</published>
    <updated>2023-02-18T10:15:47.300Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读Go 1.20 新特性 arena 的时候，看到在构建 arena 对象的时候使用了 <code>SetFinalizer</code> 这样一个函数</p><p>带着问题看世界</p><ol><li>它有什么用</li><li>它怎么用</li><li>它有什么缺点导致不是随处可见这种用法</li></ol><p>这里来详细看看它的作用，备注如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SetFinalizer sets the finalizer associated with obj to the provided finalizer function. When the garbage collector finds an unreachable block with an associated finalizer, it clears the association and runs finalizer(obj) in a separate goroutine. This makes obj reachable again,</span><br><span class="line">but now without an associated finalizer. Assuming that SetFinalizer is not called again, the next time the garbage collector sees that obj is unreachable, it will free obj.</span><br></pre></td></tr></table></figure><p>大意是：为对象提供一个析构函数，当GC发现不可达对象带有析构函数的时候，会单独使用协程执行这个析构函数。这样对GC来说对象是可达但没有了析构函数，下次GC发现对象不可达就会释放掉对象</p><p>有一些协程的生命周期是与整个服务一致的，比如定时清理机制，它的好处是自动处理一些业务而不需要人工调用，但如果是在一些与业务完全分离的场景。比如为业务提供一个缓存池，缓存池中为了清理过期的缓存而设计了一个常驻协程。是否可以使用 <code>SetFinalizer</code> 的过期删除机制</p><p>首先看一个栗子：</p><p>一般情况我们会提供对象一个 <code>Close()</code>函数用于业务在不需要的时候清理对象，这里就可以用到这个 <code>SetFinalizer</code>，如 <code>os.NewFile</code> 就注册了 <code>SetFinalizer</code>逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newFile</span><span class="params">(fd <span class="keyword">uintptr</span>, name <span class="keyword">string</span>, kind newFileKind)</span> *<span class="title">File</span></span> &#123;</span><br><span class="line">fdi := <span class="keyword">int</span>(fd)</span><br><span class="line"><span class="keyword">if</span> fdi &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">f := &amp;File&#123;&amp;file&#123;</span><br><span class="line">pfd: poll.FD&#123;</span><br><span class="line">Sysfd:         fdi,</span><br><span class="line">IsStream:      <span class="literal">true</span>,</span><br><span class="line">ZeroReadIsEOF: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line">name:        name,</span><br><span class="line">stdoutOrErr: fdi == <span class="number">1</span> || fdi == <span class="number">2</span>,</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">runtime.SetFinalizer(f.file, (*file).<span class="built_in">close</span>)</span><br><span class="line"><span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">num  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">finalizer</span><span class="params">(f *Foo)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"a finalizer has run for "</span>, f.name, f.num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeFoo</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(a_foo *Foo)</span></span> &#123;</span><br><span class="line">a_foo = &amp;Foo&#123;name, counter&#125;</span><br><span class="line">counter++</span><br><span class="line">runtime.SetFinalizer(a_foo, finalizer)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">f1 := MakeFoo(<span class="string">"one"</span>)</span><br><span class="line">f2 := MakeFoo(<span class="string">"two"</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"f1 is: "</span>, f1.name)</span><br><span class="line">fmt.Println(<span class="string">"f2 is: "</span>, f2.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">Bar()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">runtime.GC()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"done."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f1 is:  one</span><br><span class="line">f2 is:  two</span><br><span class="line">a finalizer has run <span class="keyword">for</span>  two <span class="number">1</span></span><br><span class="line">a finalizer has run <span class="keyword">for</span>  one <span class="number">0</span></span><br><span class="line">f1 is:  one</span><br><span class="line">f2 is:  two</span><br><span class="line">a finalizer has run <span class="keyword">for</span>  two <span class="number">3</span></span><br><span class="line">a finalizer has run <span class="keyword">for</span>  one <span class="number">2</span></span><br><span class="line">f1 is:  one</span><br><span class="line">f2 is:  two</span><br><span class="line">a finalizer has run <span class="keyword">for</span>  two <span class="number">5</span></span><br><span class="line">a finalizer has run <span class="keyword">for</span>  one <span class="number">4</span></span><br><span class="line">done.</span><br></pre></td></tr></table></figure><p>注意事项</p><ol><li>obj 必须是指针</li><li><code>SetFinalizer</code> 执行顺序按照类似对象的出栈顺序</li><li>可以通过 <code>SetFinalizer(obj, nil)</code> 清理对象的析构器</li></ol><p>栗子2，它的实际效果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"runtime/debug"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">debug.SetGCPercent(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ms runtime.MemStats</span><br><span class="line">runtime.ReadMemStats(&amp;ms)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Allocation: %f Mb, Number of allocation: %d\n"</span>, <span class="keyword">float32</span>(ms.HeapAlloc)/<span class="keyword">float32</span>(<span class="number">1024</span>*<span class="number">1024</span>), ms.HeapObjects)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</span><br><span class="line">f := NewFoo(i)</span><br><span class="line">_ = fmt.Sprintf(<span class="string">"%d"</span>, f.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runtime.ReadMemStats(&amp;ms)</span><br><span class="line">fmt.Printf(<span class="string">"Allocation: %f Mb, Number of allocation: %d\n"</span>, <span class="keyword">float32</span>(ms.HeapAlloc)/<span class="keyword">float32</span>(<span class="number">1024</span>*<span class="number">1024</span>), ms.HeapObjects)</span><br><span class="line"></span><br><span class="line">runtime.GC()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">runtime.ReadMemStats(&amp;ms)</span><br><span class="line">fmt.Printf(<span class="string">"Allocation: %f Mb, Number of allocation: %d\n"</span>, <span class="keyword">float32</span>(ms.HeapAlloc)/<span class="keyword">float32</span>(<span class="number">1024</span>*<span class="number">1024</span>), ms.HeapObjects)</span><br><span class="line"></span><br><span class="line">runtime.GC()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">runtime.ReadMemStats(&amp;ms)</span><br><span class="line">fmt.Printf(<span class="string">"Allocation: %f Mb, Number of allocation: %d\n"</span>, <span class="keyword">float32</span>(ms.HeapAlloc)/<span class="keyword">float32</span>(<span class="number">1024</span>*<span class="number">1024</span>), ms.HeapObjects)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFoo</span><span class="params">(i <span class="keyword">int</span>)</span> *<span class="title">Foo</span></span> &#123;</span><br><span class="line">f := &amp;Foo&#123;a: rand.Intn(<span class="number">50</span>)&#125;</span><br><span class="line">runtime.SetFinalizer(f, <span class="function"><span class="keyword">func</span><span class="params">(f *Foo)</span></span> &#123;</span><br><span class="line">_ = fmt.Sprintf(<span class="string">"foo "</span> + strconv.Itoa(i) + <span class="string">" has been garbage collected"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Allocation: <span class="number">0.121063</span> Mb, Number of allocation: <span class="number">140</span></span><br><span class="line">Allocation: <span class="number">29.111671</span> Mb, Number of allocation: <span class="number">1899990</span></span><br><span class="line">Allocation: <span class="number">128.025635</span> Mb, Number of allocation: <span class="number">4382420</span></span><br><span class="line">Allocation: <span class="number">0.122147</span> Mb, Number of allocation: <span class="number">155</span></span><br></pre></td></tr></table></figure><p>可以看出，正如它功能说的一样，在第二次GC之后，分配的内存被释放</p><p>它也有缺点：</p><ol><li><code>SetFinalizer</code> 最大的问题是延长了对象生命周期。在第一次回收时执行 Finalizer 函数，且目标对象重新变成可达状态，直到第二次才真正 “销毁”。这对于有大量对象分配的高并发算法，可能会造成很大麻烦</li><li>指针构成的 “循环引⽤” 加上 <code>runtime.SetFinalizer</code> 会导致内存泄露</li><li><code>SetFinalizer</code>只在GC 发现对象不可达之后的任意时间执行，所以如果程序正常结束或者发生错误，而对象还没有被GC选中那么 <code>SetFinalizer</code> 也不会执行。</li></ol><p>所以保险起见还是提供了 <code>Close()</code> 逻辑供业务调用</p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/76504936" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/76504936</a></li><li><a href="https://go.dev/play/p/jWhRSPNvxJ" target="_blank" rel="noopener">https://go.dev/play/p/jWhRSPNvxJ</a></li><li><a href="https://medium.com/a-journey-with-go/go-finalizers-786df8e17687" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-finalizers-786df8e17687</a></li><li><code>runtime/mfinal.go</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在阅读Go 1.20 新特性 arena 的时候，看到在构建 arena 对象的时候使用了 &lt;code&gt;SetFinalizer&lt;/code&gt; 这样一个函数&lt;/p&gt;
&lt;p&gt;带着问题看世界&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它有什么用&lt;/li&gt;
&lt;li&gt;它怎么用&lt;/li&gt;
&lt;li&gt;它
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>算法之美-八数码问题</title>
    <link href="http://xboom.github.io/2022/12/11/Algorithms%20To%20Live%20By/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>http://xboom.github.io/2022/12/11/Algorithms%20To%20Live%20By/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/</id>
    <published>2022-12-11T09:47:28.000Z</published>
    <updated>2022-12-11T09:47:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>八数码问题也称为九宫问题。在3×3的棋盘，摆有八个棋子，每个棋子上标有1至8的某一数字，不同棋子上标的数字不相同。棋盘上还有一个空格，与空格相邻的棋子可以移到空格中。要求解决的问题是：给出一个初始状态和一个目标状态，找出一种从初始转变成目标状态的移动棋子步数最少的移动步骤</p><blockquote><p>所谓一个状态就是棋子在棋盘上的一种摆法。棋子移动后，状态就会发生改变。实际上就是找出从初始状态到达目标状态所经过的一系列中间过渡状态</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-11-03_23-53-25_bashuma_1.png" alt="Snipaste_2022-11-03_23-53-25_bashuma_1" style="zoom:67%;" /><p>首先这个九宫格的状态数量是 9!，那么存在问题</p><ol><li><p>是否存在从一个状态转移到另外一个状态无解的情况？</p></li><li><p>如何计算或者衡量从一个转移到另外一个状态的需要走多少步？</p></li></ol><h3 id="排列的性质"><a class="markdownIt-Anchor" href="#排列的性质"></a> 排列的性质</h3><p>为了搞清楚上述问题，需要知道几个基本定义与引理</p><ol><li><p>把n个不同的元素按一定的顺序排列成一行，成为这n个元素的一个<strong>排列</strong>。n个不同元素的排列共有 <strong>n!</strong> 种</p></li><li><p>对于n个自然数的一个排列，如果一个大数排在一个小数之前，就称这两个数构成一个<strong>逆序</strong>。一个排列的逆序总和称为该排列的<strong>逆序对</strong>，记为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi><mo stretchy="false">(</mo><mi>j</mi><mn>1</mn><mi>j</mi><mn>2</mn><mo>⋯</mo><mi>j</mi><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>τ</mi><mo>∗</mo><mo stretchy="false">(</mo><mo>∗</mo><mi>j</mi><mo>∗</mo><mn>1</mn><mo>∗</mo><mi>j</mi><mo>∗</mo><mn>2</mn><mo>⋯</mo><mo>∗</mo><mi>j</mi><mo>∗</mo><mo>∗</mo><mi>n</mi><mo>∗</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">τ(j1j2⋯jn)*τ*(*j*1*j*2⋯*j**n*)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">∗</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∗</span><span class="mord mathdefault">n</span><span class="mord">∗</span><span class="mclose">)</span></span></span></span></p><blockquote><p>如5阶排列31542的逆序是(3,1),(3,2),(5,4),(5,2),(4,2),故 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi><mo stretchy="false">(</mo><mn>31542</mn><mo stretchy="false">)</mo><mo>=</mo><mn>5</mn><mo>∗</mo><mi>τ</mi><mo>∗</mo><mo stretchy="false">(</mo><mn>31542</mn><mo stretchy="false">)</mo><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">τ(31542)=5*τ*(31542)=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mopen">(</span><span class="mord">3</span><span class="mord">1</span><span class="mord">5</span><span class="mord">4</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mord">1</span><span class="mord">5</span><span class="mord">4</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span></p></blockquote></li><li><p>逆序对为奇数的排列称为<strong>奇排列</strong>。逆序对为偶数的排列称为<strong>偶排列</strong>。<strong>自然排列</strong> 123⋯<em>n</em>的逆序对为0，故它是偶排列</p></li><li><p>在一个排列中，把某两个数的位置互换（其他数不动）变成另一个排列的变动称为一个<strong>对换</strong>，将相邻的两个数对换称为<strong>相邻对换</strong></p></li></ol><h3 id="性质的证明"><a class="markdownIt-Anchor" href="#性质的证明"></a> 性质的证明</h3><p><strong>性质1</strong>：<strong>一个排列中的任意两个数对换后，排列改变奇偶性。即经过一次对换，奇排列变成偶排列，偶排列变成奇排列</strong></p><p>证明：</p><ol><li><p>先证明相邻对换的情形</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-11-05_23-25-04-bashuma2.png" alt="Snipaste_2022-11-05_23-25-04-bashuma2" style="zoom:50%;" /><ul><li><p>设排列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>s</mi></msub><mi>a</mi><mi>b</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 ... a_s a b b_1 b_2 ... b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，对换a 与 b 的排列变为  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>s</mi></msub><mi>b</mi><mi>a</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 ... a_s b a b_1 b_2 ... b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p></li><li><p>a 与 b 的 对换不影响  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 ... a_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">b_1 b_2 ... b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 与 其他数的关系</p></li><li><p>但a与b的序关系变为：</p><ul><li><p>当 a &lt; b 时，在新排列中 a 、b 构成逆序</p></li><li><p>当 a &gt; b 时，在新排列中 a、b 不构成逆序</p></li></ul></li><li><p>因此 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>s</mi></msub><mi>a</mi><mi>b</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 ... a_s a b b_1 b_2 ... b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 比  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>s</mi></msub><mi>b</mi><mi>a</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 ... a_s b a b_1 b_2 ... b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的逆序多1或者少1</p></li></ul></li><li><p>再证一般对换情形</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-11-05_23-30-29-bashuma3.png" alt="Snipaste_2022-11-05_23-30-29-bashuma3" style="zoom:50%;" /><ul><li>设存在排列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>s</mi></msub><mi>a</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>…</mo><msub><mi>b</mi><mi>m</mi></msub><mi>b</mi><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>…</mo><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 … a_s a b_1 b_2 … b_m b c_1 c_2 … c_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>将 b 做 m 次相邻对换变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>s</mi></msub><mi>a</mi><mi>b</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>…</mo><msub><mi>b</mi><mi>m</mi></msub><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>…</mo><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 … a_s a b b_1 b_2 … b_m c_1 c_2 … c_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>再将 a 做 (m + 1) 次相邻对换变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>s</mi></msub><mi>b</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>…</mo><msub><mi>b</mi><mi>m</mi></msub><mi>a</mi><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>…</mo><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 … a_s b b_1 b_2 … b_m a c_1 c_2 … c_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>所以 经过 (2m + 1) 次相邻兑换，可以把排列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>s</mi></msub><mi>a</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>…</mo><msub><mi>b</mi><mi>m</mi></msub><mi>b</mi><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>…</mo><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 … a_s a b_1 b_2 … b_m b c_1 c_2 … c_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>转变成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>s</mi></msub><mi>b</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>…</mo><msub><mi>b</mi><mi>m</mi></msub><mi>a</mi><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>…</mo><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 … a_s b b_1 b_2 … b_m a c_1 c_2 … c_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，这两个排列的奇偶性相反</li></ul></li></ol><p><strong>性质2：在全部的 n(n≥2)阶排列中，奇偶排列各占一半，各有 n!/2 个</strong></p><p>证明：</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-11-06_09-56-51-bashuma4.png" alt="Snipaste_2022-11-06_09-56-51-bashuma4" style="zoom:50%;" /><ul><li><p>假设在全部n级排列中共有t个奇排列，s个偶排列</p></li><li><p>将t个奇排列中的前两个数字对换，得到t个互不相同的偶排列。因此 t≤s</p></li><li><p>同理可证 s≤t</p></li><li><p>于是 s=t，即奇、偶排列的总数相等，各有 n!/2个</p></li></ul><p><strong>性质3：任意一个n阶排列都可以经过一系列对换变成自然排列，并且所作对换的次数与这个排列有相同的奇偶性</strong></p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-11-06_13-10-01-bashuma5.png" alt="Snipaste_2022-11-06_13-10-01-bashuma5" style="zoom:50%;" /><p>证明(归纳法)：</p><ul><li>1阶排列只有一个，结论显然成立</li><li>假设对n-1阶排列已经成立，证对n阶排列的情形结论也成立<ul><li>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mn>1</mn></msub><msub><mi>j</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>j</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">j_1 j_2 ... j_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是一个n阶排列<ul><li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mi>n</mi></msub><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">j_n=n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> ，假设n-1级排列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mn>1</mn></msub><msub><mi>j</mi><mn>2</mn></msub><mo>…</mo><msub><mi>j</mi><mi>n</mi></msub><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">j_1 j_2 … j_n−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 可以经过一系列变换变成自然序列，即 1 2 … n−1，于是这一系列对换也就把 j1j2⋯jn 变成 12⋯n 这种自然序列的形式。</li><li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mi>n</mi><mi mathvariant="normal">≠</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">jn≠n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，那么对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mn>1</mn></msub><msub><mi>j</mi><mn>2</mn></msub><mo>…</mo><msub><mi>j</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">j_1 j_2 … j_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">j_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 n 的对换，它就变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mn>1</mn></msub><msub><mi>j</mi><mn>2</mn></msub><mo>…</mo><msub><mi>j</mi><mi>n</mi></msub><mi mathvariant="normal">−</mi><mn>1</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">j_1 j_2 … j_n−1 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">−</span><span class="mord">1</span><span class="mord mathdefault">n</span></span></span></span> ，这就归结成上面的情形，因此</li></ul></li></ul></li></ul><p><strong>性质4：奇偶性与可达性关系与证明</strong></p><blockquote><p>必要性证明：排列的奇偶性不同则对应在八数码问题中不可达</p></blockquote><p>在满足上述约定的八数码问题中，空格与相邻棋子的交换不会改变棋局中棋子数列的逆序对的奇偶性</p><ul><li><p>空格与左右棋子交换：是不改变棋子数列的逆序对的(因为数列并没有改变)</p></li><li><p>空格与上下棋子交换：也是不改变棋子数列的逆序对的</p><ul><li>假设交换棋子为c[i]=X</li><li>原数列p=c[1]… X c[i+1]c[i+2]…c[8]将变为新数列q=c[1]…c[i+1]c[i+2]X …c[8]（注意：在棋盘中，上下相邻的两棋格之间隔有两个棋格）。可以解释为用X与c[i+1]、 c[i+2]先后进行两次相邻交换而完成状态转变。</li><li>由p状态到q状态并不会改变改变棋子数列的逆序对的奇偶性。同理可证空格与下方棋子交换也不会改变棋子数列的逆序对的奇偶性。所以，空格与相邻棋子的交换不会改变棋局中棋子数列的逆序对的奇偶性</li></ul></li></ul><p>得出 <strong>定理1：对于任意两个状态映射的序列，如果这两个状态等价，那么它们的逆序数相同</strong></p><blockquote><p>充分性证明：<strong>排列的奇偶性相同则对应在八数码问题中也可达</strong></p></blockquote><p>首先明确几个定义：</p><ul><li><p><strong>状态</strong>(<strong>state</strong>)：八数码中8个数字与0的排列被定义为八数码的<strong>状态</strong>，比如：</p></li><li><p><strong>状态空间</strong>(<strong>state space</strong>)：八数码所有状态的合集被称为<strong>状态空间</strong></p></li><li><p><strong>完全态</strong>(<strong>completeness</strong>)：当状态空间的子集中任何两个状态都能通过一定步骤得到，那么称这个状态空间的子集是<strong>完全态</strong></p></li><li><p><strong>状态映射</strong>(<strong>a sequence mapped by a state</strong>)：一个状态{}可以映射(忽略0)成一个排序，那么这个排列就称为这个<strong>状态的映射</strong></p></li><li><p><strong>标准格式(a standard form)</strong>：如果 0 在正中间，那么称这个状态为<strong>标准格式</strong></p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20221211150738067.png" alt="image-20221211150738067" style="zoom:50%;" /></li><li><p><strong>区域(field)</strong>：对于任意状态(state)，4个位置中任意两个都相邻，那么称之为 <strong>区域</strong>，特别的，当两个区域有相同的两个位置，则称为 <strong>同边区域</strong></p></li><li><p><strong>转圈(circle moving)</strong>：0在一个区域内移动称 <strong>转圈</strong></p></li></ul><p><strong>引理1：对于标准格式中的任意区域，转圈可以得到两个等价的区域</strong></p><p>考虑到 <strong>标准格式</strong> 的对称性，只需要考虑一个区域的的变化</p><p>第一种情况(顺时针方向部分先后): a b d</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121101.png" alt="bashuma-121101" style="zoom:50%;" /><p>第二种情况(顺时针方向不分先后): a d b</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121102.png" alt="bashuma-121102" /></p><p>接着考虑在一个标准格式中，在两个具有相同边的区域交换数据，由于标准格式的对称性，所以只考虑上半部分</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121103.png" alt="bashuma-121103" style="zoom:50%;" /><blockquote><p>这个图形转换根据上述原则手动绘制交换流程更容易理解</p></blockquote><p>得出的<strong>规律1</strong>: m 属于 {a ,d}，n 属于 {c, e}，p 属于 {a, d} 但 p != m，q 属于 {c, e}但 q != n，那么交换 m n，则 n 来到 m 之前的位置，而 m 来到 q 之前的位置，q 来到 n 之前的位置</p><p>得出的<strong>规律2</strong>：abc 可以经过转换编程 cab 或者 bac，不影响其他行且逆序对不变</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121104.png" alt="bashuma-121104" style="zoom:80%;" /><p>对于标准格式，如果它们的逆序对的奇偶性相同，那么它们是等价的</p><p>证明：</p><p>首先，将九宫格分为A、B、C、D分为四个区域</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121106.png" alt="bashuma-121106" style="zoom:50%;" /><p>第一步，将 h 移动到位置 位置 9，这是肯定可以的</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121107.png" alt="bashuma-121107" style="zoom:50%;" /><p>第二步，将 g、e 移动到区域D</p><blockquote><p>为什么不考虑g、e的顺序，因为可以在不影响h的情况下 g 在 位置 6 与 位置8 任意切换</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121112.png" alt="bashuma-121112" style="zoom:50%;" /><ul><li><p>2.1 如果 g、e 已经在区域D，那么不需要移动</p></li><li><p>2.2 如果其中 g 在 区域D，而e 在其他区域</p><ul><li><p>2.2.1 e 在区域A</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121109.png" alt="bashuma-121109" style="zoom:50%;" /></li><li><p>2.2.2 e 在区域B</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-12-11_16-55-10.png" alt="Snipaste_2022-12-11_16-55-10" style="zoom:50%;" /></li><li><p>2.2.3 e 在区域C</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121111.png" alt="bashuma-121111" style="zoom:50%;" /></li></ul><p>第三步，将 b、c 移动到 B区域</p><ul><li><p>3.1 如果 b、c 都在区域 B，那么不需要移动</p></li><li><p>3.2 如果 b、c 有一个在区域B，那么</p><blockquote><p>b 、c 的位置也同样可以忽略，如果b、c是正常顺序，那么也可以在不影响 g e h 位置的情况下调整 b c 的顺序</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-1211-13.png" alt="bashuma-1211-13" style="zoom:50%;" /><ul><li><p>3.1.1 如果在位置3</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma121110.png" alt="bashuma121110" style="zoom:50%;" /></li><li><p>3.1.2 如果在位置2，那么先将c移动位置3再执行上述步骤</p></li></ul></li><li><p>如果 b、c 都不在区域B，同理将c 移动到位置3，然后在执行上述3.1.1 步骤</p></li></ul></li></ul><p>第四步，在不影响bcehg的情况下调整adf的顺序</p><ul><li>规律二在 此场景下仍然适用，所以首先将防止到位置7</li><li>根据定理1，如果两者等价，那么它们的逆序对是相同的。而如果位置1与位置3交换其他位置不变，那边整个序列的逆序对是变化的。所以a一定在位置1，d在位置4</li></ul><p>所以，如果奇偶性相同，那么两个状态都能转换成一个相同的标准状态，那么两个状态之间是可达的</p><p>得出结论：<strong>两个排列的逆序对奇偶性相同，那么在八数码中必可达</strong></p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://blog.csdn.net/u011008379/article/details/40144147" target="_blank" rel="noopener">https://blog.csdn.net/u011008379/article/details/40144147</a></li><li><a href="https://chengfeng96.com/blog/2018/05/26/%E5%88%A9%E7%94%A8BFS%EF%BC%8CDFS%EF%BC%8CA-%E8%A7%A3%E5%86%B3%E5%85%AB%E6%95%B0%E7%A0%81%E9%9A%BE%E9%A2%98/" target="_blank" rel="noopener">https://chengfeng96.com/blog/2018/05/26/利用BFS，DFS，A-解决八数码难题/</a></li><li><a href="http://www.huaying1988.com/blogs/8_Puzzle_StrictProof_SolutionAlgorithm_AndOthers/detail.html" target="_blank" rel="noopener">http://www.huaying1988.com/blogs/8_Puzzle_StrictProof_SolutionAlgorithm_AndOthers/detail.html</a></li><li>《A constructive proof for the subsets completeness of 8-Puzzle state space》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;八数码问题也称为九宫问题。在3×3的棋盘，摆有八个棋子，每个棋子上标有1至8的某一数字，不同棋子上标的数字不相同。棋盘上还有一个空格，与空格相邻的棋子可以移到空格中。要求解决的问题是：给出一个初始状态和一个目标状态，找出一种从初始转变成目标状态的移动棋子步数最少的移动步骤&lt;
      
    
    </summary>
    
    
      <category term="Algorithms To Live By" scheme="http://xboom.github.io/categories/Algorithms-To-Live-By/"/>
    
    
      <category term="Algorithms To Live By" scheme="http://xboom.github.io/tags/Algorithms-To-Live-By/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-14-健康检查</title>
    <link href="http://xboom.github.io/2022/11/04/Grpc/Grpc-14-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/"/>
    <id>http://xboom.github.io/2022/11/04/Grpc/Grpc-14-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/</id>
    <published>2022-11-04T14:58:29.000Z</published>
    <updated>2023-05-27T10:56:13.039Z</updated>
    
    <content type="html"><![CDATA[<p>前面学习了保持链接，这里看一下健康检查</p><p>带着问题看世界</p><ol><li>健康检查的作用</li><li>健康检查的原理</li><li>保持链接与健康检查的区别</li></ol><p>首先看一下源码例子中的ReadMe说明，gRPC提供了一个健康检查库，用于向客户端通报系统的健康状况。它通过使用health/v1 API提供服务定义。通过使用健康检查库，客户端可以在遇到问题时优雅地避免使用服务器。大多数语言都提供了现成的实现，这使得它在不同系统之间可以互操作。内置健康检查的优势</p><ul><li>健康检查的格式与普通的RPC一样</li><li>重用现有的配额等机制，内部对健康检查有完全的控制权</li></ul><h3 id="基本使用"><a class="markdownIt-Anchor" href="#基本使用"></a> 基本使用</h3><p>内部定义了健康检查的 proto</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> grpc.health.v1;</span><br><span class="line"></span><br><span class="line">message HealthCheckRequest &#123;</span><br><span class="line">  <span class="keyword">string</span> service = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HealthCheckResponse &#123;</span><br><span class="line">  enum ServingStatus &#123;</span><br><span class="line">    UNKNOWN = <span class="number">0</span>;</span><br><span class="line">    SERVING = <span class="number">1</span>;</span><br><span class="line">    NOT_SERVING = <span class="number">2</span>;</span><br><span class="line">    SERVICE_UNKNOWN = <span class="number">3</span>;  <span class="comment">// Used only by the Watch method.</span></span><br><span class="line">  &#125;</span><br><span class="line">  ServingStatus status = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service Health &#123;</span><br><span class="line">  rpc Check(HealthCheckRequest) returns (HealthCheckResponse);</span><br><span class="line"></span><br><span class="line">  rpc Watch(HealthCheckRequest) returns (stream HealthCheckResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共有两种方式进行健康检查</p><ul><li><code>Check</code> 探测服务器的健康状态</li><li><code>Watch</code> 观察服务端变化，这里注意 是一个<code>服务端流</code>，也就是客户端不断会收到服务端的状态更新</li></ul><p>一般，客户端不需要手动执行 <code>Check</code>操作，而是通过配置 <code>healthCheckConfig</code> ，它会在内部自动执行 <code>Watch</code>操作</p><h4 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import grpc/health to enable transparent client side checking </span></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">"google.golang.org/grpc/health"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set up appropriate service config</span></span><br><span class="line">serviceConfig := grpc.WithDefaultServiceConfig(<span class="string">`&#123;</span></span><br><span class="line"><span class="string">  "loadBalancingPolicy": "round_robin",</span></span><br><span class="line"><span class="string">  "healthCheckConfig": &#123;</span></span><br><span class="line"><span class="string">    "serviceName": ""</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;`</span>)</span><br><span class="line"></span><br><span class="line">conn, err := grpc.Dial(..., serviceConfig)</span><br></pre></td></tr></table></figure><h4 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h4><p>启动一个协程，来模拟服务端状态变化，核心逻辑就是设置服务的状态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">port  = flag.Int(<span class="string">"port"</span>, <span class="number">50051</span>, <span class="string">"the port to serve on"</span>)</span><br><span class="line">sleep = flag.Duration(<span class="string">"sleep"</span>, time.Second*<span class="number">5</span>, <span class="string">"duration between changes in health"</span>)</span><br><span class="line"></span><br><span class="line">system = <span class="string">""</span> <span class="comment">// empty string represents the health of the system</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line">lis, err := net.Listen(<span class="string">"tcp"</span>, fmt.Sprintf(<span class="string">":%d"</span>, *port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to listen: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s := grpc.NewServer()</span><br><span class="line">healthcheck := health.NewServer()</span><br><span class="line">healthpb.RegisterHealthServer(s, healthcheck)<span class="comment">//健康检查</span></span><br><span class="line">pb.RegisterEchoServer(s, &amp;echoServer&#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//健康状态更新</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// asynchronously inspect dependencies and toggle serving status as needed</span></span><br><span class="line">next := healthpb.HealthCheckResponse_SERVING</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">healthcheck.SetServingStatus(system, next)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> next == healthpb.HealthCheckResponse_SERVING &#123;</span><br><span class="line">next = healthpb.HealthCheckResponse_NOT_SERVING</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">next = healthpb.HealthCheckResponse_SERVING</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(*sleep)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to serve: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>健康服务器可以返回四种状态：<code>UNKNOWN</code>、<code>SERVING</code>、<code>NOT_SERVING</code>和<code>SERVICE_UNKNOWN</code>。</p><ul><li><p><code>UNKNOWN</code> 表示当前状态尚未知晓。在服务器实例启动时经常会看到这种状态。</p></li><li><p><code>SERVING</code> 表示系统健康，准备好提供服务请求。</p></li><li><p><code>NOT_SERVING</code> 表示系统当前无法处理请求。</p></li><li><p><code>SERVICE_UNKNOWN</code> 表示客户端请求的服务名未被服务器所知。此状态仅由 <code>Watch()</code> 调用报告</p></li></ul><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><h4 id="客户端-2"><a class="markdownIt-Anchor" href="#客户端-2"></a> 客户端</h4><p>客户端默认初始化<code>Watch</code>函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">   internal.HealthCheckFunc = clientHealthCheck</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> healthCheckMethod = <span class="string">"/grpc.health.v1.Health/Watch"</span><span class="comment">//指定健康检查方法名称</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clientHealthCheck</span><span class="params">(ctx context.Context, newStream <span class="keyword">func</span>(<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>, <span class="title">setConnectivityState</span> <span class="title">func</span><span class="params">(connectivity.State, error)</span>, <span class="title">service</span> <span class="title">string</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">   tryCnt := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">retryConnection:</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">//退避重试</span></span><br><span class="line">      <span class="keyword">if</span> tryCnt &gt; <span class="number">0</span> &amp;&amp; !backoffFunc(ctx, tryCnt<span class="number">-1</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">      tryCnt++</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ctx.Err() != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">      setConnectivityState(connectivity.Connecting, <span class="literal">nil</span>)<span class="comment">//设置状态</span></span><br><span class="line">      rawS, err := newStream(healthCheckMethod)<span class="comment">//构建流链接</span></span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">continue</span> retryConnection</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      s, ok := rawS.(grpc.ClientStream)</span><br><span class="line">      <span class="keyword">if</span> !ok &#123;</span><br><span class="line">         setConnectivityState(connectivity.Ready, <span class="literal">nil</span>)<span class="comment">//服务端健康</span></span><br><span class="line">         <span class="keyword">return</span> fmt.Errorf(<span class="string">"newStream returned %v (type %T); want grpc.ClientStream"</span>, rawS, rawS)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> err = s.SendMsg(&amp;healthpb.HealthCheckRequest&#123;Service: service&#125;); err != <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123;</span><br><span class="line">         <span class="comment">// Stream should have been closed, so we can safely continue to create a new stream.</span></span><br><span class="line">         <span class="keyword">continue</span> retryConnection</span><br><span class="line">      &#125;</span><br><span class="line">      s.CloseSend()</span><br><span class="line"></span><br><span class="line">      resp := <span class="built_in">new</span>(healthpb.HealthCheckResponse)</span><br><span class="line">      <span class="keyword">for</span> &#123;<span class="comment">//不断接收服务端响应</span></span><br><span class="line">         err = s.RecvMsg(resp)</span><br><span class="line"></span><br><span class="line">         <span class="comment">// </span></span><br><span class="line">         <span class="keyword">if</span> status.Code(err) == codes.Unimplemented &#123;<span class="comment">//表示服务端未支持健康检查</span></span><br><span class="line">            setConnectivityState(connectivity.Ready, <span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 其他错误</span></span><br><span class="line">         <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            setConnectivityState(connectivity.TransientFailure, fmt.Errorf(<span class="string">"connection active but received health check RPC error: %v"</span>, err))</span><br><span class="line">            <span class="keyword">continue</span> retryConnection</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//收到消息那么</span></span><br><span class="line">         tryCnt = <span class="number">0</span></span><br><span class="line">         <span class="keyword">if</span> resp.Status == healthpb.HealthCheckResponse_SERVING &#123;</span><br><span class="line">            setConnectivityState(connectivity.Ready, <span class="literal">nil</span>)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setConnectivityState(connectivity.TransientFailure, fmt.Errorf(<span class="string">"connection active but health check failed. status=%s"</span>, resp.Status))</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据策略启动健康检查，<strong>针对的是同一个域名对应的多个子地址</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启健康检查</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ac *addrConn)</span> <span class="title">startHealthCheck</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> healthcheckManagingState <span class="keyword">bool</span></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> !healthcheckManagingState &#123;</span><br><span class="line">         ac.updateConnectivityState(connectivity.Ready, <span class="literal">nil</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="comment">//... 判断健康检查是否开启</span></span><br><span class="line">   currentTr := ac.transport</span><br><span class="line">   newStream := <span class="function"><span class="keyword">func</span><span class="params">(method <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">      ac.mu.Lock()</span><br><span class="line">      <span class="keyword">if</span> ac.transport != currentTr &#123;</span><br><span class="line">         ac.mu.Unlock()</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.Canceled, <span class="string">"the provided transport is no longer valid to use"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      ac.mu.Unlock()</span><br><span class="line">      <span class="keyword">return</span> newNonRetryClientStream(ctx, &amp;StreamDesc&#123;ServerStreams: <span class="literal">true</span>&#125;, method, currentTr, ac)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//更新连接状态</span></span><br><span class="line">   setConnectivityState := <span class="function"><span class="keyword">func</span><span class="params">(s connectivity.State, lastErr error)</span></span> &#123;</span><br><span class="line">      ac.mu.Lock()</span><br><span class="line">      <span class="keyword">defer</span> ac.mu.Unlock()</span><br><span class="line">      <span class="keyword">if</span> ac.transport != currentTr &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      ac.updateConnectivityState(s, lastErr)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 独立协程去检查健康状态</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      err := ac.cc.dopts.healthCheckFunc(ctx, newStream, setConnectivityState, healthCheckConfig.ServiceName)</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">   &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以通过健康检查更新连接状态，但不是唯一更新连接状态的方式</p><h4 id="服务端-2"><a class="markdownIt-Anchor" href="#服务端-2"></a> 服务端</h4><h5 id="维护"><a class="markdownIt-Anchor" href="#维护"></a> 维护</h5><p>首先需要明白服务端是如何维护状态的 <code>SetServingStatus</code> 其实还是需要用户自定义状态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">SetServingStatus</span><span class="params">(service <span class="keyword">string</span>, servingStatus healthpb.HealthCheckResponse_ServingStatus)</span></span> &#123;</span><br><span class="line">   <span class="comment">//....</span></span><br><span class="line">   s.setServingStatusLocked(service, servingStatus)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">setServingStatusLocked</span><span class="params">(service <span class="keyword">string</span>, servingStatus healthpb.HealthCheckResponse_ServingStatus)</span></span> &#123;</span><br><span class="line">   s.statusMap[service] = servingStatus</span><br><span class="line">   <span class="keyword">for</span> _, update := <span class="keyword">range</span> s.updates[service] &#123;</span><br><span class="line">      <span class="comment">// Clears previous updates, that are not sent to the client, from the channel.</span></span><br><span class="line">      <span class="comment">// This can happen if the client is not reading and the server gets flow control limited.</span></span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-update:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Puts the most recent update to the channel.</span></span><br><span class="line">      update &lt;- servingStatus</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">statusMap <span class="keyword">map</span>[<span class="keyword">string</span>]healthpb.HealthCheckResponse_ServingStatus</span><br><span class="line">updates   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[healthgrpc.Health_WatchServer]<span class="keyword">chan</span> healthpb.HealthCheckResponse_ServingStatus</span><br></pre></td></tr></table></figure><p>这里的状态更新有两种</p><ol><li>更新 <code>statusMap[service]</code> 对应的服务状态</li><li>将状态写入到服务对应的隧道中，隧道中的状态则是通过<code>Watch</code>函数不断地通知客户端(不同的状态才会通知)</li></ol><p>这里有两种特殊的情况可以直接使用内置函数，就是服务恢复正常与停止服务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Shutdown</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s.mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line">   s.shutdown = <span class="literal">true</span></span><br><span class="line">   <span class="keyword">for</span> service := <span class="keyword">range</span> s.statusMap &#123;</span><br><span class="line">      s.setServingStatusLocked(service, healthpb.HealthCheckResponse_NOT_SERVING)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Resume</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s.mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line">   s.shutdown = <span class="literal">false</span></span><br><span class="line">   <span class="keyword">for</span> service := <span class="keyword">range</span> s.statusMap &#123;</span><br><span class="line">      s.setServingStatusLocked(service, healthpb.HealthCheckResponse_SERVING)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会统一更新服务的状态，而不需要单独设置某个服务的状态更新，一般用于服务启动与恢复。</p><p>接着就是接收客户端的健康检查请求</p><h5 id="check"><a class="markdownIt-Anchor" href="#check"></a> Check</h5><p>当客户端请求服务状态的时候，直接从状态服务中返回结果  <code>statusMap[in.Service]</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Check</span><span class="params">(ctx context.Context, in *healthpb.HealthCheckRequest)</span> <span class="params">(*healthpb.HealthCheckResponse, error)</span></span> &#123;</span><br><span class="line">   s.mu.RLock()</span><br><span class="line">   <span class="keyword">defer</span> s.mu.RUnlock()</span><br><span class="line">   <span class="keyword">if</span> servingStatus, ok := s.statusMap[in.Service]; ok &#123;</span><br><span class="line">      <span class="keyword">return</span> &amp;healthpb.HealthCheckResponse&#123;</span><br><span class="line">         Status: servingStatus,</span><br><span class="line">      &#125;, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.NotFound, <span class="string">"unknown service"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="watch"><a class="markdownIt-Anchor" href="#watch"></a> Watch</h5><p><code>watch</code> 其实就是服务端不断地将状态的变化通知给客户端</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Watch implements `service Health`.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Watch</span><span class="params">(in *healthpb.HealthCheckRequest, stream healthgrpc.Health_WatchServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   service := in.Service</span><br><span class="line">   <span class="comment">// update channel is used for getting service status updates.</span></span><br><span class="line">   update := <span class="built_in">make</span>(<span class="keyword">chan</span> healthpb.HealthCheckResponse_ServingStatus, <span class="number">1</span>)</span><br><span class="line">   s.mu.Lock()</span><br><span class="line">   <span class="comment">// Puts the initial status to the channel.</span></span><br><span class="line">   <span class="keyword">if</span> servingStatus, ok := s.statusMap[service]; ok &#123;</span><br><span class="line">      update &lt;- servingStatus<span class="comment">//如果服务状态存在，那么写入隧道中</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果不存在，则更新未知</span></span><br><span class="line">      update &lt;- healthpb.HealthCheckResponse_SERVICE_UNKNOWN</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注册状态</span></span><br><span class="line">   <span class="keyword">if</span> _, ok := s.updates[service]; !ok &#123;</span><br><span class="line">      s.updates[service] = <span class="built_in">make</span>(<span class="keyword">map</span>[healthgrpc.Health_WatchServer]<span class="keyword">chan</span> healthpb.HealthCheckResponse_ServingStatus)</span><br><span class="line">   &#125;</span><br><span class="line">   s.updates[service][stream] = update</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      s.mu.Lock()</span><br><span class="line">      <span class="built_in">delete</span>(s.updates[service], stream)</span><br><span class="line">      s.mu.Unlock()</span><br><span class="line">   &#125;()</span><br><span class="line">   s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> lastSentStatus healthpb.HealthCheckResponse_ServingStatus = <span class="number">-1</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">     </span><br><span class="line">      <span class="keyword">case</span> servingStatus := &lt;-update:<span class="comment">//监听 update</span></span><br><span class="line">         <span class="keyword">if</span> lastSentStatus == servingStatus &#123;<span class="comment">//与上一次的状态相同，那么就不会响应</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//否则发送状态</span></span><br><span class="line">         lastSentStatus = servingStatus</span><br><span class="line">         err := stream.Send(&amp;healthpb.HealthCheckResponse&#123;Status: servingStatus&#125;)</span><br><span class="line">         <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> status.Error(codes.Canceled, <span class="string">"Stream has ended."</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> &lt;-stream.Context().Done():</span><br><span class="line">         <span class="keyword">return</span> status.Error(codes.Canceled, <span class="string">"Stream has ended."</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li><p>心跳检查是为了客户端可以根据服务端状态进行自定义操作</p></li><li><p>心跳检查启动的时候启动了退避算法，gRPC默认的退避算法是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultConfig = Config&#123;</span><br><span class="line">BaseDelay:  <span class="number">1.0</span> * time.Second,</span><br><span class="line">Multiplier: <span class="number">1.6</span>,</span><br><span class="line">Jitter:     <span class="number">0.2</span>,</span><br><span class="line">MaxDelay:   <span class="number">120</span> * time.Second,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>Watch</code>中如果与上一次的状态没有变化，则不会通知客户端</p></li><li><p>健康检查针对的是具有相同地址的多个服务，一个服务异常整体连接在不会断开，而是更新连接状态</p><ul><li>针对不能提供服务的服务器端，客户端会将链接状态更新为<code>TransientFailure</code>，但是链接不会断的；当该连接的状态重新更新为<code>Ready</code>时，还可以继续创建流，传输数据。</li><li>针对可以对外提供服务的服务器端，客户端会将链接状态更新为<code>Ready</code>，生成<code>Picker</code>，即将此链接缓存到平衡器里，并且将链接状态更新为<code>Ready</code>，接下来，就可以创建流，传输数据了</li></ul></li><li><p>健康检查可以应用会更新连接状态，且不能自定义 <code>withHealthCheckFunc</code></p></li><li><p>如果在传输过程中收到服务端通知，由于数据发送存在重试机制，所以还是可以从平衡器中选择 <code>Ready</code> 的连接重新传输数据</p></li><li><p>健康检查与保持链接的区别</p><ol><li><code>keepalive</code>和<code>healthcheck</code>都是用于确保通信的可用性和健康状态的机制。</li><li><code>keepalive</code>是一种保持连接活动的机制，用于检测连接是否处于空闲状态，并在需要时发送ping帧以防止连接关闭。<code>keepalive</code>机制确保长时间的空闲连接不会被关闭，以避免重新建立连接的开销</li><li><code>healthcheck</code>是一种检查服务可用性的机制，用于检测服务器是否可用，以及在服务器不可用时采取相应的措施。<code>healthcheck</code>机制通过发送特定的RPC请求来检查服务器的可用性，并根据响应的状态码和错误信息来确定服务器的状态。</li></ol></li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://github.com/grpc/grpc/blob/master/doc/health-checking.md" target="_blank" rel="noopener">https://github.com/grpc/grpc/blob/master/doc/health-checking.md</a></li><li><a href="https://blog.csdn.net/u011582922/article/details/120052706" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/120052706</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面学习了保持链接，这里看一下健康检查&lt;/p&gt;
&lt;p&gt;带着问题看世界&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;健康检查的作用&lt;/li&gt;
&lt;li&gt;健康检查的原理&lt;/li&gt;
&lt;li&gt;保持链接与健康检查的区别&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先看一下源码例子中的ReadMe说明，gRPC提供了一
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-13-保持链接</title>
    <link href="http://xboom.github.io/2022/10/31/Grpc/Grpc-13-%E4%BF%9D%E6%8C%81%E9%93%BE%E6%8E%A5/"/>
    <id>http://xboom.github.io/2022/10/31/Grpc/Grpc-13-%E4%BF%9D%E6%8C%81%E9%93%BE%E6%8E%A5/</id>
    <published>2022-10-31T14:58:29.000Z</published>
    <updated>2023-05-27T10:56:04.414Z</updated>
    
    <content type="html"><![CDATA[<p>在学习的过程中看到了grpc-go中的两个概念 <strong>保持链接</strong> 和 <strong>心跳检查</strong>，这里先学习一下<strong>保持链接</strong></p><p>带着问题看世界</p><ol><li>保持链接的作用</li><li>保持链接的原理</li><li>它与TCP的 <code>keepalive</code> 有什么区别</li></ol><p>首先来看一下<a href="https://github.com/grpc/grpc-go/blob/master/Documentation/keepalive.md" target="_blank" rel="noopener">官方的介绍</a>，</p><ul><li><p>保持连接功能可以检测TCP层面的连接故障。在某些情况下，TCP连接会丢失数据包(包括FIN)，需要等待系统TCP超时时间(可能为30分钟)才能检测到故障。使用保持连接功能可以让gRPC更早地检测到这种故障</p></li><li><p>另外是保持连接活动，比如在L4代理中配置为关闭“空闲连接”的情况下，发送包活消息可以是连接不处于“空闲”状态</p></li></ul><p>这里补充一下TCP的 keepalive 的原理：</p><p>当一方发送一个数据包后，如果对方没有回应，那么TCP协议会按照指数退避的算法重新发送数据包，最多会重发12次。如果在这12次内仍然没有收到对方的响应，则会将连接标记为“超时”，并关闭连接。这个过程通常需要30分钟左右</p><blockquote><p>可以手动修改TCP默认的超时时间</p><p>sudo sysctl -w net.ipv4.tcp_keepalive_time=300</p></blockquote><h3 id="基本使用"><a class="markdownIt-Anchor" href="#基本使用"></a> 基本使用</h3><h4 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kacp = keepalive.ClientParameters&#123;</span><br><span class="line">   Time:                <span class="number">10</span> * time.Second, <span class="comment">// send pings every 10 seconds if there is no activity</span></span><br><span class="line">   Timeout:             time.Second,      <span class="comment">// wait 1 second for ping ack before considering the connection dead</span></span><br><span class="line">   PermitWithoutStream: <span class="literal">true</span>,             <span class="comment">// send pings even without active streams</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithKeepaliveParams(kacp))</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端的保持心跳参数一共有三个</p><ol><li><code>Time</code>：在没有活动的情况下，发送 ping 的时间间隔(<strong>不能少于10s</strong>)</li><li><code>Timeout</code>：等待ping确认的超时时间</li><li><code>PermitWithoutStream</code>：及时没有活动的流也要发送<code>ping</code>请求</li></ol><h4 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kaep = keepalive.EnforcementPolicy&#123;</span><br><span class="line">   MinTime:             <span class="number">5</span> * time.Second, <span class="comment">// If a client pings more than once every 5 seconds, terminate the connection</span></span><br><span class="line">   PermitWithoutStream: <span class="literal">true</span>,            <span class="comment">// Allow pings even when there are no active streams</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kasp = keepalive.ServerParameters&#123;</span><br><span class="line">   MaxConnectionIdle:     <span class="number">15</span> * time.Second, <span class="comment">// If a client is idle for 15 seconds, send a GOAWAY</span></span><br><span class="line">   MaxConnectionAge:      <span class="number">30</span> * time.Second, <span class="comment">// If any connection is alive for more than 30 seconds, send a GOAWAY</span></span><br><span class="line">   MaxConnectionAgeGrace: <span class="number">5</span> * time.Second,  <span class="comment">// Allow 5 seconds for pending RPCs to complete before forcibly closing connections</span></span><br><span class="line">   Time:                  <span class="number">5</span> * time.Second,  <span class="comment">// Ping the client if it is idle for 5 seconds to ensure the connection is still active</span></span><br><span class="line">   Timeout:               <span class="number">1</span> * time.Second,  <span class="comment">// Wait 1 second for the ping ack before assuming the connection is dead</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := grpc.NewServer(grpc.KeepaliveEnforcementPolicy(kaep), grpc.KeepaliveParams(kasp))</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一共有两个保活配置 <code>EnforcementPolicy</code> 与 <code>ServerParameters</code></p><p><code>EnforcementPolicy</code> 定义了服务端如何执行保活策略</p><ul><li><code>MinTime</code>：如果客户端每隔不到5秒就发送一个ping请求，服务器就终止连接</li><li><code>PermitWithoutStream</code>：表示即使没有活动的流，也允许ping请求</li></ul><p>ServerParameters 定义了保活</p><ul><li><code>MaxConnectionIdle</code>：如果客户端闲置超过 15 秒，则发送 <code>GOAWAY</code></li><li><code>MaxConnectionAge</code>： 如果任何连接存在时间超过 30 秒，则发送 <code>GOAWAY</code></li><li><code>MaxConnectionAgeGrace</code>：允许在强制关闭连接之前等待 5 秒钟以完成待处理的 <code>RPC</code></li><li><code>Time</code>：如果客户端闲置超过 5 秒钟，则发送 <code>ping</code> 以确保连接仍处于活动状态</li><li><code>Timeout</code>：等待 1 秒钟以获取 <code>ping</code> 的响应，在此之后假定连接已断开</li></ul><p><code>MaxConnectionAge</code>是指整个连接（connection）的最长存在时间，不是单个流(stream)的最长存在时间。当一个连接的时间超过了 <code>MaxConnectionAge</code> 指定的时间，服务器会发送一个 <code>GOAWAY</code> 帧，表示不再接受来自该连接的新流。任何新的流的创建请求都会被拒绝，并且服务器会等待 <code>MaxConnectionAgeGrace</code> 指定的一段时间，让尚未完成的 RPC 请求完成。在这段时间内，服务器不会发送任何新的数据帧，但仍会响应已有的流。</p><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><h4 id="客户端-2"><a class="markdownIt-Anchor" href="#客户端-2"></a> 客户端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newHTTP2Client</span><span class="params">(connectCtx, ctx context.Context, addr resolver.Address, opts ConnectOptions, onPrefaceReceipt <span class="keyword">func</span>()</span>, <span class="title">onGoAway</span> <span class="title">func</span><span class="params">(GoAwayReason)</span>, <span class="title">onClose</span> <span class="title">func</span><span class="params">()</span>) <span class="params">(_ *http2Client, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">kp := opts.KeepaliveParams</span><br><span class="line"><span class="comment">// Validate keepalive parameters.</span></span><br><span class="line"><span class="keyword">if</span> kp.Time == <span class="number">0</span> &#123;</span><br><span class="line">kp.Time = defaultClientKeepaliveTime</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> kp.Timeout == <span class="number">0</span> &#123;</span><br><span class="line">kp.Timeout = defaultClientKeepaliveTimeout</span><br><span class="line">&#125;</span><br><span class="line">keepaliveEnabled := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> kp.Time != infinity &#123;</span><br><span class="line"><span class="keyword">if</span> err = syscall.SetTCPUserTimeout(conn, kp.Timeout); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, connectionErrorf(<span class="literal">false</span>, err, <span class="string">"transport: failed to set TCP_USER_TIMEOUT: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">keepaliveEnabled = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//... </span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> t.keepaliveEnabled &#123;<span class="comment">//如果开启包活</span></span><br><span class="line">t.kpDormancyCond = sync.NewCond(&amp;t.mu)</span><br><span class="line"><span class="keyword">go</span> t.keepalive()</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是在构建链接的时候设置的超时时间 <code>SetTCPUserTimeout</code>，指定发送数据后多久没有收到确认信号就会超时。</p><ul><li>这是设置是设置网络层的，并不会影响gRPC应用层，因为gRPC超时会重试</li><li>并不是所有的操作系统都支持 <code>syscall.SetTCPUserTimeout</code>(可能老的操作系统不支持，Linux、Windows、MacOS都支持)</li></ul><p>如果开启保活，通过开启独立协程发送ping帧确保链接是活的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *http2Client)</span> <span class="title">keepalive</span><span class="params">()</span></span> &#123;</span><br><span class="line">   p := &amp;ping&#123;data: [<span class="number">8</span>]<span class="keyword">byte</span>&#123;&#125;&#125;</span><br><span class="line">   outstandingPing := <span class="literal">false</span> <span class="comment">//是否有等待响应的ping帧</span></span><br><span class="line">   timeoutLeft := time.Duration(<span class="number">0</span>)<span class="comment">//记录发送ping之后剩余时间</span></span><br><span class="line">   prevNano := time.Now().UnixNano() <span class="comment">//记录活动时间</span></span><br><span class="line">   timer := time.NewTimer(t.kp.Time)<span class="comment">//开启定时器</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">         lastRead := atomic.LoadInt64(&amp;t.lastRead)</span><br><span class="line">         <span class="keyword">if</span> lastRead &gt; prevNano &#123;<span class="comment">//自从上次定时器已经读取过了</span></span><br><span class="line">            outstandingPing = <span class="literal">false</span></span><br><span class="line">            <span class="comment">// Next timer should fire at kp.Time seconds from lastRead time.</span></span><br><span class="line">           <span class="comment">//重新计算下次触发定时器时间(从上次读取时间开始算)</span></span><br><span class="line">            timer.Reset(time.Duration(lastRead) + t.kp.Time - time.Duration(time.Now().UnixNano()))</span><br><span class="line">            prevNano = lastRead</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//outstandingPing  有等待响应的ping帧，且已经超时。表示链接超时关闭</span></span><br><span class="line">         <span class="keyword">if</span> outstandingPing &amp;&amp; timeoutLeft &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            t.Close(connectionErrorf(<span class="literal">true</span>, <span class="literal">nil</span>, <span class="string">"keepalive ping failed to receive ACK within timeout"</span>))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         t.mu.Lock()</span><br><span class="line">         <span class="keyword">if</span> t.state == closing &#123;<span class="comment">//如果链接的状态是关闭中，那么也退出</span></span><br><span class="line">            t.mu.Unlock()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//如果没有活动流，且没有活动流不允许发送ping帧</span></span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">len</span>(t.activeStreams) &lt; <span class="number">1</span> &amp;&amp; !t.kp.PermitWithoutStream &#123;</span><br><span class="line">            outstandingPing = <span class="literal">false</span></span><br><span class="line">            t.kpDormant = <span class="literal">true</span></span><br><span class="line">            t.kpDormancyCond.Wait() <span class="comment">//在初始化流或者关闭客户端的时候 会触发 t.kpDormancyCond.Signal()</span></span><br><span class="line">         &#125;</span><br><span class="line">         t.kpDormant = <span class="literal">false</span></span><br><span class="line">         t.mu.Unlock()</span><br><span class="line"></span><br><span class="line">         <span class="comment">//没有等待响应的ping帧，就发送ping帧</span></span><br><span class="line">         <span class="keyword">if</span> !outstandingPing &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            t.controlBuf.put(p)<span class="comment">//发送ping帧</span></span><br><span class="line">            timeoutLeft = t.kp.Timeout</span><br><span class="line">            outstandingPing = <span class="literal">true</span></span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         sleepDuration := minTime(t.kp.Time, timeoutLeft)</span><br><span class="line">         timeoutLeft -= sleepDuration</span><br><span class="line">         timer.Reset(sleepDuration)<span class="comment">//计算定时器下一次触发时间</span></span><br><span class="line">      <span class="keyword">case</span> &lt;-t.ctx.Done():</span><br><span class="line">         <span class="keyword">if</span> !timer.Stop() &#123;</span><br><span class="line">            &lt;-timer.C</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是根据 ping帧的状态以及链接是否有活动来计算发送ping帧时间。</p><p>有几个注意点</p><ol><li><p>如何判断有ping帧响应的</p><p>其实它并没有判断是有有相应帧，而是是否在指定时间内是否读取到消息即可</p></li><li><p>如果没有活动流又不允许非活动流发送ping，那么它是如何处理的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果没有活动流，且没有活动流不允许发送ping帧</span></span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">len</span>(t.activeStreams) &lt; <span class="number">1</span> &amp;&amp; !t.kp.PermitWithoutStream &#123;</span><br><span class="line">    outstandingPing = <span class="literal">false</span></span><br><span class="line">    t.kpDormant = <span class="literal">true</span></span><br><span class="line">    t.kpDormancyCond.Wait() <span class="comment">//在初始化流或者关闭客户端的时候 会触发 t.kpDormancyCond.Signal()</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>而出发 <code>kpDormancyCond.Signal()</code>的位置是 构建流或者关闭连接</p></li></ol><h4 id="服务端-2"><a class="markdownIt-Anchor" href="#服务端-2"></a> 服务端</h4><p>服务端同样也是使用独立协程来运行保活逻辑</p><ol><li>超过 最长闲置时间 <code>MaxConnectionIdle</code> 优雅的关闭连接</li><li>超过 最大连接时间 MaxConnectionAge 优雅的关闭连接</li><li>等待 <code>MaxConnectionAgeGrace</code> 后强制关闭连接。</li><li>以 <code>Time</code> 的频率发送 <code>ping</code> 确保连接存活，并在 <code>Timeout</code> 的额外时间内关闭无响应的连接</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *http2Server)</span> <span class="title">keepalive</span><span class="params">()</span></span> &#123;</span><br><span class="line">   p := &amp;ping&#123;&#125;</span><br><span class="line">   outstandingPing := <span class="literal">false</span> <span class="comment">//是否有等待响应帧</span></span><br><span class="line">   kpTimeoutLeft := time.Duration(<span class="number">0</span>)</span><br><span class="line">   prevNano := time.Now().UnixNano()</span><br><span class="line">   <span class="comment">// Initialize the different timers to their default values.</span></span><br><span class="line">   idleTimer := time.NewTimer(t.kp.MaxConnectionIdle)</span><br><span class="line">   ageTimer := time.NewTimer(t.kp.MaxConnectionAge)</span><br><span class="line">   kpTimer := time.NewTimer(t.kp.Time)</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      idleTimer.Stop()</span><br><span class="line">      ageTimer.Stop()</span><br><span class="line">      kpTimer.Stop()</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-idleTimer.C:<span class="comment">//闲置定时器</span></span><br><span class="line">         t.mu.Lock()</span><br><span class="line">         idle := t.idle</span><br><span class="line">         <span class="keyword">if</span> idle.IsZero() &#123; <span class="comment">//未闲置则重置最大闲置时间</span></span><br><span class="line">            t.mu.Unlock()</span><br><span class="line">            idleTimer.Reset(t.kp.MaxConnectionIdle)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         val := t.kp.MaxConnectionIdle - time.Since(idle)</span><br><span class="line">         t.mu.Unlock()</span><br><span class="line">         <span class="keyword">if</span> val &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            t.Drain()<span class="comment">//优雅关闭连接</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         idleTimer.Reset(val)<span class="comment">//重置闲置连接</span></span><br><span class="line">      <span class="keyword">case</span> &lt;-ageTimer.C:<span class="comment">//最长连接</span></span><br><span class="line">         t.Drain()</span><br><span class="line">         ageTimer.Reset(t.kp.MaxConnectionAgeGrace)</span><br><span class="line">         <span class="keyword">select</span> &#123;</span><br><span class="line">         <span class="keyword">case</span> &lt;-ageTimer.C:</span><br><span class="line">            <span class="comment">// Close the connection after grace period.</span></span><br><span class="line">            <span class="keyword">if</span> logger.V(logLevel) &#123;</span><br><span class="line">               logger.Infof(<span class="string">"transport: closing server transport due to maximum connection age."</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            t.Close()</span><br><span class="line">         <span class="keyword">case</span> &lt;-t.done:</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">case</span> &lt;-kpTimer.C:<span class="comment">//保活定时器</span></span><br><span class="line">         lastRead := atomic.LoadInt64(&amp;t.lastRead)</span><br><span class="line">         <span class="keyword">if</span> lastRead &gt; prevNano &#123;</span><br><span class="line">            <span class="comment">// There has been read activity since the last time we were</span></span><br><span class="line">            <span class="comment">// here. Setup the timer to fire at kp.Time seconds from</span></span><br><span class="line">            <span class="comment">// lastRead time and continue.</span></span><br><span class="line">            outstandingPing = <span class="literal">false</span></span><br><span class="line">            kpTimer.Reset(time.Duration(lastRead) + t.kp.Time - time.Duration(time.Now().UnixNano()))</span><br><span class="line">            prevNano = lastRead</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> outstandingPing &amp;&amp; kpTimeoutLeft &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> logger.V(logLevel) &#123;</span><br><span class="line">               logger.Infof(<span class="string">"transport: closing server transport due to idleness."</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            t.Close()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> !outstandingPing &#123;<span class="comment">//如果没有等待保活则发送保活帧</span></span><br><span class="line">            <span class="keyword">if</span> channelz.IsOn() &#123;</span><br><span class="line">               atomic.AddInt64(&amp;t.czData.kpCount, <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            t.controlBuf.put(p)</span><br><span class="line">            kpTimeoutLeft = t.kp.Timeout</span><br><span class="line">            outstandingPing = <span class="literal">true</span></span><br><span class="line">         &#125;</span><br><span class="line">         sleepDuration := minTime(t.kp.Time, kpTimeoutLeft)</span><br><span class="line">         kpTimeoutLeft -= sleepDuration</span><br><span class="line">         kpTimer.Reset(sleepDuration)</span><br><span class="line">      <span class="keyword">case</span> &lt;-t.done:</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：</p><ol><li><p>连接什么时候闲置的?</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(t.activeStreams) == <span class="number">1</span> &#123;</span><br><span class="line">  t.idle = time.Time&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在处理头帧的时候(构建了一个活跃流)，如果 <code>len(t.activeStreams) == 1</code> ，表示刚新建一个流且仅有一个活跃流，那么这个时候连接是闲置的</p></li><li><p>服务端也会主动发送ping帧</p></li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li><p>TCP与gRPC的区别</p><p>TCP的Keepalive是一种机制，它允许在网络连接空闲时发送探测包（keepalive包）来维护连接的状态。这些探测包不包含有效负载，只是一个空的TCP报文段，主要用于检测连接是否仍然活着。</p><p>当TCP连接上没有传输数据时会进入空闲状态，即使连接已经中断或不可用，导致不必要的延迟和资源浪费。Keepalive机制可以在连接空闲时周期性地发送探测包，以检测连接是否仍然活着。如果远程端点没有响应这些探测包，则可以视为连接已经断开，并且可以关闭连接。</p><p>在gRPC中，使用Keepalive可以检测底层TCP连接是否失效，并在检测到连接问题时及时重新建立连接，从而提高网络连接的可靠性和性能。</p></li><li><p>客户端与服务端都会根据配置向对端发送ping帧，只要在指定时间内读取到帧，那么就不会主动发送ping帧</p></li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://blog.csdn.net/u011582922/article/details/120279303" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/120279303</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习的过程中看到了grpc-go中的两个概念 &lt;strong&gt;保持链接&lt;/strong&gt; 和 &lt;strong&gt;心跳检查&lt;/strong&gt;，这里先学习一下&lt;strong&gt;保持链接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;带着问题看世界&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;保持链接的作用&lt;/l
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-02-平衡器</title>
    <link href="http://xboom.github.io/2022/10/28/Grpc/Grpc-12-%E5%B9%B3%E8%A1%A1%E5%99%A8/"/>
    <id>http://xboom.github.io/2022/10/28/Grpc/Grpc-12-%E5%B9%B3%E8%A1%A1%E5%99%A8/</id>
    <published>2022-10-28T14:58:29.000Z</published>
    <updated>2023-05-27T10:55:56.060Z</updated>
    
    <content type="html"><![CDATA[<p>平衡器的核心目的就是用于向服务端发起链接，主要包括</p><ul><li>子链接的维护，每个 target 可能对应多个地址(类似一个服务有多个副本)，进行子链接的新增与删除</li><li>当平衡器状态发生变化，更新 <code>ClientConn</code> 的状态，自定义选择器，从而让客户端选择具体子链接进行发送</li><li>在满足一定条件的情况下，执行解析器操作。如解析器由阻塞状态 --&gt; 非阻塞状态</li></ul><h4 id="整体流程"><a class="markdownIt-Anchor" href="#整体流程"></a> 整体流程</h4><h4 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h4><p>代码路径:<code>/balancer/balancer.go</code>，在这个文件中一共定义了五个接口</p><ul><li><strong>Builder 接口</strong>，主要用来创建平衡器</li><li><strong>SubConn 接</strong>口，主要用来负责具体的链接(<strong>这里的链接指的是一对实际建立链接的客户端与服务器</strong>)</li><li><strong>Picker 接口</strong>，主要是从众多 <code>SubConn</code>中按照某个策略选择一个链接进行数据传输，也就是 <strong>选择器</strong></li><li><strong>Balancer 接口</strong>，主要是更新 <code>ClientConn</code> 的状态，更新<code>SubConn</code>状态</li><li><strong>ClientConn 接口</strong>，主要是负责链路的维护，包括创建、移除、更新一个子链路，更新 <code>ClientConn</code> 状态</li></ul><p>所以平衡器也跟解析器一样，由两部分组成平衡器构建器与平衡器，内部在封装到一个结构体实现平衡器功能</p><h4 id="平衡器构建器注册"><a class="markdownIt-Anchor" href="#平衡器构建器注册"></a> 平衡器构建器注册</h4><p>平衡器构建器通过注册的方式将自己平衡器的构建方法存入全局变量中，当需要使用的时候则直接根据名称获取</p><ol><li><p>使用一个全局的 map  <code>var m = make(map[string]Builder)</code>进行平衡器构建器 <code>Builder</code> 的存储。k/v 分别对应的是构建 构建器的名称以及构建器的实现方法。</p></li><li><p>平衡器构建器可以通过 <code>Register</code> 函数存储到这个 map 中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Register 注册平衡器构建器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Register</span><span class="params">(b Builder)</span></span> &#123;</span><br><span class="line">m[strings.ToLower(b.Name())] = b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Get 获取平衡器构建器，如果找不到则返回nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Builder</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> b, ok := m[strings.ToLower(name)]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>有了存储与添加，它还增加了一个删除操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//仅做测试使用，去掉某一个平衡器解析器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unregisterForTesting</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(m, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">internal.BalancerUnregister = unregisterForTesting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除操作则是利用 <code>init</code> 给 <code>BalancerUnregister</code> 复制一个 删除函数 <code>unregisterForTesting</code></p></li><li><p>而一个普通的平衡器构建器(已轮询平衡器构建器为例<code>rrPickerBuilder</code>)，则是利用 init 函数直接初始化到这个全局map中，那么就可以在需要使用的时候，直接从全局map 中获取</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Name = <span class="string">"round_robin"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个平衡器构建器对洗那个</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newBuilder</span><span class="params">()</span> <span class="title">balancer</span>.<span class="title">Builder</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> base.NewBalancerBuilder(Name, &amp;rrPickerBuilder&#123;&#125;, base.Config&#123;HealthCheck: <span class="literal">true</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化将 round_robin平衡器构建器存入全局 map 中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">balancer.Register(newBuilder())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="构建平衡器"><a class="markdownIt-Anchor" href="#构建平衡器"></a> 构建平衡器</h4><p>有了平衡器构建器之后，通过选定的平衡器构建器进行平衡器的构建</p><ol><li><p>设置通过哪个平衡器构建器获取平衡器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serviceConfig = <span class="string">`&#123;</span></span><br><span class="line"><span class="string">"loadBalancingConfig": [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">"grpclb": &#123;</span></span><br><span class="line"><span class="string">"childPolicy": [</span></span><br><span class="line"><span class="string">&#123;"round_robin": ""&#125;,</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line">grpc.WithDefaultServiceConfig(serviceConfig)</span><br></pre></td></tr></table></figure><p>如果不设置负载均衡构建器名称，那么grpc-go 会默认使用 <code>round_robin</code> 构建平衡器</p></li><li><p>指定了构建器之后就会在构建链接过程中调用构建函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialContext</span><span class="params">(ctx context.Context, target <span class="keyword">string</span>, opts ...DialOption)</span> <span class="params">(conn *ClientConn, err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//...                                                                                                      </span></span><br><span class="line">    cc.balancerWrapper = newCCBalancerWrapper(cc, balancer.BuildOptions&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在建立连接的过程中，通过</p></li></ol><h4 id="构建链接"><a class="markdownIt-Anchor" href="#构建链接"></a> 构建链接</h4><h4 id="存储链接"><a class="markdownIt-Anchor" href="#存储链接"></a> 存储链接</h4><h4 id="实际应用"><a class="markdownIt-Anchor" href="#实际应用"></a> 实际应用</h4><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://blog.csdn.net/u011582922/article/details/117547171" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/117547171</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平衡器的核心目的就是用于向服务端发起链接，主要包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子链接的维护，每个 target 可能对应多个地址(类似一个服务有多个副本)，进行子链接的新增与删除&lt;/li&gt;
&lt;li&gt;当平衡器状态发生变化，更新 &lt;code&gt;ClientConn&lt;/code&gt; 
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-03-选择器</title>
    <link href="http://xboom.github.io/2022/10/25/Grpc/Grpc-11-%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <id>http://xboom.github.io/2022/10/25/Grpc/Grpc-11-%E9%80%89%E6%8B%A9%E5%99%A8/</id>
    <published>2022-10-25T14:58:29.000Z</published>
    <updated>2023-05-27T10:55:51.743Z</updated>
    
    <content type="html"><![CDATA[<ol><li>什么是Grpc</li><li>为什么我们要使用grpc</li><li>优点有哪些</li></ol><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/20210605094836494.jpg" alt="resolver、balancer、picker之间的关系" /></p><p>从图中可以看出 grpc 客户端与服务端的通信主要有两个阶段</p><ol><li>建立链接阶段</li><li>帧传输阶段</li></ol><p>这其中存在三个主要的功能接口</p><ul><li><p>解析器 resolver 负责根据域名解析地址</p></li><li><p>平衡器 balancer 负责根据地址构建对应连接</p></li><li><p>选择器 picker 负责在发送的时候选择合适的连接</p></li></ul><p>在第一阶段建立链接的过程中，主要通过 解析器与平衡器构建链接；在第二阶段发送过程中通过选择器从准备好的连接中选择合适的连接进行帧的传输</p><p>根据负载均衡器的位置不同，可以分为</p><ul><li>根据作用的位置可以分为客户端负载均衡器、服务端负载均衡器</li><li>根据部署的方式可以分为 <strong>集中式LB(Proxy Model)</strong>、进程内LB(Balancing-aware Client)、<strong>独立LB进程(External Load Balancing Service)</strong></li></ul><blockquote><p>独立LB与集中式LB的区别是，独立LB不在进程内部，但是是伴随着进程的，类似SideCar模式。</p></blockquote><p>在 <code>grpc-go</code> 的中的负载均衡器(选择器)，其实是一种 <strong>进程内LB</strong>，它的核心功能就是：<strong>根据规则选择合适的子链接进行消息发送</strong></p><h3 id="整体流程"><a class="markdownIt-Anchor" href="#整体流程"></a> 整体流程</h3><h3 id="实际应用"><a class="markdownIt-Anchor" href="#实际应用"></a> 实际应用</h3><p>代码路径：<code>balancer\balancer.go</code></p><p>选择器定义了一个 <code>Picker</code> 的接口，按照备注</p><ol><li><code>Pick</code> 函数用于发送RPC消息的连接以及相关信息</li><li><code>Pick</code> 函数不应该被阻塞，如果有任何I/O、阻塞、一定时间开销的操作，那么应该返回 <code>ErrNoSubConnAvailable</code>的内部错误，那么它将重复调用(注意：它会一致重复！)直到Picker更新 <code>ClientConn.UpdateState</code></li><li>如果返回了其他错误<ul><li>如果返回一个状态错误来源于 <code>status\status.go</code>，那么 rpc将停止并返回这个错误</li><li>如果是其他错误，那么等待的rpc调用将继续调用，不需要等待的rpc调用将立即停止并返回这个错误以及 状态 Code 为 <code>Unavailable</code></li></ul></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Picker <span class="keyword">interface</span> &#123;</span><br><span class="line">Pick(info PickInfo) (PickResult, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择器执行失败的逻辑处理，代码路径：<code>picker_wrapper.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">pickResult, err := p.Pick(info)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == balancer.ErrNoSubConnAvailable &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, ok := status.FromError(err); ok &#123;</span><br><span class="line"><span class="comment">// Status error: end the RPC unconditionally with this status.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, dropError&#123;error: err&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// For all other errors, wait for ready RPCs should block and other</span></span><br><span class="line"><span class="comment">// RPCs should fail with unavailable.</span></span><br><span class="line"><span class="keyword">if</span> !failfast &#123;</span><br><span class="line">lastPickErr = err</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, status.Error(codes.Unavailable, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 failfast 是通过 <code>serviceconfig.MethodConfig</code> 中的 <code>WaitForReady</code> 控制，可在初始化连接配置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grpc.WithDefaultServiceConfig(<span class="string">`&#123;"methodConfig": [&#123;"waitForReady": true&#125;]&#125;`</span>)</span><br></pre></td></tr></table></figure><h3 id="实际应用-2"><a class="markdownIt-Anchor" href="#实际应用-2"></a> 实际应用</h3><h4 id="pickfirst"><a class="markdownIt-Anchor" href="#pickfirst"></a> PickFirst</h4><p>pickFirst 是 grpc-go 内置的选择器，它的作用是从链接中选择第一个已经建立好的链接给流使用</p><p>代码路径：<code>pickfirst.go</code></p><p>首先，看下选择器 <code>pickfirstBalancer</code> 结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pickfirstBalancer <span class="keyword">struct</span> &#123;</span><br><span class="line">state connectivity.State</span><br><span class="line">cc    balancer.ClientConn</span><br><span class="line">sc    balancer.SubConn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>connectivity.State 表示选择器的状态</li><li>balancer.ClientConn 负责子链接 SubConn 的创建、移除。更新客户端链接 ClientConn 的状态。由 <code>ccBalancerWrapper</code>结构实现</li><li>balancer.SubConn 主要负责向 grpc 服务发起链接</li></ul><p>其次，<code>pickfirstBalancer</code> 其实实现了平衡器构建接口，也就是说，通过 <code>pickfirstBalancer</code> 可以构建一个平衡器</p><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/377860784" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/377860784</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;什么是Grpc&lt;/li&gt;
&lt;li&gt;为什么我们要使用grpc&lt;/li&gt;
&lt;li&gt;优点有哪些&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-10-连接</title>
    <link href="http://xboom.github.io/2022/10/22/Grpc/Grpc-10-%E8%BF%9E%E6%8E%A5/"/>
    <id>http://xboom.github.io/2022/10/22/Grpc/Grpc-10-%E8%BF%9E%E6%8E%A5/</id>
    <published>2022-10-22T14:58:29.000Z</published>
    <updated>2023-05-27T10:55:43.898Z</updated>
    
    <content type="html"><![CDATA[<h3 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h3><ol><li><p>构建链接阶段设置超时时间</p><p>构建链接阶段有单独的超时控制，也就是链接的超时控制与发送请求的超时控制是分开的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conn, err := grpc.DialContext(context.Background(), *addr, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatalf(<span class="string">"did not connect: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br></pre></td></tr></table></figure><p>在构建链接的过程中，通过强制等待</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialContext</span><span class="params">(ctx context.Context, target <span class="keyword">string</span>, opts ...DialOption)</span> <span class="params">(conn *ClientConn, err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//等待最后的结果，要么ctx.Done()结束</span></span><br><span class="line">     <span class="keyword">select</span> &#123;</span><br><span class="line">     <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> ctx.Err() == err:<span class="comment">//失败错误</span></span><br><span class="line">           conn = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> err == <span class="literal">nil</span> || !cc.dopts.returnLastError:<span class="comment">//将服务端的错误与错误信息一起返回给客户端而不是仅仅一个错误码</span></span><br><span class="line">           conn, err = <span class="literal">nil</span>, ctx.Err()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">           conn, err = <span class="literal">nil</span>, fmt.Errorf(<span class="string">"%v: %v"</span>, ctx.Err(), err)<span class="comment">//返回其他错误</span></span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span> cc.dopts.block &#123;<span class="comment">//如果是阻塞模式</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">cc.Connect()</span><br><span class="line">s := cc.GetState()</span><br><span class="line"><span class="keyword">if</span> s == connectivity.Ready &#123;<span class="comment">//连接状态，健康检查的时候也会更新</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> cc.dopts.copts.FailOnNonTempDialError &amp;&amp; s == connectivity.TransientFailure &#123;</span><br><span class="line"><span class="keyword">if</span> err = cc.connectionError(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">terr, ok := err.(<span class="keyword">interface</span> &#123;</span><br><span class="line">Temporary() <span class="keyword">bool</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> ok &amp;&amp; !terr.Temporary() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !cc.WaitForStateChange(ctx, s) &#123;<span class="comment">//为什么是等待状态变化，因为构建链接的时候是每个都使用一个协程进行建立连接</span></span><br><span class="line"><span class="comment">// ctx got timeout or canceled.</span></span><br><span class="line"><span class="keyword">if</span> err = cc.connectionError(); err != <span class="literal">nil</span> &amp;&amp; cc.dopts.returnLastError &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ctx.Err()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> cc, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等待连接的状态其实就是等待结果后者超时的过程，通过隧道通知</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *ClientConn)</span> <span class="title">WaitForStateChange</span><span class="params">(ctx context.Context, sourceState connectivity.State)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   ch := cc.csMgr.getNotifyChan()</span><br><span class="line">   <span class="keyword">if</span> cc.csMgr.getState() != sourceState &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Dfasdf</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;客户端&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#客户端&quot;&gt;&lt;/a&gt; 客户端&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;构建链接阶段设置超时时间&lt;/p&gt;
&lt;p&gt;构建链接阶段有单独的超时控制，也就是链接的超时控制与发送请求的超时控制是分开的
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-05-重试机制</title>
    <link href="http://xboom.github.io/2022/10/19/Grpc/Grpc-09-%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/"/>
    <id>http://xboom.github.io/2022/10/19/Grpc/Grpc-09-%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/</id>
    <published>2022-10-19T14:58:29.000Z</published>
    <updated>2023-05-27T10:55:34.640Z</updated>
    
    <content type="html"><![CDATA[<p>重试机制是为了在短暂异常情况下能够正常恢复，也能防止长时间异常而不退出。这里看一下grpc-go 中的重试机制以及使用方法</p><p>带着问题看世界：</p><ol><li>grpc-go 的重试策略的使用</li><li>grpc-go 的重试机制是怎样的</li><li>grpc-go 的重试机制都应用在哪些地方</li></ol><h3 id="基本使用"><a class="markdownIt-Anchor" href="#基本使用"></a> 基本使用</h3><p>通过 <code>Dial</code> 可选参数设置自定义重试策略</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   addr = flag.String(<span class="string">"addr"</span>, <span class="string">"localhost:50052"</span>, <span class="string">"the address to connect to"</span>)</span><br><span class="line">   <span class="comment">// see https://github.com/grpc/grpc/blob/master/doc/service_config.md to know more about service config</span></span><br><span class="line">   retryPolicy = <span class="string">`&#123;</span></span><br><span class="line"><span class="string">      "methodConfig": [&#123;</span></span><br><span class="line"><span class="string">        "name": [&#123;"service": "grpc.examples.echo.Echo"&#125;],</span></span><br><span class="line"><span class="string">        "waitForReady": true,</span></span><br><span class="line"><span class="string">        "retryPolicy": &#123;</span></span><br><span class="line"><span class="string">           "MaxAttempts": 4,</span></span><br><span class="line"><span class="string">           "InitialBackoff": ".01s",</span></span><br><span class="line"><span class="string">           "MaxBackoff": ".01s",</span></span><br><span class="line"><span class="string">           "BackoffMultiplier": 1.0,</span></span><br><span class="line"><span class="string">           "RetryableStatusCodes": [ "UNAVAILABLE" ]</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        "hedgingPolicy": &#123;</span></span><br><span class="line"><span class="string">        "MaxAttempts": "",</span></span><br><span class="line"><span class="string">        "HedgingDelay": "",</span></span><br><span class="line"><span class="string">        "NonFatalStatusCodes": [""]</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;]&#125;`</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// use grpc.WithDefaultServiceConfig() to set service config</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retryDial</span><span class="params">()</span> <span class="params">(*grpc.ClientConn, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithDefaultServiceConfig(retryPolicy))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，这里有两种重试策略 <code>hedgingPolicy</code> (<strong>重试</strong>) 与 <code>retryPolicy</code>(<strong>对冲</strong>)</p><p>重试中参数的解释</p><ol><li><code>MaxAttempts</code>：最大重试次数</li><li><code>InitialBackoff</code>：默认退避时间</li><li><code>MaxBackoff</code>：最大退避时间</li><li><code>BackoffMultiplier</code>：退避时间增加倍率</li><li><code>RetryableStatusCodes</code>: 服务端返回什么错误码才重试</li></ol><p><strong>对冲</strong>是指在不等待响应的情况下主动发送单词调用的多个请求。通俗解释就是 如果<code>HedgingDelay</code>时间没有响应，那么直接发送第二次请求，以此类推，直到达到最大次数 <code>MaxAttempts</code></p><ol><li><code>MaxAttempts</code>：最大重试次数</li><li><code>HedgingDelay</code>：等待响应时间</li></ol><p>也可以通过可选参数关闭重试策略</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDisableRetry</span><span class="params">()</span> <span class="title">DialOption</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> newFuncDialOption(<span class="function"><span class="keyword">func</span><span class="params">(o *dialOptions)</span></span> &#123;</span><br><span class="line">      o.disableRetry = <span class="literal">true</span></span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重试策略"><a class="markdownIt-Anchor" href="#重试策略"></a> 重试策略</h3><p>这两种策略都是通过实现统一的重试接口进行加载</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> isMethodConfig_RetryOrHedgingPolicy <span class="keyword">interface</span> &#123;</span><br><span class="line">   isMethodConfig_RetryOrHedgingPolicy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过转换而进行重试测试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pushback := <span class="number">0</span><span class="comment">//记录重试间隔时间</span></span><br><span class="line">hasPushback := <span class="literal">false</span>  <span class="comment">//记录是否要重试</span></span><br><span class="line"><span class="keyword">if</span> cs.attempt.s != <span class="literal">nil</span> &#123;<span class="comment">//存在重试任务</span></span><br><span class="line">   <span class="keyword">if</span> !cs.attempt.s.TrailersOnly() &#123;<span class="comment">//如果流不是只有trailer,则无法直接读取元数据</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   sps := cs.attempt.s.Trailer()[<span class="string">"grpc-retry-pushback-ms"</span>]<span class="comment">//获取元数据</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(sps) == <span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> e error</span><br><span class="line">      <span class="keyword">if</span> pushback, e = strconv.Atoi(sps[<span class="number">0</span>]); e != <span class="literal">nil</span> || pushback &lt; <span class="number">0</span> &#123;</span><br><span class="line">         cs.retryThrottler.throttle() <span class="comment">// 记录重试次数</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">      &#125;</span><br><span class="line">      hasPushback = <span class="literal">true</span><span class="comment">//重试</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(sps) &gt; <span class="number">1</span> &#123;<span class="comment">//如果存在多个 sps 表示异常</span></span><br><span class="line">      cs.retryThrottler.throttle() <span class="comment">// 记录重试次数(用于重试失败限速)</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>Trailers</code> 是一种消息元数据，用于在相应结束时传递关于次消息的附加信息，通常包含状态码，消息和错误信息的传递。Trailers 通常会在流关闭之前发送。<code>Trailers</code> 发送的情况有几下几种</p><ul><li>RPC正常结束，<code>Trailers</code>中携带调用的状态、错误码、响应时间等信息；</li><li>RPC出错结束，<code>Trailers</code>中携带错误信息，例如错误码、错误消息等；</li><li>服务器关闭了stream，<code>Trailers</code>中携带stream关闭的原因；</li><li>客户端取消了RPC调用，<code>Trailers</code>中携带调用取消的原因</li></ul><p>它的特点：</p><ul><li><p><code>Trailers</code> 并不是每个RPC调用都会发，而是流关闭的时候才会发！！！ 可以包含在最后一个数据帧中附加一个<code>Trailers</code>，所以抓包看不到一个独立的 <code>Trailers</code>。</p></li><li><p>如果流中不仅仅有<code>Trailers</code>，那么无法直接从流中获取 <code>Trailers</code>，而是需要其他办法，比如拦截器</p></li><li><p>包含元数据存储在ctx中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx := metadata.NewOutgoingContext(context.Background(), metadata.Pairs(</span><br><span class="line">    <span class="string">"grpc-retry-pushback-ms"</span>, <span class="string">"5000"</span>,</span><br><span class="line">))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>这里还多了一个 <code>retryThrottler.throttle</code>，在下面的重试速率中说明</p></li><li><p>如果有 没有配置 <code>grpc-retry-pushback-ms</code>，那么就使用重试策略，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dur time.Duration</span><br><span class="line"><span class="keyword">if</span> hasPushback &#123;<span class="comment">//设置了重试元数据</span></span><br><span class="line">   dur = time.Millisecond * time.Duration(pushback)</span><br><span class="line">   cs.numRetriesSincePushback = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   fact := math.Pow(rp.BackoffMultiplier, <span class="keyword">float64</span>(cs.numRetriesSincePushback))</span><br><span class="line">   cur := <span class="keyword">float64</span>(rp.InitialBackoff) * fact</span><br><span class="line">   <span class="keyword">if</span> max := <span class="keyword">float64</span>(rp.MaxBackoff); cur &gt; max &#123;<span class="comment">//最大判断</span></span><br><span class="line">      cur = max</span><br><span class="line">   &#125;</span><br><span class="line">   dur = time.Duration(grpcrand.Int63n(<span class="keyword">int64</span>(cur)))</span><br><span class="line">   cs.numRetriesSincePushback++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，退避时间随着重试次数指数级增长 <code>InitialBackoff * math.Pow(rp.BackoffMultiplier, float64(cs.numRetriesSincePushback))</code></p></li></ol><p>根据上述计算的退避时间执行等待逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t := time.NewTimer(dur)<span class="comment">//开启一个定时器</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-t.C:<span class="comment">//定时器触发，重试次数+1</span></span><br><span class="line">   cs.numRetries++</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;-cs.ctx.Done():<span class="comment">//流程结束停止重试</span></span><br><span class="line">   t.Stop()</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>, status.FromContextError(cs.ctx.Err()).Err()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重试速率"><a class="markdownIt-Anchor" href="#重试速率"></a> 重试速率</h3><p>重试过程中还能看到 <code>RetryThrottlingPolicy</code> 做了一层重试限制，其实除了配置重试策略，还能控制重试的速率，防止重试的次数太多给服务器造成太大压力</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">policy := grpcutil.RetryThrottlingPolicy&#123;</span><br><span class="line">    MaxTokens:    <span class="number">10</span>,            <span class="comment">// 最大令牌数</span></span><br><span class="line">    TokenRate:    <span class="number">1</span>,             <span class="comment">// 每秒产生的令牌数</span></span><br><span class="line">    RetryBudget:  <span class="number">100</span> * time.Millisecond, <span class="comment">// 重试预算</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 DialOption，使用上面的 RetryThrottlingPolicy</span></span><br><span class="line">dialOption := grpc.WithRetryThrottlingPolicy(policy)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 dialOption 创建 gRPC 客户端</span></span><br></pre></td></tr></table></figure><ul><li><code>MaxTokens</code>：最大令牌数，任何时间点同时允许的最大令牌数</li><li><code>TokenRate</code>：每秒产生的令牌数，每个请求都会消耗一个令牌</li><li><code>RetryBudget</code>：重试预算，制定重试操作可以使用的总时间，如果一个请求需要重试，但是时间已经超过了 <code>RetryBudget</code>，那么不在进行重试</li></ul><h4 id="限速原理"><a class="markdownIt-Anchor" href="#限速原理"></a> 限速原理</h4><p>第一步：初始化速率配置</p><p>结构体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> retryThrottler <span class="keyword">struct</span> &#123;</span><br><span class="line">max    <span class="keyword">float64</span><span class="comment">//最大令牌数</span></span><br><span class="line">thresh <span class="keyword">float64</span><span class="comment">//预算</span></span><br><span class="line">  ratio  <span class="keyword">float64</span><span class="comment">//每秒令牌数</span></span><br><span class="line"></span><br><span class="line">mu     sync.Mutex</span><br><span class="line">tokens <span class="keyword">float64</span> <span class="comment">//可用令牌数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换规则</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cc.sc.retryThrottling != <span class="literal">nil</span> &#123;</span><br><span class="line">   newThrottler := &amp;retryThrottler&#123;</span><br><span class="line">      tokens: cc.sc.retryThrottling.MaxTokens,</span><br><span class="line">      max:    cc.sc.retryThrottling.MaxTokens,</span><br><span class="line">      thresh: cc.sc.retryThrottling.MaxTokens / <span class="number">2</span>,</span><br><span class="line">      ratio:  cc.sc.retryThrottling.TokenRatio,</span><br><span class="line">   &#125;</span><br><span class="line">   cc.retryThrottler.Store(newThrottler)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   cc.retryThrottler.Store((*retryThrottler)(<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：计算是否进行限速</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rt *retryThrottler)</span> <span class="title">throttle</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> rt == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">rt.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rt.mu.Unlock()</span><br><span class="line">rt.tokens--</span><br><span class="line"><span class="keyword">if</span> rt.tokens &lt; <span class="number">0</span> &#123;</span><br><span class="line">rt.tokens = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rt.tokens &lt;= rt.thresh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：成功调用则更新可用 <code>tokens</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rt *retryThrottler)</span> <span class="title">successfulRPC</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> rt == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">rt.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rt.mu.Unlock()</span><br><span class="line">rt.tokens += rt.ratio</span><br><span class="line"><span class="keyword">if</span> rt.tokens &gt; rt.max &#123;</span><br><span class="line">rt.tokens = rt.max</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是：一个流中只有只有成功调用的时候才会将增加可用 <code>token</code> 数量</p><h3 id="业务重试"><a class="markdownIt-Anchor" href="#业务重试"></a> 业务重试</h3><p>业务重试一般直接使用重试封装逻辑(已新建流为例)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">op := <span class="function"><span class="keyword">func</span><span class="params">(a *csAttempt)</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> a.newStream() &#125;</span><br><span class="line"><span class="keyword">if</span> err := cs.withRetry(op, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; cs.bufferForRetryLocked(<span class="number">0</span>, op) &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">   cs.finish(err)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部逻辑如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *clientStream)</span> <span class="title">withRetry</span><span class="params">(op <span class="keyword">func</span>(a *csAttempt)</span> <span class="title">error</span>, <span class="title">onSuccess</span> <span class="title">func</span><span class="params">()</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">   cs.mu.Lock()<span class="comment">//获取流的写锁，防止在重试过程又出现新的重试</span></span><br><span class="line">  <span class="keyword">for</span> &#123;<span class="comment">//使用for循环不断尝试</span></span><br><span class="line">      <span class="keyword">if</span> cs.committed &#123;<span class="comment">//流不在发送任何东西</span></span><br><span class="line">         cs.mu.Unlock()</span><br><span class="line">         <span class="keyword">return</span> toRPCErr(op(cs.attempt))</span><br><span class="line">      &#125;</span><br><span class="line">      a := cs.attempt</span><br><span class="line">      cs.mu.Unlock()</span><br><span class="line">      err := op(a)<span class="comment">//执行操作</span></span><br><span class="line">      cs.mu.Lock()</span><br><span class="line">      <span class="keyword">if</span> a != cs.attempt &#123;<span class="comment">//如果重试对象已经变更，则直接跳过继续下一次操作</span></span><br><span class="line">         <span class="comment">// We started another attempt already.</span></span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> err == io.EOF &#123; </span><br><span class="line">         &lt;-a.s.Done()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//执行成功的后续操作</span></span><br><span class="line">      <span class="keyword">if</span> err == <span class="literal">nil</span> || (err == io.EOF &amp;&amp; a.s.Status().Code() == codes.OK) &#123;</span><br><span class="line">         onSuccess()</span><br><span class="line">         cs.mu.Unlock()</span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//执行失败则尝试重试</span></span><br><span class="line">      <span class="keyword">if</span> err := cs.retryLocked(err); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         cs.mu.Unlock()</span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>committed</code>：当客户端调用 <code>CloseSend</code> 方法关闭发送流的时候，会标记 <code>ClientStream</code>为已提交，表示客户端不再发送任何消息</p><p>有个奇怪的地方如下所示，为什么不发送任何东西还要继续 <code>op</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cs.committed &#123;<span class="comment">//流不在发送任何东西</span></span><br><span class="line">   cs.mu.Unlock()</span><br><span class="line">   <span class="keyword">return</span> toRPCErr(op(cs.attempt))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因是如果是正在处理中的请求(尝试重试、取消等操作)，还是会尝试执行 <code>op</code>并返回错误结束尝试</p></li><li><p>如果在重试过程中，重试任务发生了变化，那么也会跳过直接进行下一次重试</p></li></ul><h4 id="成功"><a class="markdownIt-Anchor" href="#成功"></a> 成功</h4><p>如果执行成功，那么只需要执行后续的 <code>OnSuccess</code> 函数即可，一般有有两种</p><ul><li><p>如果是 <code>commitAttemptLocked</code>，那么表示执行成功更新状态即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *clientStream)</span> <span class="title">commitAttemptLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> !cs.committed &amp;&amp; cs.onCommit != <span class="literal">nil</span> &#123;</span><br><span class="line">      cs.onCommit() <span class="comment">//配置的重试逻辑</span></span><br><span class="line">   &#125;</span><br><span class="line">   cs.committed = <span class="literal">true</span><span class="comment">//重试逻辑执行成功</span></span><br><span class="line">   cs.buffer = <span class="literal">nil</span><span class="comment">//清空这个重试缓存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果是 <code>bufferForRetryLocked</code>，那么会缓存当前的重试操作到回放缓冲区(后续发生失败的时候再执行一次)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *clientStream)</span> <span class="title">bufferForRetryLocked</span><span class="params">(sz <span class="keyword">int</span>, op <span class="keyword">func</span>(a *csAttempt)</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">   <span class="comment">// Note: we still will buffer if retry is disabled (for transparent retries).</span></span><br><span class="line">   <span class="keyword">if</span> cs.committed &#123;<span class="comment">//如果重试逻辑执行成功结束</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   cs.bufferSize += sz</span><br><span class="line">   <span class="keyword">if</span> cs.bufferSize &gt; cs.callInfo.maxRetryRPCBufferSize &#123;<span class="comment">//回放缓冲区太大就不回放了</span></span><br><span class="line">      cs.commitAttemptLocked()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   cs.buffer = <span class="built_in">append</span>(cs.buffer, op) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="失败"><a class="markdownIt-Anchor" href="#失败"></a> 失败</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *clientStream)</span> <span class="title">retryLocked</span><span class="params">(lastErr error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      cs.attempt.finish(toRPCErr(lastErr))</span><br><span class="line">      isTransparent, err := cs.shouldRetry(lastErr)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         cs.commitAttemptLocked()</span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line">      cs.firstAttempt = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">if</span> err := cs.newAttemptLocked(isTransparent); err != <span class="literal">nil</span> &#123;<span class="comment">//创建一个新attemp</span></span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> lastErr = cs.replayBufferLocked(); lastErr == <span class="literal">nil</span> &#123;<span class="comment">//回放缓冲区，</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先，当前的尝试 <code>cs.attempt</code> 将被标记为已完成，其结果会被传递给 <code>cs.finish()</code></li><li>然后，会调用 <code>cs.shouldRetry()</code> 判断当前错误是否应该重试(服务端错误 <code>DoNotTransparentRetry</code> )<ul><li>如果返回的错误可以重试，则会通过 <code>cs.newAttemptLocked()</code> 创建新的尝试，即新的流，并在其上发起新的请求</li><li>如果没有返回新的错误，则尝试从回放缓冲区 <code>cs.replayBufferLocked()</code> 中获取上一次重试的错误</li></ul></li><li>如果在回放缓冲区中找到了错误，继续进行下一次重试，否则返回 nil 表示重试成功</li></ol><p>前面提到了，有一种成功即使执行成功也会加入到 buffer中，在执行失败的之后重新再执行一遍</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *clientStream)</span> <span class="title">replayBufferLocked</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   a := cs.attempt</span><br><span class="line">   <span class="keyword">for</span> _, f := <span class="keyword">range</span> cs.buffer &#123;</span><br><span class="line">      <span class="keyword">if</span> err := f(a); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是在构建流的时候加入的，如果构建流成功，那么会将构建流的函数加入到<code>buffer</code>，如果后续有一次临时性的失败，会将所有成功的构建流全部执行一遍。<strong>为什么其中一个创建流失败之后，需要将其他创建成功的逻辑都进行重试？</strong></p><p>答：如果一次失败了，那么执行之前的操作。前提是能够保证和之前成功的那次执行得到相同的结果。这里创建流与发送消息都会将成功的操作放入到缓冲区中，当消息发送完毕，那么这个流就结束了。所以在发送过程中，如果其中一个帧发送失败，那么它会将从流构建到消息发送再次传输一遍(相当于一个新的请求)</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>重试机制 <code>withRetry</code> 包含的业务<ul><li>建立流链接</li><li>发送头帧</li><li>发送消息</li><li>接收消息</li><li>关闭发送</li></ul></li><li>服务端响应的时候并没有重试机制</li><li>重试速率限制是针对整个连接而不是每个流一个</li><li>同时执行一个重试任务，并且执行的都是最新的那个</li><li>只有重试成功，才会更新令牌<code>tokens</code>数量。那是不是影响其他调用的重试，会但影响不大。第一是因为只要有一个成功，那么token数量都会更新。第二是重试次数过多，单次调用会因为超时停止重试。</li><li>如果在发送过程中，某一个帧发送失败，那么它会从创建流开始重新发起调用</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://blog.csdn.net/u011582922/article/details/120578941" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/120578941</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;重试机制是为了在短暂异常情况下能够正常恢复，也能防止长时间异常而不退出。这里看一下grpc-go 中的重试机制以及使用方法&lt;/p&gt;
&lt;p&gt;带着问题看世界：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;grpc-go 的重试策略的使用&lt;/li&gt;
&lt;li&gt;grpc-go 的重试机制是怎样的&lt;/l
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Go入门22-Goland激活</title>
    <link href="http://xboom.github.io/2022/10/17/Go/Go%E5%85%A5%E9%97%A822-Goland%E6%BF%80%E6%B4%BB/"/>
    <id>http://xboom.github.io/2022/10/17/Go/Go%E5%85%A5%E9%97%A822-Goland%E6%BF%80%E6%B4%BB/</id>
    <published>2022-10-17T15:51:31.000Z</published>
    <updated>2023-04-05T04:18:00.783Z</updated>
    
    <content type="html"><![CDATA[<p>Goland好用但是激活太贵，网上找了一个使用激活服务器的办法， Goland 2022.2.2 激活成功</p><blockquote><p>最好支持正版！！！</p></blockquote><p>第一步：首先打开网址 <a href="https://search.censys.io" target="_blank" rel="noopener">https://search.censys.io</a></p><p>第二步：搜索信息 <code>services.http.response.headers.location: account.jetbrains.com/fls-auth</code></p><p>第三步：点击搜索到的网址信息</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/goland-acitve-1.png" alt="goland-acitve-1" /></p><p>第四步：找到状态为302的信息网址信息，如果没有找到请重复第三步</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/goland-acitve-302.png" alt="goland-acitve-302" /></p><p>第五步：复制上一步信息中的Details信息，这里是 <code>https://188.210.42.106</code></p><p>第六步：将地址信息填入 goland 中的 Licence Service 并点击 Acitve 激活</p><p>第七步：如果激活成功将出现下图所示，否则重复第三步</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/goland-acitve-success.png" alt="goland-acitve-success" /></p><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://dushusir.com/jetbrains/" target="_blank" rel="noopener">https://dushusir.com/jetbrains/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Goland好用但是激活太贵，网上找了一个使用激活服务器的办法， Goland 2022.2.2 激活成功&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最好支持正版！！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一步：首先打开网址 &lt;a href=&quot;https://sear
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-08-超时处理</title>
    <link href="http://xboom.github.io/2022/10/17/Grpc/Grpc-08-%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86/"/>
    <id>http://xboom.github.io/2022/10/17/Grpc/Grpc-08-%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86/</id>
    <published>2022-10-17T14:58:29.000Z</published>
    <updated>2023-05-27T10:55:27.452Z</updated>
    
    <content type="html"><![CDATA[<p><code>grpc-go</code> 通信的超时处理有两种方式</p><ol><li>业务出现异常或判断处理超时主动取消</li><li><code>grpc-go</code> 存在截止时间，超过截止时间自动停止</li></ol><p>带着问题看世界</p><ol><li>取消发生在不同时机是如何处理的<ul><li>链路建立阶段</li><li>客户端发送阶段</li><li>请求传输阶段</li><li>服务端处理阶段</li><li>消息响应阶段</li></ul></li><li>截止时间又是如何做到的<ul><li>服务端是如何在截止时间停止的</li></ul></li></ol><h3 id="主动取消"><a class="markdownIt-Anchor" href="#主动取消"></a> 主动取消</h3><h4 id="基本使用"><a class="markdownIt-Anchor" href="#基本使用"></a> 基本使用</h4><p>客户端使用<code>context</code>并创建双向流，发送两条之后取消再次发送消息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">10</span>*time.Second)</span><br><span class="line">stream, err := c.BidirectionalStreamingEcho(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatalf(<span class="string">"error creating stream: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send some test messages.</span></span><br><span class="line"><span class="keyword">if</span> err := sendMessage(stream, <span class="string">"hello"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatalf(<span class="string">"error sending on stream: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := sendMessage(stream, <span class="string">"world"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatalf(<span class="string">"error sending on stream: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ensure the RPC is working.</span></span><br><span class="line">recvMessage(stream, codes.OK)</span><br><span class="line">recvMessage(stream, codes.OK)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"cancelling context"</span>)</span><br><span class="line">cancel()</span><br><span class="line"></span><br><span class="line"><span class="comment">//失败</span></span><br><span class="line">sendMessage(stream, <span class="string">"closed"</span>)</span><br></pre></td></tr></table></figure><p>服务端则是响应流的处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">BidirectionalStreamingEcho</span><span class="params">(stream pb.Echo_BidirectionalStreamingEchoServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">in, err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"server: error receiving from stream: %v\n"</span>, err)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"echoing message %q\n"</span>, in.Message)</span><br><span class="line">stream.Send(&amp;pb.EchoResponse&#123;Message: in.Message&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h4><h5 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h5><p>从调用方法的内部实现，超时控制大致分为三个阶段 构建流阶段、发送消息阶段、接收消息阶段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(ctx context.Context, method <span class="keyword">string</span>, req, reply <span class="keyword">interface</span>&#123;&#125;, cc *ClientConn, opts ...CallOption)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   cs, err := newClientStream(ctx, unaryStreamDesc, cc, method, opts...)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err := cs.SendMsg(req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> cs.RecvMsg(reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据实际情况将通过一下几个阶段进行分析</p><ul><li><p>构建流阶段</p></li><li><p>客户端发送阶段</p></li><li><p>请求传输阶段</p></li><li><p>服务端处理阶段</p></li><li><p>消息响应阶段</p></li></ul><h6 id="构建流"><a class="markdownIt-Anchor" href="#构建流"></a> 构建流</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newClientStreamWithParams</span><span class="params">(ctx context.Context, desc *StreamDesc, cc *ClientConn, method <span class="keyword">string</span>, mc serviceconfig.MethodConfig, onCommit, doneFunc <span class="keyword">func</span>()</span>, <span class="title">opts</span> ...<span class="title">CallOption</span>) <span class="params">(_ iresolver.ClientStream, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  <span class="keyword">var</span> cancel context.CancelFunc</span><br><span class="line">  <span class="keyword">if</span> mc.Timeout != <span class="literal">nil</span> &amp;&amp; *mc.Timeout &gt;= <span class="number">0</span> &#123;</span><br><span class="line">     ctx, cancel = context.WithTimeout(ctx, *mc.Timeout)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     ctx, cancel = context.WithCancel(ctx)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        cancel()</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//如果一元调用</span></span><br><span class="line">  <span class="keyword">if</span> desc != unaryStreamDesc &#123; <span class="comment">//var unaryStreamDesc = &amp;StreamDesc&#123;ServerStreams: false, ClientStreams: false&#125;</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="comment">//使用协程来清理结束时候的流</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-cc.ctx.Done():</span><br><span class="line">cs.finish(ErrClientConnClosing)</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">cs.finish(toRPCErr(ctx.Err()))</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果配置了超时时间则使用超时时间，否则默认ctx，这个超时时间以前是为了针对 <code>WithTimeout</code>，后来被 <code>DialContext</code>替代</p><p>接着，将超时时间封装到一个流的头帧的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *http2Client)</span> <span class="title">NewStream</span><span class="params">(ctx context.Context, callHdr *CallHdr)</span> <span class="params">(_ *Stream, err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//解析成头帧的KV字段</span></span><br><span class="line">  ctx = peer.NewContext(ctx, t.getPeer())</span><br><span class="line">headerFields, err := t.createHeaderFields(ctx, callHdr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">s := t.newStream(ctx, callHdr)</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//封装到头帧中</span></span><br><span class="line">  hdr := &amp;headerFrame&#123;</span><br><span class="line">hf:        headerFields,</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">//发送头帧</span></span><br><span class="line">success, err := t.controlBuf.executeAndPut(<span class="function"><span class="keyword">func</span><span class="params">(it <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !checkForStreamQuota(it) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !checkForHeaderListSize(it) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;, hdr)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ch:<span class="comment">//配额没有了</span></span><br><span class="line"><span class="keyword">case</span> &lt;-s.ctx.Done():<span class="comment">//流结束</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ContextErr(s.ctx.Err())</span><br><span class="line"><span class="keyword">case</span> &lt;-t.goAway:<span class="comment">//返回关闭流的帧</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errStreamDrain</span><br><span class="line"><span class="keyword">case</span> &lt;-t.ctx.Done():<span class="comment">//连接结束</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrConnClosing</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建流的过程中，只发送到队列中，那么流就算发送成功，</p><p>所以在构建流的过程中，如果触发 <code>context.Done()</code>，那么</p><ol><li>首先会返回 <code>context</code>中的错误</li><li>其次更新状态流的状态</li></ol><h5 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h5><h4 id="原理分析"><a class="markdownIt-Anchor" href="#原理分析"></a> 原理分析</h4><p>客户端向服务端请求的一个完整阶段，需要经历：</p><ol><li>链路建立阶段</li><li>流建立阶段</li><li>数据发送阶段</li><li>数据接收阶段</li></ol><p>在创建完客户端流<code>clientStream</code>后，取消功能以异步方式启动，开始监听是否有取消指令，有的话，就开始执行取消指令。因此，取消功能可以发生在数据发送阶段和数据接收阶段，且两个阶段的流程是一样的</p><ol><li>取消是流级别的而不是链路级别的，也就是可以用于取消单个请求</li><li>当客户端主动发起 cancel请求的时候 会构建 <code>cleanupStream</code>的请求关闭流，并发送RST帧，将流ID，取消状态码封装到RST帧中，发送给服务端</li><li>服务端收到<code>RST</code>帧之后，会停止读取 stream 中的数据，并移除对应的流</li></ol><h3 id="截止时间"><a class="markdownIt-Anchor" href="#截止时间"></a> 截止时间</h3><p>截止时间与cancel函数的原理类似，主动取消是通过</p><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://blog.csdn.net/u011582922/article/details/119834758" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/119834758</a></li><li><a href="https://blog.csdn.net/u011582922/article/details/119944259" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/119944259</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;grpc-go&lt;/code&gt; 通信的超时处理有两种方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;业务出现异常或判断处理超时主动取消&lt;/li&gt;
&lt;li&gt;&lt;code&gt;grpc-go&lt;/code&gt; 存在截止时间，超过截止时间自动停止&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;带着问题看世界&lt;/p
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-07-滑动窗口</title>
    <link href="http://xboom.github.io/2022/10/15/Grpc/Grpc-07-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://xboom.github.io/2022/10/15/Grpc/Grpc-07-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2022-10-15T14:58:29.000Z</published>
    <updated>2023-05-27T10:55:20.349Z</updated>
    
    <content type="html"><![CDATA[<p>回顾一下 tcp 的滑动窗口</p><p>那么这一章需要解决的问题是：</p><ol><li>tcp 有了滑动窗口为什么 grpc-go又需要滑动窗口，它们两者有什么区分，为什么两者都需要用到滑动窗口</li><li>grpc-go 的滑动窗口原理是什么</li><li>grpc-go 的滑动窗口是如何实现的</li></ol><p>滑动窗口的目的是，计算出下次发送数据帧的最大字节数</p><ul><li><p>客户端的帧发送器在发送数据帧时存在一些发送指标，服务器端在接收数据帧的不同阶段，也存在一些指标</p><ul><li>发送指标是如何定义的 TODO?</li></ul></li><li><p>服务器在接收数据帧时，会根据自己的接收数据帧、存储数据帧、读取数据帧的速度，向客户端发送窗口更新帧或者设置帧；</p><ul><li>计算原理是什么 ？ 窗口更新帧与设置帧的区别？ TODO</li></ul></li><li><p>客户端接收到服务器端发送过来的设置帧或者窗口更新帧后，会更新本地的发送指标</p></li><li><p>发送指标的更新，会影响到客户端下次发送数据帧的最大字节数</p></li><li><p>最大字节数的计算，服务器端会通过发送窗口更新帧或者设置帧来动态的影响客户端计算数据帧大小的参数，从而影响下次发送的最大字节数</p></li></ul><p>每个链接、每个流、每个客户端的指标都是如何定义的？ TODO</p><h3 id="滑动窗口原理"><a class="markdownIt-Anchor" href="#滑动窗口原理"></a> 滑动窗口原理</h3><p><img src="https://img-blog.csdnimg.cn/20210626180317624.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE1ODI5MjI=,size_16,color_FFFFFF,t_70#pic_center" alt="gRPC-go滑动窗口整体处理流程" /></p><h4 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h4><ul><li>构建好数据帧<code>dataFrame</code></li><li>通过发送参数指标，计算本次发送的最大字节数<em>maxSize</em>；</li><li>数据帧截取器，从数据帧里截取指定的字节数<em>maxSize</em>，交由帧发送器</li><li>帧发送器将截取的字节，转换成http2原生的帧，发送给服务器端</li></ul><h4 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h4><ul><li>帧接收器接收到数据帧，交由帧分发器处理</li><li>帧分发器根据帧的类型，交由数据处理器handleData处理，数据处理器handleData：<ul><li>抽样级别流控：对本地的接收参数进行更新(如b.sampelCount,b.sample,b.bwMax,b.bdp)，触发阈值条件后，会向客户端发送窗口更新帧outgoingWindowUpdate，其中设置streamID=0，或者发送设置帧outgoingSettings</li><li>链接级别流控：对本地的接收参数进行更新(如f.unacked,f.limit)，触发阈值条件后，会向客户端发送窗口更新帧outgoingWindowUpdate，其中设置streamID=0</li><li>流级别流控：对本地的接收参数进行更新(如f.pendingData,f.pendingUpdate,f.limit,f.delta)，触发阈值条件后，会向客户端发送窗口更新帧outgoingWindowUpdate，其中设置streamID=0</li><li>将数据帧存储到go语言原生自带的缓存bytes.Buffer里</li><li>构建recvMsg结构体，将bytes.Buffer存储到recvMsg里；（recvMsg就是对bytes.Buffer封装）</li><li>将recvMsg存储到recvBuffer里：存储逻辑是<ul><li>i.若recvMsg类型的通道里，没有数据的话，就直接将recvMsg存储到该通道里</li><li>ii.若recvMsg类型的通道里，已经有数据了的话，就将recvMsg添加到类型为recvMsg的切片的尾部</li></ul></li></ul></li><li>接收数据并解压recvAndDecompress：<ul><li>a)读取数据前，先对本地的窗口参数进行调整，如f.delta;满足触发阈值条件的话，就向客户端发送窗口更新帧outgoingWindowUpdate，其中streamID非0；</li><li>b)recvBufer读取器：<br />i.从recvBuffer的通道里获取数据recvMsg<br />ii.数据获取到后，recvBuffer缓存中，将切片的第一个数据，加载到通道里；(因为通道里刚才已经消费了数据，需要重新添加上)<br />iii.从recvMsg里获取到bytes.Buffer对象<br />iv.将bytes.Buffer里的数据读取到字节切片里<br />c)读取完成数据后，更新流级别参数，如f.pendingData,f.pendingUpdate若满足触发阈值条件的话，就向客户端发送窗口更新帧outgoingWindowUpdate，其中streamID非0；<br />d)对切片里的数据进行解压，对解压后的数据，交由handle方法<br />e)handle方法：就是grpc服务器内部，真正执行客户端请求的方法入口<br />i.对解压后的数据，进行反序列化，得到请求方法的具体参数值<br />ii.真正的执行客户端的请求方法，得到执行结果<br />f)将执行结果封装到数据帧里，存储到controlBuf缓存里<br />g)帧发送器，从帧缓存里获取到数据帧，发送给客户端</li></ul></li></ul><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://blog.csdn.net/u011582922/article/details/118887625" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/118887625</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;回顾一下 tcp 的滑动窗口&lt;/p&gt;
&lt;p&gt;那么这一章需要解决的问题是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;tcp 有了滑动窗口为什么 grpc-go又需要滑动窗口，它们两者有什么区分，为什么两者都需要用到滑动窗口&lt;/li&gt;
&lt;li&gt;grpc-go 的滑动窗口原理是什么&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Go入门19-Fuzzing</title>
    <link href="http://xboom.github.io/2022/10/14/Go/Go%E5%85%A5%E9%97%A819-Fuzzing/"/>
    <id>http://xboom.github.io/2022/10/14/Go/Go%E5%85%A5%E9%97%A819-Fuzzing/</id>
    <published>2022-10-14T15:31:50.000Z</published>
    <updated>2023-04-05T04:17:29.273Z</updated>
    
    <content type="html"><![CDATA[<p>Golang在1.18引入的第三个特性就是 Fuzzing 模糊测试：构造随机数据来找出代码里的漏洞或者可能导致程序崩溃的输入。</p><p>单元测试有局限性，每个测试输入必须由开发者指定加到单元测试的测试用例里。fuzzing的优点之一是可以基于开发者代码里指定的测试输入作为基础数据，进一步自动生成新的随机测试数据，用来发现指定测试输入没有覆盖到的边界情况。</p><p>通过fuzzing可以找出的漏洞包括SQL注入、缓冲区溢出、拒绝服务(Denial of Service)攻击和XSS(cross-site scripting)攻击等</p><p>这里通过编写反转字符串函数通过 <code>fuzz test</code> 来发现并修改问题</p><h3 id="第一步实现基本功能"><a class="markdownIt-Anchor" href="#第一步实现基本功能"></a> 第一步：实现基本功能</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">b := []<span class="keyword">byte</span>(s)</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(b)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(b)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">b[i], b[j] = b[j], b[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">input := <span class="string">"The quick brown fox jumped over the lazy dog"</span></span><br><span class="line">rev := Reverse(input)</span><br><span class="line">doubleRev := Reverse(rev)</span><br><span class="line">fmt.Printf(<span class="string">"original: %q\n"</span>, input)</span><br><span class="line">fmt.Printf(<span class="string">"reversed: %q\n"</span>, rev)</span><br><span class="line">fmt.Printf(<span class="string">"reversed again: %q\n"</span>, doubleRev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果是</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">original: <span class="string">"The quick brown fox jumped over the lazy dog"</span></span><br><span class="line">reversed: <span class="string">"god yzal eht revo depmuj xof nworb kciuq ehT"</span></span><br><span class="line">reversed again: <span class="string">"The quick brown fox jumped over the lazy dog"</span></span><br></pre></td></tr></table></figure><h3 id="第二步编写单元测试"><a class="markdownIt-Anchor" href="#第二步编写单元测试"></a> 第二步：编写单元测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func TestReverse(t *testing.T) &#123;</span><br><span class="line">testcases :&#x3D; []struct &#123;</span><br><span class="line">in, want string</span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;&quot;Hello, world&quot;, &quot;dlrow ,olleH&quot;&#125;,</span><br><span class="line">&#123;&quot; &quot;, &quot; &quot;&#125;,</span><br><span class="line">&#123;&quot;!12345&quot;, &quot;54321!&quot;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">for _, tc :&#x3D; range testcases &#123;</span><br><span class="line">rev :&#x3D; Reverse(tc.in)</span><br><span class="line">if rev !&#x3D; tc.want &#123;</span><br><span class="line">t.Errorf(&quot;Reverse: %q, want %q&quot;, rev, tc.want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行单元测试发现，一切正常</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ok      example/fuzz    0.003s</span><br></pre></td></tr></table></figure><h3 id="第三步添加模糊测试"><a class="markdownIt-Anchor" href="#第三步添加模糊测试"></a> 第三步：添加模糊测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuzzReverse</span><span class="params">(f *testing.F)</span></span> &#123;</span><br><span class="line">testcases := []<span class="keyword">string</span>&#123;<span class="string">"Hello, world"</span>, <span class="string">" "</span>, <span class="string">"!12345"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, tc := <span class="keyword">range</span> testcases &#123;</span><br><span class="line">f.Add(tc) <span class="comment">// Use f.Add to provide a seed corpus</span></span><br><span class="line">&#125;</span><br><span class="line">f.Fuzz(<span class="function"><span class="keyword">func</span><span class="params">(t *testing.T, orig <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">rev := Reverse(orig)</span><br><span class="line">doubleRev := Reverse(rev)</span><br><span class="line">    <span class="comment">//这一行是为了解释后面的错误加的，暂时可以忽略</span></span><br><span class="line">    t.Logf(<span class="string">"Number of runes: orig=%d, rev=%d, doubleRev=%d"</span>, utf8.RuneCountInString(orig), utf8.RuneCountInString(rev), utf8.RuneCountInString(doubleRev))</span><br><span class="line"><span class="keyword">if</span> orig != doubleRev &#123;</span><br><span class="line">t.Errorf(<span class="string">"Before: %q, after: %q"</span>, orig, doubleRev)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> utf8.ValidString(orig) &amp;&amp; !utf8.ValidString(rev) &#123;</span><br><span class="line">t.Errorf(<span class="string">"Reverse produced invalid UTF-8 string %q"</span>, rev)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：</p><ol><li><code>Reverse</code>函数如果是一个错误的版本(直接return返回输入的字符串)，虽然可以通过上面的模糊测试，但没法通过第二步的单元测试，所以模糊测试与单元测试是互补的关系</li><li><code>go test</code> <strong>只会使用种子语料库，而不会生成随机测试数据</strong>。通过这种方式可以用来验证种子语料库的测试数据是否可以测试通过</li><li>如果<code>reverse_test.go</code>文件里有其它单元测试函数或者模糊测试函数，但只想运行<code>FuzzReverse</code>模糊测试函数，我们可以执行<code>go test -run=FuzzReverse</code>命令</li><li>如果要基于种子语料库生成随机测试数据用于模糊测试，需要给<code>go test</code>命令增加<code>-fuzz</code>参数</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@13ce5bc74ac3:/code/fuzz# go test -fuzz .</span><br><span class="line">fuzz: elapsed: 0s, gathering baseline coverage: 0/7 completed</span><br><span class="line">fuzz: elapsed: 0s, gathering baseline coverage: 7/7 completed, now fuzzing with 2 workers</span><br><span class="line">fuzz: elapsed: 0s, execs: 648 (17784/sec), new interesting: 1 (total: 8)</span><br><span class="line">--- FAIL: FuzzReverse (0.04s)</span><br><span class="line">    --- FAIL: FuzzReverse (0.00s)</span><br><span class="line">    hello_test.go:32: Number of runes: orig=1, rev=2, doubleRev=1</span><br><span class="line">        hello_test.go:36: Reverse produced invalid UTF-8 string "\x9e\xdb"</span><br><span class="line">    </span><br><span class="line">    Failing input written to testdata/fuzz/FuzzReverse/d6a654c77ca8db001e0bbe2cbb5493efcd20e17777911523bf59bd30bd33e199</span><br><span class="line">    To re-run:</span><br><span class="line">    go test -run=FuzzReverse/d6a654c77ca8db001e0bbe2cbb5493efcd20e17777911523bf59bd30bd33e199</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    example/fuzz    0.048s</span><br></pre></td></tr></table></figure><ol start="5"><li><p>运行之后会生成testdata的文件夹，那么下次即使没有带上 <code>-fuzz</code> 参数，也会使用该数据进行模糊测试</p><p>路径：<code>./testdata/fuzz/FuzzReverse/d6a654c77ca8db001e0bbe2cbb5493efcd20e17777911523bf59bd30bd33e199</code>，内容是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> test fuzz v1  <span class="comment">//语料库文件里的第1行标识的是编码版本</span></span><br><span class="line"><span class="keyword">string</span>(<span class="string">"۞"</span>)</span><br></pre></td></tr></table></figure><p>从第2行开始，每一行数据对应的是语料库的每条测试数据(corpus entry)的其中一个参数，按照参数先后顺序排列，因为fuzz target函数<code>func(t *testing.T, orig string)</code>只有<code>orig</code>这1个参数作为真正的测试输入，也就是每条测试数据其实就1个输入，因此在上面示例的<code>testdata/fuzz/FuzzReverse</code>目录下的文件里只有string(“۞”)这一行</p></li></ol><h3 id="第四步修复bug"><a class="markdownIt-Anchor" href="#第四步修复bug"></a> 第四步：修复Bug</h3><p>模糊测试中得出的错误为 <code>Reverse produced invalid UTF-8 string &quot;\x9e\xdb&quot;</code></p><p><code>Reverse</code>函数是按照字节(byte)为维度进行字符串反转，这就是问题所在。比如字符<code>string(&quot;۞&quot;)</code> 如果按照字节反转，反转后得到的就是一个无效的字符串了。因此为了保证字符串反转后得到的仍然是一个有效的UTF-8编码的字符串，需要按照<code>rune</code>进行字符串反转。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    r := []<span class="keyword">rune</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(r)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(r)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        r[i], r[j] = r[j], r[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 <code>go test</code> 命令单元测试通过，表示老的数据能够正常的处理，但是如果再次执行 <code>go test -fuzz</code> 会出现新的错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@<span class="number">13</span>ce5bc74ac3:/code/fuzz# <span class="keyword">go</span> test -fuzz .</span><br><span class="line">fuzz: elapsed: <span class="number">0</span>s, gathering baseline coverage: <span class="number">0</span>/<span class="number">9</span> completed</span><br><span class="line">fuzz: minimizing <span class="number">38</span>-<span class="keyword">byte</span> failing input file</span><br><span class="line">fuzz: elapsed: <span class="number">0</span>s, gathering baseline coverage: <span class="number">4</span>/<span class="number">9</span> completed</span><br><span class="line">--- FAIL: FuzzReverse (<span class="number">0.01</span>s)</span><br><span class="line">    --- FAIL: FuzzReverse (<span class="number">0.00</span>s)</span><br><span class="line">        hello_test.<span class="keyword">go</span>:<span class="number">34</span>: Before: <span class="string">"\xe5"</span>, after: <span class="string">"�"</span></span><br><span class="line">    </span><br><span class="line">    Failing input written to testdata/fuzz/FuzzReverse/<span class="number">91862839</span>dc552bd95b4e42be6576a6c198f0d4c8fc2884c953030d898573b014</span><br><span class="line">    To re-run:</span><br><span class="line">    <span class="keyword">go</span> test -run=FuzzReverse/<span class="number">91862839</span>dc552bd95b4e42be6576a6c198f0d4c8fc2884c953030d898573b014</span><br><span class="line">FAIL</span><br><span class="line">exit status <span class="number">1</span></span><br><span class="line">FAIL    example/fuzz    <span class="number">0.011</span>s</span><br></pre></td></tr></table></figure><p>结构就是对一个字符串做了2次反转后得到的和原字符串不一样，这次测试输入本身是非法的unicode</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !utf8.ValidString(s) &#123;<span class="comment">//判断是否是合法的 utf-8编码</span></span><br><span class="line">        <span class="keyword">return</span> s, errors.New(<span class="string">"input is not valid UTF-8"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    r := []<span class="keyword">rune</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(r)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(r)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        r[i], r[j] = r[j], r[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(r), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改对应的引用和单元测试后，通过测试</p><h3 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h3><p>Go模糊测试和单元测试在语法上有如下差异：</p><ol><li>Go模糊测试函数以<code>FuzzXxx</code>开头，单元测试函数以<code>TestXxx</code>开头</li><li>Go模糊测试函数以 <code>*testing.F</code>作为入参，单元测试函数以<code>*testing.T</code>作为入参</li><li>Go模糊测试会调用<code>f.Add</code>函数和<code>f.Fuzz</code>函数。<ul><li><code>f.Add</code>函数把指定输入作为模糊测试的种子语料库(seed corpus)，fuzzing基于种子语料库生成随机输入。</li><li><code>f.Fuzz</code>函数接收一个fuzz target函数作为入参。fuzz target函数有多个参数，第一个参数是<code>*testing.T</code>，其它参数是被模糊的类型(<strong>注意</strong>：被模糊的类型目前只支持部分内置类型,<ul><li><code>string</code>, <code>[]byte</code></li><li><code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>/<code>rune</code>, <code>int64</code></li><li><code>uint</code>, <code>uint8</code>/<code>byte</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code></li><li><code>float32</code>, <code>float64</code></li><li><code>bool</code></li></ul></li></ul></li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://go.dev/doc/tutorial/fuzz" target="_blank" rel="noopener">https://go.dev/doc/tutorial/fuzz</a></li><li><a href="https://segmentfault.com/a/1190000041650681" target="_blank" rel="noopener">https://segmentfault.com/a/1190000041650681</a></li><li><a href="https://segmentfault.com/a/1190000041467510" target="_blank" rel="noopener">https://segmentfault.com/a/1190000041467510</a></li><li><a href="https://go.googlesource.com/proposal/+/master/design/draft-fuzzing.md" target="_blank" rel="noopener">https://go.googlesource.com/proposal/+/master/design/draft-fuzzing.md</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Golang在1.18引入的第三个特性就是 Fuzzing 模糊测试：构造随机数据来找出代码里的漏洞或者可能导致程序崩溃的输入。&lt;/p&gt;
&lt;p&gt;单元测试有局限性，每个测试输入必须由开发者指定加到单元测试的测试用例里。fuzzing的优点之一是可以基于开发者代码里指定的测试输
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-06-多路复用</title>
    <link href="http://xboom.github.io/2022/10/13/Grpc/Grpc-06-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>http://xboom.github.io/2022/10/13/Grpc/Grpc-06-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</id>
    <published>2022-10-13T14:58:29.000Z</published>
    <updated>2023-05-27T10:55:14.892Z</updated>
    
    <content type="html"><![CDATA[<p>多路复用是 HTTP/2中的重要特性，允许同一个TCP连接上同时传输多个HTTP请求和响应</p><p>带着问题看世界：</p><ol><li>通过《帧发送器》可知帧是一个一个进行消息发送，多个流的帧如何发送</li><li>服务端是如何区分不同的流的帧</li><li>帧太大一定会进行分包，最大是多少，服务端如何存储分包的帧，保证它的顺序</li><li>服务端如何从分包的数据帧的恢复数据</li></ol><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE1ODI5MjI=,size_16,color_FFFFFF,t_70-20230411222936879.png" alt="在这里插入图片描述" style="zoom:20%;" /><h3 id="发送端"><a class="markdownIt-Anchor" href="#发送端"></a> 发送端</h3><p>多路复用从 《帧接收器》说起，一个请求入上图所示，由头帧跟多个数据帧组成，现在直接看数据帧的发送逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">it, err := l.cbuf.get(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = l.handle(it); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, err = l.processData(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是从发送缓冲区获取数据进行发送，一共分为三步</p><ol><li><p>从缓冲区获取帧(这里的帧是应用帧中的数据帧 <code>dataFrame</code>)</p></li><li><p>将帧进行流的处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *loopyWriter)</span> <span class="title">preprocessData</span><span class="params">(df *dataFrame)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   str, ok := l.estdStreams[df.streamID]</span><br><span class="line">   <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// If we got data for a stream it means that</span></span><br><span class="line">   <span class="comment">// stream was originated and the headers were sent out.</span></span><br><span class="line">   str.itl.enqueue(df)</span><br><span class="line">   <span class="keyword">if</span> str.state == empty &#123;</span><br><span class="line">      str.state = active</span><br><span class="line">      l.activeStreams.enqueue(str)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意思就是：</p><ol><li><p>根据帧ID <strong>streamID</strong> 从 已经建立连接的流中 <code>estdStreams</code> 获取到流</p><blockquote><p>estdStreams 表示所有已建立但未被清除的流(stream)</p><p>在客户端，表示所有已发送头部信息的流</p><p>在服务端，表示所有已接收头部信息的流</p><p><code>activeStreams</code> 就表示的是已经发送或接收了头帧以及部分数据帧的流</p></blockquote></li><li><p>将帧存入到流的单向链表中</p></li><li><p>如果链表为空(表示仅仅是发送了头帧，还没有数据帧)，那么将流加入到 <code>activeStreams</code> 数据流中</p></li></ol></li><li><p>进行消息发送</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *loopyWriter)</span> <span class="title">processData</span><span class="params">()</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="comment">//1. 从数据流中拿第一个流的数据帧</span></span><br><span class="line">   str := l.activeStreams.dequeue() <span class="comment">// Remove the first stream.</span></span><br><span class="line">   <span class="keyword">if</span> str == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   dataItem := str.itl.peek().(*dataFrame)</span><br><span class="line">   <span class="comment">//dataItem 是业务数据帧，在这里讲真正分解为发送的多个数据帧 dataFrame</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(dataItem.h) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(dataItem.d) == <span class="number">0</span> &#123; <span class="comment">// 如果是空的</span></span><br><span class="line">      <span class="comment">//发送结束帧</span></span><br><span class="line">      <span class="keyword">if</span> err := l.framer.fr.WriteData(dataItem.streamID, dataItem.endStream, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//...根据流的帧后续是否仍然有数据进行处理</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> (</span><br><span class="line">      buf []<span class="keyword">byte</span></span><br><span class="line">   )</span><br><span class="line">  </span><br><span class="line">   maxSize := http2MaxFrameLen <span class="comment">//16KB</span></span><br><span class="line">   <span class="comment">//计算一个帧最大值，默认16KB</span></span><br><span class="line">   hSize := min(maxSize, <span class="built_in">len</span>(dataItem.h))<span class="comment">//头部的最大长度</span></span><br><span class="line">   dSize := min(maxSize-hSize, <span class="built_in">len</span>(dataItem.d)) <span class="comment">//负载的最大长度</span></span><br><span class="line">   <span class="comment">//... 将dataItem 部分数据写入到buf中</span></span><br><span class="line"></span><br><span class="line">   size := hSize + dSize</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">   <span class="keyword">var</span> endStream <span class="keyword">bool</span></span><br><span class="line">   <span class="comment">//是否是流的最后一帧</span></span><br><span class="line">   <span class="keyword">if</span> dataItem.endStream &amp;&amp; <span class="built_in">len</span>(dataItem.h)+<span class="built_in">len</span>(dataItem.d) &lt;= size &#123;</span><br><span class="line">      endStream = <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="keyword">if</span> err := l.framer.fr.WriteData(dataItem.streamID, endStream, buf[:size]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   str.bytesOutStanding += size</span><br><span class="line">   l.sendQuota -= <span class="keyword">uint32</span>(size)</span><br><span class="line">   dataItem.h = dataItem.h[hSize:]<span class="comment">//剩余头部长度</span></span><br><span class="line">   dataItem.d = dataItem.d[dSize:]<span class="comment">//剩余负载长度</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//如果数据为空，则从链表中删除这个数据帧</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(dataItem.h) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(dataItem.d) == <span class="number">0</span> &#123; <span class="comment">// All the data from that message was written out.</span></span><br><span class="line">      str.itl.dequeue()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果流中的数据帧为空，那么标记流为 empty</span></span><br><span class="line">   <span class="comment">//如果流中下一个为头帧，那么发送头帧并清理流</span></span><br><span class="line">   <span class="comment">//如果还有一部分数据未发送完毕，那么将剩下的帧存入 activeStreams 的链表中下次再发</span></span><br><span class="line">   <span class="comment">//...发送处理</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应代码具体步骤如下：</p><ol><li>获取第一个活动流<code>activeStream</code>(有Data)</li><li>拿到流中间的数据帧 <code>dataFrame</code> (应用帧)</li><li>如果需要发送的数据是空的，那么发送数据帧并表示结束 <code>endStream == true</code></li><li>如果有一部分没有发送完毕，那么将剩下的部分作为数据帧存入 activeStreams中下次再计算发送</li></ol></li></ol><p>总结：</p><ol><li>在发送端，由于同一个链接中多个流公用一个帧缓冲区，所以虽然是多路复用，但其实客户端所有的帧还是一个一个发送的。只是可能存在一个流的帧没有发完就会发送另一个流的帧</li><li>一个帧最大为 16KB，剩下部分会作为一个帧重新加入到帧缓冲区链表中，下一次重新计算发送</li></ol><h3 id="接收端"><a class="markdownIt-Anchor" href="#接收端"></a> 接收端</h3><p>接收端可以分为上述三个问题</p><ol><li>如何接收数据帧分帧的</li><li>如何存储数据帧分帧的</li></ol><h4 id="帧的读取"><a class="markdownIt-Anchor" href="#帧的读取"></a> 帧的读取</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fr *Framer)</span> <span class="title">ReadFrame</span><span class="params">()</span> <span class="params">(Frame, error)</span></span> &#123;</span><br><span class="line">   fr.errDetail = <span class="literal">nil</span></span><br><span class="line">   <span class="keyword">if</span> fr.lastFrame != <span class="literal">nil</span> &#123;</span><br><span class="line">      fr.lastFrame.invalidate()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//1. 利用第三方依赖，直接读取帧的头部</span></span><br><span class="line">   fh, err := readFrameHeader(fr.headerBuf[:], fr.r)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> fh.Length &gt; fr.maxReadSize &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ErrFrameTooLarge</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2. 获取负载长度并读取</span></span><br><span class="line">   payload := fr.getReadBuf(fh.Length)</span><br><span class="line">   <span class="keyword">if</span> _, err := io.ReadFull(fr.r, payload); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//根据帧的类型，将真转换为程序数据结构</span></span><br><span class="line">   f, err := typeFrameParser(fh.Type)(fr.frameCache, fh, payload)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ce, ok := err.(connError); ok &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, fr.connError(ce.Code, ce.Reason)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//检查帧的顺序</span></span><br><span class="line">   <span class="keyword">if</span> err := fr.checkFrameOrder(f); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果是头帧，还需要将其中的元数据再解析一次，最终变为 MetaHeadersFrame 帧</span></span><br><span class="line">   <span class="keyword">if</span> fh.Type == FrameHeaders &amp;&amp; fr.ReadMetaHeaders != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fr.readMetaFrame(f.(*HeadersFrame))</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> f, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="帧转换器"><a class="markdownIt-Anchor" href="#帧转换器"></a> 帧转换器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> frameParsers = <span class="keyword">map</span>[FrameType]frameParser&#123;</span><br><span class="line">   FrameData:         parseDataFrame,</span><br><span class="line">   FrameHeaders:      parseHeadersFrame,</span><br><span class="line">   FramePriority:     parsePriorityFrame,</span><br><span class="line">   FrameRSTStream:    parseRSTStreamFrame,</span><br><span class="line">   FrameSettings:     parseSettingsFrame,</span><br><span class="line">   FramePushPromise:  parsePushPromise,</span><br><span class="line">   FramePing:         parsePingFrame,</span><br><span class="line">   FrameGoAway:       parseGoAwayFrame,</span><br><span class="line">   FrameWindowUpdate: parseWindowUpdateFrame,</span><br><span class="line">   FrameContinuation: parseContinuationFrame,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typeFrameParser</span><span class="params">(t FrameType)</span> <span class="title">frameParser</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> f := frameParsers[t]; f != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> f</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> parseUnknownFrame</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据帧处理"><a class="markdownIt-Anchor" href="#数据帧处理"></a> 数据帧处理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *http2Server)</span> <span class="title">handleData</span><span class="params">(f *http2.DataFrame)</span></span> &#123;</span><br><span class="line">   size := f.Header().Length</span><br><span class="line">   <span class="comment">//...流控</span></span><br><span class="line">   <span class="comment">// Select the right stream to dispatch.</span></span><br><span class="line">   s, ok := t.getStream(f)</span><br><span class="line">   <span class="comment">//... </span></span><br><span class="line">   <span class="keyword">if</span> size &gt; <span class="number">0</span> &#123;<span class="comment">//负载大于0</span></span><br><span class="line">      <span class="comment">//... 流控</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(f.Data()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">         buffer := t.bufferPool.get()</span><br><span class="line">         buffer.Reset()</span><br><span class="line">         buffer.Write(f.Data())</span><br><span class="line">         s.write(recvMsg&#123;buffer: buffer&#125;)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//如果流结束了，</span></span><br><span class="line">   <span class="keyword">if</span> f.StreamEnded() &#123;</span><br><span class="line">      <span class="comment">// Received the end of stream from the client.</span></span><br><span class="line">      s.compareAndSwapState(streamActive, streamReadDone)</span><br><span class="line">      s.write(recvMsg&#123;err: io.EOF&#125;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li>如果是数据帧则获取流的大小以及负载</li><li>将负载封装成<code>recvMsg</code>写入到流中</li><li>如果对方告知流结束了，那么将流的状态从 <code>streamActive</code> 改为 <code>streamReadDone</code></li><li>封装帧结束消息 <code>recvMsg{err: io.EOF}</code></li></ol><p>核心就是讲数据写入流中的 <code>s.write(recvMsg{buffer: buffer})</code></p><h4 id="帧缓冲区"><a class="markdownIt-Anchor" href="#帧缓冲区"></a> 帧缓冲区</h4><p>与发送端所有流的帧都放入到一个帧缓冲区不一样，这里的缓冲区是一个缓冲区切片，用于接收同一个流中的分帧数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> recvBuffer <span class="keyword">struct</span> &#123;</span><br><span class="line">   c       <span class="keyword">chan</span> recvMsg<span class="comment">//缓冲区为1 的 channel</span></span><br><span class="line">   mu      sync.Mutex<span class="comment">//原子锁</span></span><br><span class="line">   backlog []recvMsg<span class="comment">//缓冲切片</span></span><br><span class="line">   err     error<span class="comment">//错误信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="帧的存储"><a class="markdownIt-Anchor" href="#帧的存储"></a> 帧的存储</h5><p>如果 切片 里面没有没有数据，就直接存入隧道，说明切面的消息已经都消费了</p><p>如果 切片 里面有数据，那么就存入到切片的后面，保证消息的顺序消费</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *recvBuffer)</span> <span class="title">put</span><span class="params">(r recvMsg)</span></span> &#123;</span><br><span class="line">   b.mu.Lock()</span><br><span class="line">   <span class="keyword">if</span> b.err != <span class="literal">nil</span> &#123;</span><br><span class="line">      b.mu.Unlock()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   b.err = r.err</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(b.backlog) == <span class="number">0</span> &#123;<span class="comment">//切片为空，则直接存入隧道</span></span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> b.c &lt;- r:</span><br><span class="line">         b.mu.Unlock()</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   b.backlog = <span class="built_in">append</span>(b.backlog, r)<span class="comment">//切片不为空则直接存入切片尾部</span></span><br><span class="line">   b.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="帧的消费"><a class="markdownIt-Anchor" href="#帧的消费"></a> 帧的消费</h5><p>如果切片长度大于0，说明切片内部有消息，则直接将切片第一条数据传入隧道，这样每次读取隧道中的数据即可，也能缓冲一部分数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *recvBuffer)</span> <span class="title">load</span><span class="params">()</span></span> &#123;</span><br><span class="line">   b.mu.Lock()</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(b.backlog) &gt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> b.c &lt;- b.backlog[<span class="number">0</span>]:</span><br><span class="line">         b.backlog[<span class="number">0</span>] = recvMsg&#123;&#125;</span><br><span class="line">         b.backlog = b.backlog[<span class="number">1</span>:]</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   b.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然帧被放入到了同一个流的 <code>recvBuffer</code>中，但还是没有说明：<strong>如果一个帧的分帧是前后发送的，但是接收的顺序是乱序的时候，即使顺序消费也无法保证数据帧能够正常的解析</strong>？</p><p>答：这里可以这样想，由于TCP是有序的，那么所有的TCP包都会按照发送顺序在接收端组装完成。也就是说只要发送顺序一定，那么接收端的顺序与发送端的是一样的。又因为同一个连接共用一个帧缓冲器，也就是说同一个流中的帧都是顺序发送的，所以接收端收到的帧的顺序也是不会乱序的。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li><p>多路复用可以在同一个TCP连接上同时传输多个HTTP请求和响应，避免建立和关闭连接的开销</p></li><li><p>和长连接的区别是: <strong>多路复用</strong> 可以避免 <strong>队头阻塞(Head-of-Line Blocking)</strong> 问题。如果某个请求在传输过程过程中出现阻塞，那么后续的请求也会被阻塞</p></li><li><p>和分包的区别是:HTTP分包是指将一个HTTP消息分为多个TCP数据包(Packet)进行传输，而多路复用是在同一个TCP连接上同时传输多个HTTP请求和响应</p></li><li><p>HTTP2 帧的最大传输字节是 16KB，TCP最大传输MSS是 1460B，IP层最大传输单元 MTU 1500B</p><blockquote><p>HTTP2 的帧有一个固定9B的头部，用于描述帧的类型，长度，标志等信息。其中保存林该帧的有效载荷的长度，最大长度 2^24 - 1 大约为 16KB</p></blockquote></li><li><p>多路复使用相同的 StreamID 来标识属于同一个流，使用recvBuffer进行帧的缓存(多个数据帧)，使用独立协程或者生产者消费者模式进行帧处理</p></li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://blog.csdn.net/u011582922/article/details/120426690" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/120426690</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;多路复用是 HTTP/2中的重要特性，允许同一个TCP连接上同时传输多个HTTP请求和响应&lt;/p&gt;
&lt;p&gt;带着问题看世界：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过《帧发送器》可知帧是一个一个进行消息发送，多个流的帧如何发送&lt;/li&gt;
&lt;li&gt;服务端是如何区分不同的流的帧&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-03-帧</title>
    <link href="http://xboom.github.io/2022/10/11/Grpc/Grpc-05-%E5%B8%A7/"/>
    <id>http://xboom.github.io/2022/10/11/Grpc/Grpc-05-%E5%B8%A7/</id>
    <published>2022-10-11T14:58:29.000Z</published>
    <updated>2023-05-27T10:55:06.561Z</updated>
    
    <content type="html"><![CDATA[<p>从前面可知，流单独负责一次调用，并且在服务端使用多路复用实现消息的处理。流其实是通过 ID 标志的虚拟概念，真正传输的其实是帧，帧通过发送器与帧接收器进行发送处理。</p><p>带着问题看世界：</p><ol><li>帧的类型有哪些，具体结构是怎样的</li><li>当消息体过大的时候分帧是如何处理的</li><li>当帧的缓冲区是否也会满，什么时候清理</li></ol><p>在 grpc-go 中，通过对 HTTP/2 中协议的封装，增加了<code>grpc-go</code>自己的业务类型。看源码的时候注意不要弄混了。这里说的协议帧 是 HTTP/2 中定义实际传输过程中的帧 是由 net 库实现的；而应用帧则是 <code>grpc-go</code> 根据自己的实际需要由转换了一层</p><h3 id="协议帧"><a class="markdownIt-Anchor" href="#协议帧"></a> 协议帧</h3><p>每个协议帧都是由<strong>头部</strong>与<strong>负载</strong>两个部分组成</p><h4 id="头部"><a class="markdownIt-Anchor" href="#头部"></a> 头部</h4><p>协议帧指的就是HTTP2中帧的结构，每个帧也分为头部与负载</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+--------+--------+--------+--------+--------+--------+</span><br><span class="line">|        Length(<span class="number">24</span>)        |Type(<span class="number">8</span>) |Flags(<span class="number">8</span>)|R|       StreamID(<span class="number">31</span>)     |</span><br><span class="line">+--------+--------+--------+--------+--------+--------+--------+--------+</span><br></pre></td></tr></table></figure><blockquote><p>虽然Length 是24位，但这不意味着就能处理 2^24 16M大小的帧，一般是默认只支持2^16 16k以下的帧，而2^16 - 2^24 16M 的帧 需要接收端公布自己可以处理这么大的帧，需要在 <strong>SETTINGS_MAX_FRAME_SIZE</strong> 帧中告知</p></blockquote><p>将二进制buffer转换为帧头部结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FrameHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">valid <span class="keyword">bool</span> <span class="comment">// 是否有效，供内部使用</span></span><br><span class="line">Type FrameType<span class="comment">// 帧的类型</span></span><br><span class="line">Flags Flags<span class="comment">// 标志位</span></span><br><span class="line">Length <span class="keyword">uint32</span><span class="comment">// 帧的负载长度(即不包括头部)</span></span><br><span class="line">StreamID <span class="keyword">uint32</span><span class="comment">// 流ID，有的帧没有流，那么StreamID == 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以头部的整体解析流程就变成了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFrameHeader</span><span class="params">(buf []<span class="keyword">byte</span>, r io.Reader)</span> <span class="params">(FrameHeader, error)</span></span> &#123;</span><br><span class="line">   _, err := io.ReadFull(r, buf[:frameHeaderLen])<span class="comment">//读取9B到buf中</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> FrameHeader&#123;&#125;, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> FrameHeader&#123;<span class="comment">//解析成头部接头</span></span><br><span class="line">      Length:   (<span class="keyword">uint32</span>(buf[<span class="number">0</span>])&lt;&lt;<span class="number">16</span> | <span class="keyword">uint32</span>(buf[<span class="number">1</span>])&lt;&lt;<span class="number">8</span> | <span class="keyword">uint32</span>(buf[<span class="number">2</span>])),<span class="comment">//头部长度 </span></span><br><span class="line">      Type:     FrameType(buf[<span class="number">3</span>]),<span class="comment">//类型</span></span><br><span class="line">      Flags:    Flags(buf[<span class="number">4</span>]),<span class="comment">//标志位</span></span><br><span class="line">      StreamID: binary.BigEndian.Uint32(buf[<span class="number">5</span>:]) &amp; (<span class="number">1</span>&lt;&lt;<span class="number">31</span> - <span class="number">1</span>),</span><br><span class="line">      valid:    <span class="literal">true</span>,<span class="comment">//是否有效</span></span><br><span class="line">   &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是：</p><ol><li><code>binary.BigEndian.Uint32</code> 这个作用是将 4个字节的二进制数据转换为 uint32类型的数据</li><li><code>1&lt;&lt;31 - 1</code> 用于将高位设置为0，确保能被正确的解析为uint32位的值</li></ol><p>最后数据帧的格式如下</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/http2_dataframe.png" alt="" /></p><h4 id="帧的类型"><a class="markdownIt-Anchor" href="#帧的类型"></a> 帧的类型</h4><p>其中 <code>FrameType</code> 代表的帧类型，一共有10中</p><table><thead><tr><th>帧类型</th><th>说明</th><th>值</th><th>字符</th></tr></thead><tbody><tr><td><strong>FrameData</strong></td><td>表示数据帧，用于传输 HTTP 报文的实际数据部分</td><td>0x0</td><td>“DATA”</td></tr><tr><td><strong>FrameHeaders</strong></td><td>携带请求或响应头部，也可以分为多个帧进行传输</td><td>0x1</td><td>“HEADERS”</td></tr><tr><td><strong>FramePriority</strong></td><td>表示某个流的优先级，用于流量控制</td><td>0x2</td><td>“PRIORITY”</td></tr><tr><td><strong>FrameRSTStream</strong></td><td>重置某个流，表示这个流将不再使用</td><td>0x3</td><td>“RST_STREAM”</td></tr><tr><td><strong>FrameSettings</strong></td><td>表示设置帧，用于在连接和流级别上传输参数设置</td><td>0x4</td><td>“SETTINGS”</td></tr><tr><td><strong>FramePushPromise</strong></td><td>允许服务端在客户端还没有请求的情况下发送响应头部，用于服务端推送(server push)功能</td><td>0x5</td><td>“PUSH_PROMISE”</td></tr><tr><td><strong>FramePing</strong></td><td>表示 Ping 帧，用于检测连接是否存活</td><td>0x6</td><td>“PING”</td></tr><tr><td><strong>FrameGoAway</strong></td><td>表示断开帧，用于通知对端关闭连接</td><td>0x7</td><td>“GOAWAY”</td></tr><tr><td><strong>FrameWindowUpdate</strong></td><td>用于流量控制，通知对端窗口大小的变化</td><td>0x8</td><td>“WINDOW_UPDATE”</td></tr><tr><td><strong>FrameContinuation</strong></td><td>表示继续帧，将头部帧或推送帧拆分为多个帧进行传输时，用于指示后续帧属于同一个头部块</td><td>0x9</td><td>“CONTINUATION”</td></tr></tbody></table><h4 id="帧的标志位"><a class="markdownIt-Anchor" href="#帧的标志位"></a> 帧的标志位</h4><p>另外一个标志位Flags则是帧</p><table><thead><tr><th>帧类型</th><th>Flags类型</th><th>说明</th><th>值</th></tr></thead><tbody><tr><td><strong>FrameData</strong></td><td>FlagDataEndStream</td><td>标志位用于 <code>DATA</code> 帧，表示这是最后一个 <code>DATA</code> 帧，即流已经结束，接收方不应该再等待更多的 <code>DATA</code> 帧</td><td>0x1</td></tr><tr><td></td><td>FlagDataPadded</td><td>数据帧的填充(Padded)标志，表示数据帧后面跟随一个填充字段</td><td>0x8</td></tr><tr><td><strong>FrameHeaders</strong></td><td>FlagHeadersEndStream</td><td>首部帧(Headers Frame)的结束流标志，表示发送方已经发送完整个消息</td><td>0x1</td></tr><tr><td></td><td>FlagHeadersEndHeaders</td><td>首部帧的结束头(End Headers)标志，表示这个首部块是消息的最后一个首部块</td><td>0x4</td></tr><tr><td></td><td>FlagHeadersPadded</td><td>首部帧的填充标志，表示首部帧后面跟随一个填充字段</td><td>0x8</td></tr><tr><td></td><td>FlagHeadersPriority</td><td>首部帧的优先级(Priority)标志，表示这个首部块包含了一个优先级信息</td><td>0x20</td></tr><tr><td><strong>FrameSettings</strong></td><td>FlagSettingsAck</td><td>设置帧(Settings Frame)的确认(Ack)标志，表示这是一个确认帧</td><td>0x1</td></tr><tr><td><strong>FramePing</strong></td><td>FlagPingAck</td><td>Ping帧的确认标志，表示这是一个确认帧</td><td>0x1</td></tr><tr><td><strong>FrameContinuation</strong></td><td>FlagContinuationEndHeaders</td><td>连续帧(Continuation Frame)的结束头标志，表示这个连续块是消息的最后一个连续块</td><td>0x4</td></tr><tr><td><strong>FramePushPromise</strong></td><td>FlagPushPromiseEndHeaders</td><td>推送帧(Push Promise Frame)的结束头标志，表示这个推送帧包含了一个完整的首部块</td><td>0x4</td></tr><tr><td></td><td>FlagPushPromisePadded</td><td>推送帧的填充标志，表示推送帧后面跟随一个填充字段</td><td>0x8</td></tr></tbody></table><p>有了上述的帧的关键字段说明，接下来来看看各个数据帧的解析</p><h4 id="负载"><a class="markdownIt-Anchor" href="#负载"></a> 负载</h4><p>头部定义之后，负载通过头部长度 <strong>Length</strong> 进行解析，负载解析如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">payload := fr.getReadBuf(fh.Length)<span class="comment">//获取负载长度</span></span><br><span class="line"><span class="keyword">if</span> _, err := io.ReadFull(fr.r, payload); err != <span class="literal">nil</span> &#123;<span class="comment">//读取负载长度</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">f, err := typeFrameParser(fh.Type)(fr.frameCache, fh, payload)<span class="comment">//将负载根据类型解析为对应的帧 fh是上一步读取的帧头</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> ce, ok := err.(connError); ok &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, fr.connError(ce.Code, ce.Reason)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据帧的解析是通过类型参数进行解析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f, err := typeFrameParser(fh.Type)(fr.frameCache, fh, payload)</span><br></pre></td></tr></table></figure><p>其中</p><ol><li><code>fh.Type</code> 是从头部解析出来的帧的类型，用于找到指定类型的数据帧解析器</li><li><code>fr.frameCache</code> 流都具有自己的帧内存缓存池。在需要发送帧时，可以从自己的缓存池中获取内存，并在完成后将其返回以供重用</li><li><code>fh</code> 之前解析出的帧的头部，用来与解析完的负载合并成一个完整的帧</li><li><code>payload</code> 则是帧的负载，用于解析帧的数据部分</li></ol><p>需要关注的是</p><ol><li>是如何转换成其他类型的</li><li>如果有存在分帧，又是如何进行解析的</li><li>如果有帧的丢失怎么办</li></ol><h5 id="framedata"><a class="markdownIt-Anchor" href="#framedata"></a> FrameData</h5><p>数据帧的解析对应的是 <code>parseDataFrame</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseDataFrame</span><span class="params">(fc *frameCache, fh FrameHeader, payload []<span class="keyword">byte</span>)</span> <span class="params">(Frame, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> fh.StreamID == <span class="number">0</span> &#123;<span class="comment">//数据帧StreamID必不为0</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, connError&#123;ErrCodeProtocol, <span class="string">"DATA frame with stream ID 0"</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   f := fc.getDataFrame()<span class="comment">//从内存池获取一个数据帧结构</span></span><br><span class="line">   f.FrameHeader = fh<span class="comment">//帧头部</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> padSize <span class="keyword">byte</span></span><br><span class="line">   <span class="keyword">if</span> fh.Flags.Has(FlagDataPadded) &#123;<span class="comment">//如果有追加</span></span><br><span class="line">      <span class="keyword">var</span> err error</span><br><span class="line">      payload, padSize, err = readByte(payload)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">int</span>(padSize) &gt; <span class="built_in">len</span>(payload) &#123;<span class="comment">//当追加的长度大于负载的长度</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, connError&#123;ErrCodeProtocol, <span class="string">"pad size larger than data payload"</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   f.data = payload[:<span class="built_in">len</span>(payload)-<span class="keyword">int</span>(padSize)]<span class="comment">//帧的负载就是 负载 - 追加</span></span><br><span class="line">   <span class="keyword">return</span> f, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当存在追加帧 <code>FlagDataPadded</code> 的时候 使用 <code>readByte</code>进行解析出去除追加长度的负载</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readByte</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(remain []<span class="keyword">byte</span>, b <span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(p) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, io.ErrUnexpectedEOF</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> p[<span class="number">1</span>:], p[<span class="number">0</span>], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，正常情况只有负载，但是如果数据帧存在追加  <code>FlagDataPadded</code>，数据帧的负载还有一个长度</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|             padSize(<span class="number">32</span>)|</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|data...</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|padding ...</span><br><span class="line">+--------+--------+--------+--------+</span><br></pre></td></tr></table></figure><p><strong>追加的内容在解析成数据帧的过程中，丢掉了！！！！！</strong> 这是因为填充字段仅仅是为了将数据帧填充到规定的长度</p><p>最终组成数据帧</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DataFrame <span class="keyword">struct</span> &#123;</span><br><span class="line">   FrameHeader</span><br><span class="line">   data []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么另外一个标志位 <code>FlagDataEndStream</code> 是在应用gRPC使用</p><ul><li>服务端收到数据帧结束流之后，设置流的状态并结束继续读取流数据</li><li>客户端收到数据帧结束流之后，关闭流(结束读取并清理流)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">if</span> f.StreamEnded() &#123;</span><br><span class="line">t.closeStream(s, io.EOF, <span class="literal">false</span>, http2.ErrCodeNo, status.New(codes.Internal, <span class="string">"server closed the stream without sending trailers"</span>), <span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">if</span> f.StreamEnded() &#123;</span><br><span class="line">   <span class="comment">// Received the end of stream from the client.</span></span><br><span class="line">   s.compareAndSwapState(streamActive, streamReadDone)</span><br><span class="line">   s.write(recvMsg&#123;err: io.EOF&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他注意事项</p><ol><li>如果数据帧中 <code>StreamID == 0</code> ，那么这个数据帧异常，也就是说数据帧必须绑定一个流</li></ol><h5 id="frameheaders"><a class="markdownIt-Anchor" href="#frameheaders"></a> FrameHeaders</h5><p>头帧也是由头部与负载组成，通过 <code>parseHeadersFrame</code> 解析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseHeadersFrame</span><span class="params">(_ *frameCache, fh FrameHeader, p []<span class="keyword">byte</span>)</span> <span class="params">(_ Frame, err error)</span></span> &#123;</span><br><span class="line">   hf := &amp;HeadersFrame&#123;</span><br><span class="line">      FrameHeader: fh,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> fh.StreamID == <span class="number">0</span> &#123;<span class="comment">//头帧流ID不能为0</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, connError&#123;ErrCodeProtocol, <span class="string">"HEADERS frame with stream ID 0"</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> padLength <span class="keyword">uint8</span></span><br><span class="line">   <span class="keyword">if</span> fh.Flags.Has(FlagHeadersPadded) &#123;<span class="comment">//如果有头部追加，同理解析出负载与追加长度</span></span><br><span class="line">      <span class="keyword">if</span> p, padLength, err = readByte(p); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> fh.Flags.Has(FlagHeadersPriority) &#123;<span class="comment">//如果有优先级</span></span><br><span class="line">      <span class="keyword">var</span> v <span class="keyword">uint32</span></span><br><span class="line">      p, v, err = readUint32(p)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">      &#125;</span><br><span class="line">      hf.Priority.StreamDep = v &amp; <span class="number">0x7fffffff</span></span><br><span class="line">      hf.Priority.Exclusive = (v != hf.Priority.StreamDep) <span class="comment">// high bit was set</span></span><br><span class="line">      p, hf.Priority.Weight, err = readByte(p)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(p)-<span class="keyword">int</span>(padLength) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, streamError(fh.StreamID, ErrCodeProtocol)</span><br><span class="line">   &#125;</span><br><span class="line">   hf.headerFragBuf = p[:<span class="built_in">len</span>(p)-<span class="keyword">int</span>(padLength)]<span class="comment">//去掉追加部分</span></span><br><span class="line">   <span class="keyword">return</span> hf, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体来看，头帧结构如下所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|             padSize(<span class="number">32</span>)|</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|             priority(<span class="number">32</span>)|</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|weight(<span class="number">8</span>)|</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|             payload|</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|padding|</span><br><span class="line">+--------+--------+--------+--------+</span><br></pre></td></tr></table></figure><p>这里比数据帧多的第一个标志位就是 优先级 <code>FlagHeadersPriority</code>，它的作用是表示流的优先级</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PriorityParam <span class="keyword">struct</span> &#123;</span><br><span class="line">   StreamDep <span class="keyword">uint32</span></span><br><span class="line">   Exclusive <span class="keyword">bool</span></span><br><span class="line">   Weight <span class="keyword">uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>StreamDep</code>：一个31位的流标识符，表示此流依赖的流。如果为0，表示没有依赖关系。</li><li><code>Exclusive</code>：表示此流是否具有互斥性。如果此字段为true，表示此流是在其依赖的流和同级的兄弟流之间互斥的。</li><li><code>Weight</code>：此流的权重值，是一个0-255的值。根据规范，应该将此字段与<code>StreamDep</code>一起设置，或者两者都不设置。为了获得1到256之间的权重，请将此值加1</li></ol><blockquote><p>为什么流有依赖关系或者互斥关系???</p><p>流之间的依赖关系或者互斥关系可以帮助控制流之间的优先级和竞争关系，从而更有效地利用网络带宽和资源。</p><p>例如1：如果一个网页需要加载多个资源，比如图片、脚本和样式表，那么这些资源就可以分别被分配到不同的流中。为了更快地呈现网页，图片这类占用带宽较大的资源可以被赋予更高的优先级，使其在竞争网络资源时更优先被传输，从而减少用户等待时间。</p><p>例如2：如果一个客户端同时向服务器发起了多个请求，这些请求可能会在服务器端形成竞争关系，造成某些请求的延迟和等待时间过长。通过为请求之间建立依赖关系和互斥关系，可以更好地控制请求的执行顺序和资源利用，提高服务质量和用户体验</p></blockquote><p>最后组成结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HeadersFrame <span class="keyword">struct</span> &#123;</span><br><span class="line">   FrameHeader</span><br><span class="line">   Priority PriorityParam</span><br><span class="line">   headerFragBuf []<span class="keyword">byte</span> <span class="comment">// not owned</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外两个标志位 <code>FlagHeadersEndStream</code> 和 <code>FlagHeadersEndHeaders</code> 同理，是在应用层使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> fh.Type &#123;</span><br><span class="line"><span class="keyword">case</span> FrameHeaders, FrameContinuation:</span><br><span class="line">   <span class="keyword">if</span> fh.Flags.Has(FlagHeadersEndHeaders) &#123;</span><br><span class="line">      fr.lastHeaderStream = <span class="number">0</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fr.lastHeaderStream = fh.StreamID</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="framepriority"><a class="markdownIt-Anchor" href="#framepriority"></a> FramePriority</h5><p>虽然头帧中可以设置流的优先级，但是如果有大量的流需要设置优先级，将会导致头帧变得非常庞大，传输的效率也会受到影响。优先级帧可以独立于其他帧来设置流的优先级。同时，PRIORITY 帧也可以用于修改流的依赖关系，因此它具有比头帧更强的功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parsePriorityFrame</span><span class="params">(_ *frameCache, fh FrameHeader, payload []<span class="keyword">byte</span>)</span> <span class="params">(Frame, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> fh.StreamID == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, connError&#123;ErrCodeProtocol, <span class="string">"PRIORITY frame with stream ID 0"</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(payload) != <span class="number">5</span> &#123;<span class="comment">//负载必须是5</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, connError&#123;ErrCodeFrameSize, fmt.Sprintf(<span class="string">"PRIORITY frame payload size was %d; want 5"</span>, <span class="built_in">len</span>(payload))&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   v := binary.BigEndian.Uint32(payload[:<span class="number">4</span>])</span><br><span class="line">   streamID := v &amp; <span class="number">0x7fffffff</span> <span class="comment">// mask off high bit</span></span><br><span class="line">   <span class="keyword">return</span> &amp;PriorityFrame&#123;</span><br><span class="line">      FrameHeader: fh,</span><br><span class="line">      PriorityParam: PriorityParam&#123;</span><br><span class="line">         Weight:    payload[<span class="number">4</span>],<span class="comment">//256</span></span><br><span class="line">         StreamDep: streamID,</span><br><span class="line">         Exclusive: streamID != v, <span class="comment">//是否是独立</span></span><br><span class="line">      &#125;,</span><br><span class="line">   &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组成的优先级帧如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|           StreamDep(<span class="number">32</span>)|</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|Weight(<span class="number">8</span>)|</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure><h5 id="framerststream"><a class="markdownIt-Anchor" href="#framerststream"></a> FrameRSTStream</h5><p>重置帧则只需要负载的前4个字节用于标志重置原因</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func parseRSTStreamFrame(_ *frameCache, fh FrameHeader, p []byte) (Frame, error) &#123;</span><br><span class="line">   if len(p) !&#x3D; 4 &#123;</span><br><span class="line">      return nil, ConnectionError(ErrCodeFrameSize)</span><br><span class="line">   &#125;</span><br><span class="line">   if fh.StreamID &#x3D;&#x3D; 0 &#123;</span><br><span class="line">      return nil, ConnectionError(ErrCodeProtocol)</span><br><span class="line">   &#125;</span><br><span class="line">   return &amp;RSTStreamFrame&#123;fh, ErrCode(binary.BigEndian.Uint32(p[:4]))&#125;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析成如下结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|            ErrCode(<span class="number">32</span>)|</span><br><span class="line">+--------+--------+--------+--------+</span><br></pre></td></tr></table></figure><p>组成的数据结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RSTStreamFrame <span class="keyword">struct</span> &#123;</span><br><span class="line">   FrameHeader</span><br><span class="line">   ErrCode ErrCode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="framesettings"><a class="markdownIt-Anchor" href="#framesettings"></a> FrameSettings</h5><p>设置帧是通过 <code>parseSettingsFrame</code> 解析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseSettingsFrame</span><span class="params">(_ *frameCache, fh FrameHeader, p []<span class="keyword">byte</span>)</span> <span class="params">(Frame, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> fh.Flags.Has(FlagSettingsAck) &amp;&amp; fh.Length &gt; <span class="number">0</span> &#123;<span class="comment">//如果负载长度大于0，则肯定不是ACK帧</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ConnectionError(ErrCodeFrameSize)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> fh.StreamID != <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ConnectionError(ErrCodeProtocol)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(p)%<span class="number">6</span> != <span class="number">0</span> &#123;<span class="comment">//设置帧固定是 6的倍数</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ConnectionError(ErrCodeFrameSize)</span><br><span class="line">   &#125;</span><br><span class="line">   f := &amp;SettingsFrame&#123;FrameHeader: fh, p: p&#125;<span class="comment">//直接将负载存入设置帧中</span></span><br><span class="line">   <span class="keyword">if</span> v, ok := f.Value(SettingInitialWindowSize); ok &amp;&amp; v &gt; (<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ConnectionError(ErrCodeFlowControl)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> f, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它因为直接使用了KV结构，所以固定每一对的长度是6，那么就能统计出每一对的内容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *SettingsFrame)</span> <span class="title">Value</span><span class="params">(id SettingID)</span> <span class="params">(v <span class="keyword">uint32</span>, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   f.checkValid()</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; f.NumSettings(); i++ &#123;</span><br><span class="line">      <span class="keyword">if</span> s := f.Setting(i); s.ID == id &#123;</span><br><span class="line">         <span class="keyword">return</span> s.Val, <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *SettingsFrame)</span> <span class="title">Setting</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">Setting</span></span> &#123;</span><br><span class="line">buf := f.p</span><br><span class="line"><span class="keyword">return</span> Setting&#123;</span><br><span class="line">ID:  SettingID(binary.BigEndian.Uint16(buf[i*<span class="number">6</span> : i*<span class="number">6</span>+<span class="number">2</span>])),</span><br><span class="line">Val: binary.BigEndian.Uint32(buf[i*<span class="number">6</span>+<span class="number">2</span> : i*<span class="number">6</span>+<span class="number">6</span>]),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共存在6对</p><table><thead><tr><th>标志</th><th>说明</th><th>值</th></tr></thead><tbody><tr><td>SettingHeaderTableSize</td><td>客户端和服务器通信时，指定用于HPACK头表大小的值</td><td>0x1</td></tr><tr><td>SettingEnablePush</td><td>服务器指示客户端是否可以推送资源</td><td>0x2</td></tr><tr><td>SettingMaxConcurrentStreams</td><td>指定客户端可以同时使用的最大流数</td><td>0x3</td></tr><tr><td>SettingInitialWindowSize</td><td>指定流控制窗口的初始大小</td><td>0x4</td></tr><tr><td>SettingMaxFrameSize</td><td>指定帧大小的最大值</td><td>0x5</td></tr><tr><td>SettingMaxHeaderListSize</td><td>指定头部列表大小的最大值</td><td>0x6</td></tr></tbody></table><p>所以对应的结构就是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SettingsFrame <span class="keyword">struct</span> &#123;</span><br><span class="line">   FrameHeader</span><br><span class="line">   p []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化窗口大小不能大于 <code>v &gt; (1&lt;&lt;31)-1</code></p><h5 id="framepushpromise"><a class="markdownIt-Anchor" href="#framepushpromise"></a> FramePushPromise</h5><p><code>FramePushPromise</code> 通过 <code>parsePushPromise</code> 进行数据解析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parsePushPromise</span><span class="params">(_ *frameCache, fh FrameHeader, countError <span class="keyword">func</span>(<span class="keyword">string</span>)</span>, <span class="title">p</span> []<span class="title">byte</span>) <span class="params">(_ Frame, err error)</span></span> &#123;</span><br><span class="line">   pp := &amp;PushPromiseFrame&#123;</span><br><span class="line">      FrameHeader: fh,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> pp.StreamID == <span class="number">0</span> &#123;</span><br><span class="line">      countError(<span class="string">"frame_pushpromise_zero_stream"</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ConnectionError(ErrCodeProtocol)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果有追加，那么就读取追加长度</span></span><br><span class="line">   <span class="keyword">var</span> padLength <span class="keyword">uint8</span></span><br><span class="line">   <span class="keyword">if</span> fh.Flags.Has(FlagPushPromisePadded) &#123;</span><br><span class="line">      <span class="keyword">if</span> p, padLength, err = readByte(p); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         countError(<span class="string">"frame_pushpromise_pad_short"</span>)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   p, pp.PromiseID, err = readUint32(p)<span class="comment">//读取PromiseID </span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      countError(<span class="string">"frame_pushpromise_promiseid_short"</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   pp.PromiseID = pp.PromiseID &amp; (<span class="number">1</span>&lt;&lt;<span class="number">31</span> - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">int</span>(padLength) &gt; <span class="built_in">len</span>(p) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ConnectionError(ErrCodeProtocol)</span><br><span class="line">   &#125;</span><br><span class="line">   pp.headerFragBuf = p[:<span class="built_in">len</span>(p)-<span class="keyword">int</span>(padLength)]</span><br><span class="line">   <span class="keyword">return</span> pp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以二进制可以看出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|           padLength(<span class="number">32</span>)|</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|PromiseID(<span class="number">32</span>)|</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|payload|</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|  padding|</span><br><span class="line">+--------+--------+--------+--------+</span><br></pre></td></tr></table></figure><p>所以最后组成的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PushPromiseFrame <span class="keyword">struct</span> &#123;</span><br><span class="line">   FrameHeader</span><br><span class="line">   PromiseID     <span class="keyword">uint32</span></span><br><span class="line">   headerFragBuf []<span class="keyword">byte</span> <span class="comment">// not owned</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="frameping"><a class="markdownIt-Anchor" href="#frameping"></a> FramePing</h5><p><code>FramePing</code> 通过 <code>parsePingFrame</code> 进行数据解析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parsePingFrame</span><span class="params">(_ *frameCache, fh FrameHeader, countError <span class="keyword">func</span>(<span class="keyword">string</span>)</span>, <span class="title">payload</span> []<span class="title">byte</span>) <span class="params">(Frame, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(payload) != <span class="number">8</span> &#123;</span><br><span class="line">      countError(<span class="string">"frame_ping_length"</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ConnectionError(ErrCodeFrameSize)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> fh.StreamID != <span class="number">0</span> &#123;</span><br><span class="line">      countError(<span class="string">"frame_ping_has_stream"</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ConnectionError(ErrCodeProtocol)</span><br><span class="line">   &#125;</span><br><span class="line">   f := &amp;PingFrame&#123;FrameHeader: fh&#125;</span><br><span class="line">   <span class="built_in">copy</span>(f.Data[:], payload)</span><br><span class="line">   <span class="keyword">return</span> f, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组成的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PingFrame <span class="keyword">struct</span> &#123;</span><br><span class="line">   FrameHeader</span><br><span class="line">   Data [<span class="number">8</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ping帧中很特别的是负载是指定长度的8，通常是时间戳</p><h5 id="framegoaway"><a class="markdownIt-Anchor" href="#framegoaway"></a> FrameGoAway</h5><p><code>FrameGoAway</code> 通过 <code>parseGoAwayFrame</code> 进行数据解析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseGoAwayFrame</span><span class="params">(_ *frameCache, fh FrameHeader, countError <span class="keyword">func</span>(<span class="keyword">string</span>)</span>, <span class="title">p</span> []<span class="title">byte</span>) <span class="params">(Frame, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> fh.StreamID != <span class="number">0</span> &#123;</span><br><span class="line">      countError(<span class="string">"frame_goaway_has_stream"</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ConnectionError(ErrCodeProtocol)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(p) &lt; <span class="number">8</span> &#123;</span><br><span class="line">      countError(<span class="string">"frame_goaway_short"</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ConnectionError(ErrCodeFrameSize)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &amp;GoAwayFrame&#123;</span><br><span class="line">      FrameHeader:  fh,</span><br><span class="line">      LastStreamID: binary.BigEndian.Uint32(p[:<span class="number">4</span>]) &amp; (<span class="number">1</span>&lt;&lt;<span class="number">31</span> - <span class="number">1</span>),</span><br><span class="line">      ErrCode:      ErrCode(binary.BigEndian.Uint32(p[<span class="number">4</span>:<span class="number">8</span>])),</span><br><span class="line">      debugData:    p[<span class="number">8</span>:],</span><br><span class="line">   &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GoAway</code>帧用于通知对端，当前的连接即将关闭，以及关闭的原因。<code>LastStreamID</code> 表示这个流之后的所有流都将被关闭</p><p>组成的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GoAwayFrame <span class="keyword">struct</span> &#123;</span><br><span class="line">   FrameHeader</span><br><span class="line">   LastStreamID <span class="keyword">uint32</span></span><br><span class="line">   ErrCode      ErrCode</span><br><span class="line">   debugData    []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="framewindowupdate"><a class="markdownIt-Anchor" href="#framewindowupdate"></a> FrameWindowUpdate</h5><p><code>FrameWindowUpdate</code> 通过 <code>parseWindowUpdateFrame</code> 进行数据解析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseWindowUpdateFrame</span><span class="params">(_ *frameCache, fh FrameHeader, countError <span class="keyword">func</span>(<span class="keyword">string</span>)</span>, <span class="title">p</span> []<span class="title">byte</span>) <span class="params">(Frame, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(p) != <span class="number">4</span> &#123;</span><br><span class="line">      countError(<span class="string">"frame_windowupdate_bad_len"</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ConnectionError(ErrCodeFrameSize)</span><br><span class="line">   &#125;</span><br><span class="line">   inc := binary.BigEndian.Uint32(p[:<span class="number">4</span>]) &amp; <span class="number">0x7fffffff</span> <span class="comment">// mask off high reserved bit</span></span><br><span class="line">   <span class="keyword">if</span> inc == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> fh.StreamID == <span class="number">0</span> &#123;</span><br><span class="line">         countError(<span class="string">"frame_windowupdate_zero_inc_conn"</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, ConnectionError(ErrCodeProtocol)</span><br><span class="line">      &#125;</span><br><span class="line">      countError(<span class="string">"frame_windowupdate_zero_inc_stream"</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, streamError(fh.StreamID, ErrCodeProtocol)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &amp;WindowUpdateFrame&#123;</span><br><span class="line">      FrameHeader: fh,</span><br><span class="line">      Increment:   inc,</span><br><span class="line">   &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组成的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WindowUpdateFrame <span class="keyword">struct</span> &#123;</span><br><span class="line">   FrameHeader</span><br><span class="line">   Increment <span class="keyword">uint32</span> <span class="comment">// never read with high bit set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="framecontinuation"><a class="markdownIt-Anchor" href="#framecontinuation"></a> FrameContinuation</h5><p><code>FrameContinuation</code> 通过 <code>parseContinuationFrame</code> 进行数据解析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseContinuationFrame</span><span class="params">(_ *frameCache, fh FrameHeader, countError <span class="keyword">func</span>(<span class="keyword">string</span>)</span>, <span class="title">p</span> []<span class="title">byte</span>) <span class="params">(Frame, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> fh.StreamID == <span class="number">0</span> &#123;</span><br><span class="line">      countError(<span class="string">"frame_continuation_zero_stream"</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, connError&#123;ErrCodeProtocol, <span class="string">"CONTINUATION frame with stream ID 0"</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &amp;ContinuationFrame&#123;fh, p&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组成的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ContinuationFrame <span class="keyword">struct</span> &#123;</span><br><span class="line">   FrameHeader</span><br><span class="line">   headerFragBuf []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个将用在帧过大的时候进行数据分帧，这个逻辑将在下面的分帧逻辑进行进一步分析</p><h3 id="应用帧"><a class="markdownIt-Anchor" href="#应用帧"></a> 应用帧</h3><p>上面其实看的是HTTP2协议中的协议帧，而实际在grpc-go中又做了进一步的区分</p><table><thead><tr><th>帧类型</th><th>说明</th></tr></thead><tbody><tr><td>incomingWindowUpdate</td><td>通知发送方更新发送窗口的大小</td></tr><tr><td>outgoingWindowUpdate</td><td>通知接收方更新接收窗口的大小</td></tr><tr><td>incomingSettings</td><td>设置帧</td></tr><tr><td>outgoingSettings</td><td>设置帧</td></tr><tr><td>headerFrame</td><td>帧的头部信息</td></tr><tr><td>registerStream</td><td>服务器专用</td></tr><tr><td>cleanupStream</td><td>针对RST帧</td></tr><tr><td>earlyAbortStream</td><td></td></tr><tr><td>incomingGoAway</td><td>为客户端服务，客户端一旦接受此帧，帧发送器状态为draining</td></tr><tr><td>dataFrame</td><td>数据帧</td></tr><tr><td>ping</td><td>Ping帧</td></tr><tr><td>goAway</td><td>goAway帧</td></tr><tr><td>outFlowControlSizeRequest</td><td></td></tr></tbody></table><p>这里特殊说明一个数据帧，因为在后续的分帧会说到</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> dataFrame <span class="keyword">struct</span> &#123;</span><br><span class="line">   streamID  <span class="keyword">uint32</span><span class="comment">//帧所属的流</span></span><br><span class="line">   endStream <span class="keyword">bool</span><span class="comment">//该帧是否为该流的最后一帧</span></span><br><span class="line">   h         []<span class="keyword">byte</span><span class="comment">//帧的头部，包含了一些控制信息，例如帧长度、类型、标志等</span></span><br><span class="line">   d         []<span class="keyword">byte</span><span class="comment">//帧的数据负载</span></span><br><span class="line">   onEachWrite <span class="function"><span class="keyword">func</span><span class="params">()</span>//在每次写出帧的一部分数据时调用的回调函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特殊注意的就是<code>d</code> 字段，表示的数据负载在传输时可能被切割成多个 <code>dataFrame</code> 进行传输。</p><h3 id="分帧"><a class="markdownIt-Anchor" href="#分帧"></a> 分帧</h3><p>当数据过大时，就需要分批发送</p><blockquote><p>TCP 分段(segment):将应用层数据分成多个 TCP 段进行传输，每个 TCP 段都有自己的头部信息</p><p>应用层 分包(packet)：分包是指将一个应用层数据包分成多个 IP 数据报进行传输</p><p>IP数据包 分片(fragmentation)：分片是指将一个 IP 数据报分成多个较小的数据报进行传输</p></blockquote><p><img src="https://img-blog.csdnimg.cn/f3f3f45e713842cdb0162ae119b6045f.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE1ODI5MjI=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /></p><p>将发送的请求Body超过限制16KB就能看到分帧了</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/http2_dataframe2.png" alt="http2_dataframe2" style="zoom:50%;" /><p>抓包可以看到其实单个帧的大小是 16384，而他们两个区别是</p><ol><li>在第二个中间带上的是<code>0x01 EndStream</code>，表示这个流结束</li><li>因为负载不同，所以他们头部<code>Length</code>也不一样，但是最大就是16384</li></ol><p>然后直接看看分帧分别是如何发送与接收的</p><h4 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h4><p>接着上述 dataFrame的结构说起，它并不是直接切分成多个，而是一部分一部分的切割发送</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *http2Client)</span> <span class="title">Write</span><span class="params">(s *Stream, hdr []<span class="keyword">byte</span>, data []<span class="keyword">byte</span>, opts *Options)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">df := &amp;dataFrame&#123;</span><br><span class="line">streamID:  s.id,</span><br><span class="line">endStream: opts.Last,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> hdr != <span class="literal">nil</span> || data != <span class="literal">nil</span> &#123; <span class="comment">// If it's not an empty data frame.</span></span><br><span class="line"><span class="comment">// Add some data to grpc message header so that we can equally</span></span><br><span class="line"><span class="comment">// distribute bytes across frames.</span></span><br><span class="line">emptyLen := http2MaxFrameLen - <span class="built_in">len</span>(hdr)</span><br><span class="line"><span class="keyword">if</span> emptyLen &gt; <span class="built_in">len</span>(data) &#123;</span><br><span class="line">emptyLen = <span class="built_in">len</span>(data)</span><br><span class="line">&#125;</span><br><span class="line">hdr = <span class="built_in">append</span>(hdr, data[:emptyLen]...)</span><br><span class="line">data = data[emptyLen:]</span><br><span class="line">df.h, df.d = hdr, data</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t.controlBuf.put(df)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析如下：</p><ol><li><code>hdr</code> 是应用层grpc帧的头 长度为 5B(1B是否压缩 + 4B负载长度)</li><li>data 是应用层grpc帧的负载数据</li><li>构建步骤如下：<ol><li>首先构建一个数据帧(应用层的)，指定流ID以及是否是最后一个流(<code>!cs.desc.ClientStreams</code>)</li><li>然后判断数据是否超过http2MaxFrameLen(16384)</li><li>接着 **从data中截取一部分放入到 数据帧的<code>h</code>，然后将剩余部分放入到d中！！！！！**所以这里的<code>h</code>与<code>d</code>并不是指的头与负载</li><li>最后将整个帧放入到帧缓冲器中</li></ol></li></ol><p>经过获取帧并将帧放入到链表之后到数据帧的处理中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *loopyWriter)</span> <span class="title">processData</span><span class="params">()</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">   dataItem := str.itl.peek().(*dataFrame) <span class="comment">//头部数据帧的指针，并不是出栈</span></span><br><span class="line"><span class="comment">//如果数据帧是空的，那么直接发送结束帧并关闭流</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(dataItem.h) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(dataItem.d) == <span class="number">0</span> &#123; <span class="comment">// Empty data frame</span></span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> (</span><br><span class="line">      idx <span class="keyword">int</span></span><br><span class="line">      buf []<span class="keyword">byte</span></span><br><span class="line">   )</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(dataItem.h) != <span class="number">0</span> &#123; <span class="comment">// data header has not been written out yet.</span></span><br><span class="line">      buf = dataItem.h</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      idx = <span class="number">1</span></span><br><span class="line">      buf = dataItem.d</span><br><span class="line">   &#125;</span><br><span class="line">   size := http2MaxFrameLen</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(buf) &lt; size &#123;</span><br><span class="line">      size = <span class="built_in">len</span>(buf)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//... 流级别与连接级别流控</span></span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="comment">//发送最大帧以及流控控制下的size</span></span><br><span class="line">   <span class="keyword">if</span> err := l.framer.fr.WriteData(dataItem.streamID, endStream, buf[:size]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   buf = buf[size:]<span class="comment">//更新剩余部分</span></span><br><span class="line">   <span class="keyword">if</span> idx == <span class="number">0</span> &#123;</span><br><span class="line">      dataItem.h = buf</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dataItem.d = buf</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//如果消息发完那么流头部消息发送完毕，则退出该消息</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(dataItem.h) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(dataItem.d) == <span class="number">0</span> &#123; <span class="comment">// All the data from that message was written out.</span></span><br><span class="line">      str.itl.dequeue()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于整个数据一次性放入到流的消息链表中，然后每次从数据中截取一部分给HTTP2进行发送</p><h4 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h4><p>服务端则是从结束数据开始看</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *parser)</span> <span class="title">recvMsg</span><span class="params">(maxReceiveMessageSize <span class="keyword">int</span>)</span> <span class="params">(pf payloadFormat, msg []<span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> _, err := p.r.Read(p.header[:]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   pf = payloadFormat(p.header[<span class="number">0</span>])</span><br><span class="line">   length := binary.BigEndian.Uint32(p.header[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">   <span class="comment">//...负载长度判断</span></span><br><span class="line">   <span class="keyword">if</span> _, err := p.r.Read(msg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">         err = io.ErrUnexpectedEOF</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> pf, msg, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先直接读取头部长度</li><li>接着校验负载长度是否异常(不能超过 接收最大长度)</li><li>接着读取指定长度</li></ul><p>到这里其实消息体已经是完整的应用层数据帧了，接着我们看下这个应用层数据帧是如何缓存的以及怎样触发读取的</p><p>分帧得从</p><p>由于流使用的是多路复用，所以每个流需要使用缓冲保存分帧数据，当判断已经获取到完整的帧的时候，再从缓冲中获取数据即可。这里用到的结构是 <code>recvBuffer</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> recvBuffer <span class="keyword">struct</span> &#123;</span><br><span class="line">   c       <span class="keyword">chan</span> recvMsg<span class="comment">//make(chan recvMsg, 1)</span></span><br><span class="line">   mu      sync.Mutex</span><br><span class="line">   backlog []recvMsg</span><br><span class="line">   err     error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到数据帧之后，会将帧存入到 <code>recvBuffer</code> 中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stream)</span> <span class="title">write</span><span class="params">(m recvMsg)</span></span> &#123;</span><br><span class="line">   s.buf.put(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这里做了一个特殊的设计</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *recvBuffer)</span> <span class="title">put</span><span class="params">(r recvMsg)</span></span> &#123;</span><br><span class="line">   b.mu.Lock()</span><br><span class="line">   <span class="keyword">if</span> b.err != <span class="literal">nil</span> &#123;</span><br><span class="line">      b.mu.Unlock()</span><br><span class="line">      <span class="comment">// An error had occurred earlier, don't accept more</span></span><br><span class="line">      <span class="comment">// data or errors.</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   b.err = r.err</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(b.backlog) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> b.c &lt;- r:</span><br><span class="line">         b.mu.Unlock()</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   b.backlog = <span class="built_in">append</span>(b.backlog, r)</span><br><span class="line">   b.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个操作</p><ol><li>当 backlog 为空，则直接写入到隧道中</li><li>当 backlog 不为空，则追加到backlog后面</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>帧分为帧头与负载，帧头长度为9</li><li>帧类型为10种，并结合flags进行使用</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://blog.csdn.net/u011582922/article/details/120578941" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/120578941</a></li><li><a href="https://www.jianshu.com/p/e22fef60a7f0" target="_blank" rel="noopener">https://www.jianshu.com/p/e22fef60a7f0</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从前面可知，流单独负责一次调用，并且在服务端使用多路复用实现消息的处理。流其实是通过 ID 标志的虚拟概念，真正传输的其实是帧，帧通过发送器与帧接收器进行发送处理。&lt;/p&gt;
&lt;p&gt;带着问题看世界：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;帧的类型有哪些，具体结构是怎样的&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-04-帧接收器</title>
    <link href="http://xboom.github.io/2022/10/09/Grpc/Grpc-04-%E5%B8%A7%E6%8E%A5%E6%94%B6%E5%99%A8/"/>
    <id>http://xboom.github.io/2022/10/09/Grpc/Grpc-04-%E5%B8%A7%E6%8E%A5%E6%94%B6%E5%99%A8/</id>
    <published>2022-10-09T14:58:29.000Z</published>
    <updated>2023-05-27T10:54:58.119Z</updated>
    
    <content type="html"><![CDATA[<p>看完帧的发送器，看看帧是如何接收的。</p><p>带着问题看世界：</p><ol><li>上一节中，一个连接对应一个帧发送器，那么一个连接有几个帧接收器。</li><li>服务端又是如何存储帧的</li></ol><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE1ODI5MjI=,size_16,color_FFFFFF,t_70.png" alt="帧缓存器阀门" style="zoom:50%;" /><p>跟帧发送器一样，帧接收器收到帧之后，也会根据不同类型进行分发，不同的是它并没有缓存的逻辑。</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE1ODI5MjI=,size_16,color_FFFFFF,t_70.png" alt="数据帧处理流程" style="zoom:50%;" /><h4 id="开启读取"><a class="markdownIt-Anchor" href="#开启读取"></a> 开启读取</h4><p>在构建 httpClient 客户端连接的时候会同时使用独立协程进行帧的读取</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> t.reader()</span><br></pre></td></tr></table></figure><p>每个连接(具体连接)会创建一个 <code>Framer</code> , 这个 <code>Framer</code> 就是实际上负责发送和接收 <code>HTTP2 frame</code> 的接口. 每一个 client 都会对应一个 <code>Framer</code> 来处理来自该 client 的所有 frame, 不管这些 frame 是不是属于一个 stream</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> framer <span class="keyword">struct</span> &#123;</span><br><span class="line">writer *bufWriter <span class="comment">//buf输入</span></span><br><span class="line">fr     *http2.Framer <span class="comment">//http帧处理器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> bufWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">buf       []<span class="keyword">byte</span></span><br><span class="line">offset    <span class="keyword">int</span></span><br><span class="line">batchSize <span class="keyword">int</span></span><br><span class="line">conn      net.Conn</span><br><span class="line">err       error</span><br><span class="line"></span><br><span class="line">onFlush <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读取帧"><a class="markdownIt-Anchor" href="#读取帧"></a> 读取帧</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *http2Client)</span> <span class="title">reader</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="built_in">close</span>(t.readerDone)</span><br><span class="line">   frame, err := t.framer.fr.ReadFrame() <span class="comment">//检查帧的读取是否正常</span></span><br><span class="line">   <span class="comment">//... 读取失败则关闭连接，触发重建连接</span></span><br><span class="line">   t.conn.SetReadDeadline(time.Time&#123;&#125;) <span class="comment">//设置超时时间为0</span></span><br><span class="line">   <span class="comment">//... 更新最近读取帧的时间</span></span><br><span class="line">   <span class="comment">//... 这个帧必须是设置帧并更新设置</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//循环读取帧</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      t.controlBuf.throttle()</span><br><span class="line">      frame, err := t.framer.fr.ReadFrame() </span><br><span class="line">      <span class="keyword">if</span> t.keepaliveEnabled &#123;</span><br><span class="line">         atomic.StoreInt64(&amp;t.lastRead, time.Now().UnixNano())</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="comment">//如果返回流错误则关闭流，并解析错误信息。仅仅当服务器返回错误信息才会返回</span></span><br><span class="line">         <span class="keyword">if</span> se, ok := err.(http2.StreamError); ok &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则关闭连接</span></span><br><span class="line">            <span class="comment">// Transport error.</span></span><br><span class="line">            t.Close(connectionErrorf(<span class="literal">true</span>, err, <span class="string">"error reading from server: %v"</span>, err))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//... 根据帧的类型进行处理</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个设置超时时间的逻辑需要注意</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.conn.SetReadDeadline(time.Time&#123;&#125;)  <span class="comment">//设置成 读取没有超时时间</span></span><br></pre></td></tr></table></figure><p>为什么这样设置就不会有超时时间可以看    <code>SetReadDeadline</code> 源码，当设置 零值的时候读取将不超时</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetReadDeadline sets the deadline for future Read calls</span></span><br><span class="line"><span class="comment">// and any currently-blocked Read call.</span></span><br><span class="line"><span class="comment">// A zero value for t means Read will not time out.</span></span><br><span class="line">SetReadDeadline(t time.Time) error</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">SetReadDeadline</span><span class="params">(t time.Time)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">p := c.Reader.(*pipe)</span><br><span class="line">p.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.mu.Unlock()</span><br><span class="line">p.rtimer.Stop()</span><br><span class="line">p.rtimedout = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> !t.IsZero() &#123;</span><br><span class="line">p.rtimer = time.AfterFunc(time.Until(t), <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.mu.Unlock()</span><br><span class="line">p.rtimedout = <span class="literal">true</span></span><br><span class="line">p.rwait.Broadcast()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么为什么 <code>time.Time{}</code> 被认为是 0，因为 <code>time.Time{}</code> 是 <code>0001-01-01 00:00:00 +0000 UTC</code>，而 <code>IsZero</code>的判断标准就是从起始时间开始的秒与毫秒</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">IsZero</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> t.sec() == <span class="number">0</span> &amp;&amp; t.nsec() == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="帧处理"><a class="markdownIt-Anchor" href="#帧处理"></a> 帧处理</h4><p>读取到的帧会根据不同类型直接处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> frame := frame.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *http2.MetaHeadersFrame:</span><br><span class="line">   t.operateHeaders(frame)</span><br><span class="line"><span class="keyword">case</span> *http2.DataFrame:</span><br><span class="line">   t.handleData(frame)</span><br><span class="line"><span class="keyword">case</span> *http2.RSTStreamFrame:</span><br><span class="line">   t.handleRSTStream(frame)</span><br><span class="line"><span class="keyword">case</span> *http2.SettingsFrame:</span><br><span class="line">   t.handleSettings(frame, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">case</span> *http2.PingFrame:</span><br><span class="line">   t.handlePing(frame)</span><br><span class="line"><span class="keyword">case</span> *http2.GoAwayFrame:</span><br><span class="line">   t.handleGoAway(frame)</span><br><span class="line"><span class="keyword">case</span> *http2.WindowUpdateFrame:</span><br><span class="line">   t.handleWindowUpdate(frame)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">   <span class="keyword">if</span> logger.V(logLevel) &#123;</span><br><span class="line">      logger.Errorf(<span class="string">"transport: http2Client.reader got unhandled frame type %v."</span>, frame)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取帧-2"><a class="markdownIt-Anchor" href="#读取帧-2"></a> 读取帧</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fr *Framer)</span> <span class="title">ReadFrame</span><span class="params">()</span> <span class="params">(Frame, error)</span></span> &#123;</span><br><span class="line">fr.errDetail = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> fr.lastFrame != <span class="literal">nil</span> &#123;</span><br><span class="line">fr.lastFrame.invalidate()</span><br><span class="line">&#125;</span><br><span class="line">fh, err := readFrameHeader(fr.headerBuf[:], fr.r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//超过最大读取格式，那么将报错</span></span><br><span class="line"><span class="keyword">if</span> fh.Length &gt; fr.maxReadSize &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrFrameTooLarge</span><br><span class="line">&#125;</span><br><span class="line">payload := fr.getReadBuf(fh.Length)</span><br><span class="line"><span class="keyword">if</span> _, err := io.ReadFull(fr.r, payload); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">f, err := typeFrameParser(fh.Type)(fr.frameCache, fh, fr.countError, payload)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ce, ok := err.(connError); ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fr.connError(ce.Code, ce.Reason)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := fr.checkFrameOrder(f); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> fr.logReads &#123;</span><br><span class="line">fr.debugReadLoggerf(<span class="string">"http2: Framer %p: read %v"</span>, fr, summarizeFrame(f))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> fh.Type == FrameHeaders &amp;&amp; fr.ReadMetaHeaders != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fr.readMetaFrame(f.(*HeadersFrame))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://blog.csdn.net/u011582922/article/details/117979181" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/117979181</a></li><li><a href="https://juejin.cn/post/7092975446257565726" target="_blank" rel="noopener">https://juejin.cn/post/7092975446257565726</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看完帧的发送器，看看帧是如何接收的。&lt;/p&gt;
&lt;p&gt;带着问题看世界：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上一节中，一个连接对应一个帧发送器，那么一个连接有几个帧接收器。&lt;/li&gt;
&lt;li&gt;服务端又是如何存储帧的&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;实现原理&quot;&gt;&lt;a class=&quot;
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-03-帧发送器</title>
    <link href="http://xboom.github.io/2022/10/07/Grpc/Grpc-03-%E5%B8%A7%E5%8F%91%E9%80%81%E5%99%A8/"/>
    <id>http://xboom.github.io/2022/10/07/Grpc/Grpc-03-%E5%B8%A7%E5%8F%91%E9%80%81%E5%99%A8/</id>
    <published>2022-10-07T14:58:29.000Z</published>
    <updated>2023-05-27T10:54:52.069Z</updated>
    
    <content type="html"><![CDATA[<p>在客户端跟服务器交互过程中，流具体是通过帧来进行数据的发送。这里学习如何发送帧的，整体如下</p><img src="https://img-blog.csdnimg.cn/20210614141120519.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE1ODI5MjI=,size_16,color_FFFFFF,t_70#pic_center" alt="帧发送器的整体利处理图" style="zoom:50%;" /><p>主要流程：</p><ol><li>各种类型的帧通过帧存储器接口(<code>put, executeAndPut</code>)将帧存储到帧缓存器<code>controlBuf</code>里，一个连接里的所有帧共享一个帧缓存器<code>controlBuf</code></li><li>帧发送器开始发送<ul><li>帧加载接口获取帧的策略，从帧缓存器controlBuf里加载帧，将帧传递给帧分发器</li><li>帧分发器根据帧的类型，分发给不同类型的帧处理器</li><li>不同类型的帧处理器接收到帧后，根据设置好的规则进行处理</li></ul></li></ol><p><strong>带着问题看世界</strong></p><ol><li>帧缓冲区可以无限存储帧吗，满了怎么办，什么时候删，大小可以设置吗</li><li>多个流公用一个帧缓冲区吗(显而易见的，因为帧属于不同的流，它们都存入的帧缓冲区中)</li><li>帧缓冲区是如何进行消息发送的</li></ol><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>在之前的流当中，有帧发送器的逻辑，即帧会在发送之前将帧都存储到帧缓冲器中</p><h4 id="帧缓冲器"><a class="markdownIt-Anchor" href="#帧缓冲器"></a> 帧缓冲器</h4><h5 id="帧缓存器结构"><a class="markdownIt-Anchor" href="#帧缓存器结构"></a> 帧缓存器结构</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> controlBuffer <span class="keyword">struct</span> &#123;</span><br><span class="line">ch              <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">done            &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">mu              sync.Mutex</span><br><span class="line">consumerWaiting <span class="keyword">bool</span></span><br><span class="line">list            *itemList</span><br><span class="line">err             error</span><br><span class="line"></span><br><span class="line">transportResponseFrames <span class="keyword">int</span></span><br><span class="line">trfChan                 atomic.Value <span class="comment">// chan struct&#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itemNode <span class="keyword">struct</span> &#123;</span><br><span class="line">it   <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">next *itemNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itemList <span class="keyword">struct</span> &#123;</span><br><span class="line">head *itemNode</span><br><span class="line">tail *itemNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>itemList</code> 单向链表存储帧信息</p><h5 id="帧进队列"><a class="markdownIt-Anchor" href="#帧进队列"></a> 帧进队列</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据加入到链表尾部</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(il *itemList)</span> <span class="title">enqueue</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">n := &amp;itemNode&#123;it: i&#125;</span><br><span class="line"><span class="keyword">if</span> il.tail == <span class="literal">nil</span> &#123;<span class="comment">//如果没有尾巴，说明链表为空，新节点为链表</span></span><br><span class="line">il.head, il.tail = n, n</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">il.tail.next = n<span class="comment">//将新节点加入到链表尾部</span></span><br><span class="line">il.tail = n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是将帧添加到链表中，这里并没有限制链表长度，超过负载则是单独处理的 <code>throttle()</code></p><h5 id="帧出队列"><a class="markdownIt-Anchor" href="#帧出队列"></a> 帧出队列</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//弹出链表头部数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(il *itemList)</span> <span class="title">dequeue</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">if</span> il.head == <span class="literal">nil</span> &#123;<span class="comment">//如果head为空，说明链表为空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">i := il.head.it</span><br><span class="line">    <span class="comment">//更新头部与尾部指针</span></span><br><span class="line">il.head = il.head.next</span><br><span class="line"><span class="keyword">if</span> il.head == <span class="literal">nil</span> &#123;<span class="comment">//注意尾部指针</span></span><br><span class="line">il.tail = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回链表头部数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(il *itemList)</span> <span class="title">peek</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> il.head.it</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回链表，缓存器清空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(il *itemList)</span> <span class="title">dequeueAll</span><span class="params">()</span> *<span class="title">itemNode</span></span> &#123;</span><br><span class="line">h := il.head</span><br><span class="line">il.head, il.tail = <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="帧缓存器限制"><a class="markdownIt-Anchor" href="#帧缓存器限制"></a> 帧缓存器限制</h5><p><code>itemList</code>仅仅单纯用于消息存储，并没有数量限制。但是如果不限制消息数量，可能导致OOM或者消息大面积丢失，其实它单独做了一个限制</p><p>当特殊帧达到上限 <code>maxQueuedTransportResponseFrames = 56</code> 之后，会存储一个流控隧道</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c.list.enqueue(it)</span><br><span class="line"><span class="keyword">if</span> it.isTransportResponseFrame() &#123;</span><br><span class="line">c.transportResponseFrames++</span><br><span class="line"><span class="keyword">if</span> c.transportResponseFrames == maxQueuedTransportResponseFrames &#123;</span><br><span class="line"><span class="comment">// We are adding the frame that puts us over the threshold; create</span></span><br><span class="line"><span class="comment">// a throttling channel.</span></span><br><span class="line">c.trfChan.Store(<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>记录条件的帧数量，而不是发送的所有帧都记录进去</strong>，符合条件的只有两种帧 <code>incomingSettings</code> 和 <code>ping</code> ，存储了一个隧道，直接通过隧道控制流量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controlBuffer)</span> <span class="title">throttle</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch, _ := c.trfChan.Load().(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> ch != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ch:<span class="comment">//要么隧道关闭</span></span><br><span class="line"><span class="keyword">case</span> &lt;-c.done:<span class="comment">//要么超时</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一共只有两个地方用到</span></span><br><span class="line"><span class="comment">//http_client.go 读取帧的之后 reader</span></span><br><span class="line"><span class="comment">//http_server.go 处理流中帧逻辑 HandleStreams</span></span><br></pre></td></tr></table></figure><p>注意这里用的是等于 <code>c.transportResponseFrames == maxQueuedTransportResponseFrames</code>，每个客户端<code>http_client</code>都有一个 帧缓存器</p><h4 id="帧存储与获取"><a class="markdownIt-Anchor" href="#帧存储与获取"></a> 帧存储与获取</h4><p><img src="https://img-blog.csdnimg.cn/20210615204217493.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE1ODI5MjI=,size_16,color_FFFFFF,t_70#pic_center" alt="grpc 帧存储器和帧加载器" /></p><p>生产生通过一个隧道通知消费者消息的处理，否则消费者阻塞等待</p><h5 id="帧获取"><a class="markdownIt-Anchor" href="#帧获取"></a> 帧获取</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controlBuffer)</span> <span class="title">get</span><span class="params">(block <span class="keyword">bool</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> !c.list.isEmpty() &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !block &#123;<span class="comment">//如果不阻塞，直接退出</span></span><br><span class="line">c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">c.consumerWaiting = <span class="literal">true</span><span class="comment">//否则等待消息</span></span><br><span class="line">c.mu.Unlock()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-c.ch:</span><br><span class="line"><span class="keyword">case</span> &lt;-c.done:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrConnClosing</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="帧存储"><a class="markdownIt-Anchor" href="#帧存储"></a> 帧存储</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controlBuffer)</span> <span class="title">executeAndPut</span><span class="params">(f <span class="keyword">func</span>(it <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>, <span class="title">it</span> <span class="title">cbItem</span>) <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wakeUp <span class="keyword">bool</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> c.consumerWaiting &#123;<span class="comment">//如果消费端还在等待</span></span><br><span class="line">wakeUp = <span class="literal">true</span></span><br><span class="line">c.consumerWaiting = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">c.list.enqueue(it)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> wakeUp &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c.ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:<span class="comment">//通知消费者有消息来了</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="帧分发器"><a class="markdownIt-Anchor" href="#帧分发器"></a> 帧分发器</h4><p>将帧从<strong>帧缓冲器</strong>获取出来进行分发，就需要用到<strong>帧分发器</strong>，执行逻辑帧逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *loopyWriter)</span> <span class="title">run</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="comment">//defer 打印链接 ErrConnClosing</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">it, err := l.cbuf.get(<span class="literal">true</span>)<span class="comment">//阻塞式获取</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = l.handle(it); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, err = l.processData(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">gosched := <span class="literal">true</span></span><br><span class="line">hasdata:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">it, err := l.cbuf.get(<span class="literal">false</span>)<span class="comment">//非阻塞式获取</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> it != <span class="literal">nil</span> &#123;<span class="comment">//拿到了消息</span></span><br><span class="line"><span class="keyword">if</span> err = l.handle(it); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, err = l.processData(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span> hasdata</span><br><span class="line">&#125;</span><br><span class="line">isEmpty, err := l.processData()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !isEmpty &#123;</span><br><span class="line"><span class="keyword">continue</span> hasdata</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> gosched &#123;</span><br><span class="line">gosched = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> l.framer.writer.offset &lt; minBatchSize &#123;<span class="comment">//如果</span></span><br><span class="line">runtime.Gosched()<span class="comment">//让出CPU时间片</span></span><br><span class="line"><span class="keyword">continue</span> hasdata</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">l.framer.writer.Flush()  <span class="comment">//向连接中写入数据</span></span><br><span class="line"><span class="keyword">break</span> hasdata</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li><p>一开始阻塞式获取， 后来非阻塞式获取</p><ul><li>一开始阻塞式获取，因为初始化的时候一般没有消息，那么这里就一直等到有消息了</li><li><code>processData</code> 的作用是将数据写入到连接中，并且如果还有数据则继续写入</li></ul></li><li><p>有一段让出CPU的操作，意思是：在数据量不足最小批处理大小时，让出CPU时间片，以等待更多数据到达，以尽可能地将数据一次性写入连接中，从而提高性能。</p><p>具体来说，当 l.framer.writer.offset（写入缓冲区中的数据量）小于 minBatchSize（最小批处理大小）时，表示当前缓冲区中的数据量不足以一次性写入连接中，这时候我们不应该立即将数据写入连接中，而是应该等待更多的数据到达，以尽可能地将数据一次性写入连接中，从而减少系统调用的次数，提高性能。因此，我们使用 runtime.Gosched() 方法让出CPU时间片，等待更多的数据到达，然后继续循环，直到数据量达到最小批处理大小时，再将数据一次性写入连接中，以提高性能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> gosched &#123;</span><br><span class="line">    gosched = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> l.framer.writer.offset &lt; minBatchSize &#123;<span class="comment">//如果</span></span><br><span class="line">        runtime.Gosched()<span class="comment">//让出CPU时间片</span></span><br><span class="line">        <span class="keyword">continue</span> hasdata</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>首先回答一开始的问题</p><p><strong>问题1</strong>：帧缓冲区可以无限存储帧吗，满了怎么办，什么时候删，大小可以设置吗</p><p>答：理论上可以无限存储(链表)，通过ping与窗口更新帧来控制来控制负载</p><p><strong>问题2</strong>：多个流公用一个帧缓冲区吗</p><p>答：因为帧属于不同的流，它们都公用同一个帧缓冲区中</p><p><strong>问题3</strong>：帧缓冲区是如何进行消息发送的</p><p>答：利用生产者消费者模式进行消息存储与发送</p><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://blog.csdn.net/u011582922/article/details/117979181" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/117979181</a></li><li><a href="https://juejin.cn/post/7092975446257565726" target="_blank" rel="noopener">https://juejin.cn/post/7092975446257565726</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在客户端跟服务器交互过程中，流具体是通过帧来进行数据的发送。这里学习如何发送帧的，整体如下&lt;/p&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/20210614141120519.jpg?x-oss-process=image/waterma
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
</feed>
