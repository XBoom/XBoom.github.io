<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XBoom Dove</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xboom.github.io/"/>
  <updated>2022-12-11T09:47:28.000Z</updated>
  <id>http://xboom.github.io/</id>
  
  <author>
    <name>XBoom Dove</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法之美-八数码问题</title>
    <link href="http://xboom.github.io/2022/12/11/Algorithms%20To%20Live%20By/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>http://xboom.github.io/2022/12/11/Algorithms%20To%20Live%20By/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/</id>
    <published>2022-12-11T09:47:28.000Z</published>
    <updated>2022-12-11T09:47:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>八数码问题也称为九宫问题。在3×3的棋盘，摆有八个棋子，每个棋子上标有1至8的某一数字，不同棋子上标的数字不相同。棋盘上还有一个空格，与空格相邻的棋子可以移到空格中。要求解决的问题是：给出一个初始状态和一个目标状态，找出一种从初始转变成目标状态的移动棋子步数最少的移动步骤</p><blockquote><p>所谓一个状态就是棋子在棋盘上的一种摆法。棋子移动后，状态就会发生改变。实际上就是找出从初始状态到达目标状态所经过的一系列中间过渡状态</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-11-03_23-53-25_bashuma_1.png" alt="Snipaste_2022-11-03_23-53-25_bashuma_1" style="zoom:67%;" /><p>首先这个九宫格的状态数量是 9!，那么存在问题</p><ol><li><p>是否存在从一个状态转移到另外一个状态无解的情况？</p></li><li><p>如何计算或者衡量从一个转移到另外一个状态的需要走多少步？</p></li></ol><h3 id="排列的性质"><a class="markdownIt-Anchor" href="#排列的性质"></a> 排列的性质</h3><p>为了搞清楚上述问题，需要知道几个基本定义与引理</p><ol><li><p>把n个不同的元素按一定的顺序排列成一行，成为这n个元素的一个<strong>排列</strong>。n个不同元素的排列共有 <strong>n!</strong> 种</p></li><li><p>对于n个自然数的一个排列，如果一个大数排在一个小数之前，就称这两个数构成一个<strong>逆序</strong>。一个排列的逆序总和称为该排列的<strong>逆序对</strong>，记为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi><mo stretchy="false">(</mo><mi>j</mi><mn>1</mn><mi>j</mi><mn>2</mn><mo>⋯</mo><mi>j</mi><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>τ</mi><mo>∗</mo><mo stretchy="false">(</mo><mo>∗</mo><mi>j</mi><mo>∗</mo><mn>1</mn><mo>∗</mo><mi>j</mi><mo>∗</mo><mn>2</mn><mo>⋯</mo><mo>∗</mo><mi>j</mi><mo>∗</mo><mo>∗</mo><mi>n</mi><mo>∗</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">τ(j1j2⋯jn)*τ*(*j*1*j*2⋯*j**n*)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">∗</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∗</span><span class="mord mathdefault">n</span><span class="mord">∗</span><span class="mclose">)</span></span></span></span></p><blockquote><p>如5阶排列31542的逆序是(3,1),(3,2),(5,4),(5,2),(4,2),故 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi><mo stretchy="false">(</mo><mn>31542</mn><mo stretchy="false">)</mo><mo>=</mo><mn>5</mn><mo>∗</mo><mi>τ</mi><mo>∗</mo><mo stretchy="false">(</mo><mn>31542</mn><mo stretchy="false">)</mo><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">τ(31542)=5*τ*(31542)=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mopen">(</span><span class="mord">3</span><span class="mord">1</span><span class="mord">5</span><span class="mord">4</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mord">1</span><span class="mord">5</span><span class="mord">4</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span></p></blockquote></li><li><p>逆序对为奇数的排列称为<strong>奇排列</strong>。逆序对为偶数的排列称为<strong>偶排列</strong>。<strong>自然排列</strong> 123⋯<em>n</em>的逆序对为0，故它是偶排列</p></li><li><p>在一个排列中，把某两个数的位置互换（其他数不动）变成另一个排列的变动称为一个<strong>对换</strong>，将相邻的两个数对换称为<strong>相邻对换</strong></p></li></ol><h3 id="性质的证明"><a class="markdownIt-Anchor" href="#性质的证明"></a> 性质的证明</h3><p><strong>性质1</strong>：<strong>一个排列中的任意两个数对换后，排列改变奇偶性。即经过一次对换，奇排列变成偶排列，偶排列变成奇排列</strong></p><p>证明：</p><ol><li><p>先证明相邻对换的情形</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-11-05_23-25-04-bashuma2.png" alt="Snipaste_2022-11-05_23-25-04-bashuma2" style="zoom:50%;" /><ul><li><p>设排列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>s</mi></msub><mi>a</mi><mi>b</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 ... a_s a b b_1 b_2 ... b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，对换a 与 b 的排列变为  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>s</mi></msub><mi>b</mi><mi>a</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 ... a_s b a b_1 b_2 ... b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p></li><li><p>a 与 b 的 对换不影响  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 ... a_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">b_1 b_2 ... b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 与 其他数的关系</p></li><li><p>但a与b的序关系变为：</p><ul><li><p>当 a &lt; b 时，在新排列中 a 、b 构成逆序</p></li><li><p>当 a &gt; b 时，在新排列中 a、b 不构成逆序</p></li></ul></li><li><p>因此 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>s</mi></msub><mi>a</mi><mi>b</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 ... a_s a b b_1 b_2 ... b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 比  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>s</mi></msub><mi>b</mi><mi>a</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 ... a_s b a b_1 b_2 ... b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的逆序多1或者少1</p></li></ul></li><li><p>再证一般对换情形</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-11-05_23-30-29-bashuma3.png" alt="Snipaste_2022-11-05_23-30-29-bashuma3" style="zoom:50%;" /><ul><li>设存在排列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>s</mi></msub><mi>a</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>…</mo><msub><mi>b</mi><mi>m</mi></msub><mi>b</mi><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>…</mo><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 … a_s a b_1 b_2 … b_m b c_1 c_2 … c_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>将 b 做 m 次相邻对换变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>s</mi></msub><mi>a</mi><mi>b</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>…</mo><msub><mi>b</mi><mi>m</mi></msub><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>…</mo><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 … a_s a b b_1 b_2 … b_m c_1 c_2 … c_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>再将 a 做 (m + 1) 次相邻对换变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>s</mi></msub><mi>b</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>…</mo><msub><mi>b</mi><mi>m</mi></msub><mi>a</mi><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>…</mo><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 … a_s b b_1 b_2 … b_m a c_1 c_2 … c_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>所以 经过 (2m + 1) 次相邻兑换，可以把排列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>s</mi></msub><mi>a</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>…</mo><msub><mi>b</mi><mi>m</mi></msub><mi>b</mi><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>…</mo><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 … a_s a b_1 b_2 … b_m b c_1 c_2 … c_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>转变成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>s</mi></msub><mi>b</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>…</mo><msub><mi>b</mi><mi>m</mi></msub><mi>a</mi><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>…</mo><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 … a_s b b_1 b_2 … b_m a c_1 c_2 … c_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，这两个排列的奇偶性相反</li></ul></li></ol><p><strong>性质2：在全部的 n(n≥2)阶排列中，奇偶排列各占一半，各有 n!/2 个</strong></p><p>证明：</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-11-06_09-56-51-bashuma4.png" alt="Snipaste_2022-11-06_09-56-51-bashuma4" style="zoom:50%;" /><ul><li><p>假设在全部n级排列中共有t个奇排列，s个偶排列</p></li><li><p>将t个奇排列中的前两个数字对换，得到t个互不相同的偶排列。因此 t≤s</p></li><li><p>同理可证 s≤t</p></li><li><p>于是 s=t，即奇、偶排列的总数相等，各有 n!/2个</p></li></ul><p><strong>性质3：任意一个n阶排列都可以经过一系列对换变成自然排列，并且所作对换的次数与这个排列有相同的奇偶性</strong></p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-11-06_13-10-01-bashuma5.png" alt="Snipaste_2022-11-06_13-10-01-bashuma5" style="zoom:50%;" /><p>证明(归纳法)：</p><ul><li>1阶排列只有一个，结论显然成立</li><li>假设对n-1阶排列已经成立，证对n阶排列的情形结论也成立<ul><li>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mn>1</mn></msub><msub><mi>j</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>j</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">j_1 j_2 ... j_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是一个n阶排列<ul><li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mi>n</mi></msub><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">j_n=n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> ，假设n-1级排列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mn>1</mn></msub><msub><mi>j</mi><mn>2</mn></msub><mo>…</mo><msub><mi>j</mi><mi>n</mi></msub><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">j_1 j_2 … j_n−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 可以经过一系列变换变成自然序列，即 1 2 … n−1，于是这一系列对换也就把 j1j2⋯jn 变成 12⋯n 这种自然序列的形式。</li><li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mi>n</mi><mi mathvariant="normal">≠</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">jn≠n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，那么对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mn>1</mn></msub><msub><mi>j</mi><mn>2</mn></msub><mo>…</mo><msub><mi>j</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">j_1 j_2 … j_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">j_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 n 的对换，它就变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mn>1</mn></msub><msub><mi>j</mi><mn>2</mn></msub><mo>…</mo><msub><mi>j</mi><mi>n</mi></msub><mi mathvariant="normal">−</mi><mn>1</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">j_1 j_2 … j_n−1 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">−</span><span class="mord">1</span><span class="mord mathdefault">n</span></span></span></span> ，这就归结成上面的情形，因此</li></ul></li></ul></li></ul><p><strong>性质4：奇偶性与可达性关系与证明</strong></p><blockquote><p>必要性证明：排列的奇偶性不同则对应在八数码问题中不可达</p></blockquote><p>在满足上述约定的八数码问题中，空格与相邻棋子的交换不会改变棋局中棋子数列的逆序对的奇偶性</p><ul><li><p>空格与左右棋子交换：是不改变棋子数列的逆序对的(因为数列并没有改变)</p></li><li><p>空格与上下棋子交换：也是不改变棋子数列的逆序对的</p><ul><li>假设交换棋子为c[i]=X</li><li>原数列p=c[1]… X c[i+1]c[i+2]…c[8]将变为新数列q=c[1]…c[i+1]c[i+2]X …c[8]（注意：在棋盘中，上下相邻的两棋格之间隔有两个棋格）。可以解释为用X与c[i+1]、 c[i+2]先后进行两次相邻交换而完成状态转变。</li><li>由p状态到q状态并不会改变改变棋子数列的逆序对的奇偶性。同理可证空格与下方棋子交换也不会改变棋子数列的逆序对的奇偶性。所以，空格与相邻棋子的交换不会改变棋局中棋子数列的逆序对的奇偶性</li></ul></li></ul><p>得出 <strong>定理1：对于任意两个状态映射的序列，如果这两个状态等价，那么它们的逆序数相同</strong></p><blockquote><p>充分性证明：<strong>排列的奇偶性相同则对应在八数码问题中也可达</strong></p></blockquote><p>首先明确几个定义：</p><ul><li><p><strong>状态</strong>(<strong>state</strong>)：八数码中8个数字与0的排列被定义为八数码的<strong>状态</strong>，比如：</p></li><li><p><strong>状态空间</strong>(<strong>state space</strong>)：八数码所有状态的合集被称为<strong>状态空间</strong></p></li><li><p><strong>完全态</strong>(<strong>completeness</strong>)：当状态空间的子集中任何两个状态都能通过一定步骤得到，那么称这个状态空间的子集是<strong>完全态</strong></p></li><li><p><strong>状态映射</strong>(<strong>a sequence mapped by a state</strong>)：一个状态{}可以映射(忽略0)成一个排序，那么这个排列就称为这个<strong>状态的映射</strong></p></li><li><p><strong>标准格式(a standard form)</strong>：如果 0 在正中间，那么称这个状态为<strong>标准格式</strong></p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20221211150738067.png" alt="image-20221211150738067" style="zoom:50%;" /></li><li><p><strong>区域(field)</strong>：对于任意状态(state)，4个位置中任意两个都相邻，那么称之为 <strong>区域</strong>，特别的，当两个区域有相同的两个位置，则称为 <strong>同边区域</strong></p></li><li><p><strong>转圈(circle moving)</strong>：0在一个区域内移动称 <strong>转圈</strong></p></li></ul><p><strong>引理1：对于标准格式中的任意区域，转圈可以得到两个等价的区域</strong></p><p>考虑到 <strong>标准格式</strong> 的对称性，只需要考虑一个区域的的变化</p><p>第一种情况(顺时针方向部分先后): a b d</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121101.png" alt="bashuma-121101" style="zoom:50%;" /><p>第二种情况(顺时针方向不分先后): a d b</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121102.png" alt="bashuma-121102" /></p><p>接着考虑在一个标准格式中，在两个具有相同边的区域交换数据，由于标准格式的对称性，所以只考虑上半部分</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121103.png" alt="bashuma-121103" style="zoom:50%;" /><blockquote><p>这个图形转换根据上述原则手动绘制交换流程更容易理解</p></blockquote><p>得出的<strong>规律1</strong>: m 属于 {a ,d}，n 属于 {c, e}，p 属于 {a, d} 但 p != m，q 属于 {c, e}但 q != n，那么交换 m n，则 n 来到 m 之前的位置，而 m 来到 q 之前的位置，q 来到 n 之前的位置</p><p>得出的<strong>规律2</strong>：abc 可以经过转换编程 cab 或者 bac，不影响其他行且逆序对不变</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121104.png" alt="bashuma-121104" style="zoom:80%;" /><p>对于标准格式，如果它们的逆序对的奇偶性相同，那么它们是等价的</p><p>证明：</p><p>首先，将九宫格分为A、B、C、D分为四个区域</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121106.png" alt="bashuma-121106" style="zoom:50%;" /><p>第一步，将 h 移动到位置 位置 9，这是肯定可以的</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121107.png" alt="bashuma-121107" style="zoom:50%;" /><p>第二步，将 g、e 移动到区域D</p><blockquote><p>为什么不考虑g、e的顺序，因为可以在不影响h的情况下 g 在 位置 6 与 位置8 任意切换</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121112.png" alt="bashuma-121112" style="zoom:50%;" /><ul><li><p>2.1 如果 g、e 已经在区域D，那么不需要移动</p></li><li><p>2.2 如果其中 g 在 区域D，而e 在其他区域</p><ul><li><p>2.2.1 e 在区域A</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121109.png" alt="bashuma-121109" style="zoom:50%;" /></li><li><p>2.2.2 e 在区域B</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-12-11_16-55-10.png" alt="Snipaste_2022-12-11_16-55-10" style="zoom:50%;" /></li><li><p>2.2.3 e 在区域C</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121111.png" alt="bashuma-121111" style="zoom:50%;" /></li></ul><p>第三步，将 b、c 移动到 B区域</p><ul><li><p>3.1 如果 b、c 都在区域 B，那么不需要移动</p></li><li><p>3.2 如果 b、c 有一个在区域B，那么</p><blockquote><p>b 、c 的位置也同样可以忽略，如果b、c是正常顺序，那么也可以在不影响 g e h 位置的情况下调整 b c 的顺序</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-1211-13.png" alt="bashuma-1211-13" style="zoom:50%;" /><ul><li><p>3.1.1 如果在位置3</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma121110.png" alt="bashuma121110" style="zoom:50%;" /></li><li><p>3.1.2 如果在位置2，那么先将c移动位置3再执行上述步骤</p></li></ul></li><li><p>如果 b、c 都不在区域B，同理将c 移动到位置3，然后在执行上述3.1.1 步骤</p></li></ul></li></ul><p>第四步，在不影响bcehg的情况下调整adf的顺序</p><ul><li>规律二在 此场景下仍然适用，所以首先将防止到位置7</li><li>根据定理1，如果两者等价，那么它们的逆序对是相同的。而如果位置1与位置3交换其他位置不变，那边整个序列的逆序对是变化的。所以a一定在位置1，d在位置4</li></ul><p>所以，如果奇偶性相同，那么两个状态都能转换成一个相同的标准状态，那么两个状态之间是可达的</p><p>得出结论：<strong>两个排列的逆序对奇偶性相同，那么在八数码中必可达</strong></p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://blog.csdn.net/u011008379/article/details/40144147" target="_blank" rel="noopener">https://blog.csdn.net/u011008379/article/details/40144147</a></li><li><a href="https://chengfeng96.com/blog/2018/05/26/%E5%88%A9%E7%94%A8BFS%EF%BC%8CDFS%EF%BC%8CA-%E8%A7%A3%E5%86%B3%E5%85%AB%E6%95%B0%E7%A0%81%E9%9A%BE%E9%A2%98/" target="_blank" rel="noopener">https://chengfeng96.com/blog/2018/05/26/利用BFS，DFS，A-解决八数码难题/</a></li><li><a href="http://www.huaying1988.com/blogs/8_Puzzle_StrictProof_SolutionAlgorithm_AndOthers/detail.html" target="_blank" rel="noopener">http://www.huaying1988.com/blogs/8_Puzzle_StrictProof_SolutionAlgorithm_AndOthers/detail.html</a></li><li>《A constructive proof for the subsets completeness of 8-Puzzle state space》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;八数码问题也称为九宫问题。在3×3的棋盘，摆有八个棋子，每个棋子上标有1至8的某一数字，不同棋子上标的数字不相同。棋盘上还有一个空格，与空格相邻的棋子可以移到空格中。要求解决的问题是：给出一个初始状态和一个目标状态，找出一种从初始转变成目标状态的移动棋子步数最少的移动步骤&lt;
      
    
    </summary>
    
    
      <category term="Algorithms To Live By" scheme="http://xboom.github.io/categories/Algorithms-To-Live-By/"/>
    
    
      <category term="Algorithms To Live By" scheme="http://xboom.github.io/tags/Algorithms-To-Live-By/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-03-解析器原理</title>
    <link href="http://xboom.github.io/2022/10/19/Grpc/Grpc-03-%E8%A7%A3%E6%9E%90%E5%99%A8%E5%8E%9F%E7%90%86/"/>
    <id>http://xboom.github.io/2022/10/19/Grpc/Grpc-03-%E8%A7%A3%E6%9E%90%E5%99%A8%E5%8E%9F%E7%90%86/</id>
    <published>2022-10-18T16:18:01.000Z</published>
    <updated>2023-02-03T13:42:16.534Z</updated>
    
    <content type="html"><![CDATA[<p>解析器的的作用</p><ol><li>通过对字符串的解析得到后端提供服务的地址列表</li><li>解析地址之后触发平衡器流程，平衡器开始根据解析的地址们与服务端建立链接</li></ol><p>下面会反复讲到几个词语，这里提前定义</p><ol><li><strong>链接</strong> 或 <strong>ConnectClient</strong>：这里代表的是 target 对应连接，可能实际存在多个子连接 addrConn</li><li><strong>子链接</strong> 或 <strong>addrConn</strong>：这里代表具体的客户端与服务器建立的一个TCP链接</li></ol><h3 id="整理流程"><a class="markdownIt-Anchor" href="#整理流程"></a> 整理流程</h3><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/grpc-resolver-1111.png" alt="grpc-resolver-1111" style="zoom:67%;" /><ol><li>通过 <code>Target</code> 解析获取 的<code>scheme</code>指定解析器构建器名称</li><li>解析器构建器在<code>Build</code>过程中构建解析器，获取地址信息，触发平衡器</li><li>生成解析器之后再通过 协程<code>for</code>循环建立子链接</li></ol><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>代码路径:<code>/resolver/resolver.go</code>，在这个文件中一共定义了2个接口</p><ul><li>Builder 接口，主要用来构建解析器</li><li>Resolver 接口，主要用来让解析器进行解析</li></ul><h4 id="解析器构建器注册"><a class="markdownIt-Anchor" href="#解析器构建器注册"></a> 解析器构建器注册</h4><p>解析器构建器通过注册的方式将解析器的构建方法存入全局变量中，当需要使用的时候则直接根据名称获取</p><ol><li><p>使用一个全局的 map  <code>var m = make(map[string]Builder)</code>进行解析器构建器 Builder 的存储。k/v 分别对应的是构建 构建器的名称以及构建器的实现方法。</p></li><li><p>解析器构建器可以通过 <code>Register</code> 函数存储到这个 map 中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册解析器构建器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Register</span><span class="params">(b Builder)</span></span> &#123;</span><br><span class="line">m[b.Scheme()] = b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回解析器构建器 scheme</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(scheme <span class="keyword">string</span>)</span> <span class="title">Builder</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> b, ok := m[scheme]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在获取构建中不是通过名称，而是通过<code>scheme</code>做为解析器构建器的名称</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultScheme = <span class="string">"passthrough"</span> <span class="comment">//默认是passthrough解析器</span></span><br></pre></td></tr></table></figure><p>前面说过解析器是通过 字符串解析获取对应的服务地址</p><ul><li>这个字符串的格式 <code>Scheme://Authority/Endpoint</code>，其中 <code>Scheme</code>，<code>Authorith</code>，<code>Endpoint</code> 是需要用户自己设置的。<code>Scheme</code>，<code>Authorith</code>不是必须设置的，默认使用 <code>passthrouth</code> 解析器</li><li>字符串格式例子<ul><li><code>etcd://auth/config.bar</code>，其中 <code>Scheme = etcd</code>，<code>Authorith = auth</code>，<code>Endpoint = config.bar</code></li><li><code>dns:///config.bar</code>，其中 <code>Scheme = dns</code>，<code>Authorith = &quot;&quot;</code>，<code>Endpoint = config.bar</code></li><li><code>localhost:8080</code>，其中 <code>Scheme = &quot;&quot;</code>，<code>Authorith = &quot;&quot;</code>，<code>Endpoint = localhost:8080</code></li></ul></li><li>服务地址有可能是具体的服务地址，也可能是负载均衡的地址</li></ul></li><li><p>而一个普通的解析器构建器(已DNS解析器构建器为例<code>rrPickerBuilder</code>)，则是利用 init 函数直接初始化到这个全局map中，那么就可以在需要使用的时候，直接从全局map 中获取</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">resolver.Register(NewBuilder())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBuilder</span><span class="params">()</span> <span class="title">resolver</span>.<span class="title">Builder</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;dnsBuilder&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="构建解析器"><a class="markdownIt-Anchor" href="#构建解析器"></a> 构建解析器</h4><p>有了解析器构建器之后就可以构建解析器，默认解析器是 <code>passthrough</code></p><ol><li><p>设置通过哪个平衡器构建器获取平衡器，由于<code>grpc.Dial(target)</code>中 <code>target</code> 就是由 <code>Scheme://Authority/Endpoint</code>，这样来指定的解析器</p></li><li><p>指定了构建器之后就会在构建链接过程中调用构建函数 <code>resolver.Builder</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据 target 获取解析器构建器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *ClientConn)</span> <span class="title">parseTargetAndFindResolver</span><span class="params">()</span> <span class="params">(resolver.Builder, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> rb resolver.Builder</span><br><span class="line">    <span class="comment">//將target 转换成 resolver.Target 结构</span></span><br><span class="line">parsedTarget, err := parseTarget(cc.target)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//target格式不是这样 [scheme]://[authority]/endpoint</span></span><br><span class="line">        <span class="comment">//log</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rb = cc.getResolver(parsedTarget.Scheme)</span><br><span class="line"><span class="keyword">if</span> rb != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//根据Scheme找到了对应的解析器构建者</span></span><br><span class="line">cc.parsedTarget = parsedTarget</span><br><span class="line"><span class="keyword">return</span> rb, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果target名称不规范，或者根据scheme找不到解析的构建者，那么就会尝试使用默认的解析器进行解析 passthrouth</span></span><br><span class="line">defScheme := resolver.GetDefaultScheme()</span><br><span class="line">canonicalTarget := defScheme + <span class="string">":///"</span> + cc.target</span><br><span class="line"></span><br><span class="line">parsedTarget, err = parseTarget(canonicalTarget)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="comment">//使用默认的解析器格式还是错误的，那么就直接退出</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rb = cc.getResolver(parsedTarget.Scheme) <span class="comment">//否则使用默认解析器的构建者</span></span><br><span class="line"><span class="keyword">if</span> rb == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"could not get resolver for default scheme: %q"</span>, parsedTarget.Scheme)</span><br><span class="line">&#125;</span><br><span class="line">cc.parsedTarget = parsedTarget</span><br><span class="line"><span class="keyword">return</span> rb, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>newCCResolverWrapper</code> 解析器构建器的来返回一个构建器，<code>ccResolverWrapper</code> 是内部封装解析器功能对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCCResolverWrapper</span><span class="params">(cc *ClientConn, rb resolver.Builder)</span> <span class="params">(*ccResolverWrapper, error)</span></span> &#123;</span><br><span class="line">ccr := &amp;ccResolverWrapper&#123;</span><br><span class="line">cc:   cc,</span><br><span class="line">done: grpcsync.NewEvent(),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//... 可选参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="comment">// 这里加锁的原因是：</span></span><br><span class="line"><span class="comment">// rb.Build--&gt;ccr.ReportError--&gt;ccr.poll--&gt;ccr.resolveNow, would end up</span></span><br><span class="line">ccr.resolverMu.Lock()</span><br><span class="line"><span class="keyword">defer</span> ccr.resolverMu.Unlock()</span><br><span class="line">ccr.resolver, err = rb.Build(cc.parsedTarget, ccr, rbo)<span class="comment">//在这里出发解析器构建器的Build 进行构建解析器</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ccr, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>​传入的是连接指针与解析器构建器，返回的是包含了解析器的 <code>ccResolverWrapper</code> 对象</p><ol start="4"><li><p>这个 <code>ccResolverWrapper</code> 结构其实就是包含了这个连接的解析信息，下面看下包含的内容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ccResolverWrapper <span class="keyword">struct</span> &#123;</span><br><span class="line">cc         *ClientConn<span class="comment">//target 对应的连接</span></span><br><span class="line">resolverMu sync.Mutex           <span class="comment">//解析原子锁</span></span><br><span class="line">resolver   resolver.Resolver    <span class="comment">//解析器</span></span><br><span class="line">done       *grpcsync.Event      <span class="comment">//同步事件</span></span><br><span class="line">curState   resolver.State       <span class="comment">//解析状态</span></span><br><span class="line"></span><br><span class="line">incomingMu sync.Mutex <span class="comment">// 原子锁所有的调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> State <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// target 对应的地址信息，后续平衡器根据这些Address 建立连接</span></span><br><span class="line">Addresses []Address</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置信息</span></span><br><span class="line">ServiceConfig *serviceconfig.ParseResult</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析器属性</span></span><br><span class="line">Attributes *attributes.Attributes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在第三步中，通过构建器解析器的构建，接下来就是进行链接操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A blocking dial blocks until the clientConn is ready.</span></span><br><span class="line"><span class="keyword">if</span> cc.dopts.block &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">cc.Connect()</span><br><span class="line">s := cc.GetState()</span><br><span class="line"><span class="keyword">if</span> s == connectivity.Ready &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> cc.dopts.copts.FailOnNonTempDialError &amp;&amp; s == connectivity.TransientFailure &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> !cc.WaitForStateChange(ctx, s) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这里会 <code>for</code> 循环执行三个操作</p><ul><li><p>第一个是 <code>Connect</code>，这里通过第三步的 解析器 <code>Build</code> 已经获取了target 对应的地址信息，这里根据地址进行连接</p></li><li><p>第二个是 <code>GetState</code>，用于获取链接状态，如果链接是就绪状态 <code>connectivity.Ready</code> 表示整个链接就绪</p></li><li><p>第三个是 <code>WaitForStateChange</code>在后续还有一个状态改变的过程</p></li><li><p>第四个是 <code>cc.dopts.block</code>，表示阻塞情况下才会直接进行地址链接。</p></li></ul><h4 id="应用解析器"><a class="markdownIt-Anchor" href="#应用解析器"></a> 应用解析器</h4><ol><li><p>生成了解析器之后就需要放入合适的时间进行解析，解析器的接口包括</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Resolver <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">//立即we</span></span><br><span class="line">ResolveNow(ResolveNowOptions)</span><br><span class="line">    <span class="comment">//关闭解析器</span></span><br><span class="line">Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这里的 ResolveNow 可以不用实现，因为 ResolveNow 其实是在建立连接失败之后立即尝试重新建立链接</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Connect -&gt; connect -&gt; resetTransport</span></span><br><span class="line"><span class="keyword">if</span> err := ac.tryAllAddrs(addrs, connectDeadline); err != <span class="literal">nil</span> &#123;</span><br><span class="line">ac.cc.resolveNow(resolver.ResolveNowOptions&#123;&#125;) <span class="comment">//如果失败了，就执行resolveNow(可以由用户自定义，在连接失败之后可以立即重新更新地址已重新建立连接)</span></span><br><span class="line">  <span class="comment">//... 退避算法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不实现resolveNow ，那么就需要通过退避算法等待一段时间再次进行链接</p></li></ol><h3 id="实际应用"><a class="markdownIt-Anchor" href="#实际应用"></a> 实际应用</h3><p>这里已内部解析器的实现 <code>passthrough</code> 为例，代码路径：<code>internal/resolver/passthrough/passthrough.go</code></p><ol><li><p>第一步，为了实现解析器就需要解析器构建器与解析器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> passthroughBuilder <span class="keyword">struct</span>&#123;&#125;  <span class="comment">//解析器构建器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> passthroughResolver <span class="keyword">struct</span> &#123;<span class="comment">//解析器</span></span><br><span class="line">target resolver.Target</span><br><span class="line">cc     resolver.ClientConn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析器结构字段可自定义</p></li><li><p>解析器构建器需要实现 <code>Builder</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Builder <span class="keyword">interface</span> &#123;</span><br><span class="line">Build(target Target, cc ClientConn, opts BuildOptions) (Resolver, error)</span><br><span class="line">Scheme() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建解析器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*passthroughBuilder)</span> <span class="title">Build</span><span class="params">(target resolver.Target, cc resolver.ClientConn, opts resolver.BuildOptions)</span> <span class="params">(resolver.Resolver, error)</span></span> &#123;</span><br><span class="line">r := &amp;passthroughResolver&#123; <span class="comment">//构建解析器</span></span><br><span class="line">target: target,</span><br><span class="line">cc:     cc,</span><br><span class="line">&#125;</span><br><span class="line">r.start()</span><br><span class="line"><span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//触发平衡器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *passthroughResolver)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">r.cc.UpdateState(resolver.State&#123;Addresses: []resolver.Address&#123;&#123;Addr: r.target.Endpoint&#125;&#125;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> scheme = <span class="string">"passthrough"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回构建器名称</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*passthroughBuilder)</span> <span class="title">Scheme</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> scheme</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解析器的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*passthroughResolver)</span> <span class="title">ResolveNow</span><span class="params">(o resolver.ResolveNowOptions)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*passthroughResolver)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>这里就没有进行任务的实现</p></li><li><p>最后将解析器注册到全局内存中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">resolver.Register(&amp;passthroughBuilder&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>解析器其实包含了解析器构建器与解析器</li><li>可以同时定义多个解析器，然后通过<code>target</code>指定解析器</li><li>解析器中获取地址的方式自定义还能加入注册中心来获取地址信息</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/377860784" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/377860784</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;解析器的的作用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过对字符串的解析得到后端提供服务的地址列表&lt;/li&gt;
&lt;li&gt;解析地址之后触发平衡器流程，平衡器开始根据解析的地址们与服务端建立链接&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面会反复讲到几个词语，这里提前定义&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;s
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Go入门20-Goland激活</title>
    <link href="http://xboom.github.io/2022/10/17/Go/Go%E5%85%A5%E9%97%A820-Goland%E6%BF%80%E6%B4%BB/"/>
    <id>http://xboom.github.io/2022/10/17/Go/Go%E5%85%A5%E9%97%A820-Goland%E6%BF%80%E6%B4%BB/</id>
    <published>2022-10-17T15:51:31.000Z</published>
    <updated>2022-10-17T15:51:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>Goland好用但是激活太贵，网上找了一个使用激活服务器的办法， Goland 2022.2.2 激活成功</p><blockquote><p>最好支持正版！！！</p></blockquote><p>第一步：首先打开网址 <a href="https://search.censys.io" target="_blank" rel="noopener">https://search.censys.io</a></p><p>第二步：搜索信息 <code>services.http.response.headers.location: account.jetbrains.com/fls-auth</code></p><p>第三步：点击搜索到的网址信息</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/goland-acitve-1.png" alt="goland-acitve-1" /></p><p>第四步：找到状态为302的信息网址信息，如果没有找到请重复第三步</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/goland-acitve-302.png" alt="goland-acitve-302" /></p><p>第五步：复制上一步信息中的Details信息，这里是 <code>https://188.210.42.106</code></p><p>第六步：将地址信息填入 goland 中的 Licence Service 并点击 Acitve 激活</p><p>第七步：如果激活成功将出现下图所示，否则重复第三步</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/goland-acitve-success.png" alt="goland-acitve-success" /></p><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://dushusir.com/jetbrains/" target="_blank" rel="noopener">https://dushusir.com/jetbrains/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Goland好用但是激活太贵，网上找了一个使用激活服务器的办法， Goland 2022.2.2 激活成功&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最好支持正版！！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一步：首先打开网址 &lt;a href=&quot;https://sear
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go入门18-Fuzzing</title>
    <link href="http://xboom.github.io/2022/10/14/Go/Go%E5%85%A5%E9%97%A818-Fuzzing/"/>
    <id>http://xboom.github.io/2022/10/14/Go/Go%E5%85%A5%E9%97%A818-Fuzzing/</id>
    <published>2022-10-14T15:31:50.000Z</published>
    <updated>2022-10-14T15:31:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>Golang在1.18引入的第三个特性就是 Fuzzing 模糊测试：构造随机数据来找出代码里的漏洞或者可能导致程序崩溃的输入。</p><p>单元测试有局限性，每个测试输入必须由开发者指定加到单元测试的测试用例里。fuzzing的优点之一是可以基于开发者代码里指定的测试输入作为基础数据，进一步自动生成新的随机测试数据，用来发现指定测试输入没有覆盖到的边界情况。</p><p>通过fuzzing可以找出的漏洞包括SQL注入、缓冲区溢出、拒绝服务(Denial of Service)攻击和XSS(cross-site scripting)攻击等</p><p>这里通过编写反转字符串函数通过 <code>fuzz test</code> 来发现并修改问题</p><h3 id="第一步实现基本功能"><a class="markdownIt-Anchor" href="#第一步实现基本功能"></a> 第一步：实现基本功能</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">b := []<span class="keyword">byte</span>(s)</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(b)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(b)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">b[i], b[j] = b[j], b[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">input := <span class="string">"The quick brown fox jumped over the lazy dog"</span></span><br><span class="line">rev := Reverse(input)</span><br><span class="line">doubleRev := Reverse(rev)</span><br><span class="line">fmt.Printf(<span class="string">"original: %q\n"</span>, input)</span><br><span class="line">fmt.Printf(<span class="string">"reversed: %q\n"</span>, rev)</span><br><span class="line">fmt.Printf(<span class="string">"reversed again: %q\n"</span>, doubleRev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果是</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">original: <span class="string">"The quick brown fox jumped over the lazy dog"</span></span><br><span class="line">reversed: <span class="string">"god yzal eht revo depmuj xof nworb kciuq ehT"</span></span><br><span class="line">reversed again: <span class="string">"The quick brown fox jumped over the lazy dog"</span></span><br></pre></td></tr></table></figure><h3 id="第二步编写单元测试"><a class="markdownIt-Anchor" href="#第二步编写单元测试"></a> 第二步：编写单元测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func TestReverse(t *testing.T) &#123;</span><br><span class="line">testcases :&#x3D; []struct &#123;</span><br><span class="line">in, want string</span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;&quot;Hello, world&quot;, &quot;dlrow ,olleH&quot;&#125;,</span><br><span class="line">&#123;&quot; &quot;, &quot; &quot;&#125;,</span><br><span class="line">&#123;&quot;!12345&quot;, &quot;54321!&quot;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">for _, tc :&#x3D; range testcases &#123;</span><br><span class="line">rev :&#x3D; Reverse(tc.in)</span><br><span class="line">if rev !&#x3D; tc.want &#123;</span><br><span class="line">t.Errorf(&quot;Reverse: %q, want %q&quot;, rev, tc.want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行单元测试发现，一切正常</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ok      example/fuzz    0.003s</span><br></pre></td></tr></table></figure><h3 id="第三步添加模糊测试"><a class="markdownIt-Anchor" href="#第三步添加模糊测试"></a> 第三步：添加模糊测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuzzReverse</span><span class="params">(f *testing.F)</span></span> &#123;</span><br><span class="line">testcases := []<span class="keyword">string</span>&#123;<span class="string">"Hello, world"</span>, <span class="string">" "</span>, <span class="string">"!12345"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, tc := <span class="keyword">range</span> testcases &#123;</span><br><span class="line">f.Add(tc) <span class="comment">// Use f.Add to provide a seed corpus</span></span><br><span class="line">&#125;</span><br><span class="line">f.Fuzz(<span class="function"><span class="keyword">func</span><span class="params">(t *testing.T, orig <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">rev := Reverse(orig)</span><br><span class="line">doubleRev := Reverse(rev)</span><br><span class="line">    <span class="comment">//这一行是为了解释后面的错误加的，暂时可以忽略</span></span><br><span class="line">    t.Logf(<span class="string">"Number of runes: orig=%d, rev=%d, doubleRev=%d"</span>, utf8.RuneCountInString(orig), utf8.RuneCountInString(rev), utf8.RuneCountInString(doubleRev))</span><br><span class="line"><span class="keyword">if</span> orig != doubleRev &#123;</span><br><span class="line">t.Errorf(<span class="string">"Before: %q, after: %q"</span>, orig, doubleRev)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> utf8.ValidString(orig) &amp;&amp; !utf8.ValidString(rev) &#123;</span><br><span class="line">t.Errorf(<span class="string">"Reverse produced invalid UTF-8 string %q"</span>, rev)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：</p><ol><li><code>Reverse</code>函数如果是一个错误的版本(直接return返回输入的字符串)，虽然可以通过上面的模糊测试，但没法通过第二步的单元测试，所以模糊测试与单元测试是互补的关系</li><li><code>go test</code> <strong>只会使用种子语料库，而不会生成随机测试数据</strong>。通过这种方式可以用来验证种子语料库的测试数据是否可以测试通过</li><li>如果<code>reverse_test.go</code>文件里有其它单元测试函数或者模糊测试函数，但只想运行<code>FuzzReverse</code>模糊测试函数，我们可以执行<code>go test -run=FuzzReverse</code>命令</li><li>如果要基于种子语料库生成随机测试数据用于模糊测试，需要给<code>go test</code>命令增加<code>-fuzz</code>参数</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@13ce5bc74ac3:/code/fuzz# go test -fuzz .</span><br><span class="line">fuzz: elapsed: 0s, gathering baseline coverage: 0/7 completed</span><br><span class="line">fuzz: elapsed: 0s, gathering baseline coverage: 7/7 completed, now fuzzing with 2 workers</span><br><span class="line">fuzz: elapsed: 0s, execs: 648 (17784/sec), new interesting: 1 (total: 8)</span><br><span class="line">--- FAIL: FuzzReverse (0.04s)</span><br><span class="line">    --- FAIL: FuzzReverse (0.00s)</span><br><span class="line">    hello_test.go:32: Number of runes: orig=1, rev=2, doubleRev=1</span><br><span class="line">        hello_test.go:36: Reverse produced invalid UTF-8 string "\x9e\xdb"</span><br><span class="line">    </span><br><span class="line">    Failing input written to testdata/fuzz/FuzzReverse/d6a654c77ca8db001e0bbe2cbb5493efcd20e17777911523bf59bd30bd33e199</span><br><span class="line">    To re-run:</span><br><span class="line">    go test -run=FuzzReverse/d6a654c77ca8db001e0bbe2cbb5493efcd20e17777911523bf59bd30bd33e199</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    example/fuzz    0.048s</span><br></pre></td></tr></table></figure><ol start="5"><li><p>运行之后会生成testdata的文件夹，那么下次即使没有带上 <code>-fuzz</code> 参数，也会使用该数据进行模糊测试</p><p>路径：<code>./testdata/fuzz/FuzzReverse/d6a654c77ca8db001e0bbe2cbb5493efcd20e17777911523bf59bd30bd33e199</code>，内容是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> test fuzz v1  <span class="comment">//语料库文件里的第1行标识的是编码版本</span></span><br><span class="line"><span class="keyword">string</span>(<span class="string">"۞"</span>)</span><br></pre></td></tr></table></figure><p>从第2行开始，每一行数据对应的是语料库的每条测试数据(corpus entry)的其中一个参数，按照参数先后顺序排列，因为fuzz target函数<code>func(t *testing.T, orig string)</code>只有<code>orig</code>这1个参数作为真正的测试输入，也就是每条测试数据其实就1个输入，因此在上面示例的<code>testdata/fuzz/FuzzReverse</code>目录下的文件里只有string(“۞”)这一行</p></li></ol><h3 id="第四步修复bug"><a class="markdownIt-Anchor" href="#第四步修复bug"></a> 第四步：修复Bug</h3><p>模糊测试中得出的错误为 <code>Reverse produced invalid UTF-8 string &quot;\x9e\xdb&quot;</code></p><p><code>Reverse</code>函数是按照字节(byte)为维度进行字符串反转，这就是问题所在。比如字符<code>string(&quot;۞&quot;)</code> 如果按照字节反转，反转后得到的就是一个无效的字符串了。因此为了保证字符串反转后得到的仍然是一个有效的UTF-8编码的字符串，需要按照<code>rune</code>进行字符串反转。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    r := []<span class="keyword">rune</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(r)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(r)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        r[i], r[j] = r[j], r[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 <code>go test</code> 命令单元测试通过，表示老的数据能够正常的处理，但是如果再次执行 <code>go test -fuzz</code> 会出现新的错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@<span class="number">13</span>ce5bc74ac3:/code/fuzz# <span class="keyword">go</span> test -fuzz .</span><br><span class="line">fuzz: elapsed: <span class="number">0</span>s, gathering baseline coverage: <span class="number">0</span>/<span class="number">9</span> completed</span><br><span class="line">fuzz: minimizing <span class="number">38</span>-<span class="keyword">byte</span> failing input file</span><br><span class="line">fuzz: elapsed: <span class="number">0</span>s, gathering baseline coverage: <span class="number">4</span>/<span class="number">9</span> completed</span><br><span class="line">--- FAIL: FuzzReverse (<span class="number">0.01</span>s)</span><br><span class="line">    --- FAIL: FuzzReverse (<span class="number">0.00</span>s)</span><br><span class="line">        hello_test.<span class="keyword">go</span>:<span class="number">34</span>: Before: <span class="string">"\xe5"</span>, after: <span class="string">"�"</span></span><br><span class="line">    </span><br><span class="line">    Failing input written to testdata/fuzz/FuzzReverse/<span class="number">91862839</span>dc552bd95b4e42be6576a6c198f0d4c8fc2884c953030d898573b014</span><br><span class="line">    To re-run:</span><br><span class="line">    <span class="keyword">go</span> test -run=FuzzReverse/<span class="number">91862839</span>dc552bd95b4e42be6576a6c198f0d4c8fc2884c953030d898573b014</span><br><span class="line">FAIL</span><br><span class="line">exit status <span class="number">1</span></span><br><span class="line">FAIL    example/fuzz    <span class="number">0.011</span>s</span><br></pre></td></tr></table></figure><p>结构就是对一个字符串做了2次反转后得到的和原字符串不一样，这次测试输入本身是非法的unicode</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !utf8.ValidString(s) &#123;<span class="comment">//判断是否是合法的 utf-8编码</span></span><br><span class="line">        <span class="keyword">return</span> s, errors.New(<span class="string">"input is not valid UTF-8"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    r := []<span class="keyword">rune</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(r)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(r)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        r[i], r[j] = r[j], r[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(r), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改对应的引用和单元测试后，通过测试</p><h3 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h3><p>Go模糊测试和单元测试在语法上有如下差异：</p><ol><li>Go模糊测试函数以<code>FuzzXxx</code>开头，单元测试函数以<code>TestXxx</code>开头</li><li>Go模糊测试函数以 <code>*testing.F</code>作为入参，单元测试函数以<code>*testing.T</code>作为入参</li><li>Go模糊测试会调用<code>f.Add</code>函数和<code>f.Fuzz</code>函数。<ul><li><code>f.Add</code>函数把指定输入作为模糊测试的种子语料库(seed corpus)，fuzzing基于种子语料库生成随机输入。</li><li><code>f.Fuzz</code>函数接收一个fuzz target函数作为入参。fuzz target函数有多个参数，第一个参数是<code>*testing.T</code>，其它参数是被模糊的类型(<strong>注意</strong>：被模糊的类型目前只支持部分内置类型,<ul><li><code>string</code>, <code>[]byte</code></li><li><code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>/<code>rune</code>, <code>int64</code></li><li><code>uint</code>, <code>uint8</code>/<code>byte</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code></li><li><code>float32</code>, <code>float64</code></li><li><code>bool</code></li></ul></li></ul></li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://go.dev/doc/tutorial/fuzz" target="_blank" rel="noopener">https://go.dev/doc/tutorial/fuzz</a></li><li><a href="https://segmentfault.com/a/1190000041650681" target="_blank" rel="noopener">https://segmentfault.com/a/1190000041650681</a></li><li><a href="https://segmentfault.com/a/1190000041467510" target="_blank" rel="noopener">https://segmentfault.com/a/1190000041467510</a></li><li><a href="https://go.googlesource.com/proposal/+/master/design/draft-fuzzing.md" target="_blank" rel="noopener">https://go.googlesource.com/proposal/+/master/design/draft-fuzzing.md</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Golang在1.18引入的第三个特性就是 Fuzzing 模糊测试：构造随机数据来找出代码里的漏洞或者可能导致程序崩溃的输入。&lt;/p&gt;
&lt;p&gt;单元测试有局限性，每个测试输入必须由开发者指定加到单元测试的测试用例里。fuzzing的优点之一是可以基于开发者代码里指定的测试输
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go入门14-泛型</title>
    <link href="http://xboom.github.io/2022/09/17/Go/Go%E5%85%A5%E9%97%A814-%E6%B3%9B%E5%9E%8B/"/>
    <id>http://xboom.github.io/2022/09/17/Go/Go%E5%85%A5%E9%97%A814-%E6%B3%9B%E5%9E%8B/</id>
    <published>2022-09-17T07:45:35.000Z</published>
    <updated>2022-09-17T07:45:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h3><p>Golang 在1.18 推出了新特性 泛型 Generics</p><ol><li>为什么要有泛型</li><li>什么是泛型</li><li>如何使用泛型</li></ol><blockquote><p>使用的golang版本 <code>go version go1.18.5 linux/amd6</code></p></blockquote><p>为什么要有泛型从一个经典的问题开始说起，<strong>实现计算两数之和的函数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很快就写完了，那么要计算浮点型或者字符串怎么办？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddFloat32</span><span class="params">(a <span class="keyword">float32</span>, b <span class="keyword">float32</span>)</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddString</span><span class="params">(a <span class="keyword">string</span>, b <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重复代码太多，有没有办法只写一个函数实现它们</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInterface</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">at := reflect.TypeOf(a)</span><br><span class="line">bt := reflect.TypeOf(b)</span><br><span class="line"><span class="keyword">if</span> at != bt &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> a.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line"><span class="keyword">return</span> a.(<span class="keyword">int</span>) + b.(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line"><span class="keyword">return</span> a.(<span class="keyword">string</span>) + b.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">float32</span>:</span><br><span class="line"><span class="keyword">return</span> a.(<span class="keyword">float32</span>) + b.(<span class="keyword">float32</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"no Generic1 %v \n"</span>, AddInterface(<span class="number">1</span>, <span class="number">2</span>))<span class="comment">//3</span></span><br><span class="line">fmt.Printf(<span class="string">"no Generic2 %v \n"</span>, AddInterface(<span class="string">"1"</span>, <span class="string">"2"</span>))  <span class="comment">//"12"</span></span><br><span class="line">fmt.Printf(<span class="string">"no Generic3 %v \n"</span>, AddInterface(<span class="keyword">float32</span>(<span class="number">0.1</span>), <span class="keyword">float32</span>(<span class="number">0.2</span>))) <span class="comment">//0.3</span></span><br></pre></td></tr></table></figure><p>上述函数有两个要求：</p><ol><li>两者的类型要一样，否则无法相加</li><li>需要是函数支持的类型，否则无法相加</li></ol><p>同时，也存在两个问题</p><ol><li>需要利用反射进行类型判断写起来很繁琐</li><li>添加反射操作必然导致性能的降低</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAddInterface</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">AddInterface(<span class="number">30</span>, <span class="number">30</span>) <span class="comment">// run AddInterface(30, 30) b.N times</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAddInt</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">AddInt(<span class="number">30</span>, <span class="number">30</span>) <span class="comment">// AddInt(30, 30) b.N times</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>go test -bench &quot;Add*&quot;</code> 得到如下图所示，性能大约降低20倍</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/generic_1.png" alt="generic_1" /></p><p>泛型就能很好的解决上述问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddT</span>[<span class="title">T</span> <span class="title">int</span> | <span class="title">string</span> | <span class="title">float32</span>]<span class="params">(a, b T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Generic1 %v \n"</span>, AddT(<span class="number">1</span>, <span class="number">2</span>))<span class="comment">//3</span></span><br><span class="line">fmt.Printf(<span class="string">"Generic2 %v \n"</span>, AddT(<span class="string">"1"</span>, <span class="string">"2"</span>))<span class="comment">//"12"</span></span><br><span class="line">fmt.Printf(<span class="string">"Generic3 %v \n"</span>, AddT(<span class="keyword">float32</span>(<span class="number">0.1</span>), <span class="keyword">float32</span>(<span class="number">0.2</span>))) <span class="comment">//0.3</span></span><br></pre></td></tr></table></figure><p>那么是否泛型的性能又是怎么样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAddInterface</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">AddInterface(<span class="number">30</span>, <span class="number">30</span>) <span class="comment">// run AddInterface(30, 30) b.N times</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAddInt</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">AddInt(<span class="number">30</span>, <span class="number">30</span>) <span class="comment">// AddInt(30, 30) b.N times</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAddT</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">AddT(<span class="number">30</span>, <span class="number">30</span>) <span class="comment">// AddT(30, 30) b.N times</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的结果如下图，与固定类型的增加基本没有差别</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/generic_2.png" alt="generic_2" /></p><h3 id="泛型"><a class="markdownIt-Anchor" href="#泛型"></a> 泛型</h3><h4 id="泛型的基本概念"><a class="markdownIt-Anchor" href="#泛型的基本概念"></a> 泛型的基本概念</h4><p>函数存在 <strong>形参(parameter)</strong> 和 <strong>实参(argument)</strong> 这一基本概念</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;  </span><br><span class="line">    <span class="comment">// 变量a,b是函数的形参   "a int, b int" 这一串被称为形参列表</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Add(<span class="number">100</span>,<span class="number">200</span>) <span class="comment">// 调用函数时，传入的100和200是实参</span></span><br></pre></td></tr></table></figure><p>为了替代固定的 int 类型，Go 引入了 <strong>类型形参</strong> 与 <strong>类型实参</strong>，让一个函数获取了处理多种不同类型数据的能力，这种编程方式就叫做 <strong>泛型编程</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 T 是类型形参，在定义函数时它的类型是不确定的，类似占位符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddT</span>[<span class="title">T</span> <span class="title">int</span> | <span class="title">string</span> | <span class="title">float32</span>]<span class="params">(a, b T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类型形参(Type parameter)</strong>：<code>T</code> 表示代表的具体类型并不确定，类似一个占位符(<strong>可以使用其他符号代替</strong>)</p><p><strong>类型约束(Type constraint)</strong>: 表示类型形参 <code>T</code> 只可以接收 <code>int</code> 或 <code>float32</code> 或 <code>string</code> 类型的实参</p><p><strong>类型形参列表(type parameter list)</strong>: <code>T int | string | float32</code>这一整串定义了所有的类型形参</p><p><strong>泛型类型(Generic type)</strong>：类型定义中带 <strong>类型形参</strong> 的类型</p><p><strong>类型实参(Type argument)</strong>：泛型类型不能直接拿来使用，必须传入<strong>类型实参(Type argument)</strong> 将其确定为具体的类型之后才可使用。</p><p><strong>实例化(Instantiations)</strong> ：传入类型实参确定具体类型的操作被称为 <strong>实例化(Instantiations)</strong></p><p>类型参数的声明紧随：</p><ul><li>函数名之后</li><li>类型名之后。类型参数通过类型集进行约束。</li></ul><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/generic_3.png" alt="generic_3" style="zoom:40%;" /><p><strong>类型集</strong>本质上就是接口，类型集可以作为类型参数的约束，一个接口也可以具有类型参数。</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/generic_4.png" alt="generic_4" style="zoom:40%;" /><p>类型集的规则是：<strong>同行并集，不同行交集</strong></p><h4 id="使用方法"><a class="markdownIt-Anchor" href="#使用方法"></a> 使用方法</h4><h5 id="基本类型"><a class="markdownIt-Anchor" href="#基本类型"></a> 基本类型</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice[T <span class="keyword">int</span>|<span class="keyword">float32</span>|<span class="keyword">float64</span> ] []T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里传入了类型实参int，泛型类型Slice[T]被实例化为具体的类型 Slice[int]</span></span><br><span class="line"><span class="keyword">var</span> a Slice[<span class="keyword">int</span>] = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  </span><br><span class="line">fmt.Printf(<span class="string">"Type Name: %T"</span>,a)  <span class="comment">//输出：Type Name: Slice[int]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入类型实参float32, 将泛型类型Slice[T]实例化为具体的类型 Slice[string]</span></span><br><span class="line"><span class="keyword">var</span> b Slice[<span class="keyword">float32</span>] = []<span class="keyword">float32</span>&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>&#125; </span><br><span class="line">fmt.Printf(<span class="string">"Type Name: %T"</span>,b)  <span class="comment">//输出：Type Name: Slice[float32]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✗ 错误。因为变量a的类型为Slice[int]，b的类型为Slice[float32]，两者类型不同</span></span><br><span class="line">a = b  </span><br><span class="line"></span><br><span class="line"><span class="comment">// ✗ 错误。string不在类型约束 int|float32|float64 中，不能用来实例化泛型类型</span></span><br><span class="line"><span class="keyword">var</span> c Slice[<span class="keyword">string</span>] = []<span class="keyword">string</span>&#123;<span class="string">"Hello"</span>, <span class="string">"World"</span>&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// ✗ 错误。Slice[T]是泛型类型，不可直接使用必须实例化为具体的类型</span></span><br><span class="line"><span class="keyword">var</span> x Slice[T] = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><h5 id="map-的使用"><a class="markdownIt-Anchor" href="#map-的使用"></a> map 的使用</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyMap类型定义了两个类型形参 KEY 和 VALUE。分别为两个形参指定了不同的类型约束</span></span><br><span class="line"><span class="comment">// 这个泛型类型的名字叫： MyMap[KEY, VALUE]</span></span><br><span class="line"><span class="keyword">type</span> MyMap[KEY <span class="keyword">int</span> | <span class="keyword">string</span>, VALUE <span class="keyword">float32</span> | <span class="keyword">float64</span>] <span class="keyword">map</span>[KEY]VALUE  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 用类型实参 string 和 flaot64 替换了类型形参 KEY 、 VALUE，泛型类型被实例化为具体的类型：MyMap[string, float64]</span></span><br><span class="line"><span class="keyword">var</span> a MyMap[<span class="keyword">string</span>, <span class="keyword">float64</span>] = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float64</span>&#123;</span><br><span class="line">    <span class="string">"jack_score"</span>: <span class="number">9.6</span>,</span><br><span class="line">    <span class="string">"bob_score"</span>:  <span class="number">8.4</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>KEY</code>和 <code>VALUE</code> 是<strong>类型形参</strong></li><li><code>int|string</code> 是<code>KEY</code>的<strong>类型约束</strong>， <code>float32|float64</code> 是<code>VALUE</code>的<strong>类型约束</strong></li><li><code>KEY int|string, VALUE float32|float64</code> 整个一串文本因为定义了所有形参所以被称为<strong>类型形参列表</strong></li><li><code>Map[KEY, VALUE]</code> 是<strong>泛型类型</strong>，类型的名字就叫 <code>Map[KEY, VALUE]</code></li><li><code>var a MyMap[string, float64] = xx</code> 中的<code>string</code>和<code>float64</code>是<strong>类型实参</strong>，用于分别替换<code>KEY</code>和<code>VALUE</code>，<strong>实例化</strong>出了具体的类型 <code>MyMap[string, float64]</code></li></ul><h5 id="其他类型"><a class="markdownIt-Anchor" href="#其他类型"></a> 其他类型</h5><ol><li><p>struct 的使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个泛型类型的结构体。可用 int 或 sring 类型实例化</span></span><br><span class="line"><span class="keyword">type</span> MyStruct[T <span class="keyword">int</span> | <span class="keyword">string</span>] <span class="keyword">struct</span> &#123;  </span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Data T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例话的时候需要指定T的类型</span></span><br><span class="line"><span class="keyword">var</span> mystruct1 = []MyStruct[<span class="keyword">int</span>]&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"1"</span>,</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="string">"2"</span>,</span><br><span class="line"><span class="number">2</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//✗ 错误。</span></span><br><span class="line"><span class="keyword">var</span> mystruct2 = []MyStruct[<span class="keyword">int</span>]&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"1"</span>,</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="string">"2"</span>,</span><br><span class="line"><span class="string">"2"</span>,<span class="comment">//cannot use "2" (untyped string constant) as int value in struct literal</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接口的泛型使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个泛型接口(关于泛型接口在后半部分会详细讲解）</span></span><br><span class="line"><span class="keyword">type</span> IPrintData[T <span class="keyword">int</span> | <span class="keyword">float32</span> | <span class="keyword">string</span>] <span class="keyword">interface</span> &#123;</span><br><span class="line">Print(data T)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyStruct[<span class="keyword">string</span>])</span> <span class="title">Print</span><span class="params">(data <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ IPrintData[<span class="keyword">string</span>] = (*MyStruct[<span class="keyword">string</span>])(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></li><li><p>chan 的泛型使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个泛型通道，可用类型实参 int 或 string 实例化</span></span><br><span class="line"><span class="keyword">type</span> MyChan[T <span class="keyword">int</span> | <span class="keyword">string</span>] <span class="keyword">chan</span> T</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myChan = <span class="built_in">make</span>(MyChan[<span class="keyword">int</span>], <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ol><h5 id="类型的互相嵌套"><a class="markdownIt-Anchor" href="#类型的互相嵌套"></a> 类型的互相嵌套</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WowStruct[T <span class="keyword">int</span> | <span class="keyword">float32</span>, S []T] <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data     S</span><br><span class="line">    MaxValue T</span><br><span class="line">    MinValue T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wowStruct1 = &amp;WowStruct[<span class="keyword">int</span>, []<span class="keyword">int</span>]&#123;</span><br><span class="line">Data:     []<span class="keyword">int</span>&#123;&#125;,</span><br><span class="line">MaxValue: <span class="number">1</span>,</span><br><span class="line">MinValue: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//✗ 错误。[]float32 dose not implement []int</span></span><br><span class="line"><span class="keyword">var</span> wowStruct2 = &amp;WowStruct[<span class="keyword">int</span>, []<span class="keyword">float32</span>]&#123;</span><br><span class="line">Data:     []<span class="keyword">float32</span>&#123;&#125;,</span><br><span class="line">MaxValue: <span class="number">1</span>,</span><br><span class="line">MinValue: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="其他错误的使用"><a class="markdownIt-Anchor" href="#其他错误的使用"></a> 其他错误的使用</h5><ol><li><p>定义泛型类型的时候，<strong>基础类型不能只有类型形参</strong>，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✗ 错误，类型形参不能单独使用 cannot use a type parameter as RHS in type declaration</span></span><br><span class="line"><span class="keyword">type</span> CommonType[T <span class="keyword">int</span>|<span class="keyword">string</span>|<span class="keyword">float32</span>] T</span><br></pre></td></tr></table></figure></li><li><p>当类型约束的一些写法会被编译器误认为是表达式时会报错。如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//✗ 错误。T *int会被编译器误认为是表达式 T乘以int，而不是int指针</span></span><br><span class="line"><span class="keyword">type</span> NewType[T *<span class="keyword">int</span>] []T</span><br><span class="line"><span class="comment">// 上面代码再编译器眼中：它认为你要定义一个存放切片的数组，数组长度由 T 乘以 int 计算得到</span></span><br><span class="line"><span class="keyword">type</span> NewType [T * <span class="keyword">int</span>][]T </span><br><span class="line"></span><br><span class="line"><span class="comment">//✗ 错误。和上面一样，这里不光*被会认为是乘号，| 还会被认为是按位或操作</span></span><br><span class="line"><span class="keyword">type</span> NewType2[T *<span class="keyword">int</span>|*<span class="keyword">float64</span>] []T </span><br><span class="line"></span><br><span class="line"><span class="comment">//✗ 错误。 undeclare name: T</span></span><br><span class="line"><span class="keyword">type</span> NewType2 [T (<span class="keyword">int</span>)] []T</span><br></pre></td></tr></table></figure><p>为了避免这种误解，解决办法就是给类型约束包上 <code>interface{}</code> 或加上逗号消除歧义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NewType[T <span class="keyword">interface</span>&#123;*<span class="keyword">int</span>&#125;] []T</span><br><span class="line"><span class="keyword">type</span> NewType2[T <span class="keyword">interface</span>&#123;*<span class="keyword">int</span>|*<span class="keyword">float64</span>&#125;] []T </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果类型约束中只有一个类型，可以添加个逗号消除歧义</span></span><br><span class="line"><span class="keyword">type</span> NewType3[T *<span class="keyword">int</span>,] []T <span class="comment">//没错，这样可以而 type NewType3[T *int] []T 不行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//✗ 错误。如果类型约束不止一个类型，加逗号是不行的,  unexpected comma; expecting ]</span></span><br><span class="line"><span class="keyword">type</span> NewType4[T *<span class="keyword">int</span>|*<span class="keyword">float32</span>,] []T</span><br></pre></td></tr></table></figure></li></ol><h5 id="特殊的泛型类型"><a class="markdownIt-Anchor" href="#特殊的泛型类型"></a> 特殊的泛型类型</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Wow[T <span class="keyword">int</span> | <span class="keyword">string</span>] <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a Wow[<span class="keyword">int</span>] = <span class="number">123</span>     <span class="comment">// 编译正确</span></span><br><span class="line"><span class="keyword">var</span> b Wow[<span class="keyword">string</span>] = <span class="number">123</span>  <span class="comment">// 编译正确</span></span><br><span class="line"><span class="keyword">var</span> c Wow[<span class="keyword">string</span>] = <span class="string">"hello"</span> <span class="comment">// 编译错误，因为"hello"不能赋值给底层类型int</span></span><br></pre></td></tr></table></figure><p>这里虽然使用了类型形参，但因为类型定义是 <code>type Wow[T int|string] int</code> ，所以无论传入什么类型实参，实例化后的新类型的底层类型都是 <code>int</code> 。所以int类型的数字123可以赋值给变量<code>a</code>和<code>b</code>，但<code>string</code>类型的字符串 <code>“hello”</code> 不能赋值给<code>c</code>，没有什么具体意义，但可以让我们理解泛型类型的实例化的机制</p><h5 id="泛型类型的套娃"><a class="markdownIt-Anchor" href="#泛型类型的套娃"></a> 泛型类型的套娃</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先定义个泛型类型 Slice[T]</span></span><br><span class="line"><span class="keyword">type</span> Slice[T <span class="keyword">int</span>|<span class="keyword">string</span>|<span class="keyword">float32</span>|<span class="keyword">float64</span>] []T</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✗ 错误。泛型类型Slice[T]的类型约束中不包含uint, uint8</span></span><br><span class="line"><span class="keyword">type</span> UintSlice[T <span class="keyword">uint</span>|<span class="keyword">uint8</span>] Slice[T]  </span><br><span class="line"></span><br><span class="line"><span class="comment">// ✓ 正确。基于泛型类型Slice[T]定义了新的泛型类型 FloatSlice[T] 。FloatSlice[T]只接受float32和float64两种类型</span></span><br><span class="line"><span class="keyword">type</span> FloatSlice[T <span class="keyword">float32</span>|<span class="keyword">float64</span>] Slice[T] </span><br><span class="line"></span><br><span class="line"><span class="comment">// ✓ 正确。基于泛型类型Slice[T]定义的新泛型类型 IntAndStringSlice[T]</span></span><br><span class="line"><span class="keyword">type</span> IntAndStringSlice[T <span class="keyword">int</span>|<span class="keyword">string</span>] Slice[T]  </span><br><span class="line"></span><br><span class="line"><span class="comment">// ✓ 正确 基于IntAndStringSlice[T]套娃定义出的新泛型类型</span></span><br><span class="line"><span class="keyword">type</span> IntSlice[T <span class="keyword">int</span>] IntAndStringSlice[T] </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在map中套一个泛型类型Slice[T]</span></span><br><span class="line"><span class="keyword">type</span> WowMap[T <span class="keyword">int</span>|<span class="keyword">string</span>] <span class="keyword">map</span>[<span class="keyword">string</span>]Slice[T]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在map中套Slice[T]的另一种写法</span></span><br><span class="line"><span class="keyword">type</span> WowMap2[T Slice[<span class="keyword">int</span>] | Slice[<span class="keyword">string</span>]] <span class="keyword">map</span>[<span class="keyword">string</span>]T <span class="comment">//!!! T 直接代替了 Slice[T]</span></span><br></pre></td></tr></table></figure><h5 id="匿名结构体不支持泛型"><a class="markdownIt-Anchor" href="#匿名结构体不支持泛型"></a> 匿名结构体不支持泛型</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">testCase := <span class="keyword">struct</span> &#123;</span><br><span class="line">    caseName <span class="keyword">string</span></span><br><span class="line">    got      <span class="keyword">int</span></span><br><span class="line">    want     <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    caseName: <span class="string">"test OK"</span>,</span><br><span class="line">    got:      <span class="number">100</span>,</span><br><span class="line">    want:     <span class="number">100</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么匿名结构体能不能使用泛型呢？答案是不能，下面的用法是错误的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//✗ 错误。 expected expression</span></span><br><span class="line">testCase := <span class="keyword">struct</span>[T <span class="keyword">int</span>|<span class="keyword">string</span>] &#123;</span><br><span class="line">    caseName <span class="keyword">string</span></span><br><span class="line">    got      T</span><br><span class="line">    want     T</span><br><span class="line">&#125;[<span class="keyword">int</span>]&#123;</span><br><span class="line">    caseName: <span class="string">"test OK"</span>,</span><br><span class="line">    got:      <span class="number">100</span>,</span><br><span class="line">    want:     <span class="number">100</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用泛型的时候我们只能放弃使用匿名结构体，对于很多场景来说这会造成麻烦(最主要麻烦集中在单元测试的时候，为泛型做单元测试会非常麻烦)</p><h5 id="泛型receiver"><a class="markdownIt-Anchor" href="#泛型receiver"></a> 泛型receiver</h5><p>为泛型类型 <code>MySlice[T]</code> 添加了一个计算成员总和的方法 <code>Sum()</code> 。注意观察这个方法的定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MySlice[T <span class="keyword">int</span> | <span class="keyword">float32</span>] []T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s MySlice[T])</span> <span class="title">Sum</span><span class="params">()</span> <span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum T</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">        sum += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先看receiver <code>(s MySlice[T])</code> ，直接把类型名称 <code>MySlice[T]</code> 写入了receiver中</li><li>然后方法的返回参数我们使用了类型形参 T (方法的接收参数也可以实用类型形参)</li><li>在方法的定义中，我们也可以使用类型形参 T (在这个例子里，我们通过 <code>var sum T</code> 定义了一个新的变量 <code>sum</code> )</li></ul><p><strong>泛型类型无论如何都需要先用类型实参实例化!!!</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s MySlice[<span class="keyword">int</span>] = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(s.Sum()) <span class="comment">// 输出：10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 MySlice[<span class="keyword">float32</span>] = []<span class="keyword">float32</span>&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>&#125;</span><br><span class="line">fmt.Println(s2.Sum()) <span class="comment">// 输出：10.0</span></span><br></pre></td></tr></table></figure><p>用类型实参 int 实例化了泛型类型 <code>MySlice[T]</code>，所以泛型类型定义中的所有 T 都被替换为 int，最终我们可以把代码看作下面这样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MySlice[<span class="keyword">int</span>] []<span class="keyword">int</span> <span class="comment">// 实例化后的类型名叫 MyIntSlice[int]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法中所有类型形参 T 都被替换为类型实参 int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s MySlice[<span class="keyword">int</span>])</span> <span class="title">Sum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum <span class="keyword">int</span> </span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">        sum += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="基于泛型的队列"><a class="markdownIt-Anchor" href="#基于泛型的队列"></a> 基于泛型的队列</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里类型约束使用了空接口，代表的意思是所有类型都可以用来实例化泛型类型 Queue[T] (关于接口在后半部分会详细介绍）</span></span><br><span class="line"><span class="keyword">type</span> Queue[T <span class="keyword">interface</span>&#123;&#125;] <span class="keyword">struct</span> &#123;</span><br><span class="line">    elements []T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据放入队列尾部</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue[T])</span> <span class="title">Put</span><span class="params">(value T)</span></span> &#123;</span><br><span class="line">    q.elements = <span class="built_in">append</span>(q.elements, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队列头部取出并从头部删除对应数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue[T])</span> <span class="title">Pop</span><span class="params">()</span> <span class="params">(T, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> value T</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(q.elements) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    value = q.elements[<span class="number">0</span>]</span><br><span class="line">    q.elements = q.elements[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> value, <span class="built_in">len</span>(q.elements) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q Queue[T])</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(q.elements)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Queue[T]</code> 因为是泛型类型，所以要使用的话必须实例化，实例化与使用方法如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> q1 Queue[<span class="keyword">int</span>]  <span class="comment">// 可存放int类型数据的队列</span></span><br><span class="line">q1.Put(<span class="number">1</span>)</span><br><span class="line">q1.Put(<span class="number">2</span>)</span><br><span class="line">q1.Put(<span class="number">3</span>)</span><br><span class="line">q1.Pop() <span class="comment">// 1</span></span><br><span class="line">q1.Pop() <span class="comment">// 2</span></span><br><span class="line">q1.Pop() <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> q2 Queue[<span class="keyword">string</span>]  <span class="comment">// 可存放string类型数据的队列</span></span><br><span class="line">q2.Put(<span class="string">"A"</span>)</span><br><span class="line">q2.Put(<span class="string">"B"</span>)</span><br><span class="line">q2.Put(<span class="string">"C"</span>)</span><br><span class="line">q2.Pop() <span class="comment">// "A"</span></span><br><span class="line">q2.Pop() <span class="comment">// "B"</span></span><br><span class="line">q2.Pop() <span class="comment">// "C"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> q3 Queue[<span class="keyword">struct</span>&#123;Name <span class="keyword">string</span>&#125;] </span><br><span class="line"><span class="keyword">var</span> q4 Queue[[]<span class="keyword">int</span>] <span class="comment">// 可存放[]int切片的队列</span></span><br><span class="line"><span class="keyword">var</span> q5 Queue[<span class="keyword">chan</span> <span class="keyword">int</span>] <span class="comment">// 可存放int通道的队列</span></span><br><span class="line"><span class="keyword">var</span> q6 Queue[io.Reader] <span class="comment">// 可存放接口的队列</span></span><br><span class="line"><span class="comment">// ......</span></span><br></pre></td></tr></table></figure><h5 id="动态判断变量的类型"><a class="markdownIt-Anchor" href="#动态判断变量的类型"></a> 动态判断变量的类型</h5><p>使用接口的时候经常会用到类型断言或 type swith 来确定接口具体的类型，然后对不同类型做出不同的处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="number">123</span></span><br><span class="line">i.(<span class="keyword">int</span>) <span class="comment">// 类型断言</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// type switch</span></span><br><span class="line"><span class="keyword">switch</span> i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么对于 <code>valut T</code> 这样通过类型形参定义的变量，能不能判断具体类型然后对不同类型做出不同处理呢？答案是<strong>不允许的!!!</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// invalid operation: cannot use type assertion on type parameter value value (variable of type T constrained by interface&#123;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue[T])</span> <span class="title">Put</span><span class="params">(value T)</span></span> &#123;</span><br><span class="line">    value.(<span class="keyword">int</span>) <span class="comment">// 错误。泛型类型定义的变量不能使用类型断言</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误。不允许使用type switch 来判断 value 的具体类型</span></span><br><span class="line">    <span class="comment">// cannot use type switch on type parameter value value (variable of type T constrained by interface&#123;&#125;)</span></span><br><span class="line">    <span class="keyword">switch</span> value.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然<code>type switch</code>和类型断言不能用，但我们可通过反射机制达到目的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver Queue[T])</span> <span class="title">Put</span><span class="params">(value T)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Printf() 可输出变量value的类型(底层就是通过反射实现的)</span></span><br><span class="line">    fmt.Printf(<span class="string">"%T"</span>, value) </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反射可以动态获得变量value的类型从而分情况处理</span></span><br><span class="line">    v := reflect.ValueOf(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> v.Kind() &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.Int:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">case</span> reflect.String:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免使用反射而选择了泛型，结果到头来又为了一些功能在在泛型中使用反射，当出现这种情况的时候你可能需要重新思考一下，自己的需求是不是真的需要用泛型(毕竟泛型机制本身就很复杂了，再加上反射的复杂度，增加的复杂度并不一定值得)</p><h5 id="泛型函数"><a class="markdownIt-Anchor" href="#泛型函数"></a> 泛型函数</h5><p>带类型形参的函数被称为<strong>泛型函数</strong>，匿名函数不支持泛型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b </span><br><span class="line">&#125;  <span class="comment">// 定义了一个匿名函数并赋值给 fn </span></span><br><span class="line"></span><br><span class="line">fmt.Println(fn(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 输出: 3</span></span><br></pre></td></tr></table></figure><p>那么Go支不支持匿名泛型函数呢？答案是不能——<strong>匿名函数不能自己定义类型形参</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误，匿名函数不能自己定义类型实参</span></span><br><span class="line"><span class="comment">// function type must have no type parameters</span></span><br><span class="line">fnGeneric := <span class="function"><span class="keyword">func</span>[<span class="title">T</span> <span class="title">int</span> | <span class="title">float32</span>]<span class="params">(a, b T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">fmt.Println(fnGeneric(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>但是匿名函数可以使用别处定义好的类型实参，如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFunc</span>[<span class="title">T</span> <span class="title">int</span> | <span class="title">float32</span> | <span class="title">float64</span>]<span class="params">(a, b T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匿名函数可使用已经定义好的类型形参</span></span><br><span class="line">    fn2 := <span class="function"><span class="keyword">func</span><span class="params">(i T, j T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i*<span class="number">2</span> - j*<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn2(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="泛型方法"><a class="markdownIt-Anchor" href="#泛型方法"></a> 泛型方法</h5><p>Go的方法并不支持泛型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不支持泛型方法</span></span><br><span class="line"><span class="comment">// method must have no type parameters</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver A)</span> <span class="title">Add</span>[<span class="title">T</span> <span class="title">int</span> | <span class="title">float32</span> | <span class="title">float64</span>]<span class="params">(a T, b T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是因为receiver支持泛型， 所以如果想在方法中使用泛型的话，目前唯一的办法就是曲线救国，迂回地通过receiver使用类型形参</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A[T <span class="keyword">int</span> | <span class="keyword">float32</span> | <span class="keyword">float64</span>] <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法可以使用类型定义中的形参 T </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver A[T])</span> <span class="title">Add</span><span class="params">(a T, b T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：</span></span><br><span class="line"><span class="keyword">var</span> a A[<span class="keyword">int</span>]</span><br><span class="line">a.Add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aa A[<span class="keyword">float32</span>]</span><br><span class="line">aa.Add(<span class="number">1.0</span>, <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure><h4 id="泛型使用进阶"><a class="markdownIt-Anchor" href="#泛型使用进阶"></a> 泛型使用进阶</h4><h5 id="复杂的接口"><a class="markdownIt-Anchor" href="#复杂的接口"></a> 复杂的接口</h5><p>有时候使用泛型编程时，会书写长长的类型约束，如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个可以容纳所有int,uint以及浮点类型的泛型切片</span></span><br><span class="line"><span class="keyword">type</span> Slice[T <span class="keyword">int</span> | <span class="keyword">int8</span> | <span class="keyword">int16</span> | <span class="keyword">int32</span> | <span class="keyword">int64</span> | <span class="keyword">uint</span> | <span class="keyword">uint8</span> | <span class="keyword">uint16</span> | <span class="keyword">uint32</span> | <span class="keyword">uint64</span> | <span class="keyword">float32</span> | <span class="keyword">float64</span>] []T</span><br></pre></td></tr></table></figure><p>这种写法是无法忍受也难以维护的，而Go支持将类型约束单独拿出来定义到接口中，从而让代码更容易维护</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntUintFloat <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> | <span class="keyword">int8</span> | <span class="keyword">int16</span> | <span class="keyword">int32</span> | <span class="keyword">int64</span> | <span class="keyword">uint</span> | <span class="keyword">uint8</span> | <span class="keyword">uint16</span> | <span class="keyword">uint32</span> | <span class="keyword">uint64</span> | <span class="keyword">float32</span> | <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T IntUintFloat] []T</span><br></pre></td></tr></table></figure><p>不过这样的代码依旧不好维护，而接口和接口、接口和普通类型之间也是可以通过 <code>|</code> 进行组合</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Int <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> | <span class="keyword">int8</span> | <span class="keyword">int16</span> | <span class="keyword">int32</span> | <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Uint <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">uint</span> | <span class="keyword">uint8</span> | <span class="keyword">uint16</span> | <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Float <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">float32</span> | <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T Int | Uint | Float] []T  <span class="comment">// 使用 '|' 将多个接口类型组合</span></span><br></pre></td></tr></table></figure><p>在接口里也能直接组合其他接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceElement <span class="keyword">interface</span> &#123;</span><br><span class="line">    Int | Uint | Float | <span class="keyword">string</span> <span class="comment">// 组合了三个接口类型并额外增加了一个 string 类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T SliceElement] []T</span><br></pre></td></tr></table></figure><h5 id="~-符号"><a class="markdownIt-Anchor" href="#~-符号"></a> ~ 符号</h5><p>上面定义的 <code>Slie[T]</code> 虽然可以达到目的，但是有一个缺点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 Slice[<span class="keyword">int</span>] <span class="comment">// 正确 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"><span class="comment">// MyInt does not implement int|string|float32|float64 (possibly missing ~ for int in constraint int|string|float32|float64)</span></span><br><span class="line"><span class="keyword">var</span> s2 Slice[MyInt] <span class="comment">// ✗ 错误。MyInt类型底层类型是int但并不是int类型，不符合 Slice[T] 的类型约束</span></span><br></pre></td></tr></table></figure><p>错误原因：泛型类型 <code>Slice[T]</code> 允许的是 <code>int</code> 作为类型实参，而不是 MyInt （虽然 MyInt 类型底层类型是 int ，但它依旧不是 int 类型）。</p><p>为了从根本上解决这个问题，Go新增了一个符号 <code>~</code> ，在类型约束中使用类似 <code>~int</code> 这种写法的话，就代表着不光是 int ，所有以 int 为底层类型的类型也都可用于实例化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Int <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="keyword">int</span> | ~<span class="keyword">int8</span> | ~<span class="keyword">int16</span> | ~<span class="keyword">int32</span> | ~<span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Uint <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="keyword">uint</span> | ~<span class="keyword">uint8</span> | ~<span class="keyword">uint16</span> | ~<span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Float <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="keyword">float32</span> | ~<span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T Int | Uint | Float] []T </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s Slice[<span class="keyword">int</span>] <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> s2 Slice[MyInt]  <span class="comment">// MyInt底层类型是int，所以可以用于实例化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyMyInt MyInt</span><br><span class="line"><span class="keyword">var</span> s3 Slice[MyMyInt]  <span class="comment">// 正确。MyMyInt 虽然基于 MyInt ，但底层类型也是int，所以也能用于实例化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat32 <span class="keyword">float32</span>  <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> s4 Slice[MyFloat32]</span><br></pre></td></tr></table></figure><p><strong>限制</strong>：使用 <code>~</code> 时有一定的限制：</p><ol><li><code>~</code>后面的类型不能为接口</li><li><code>~</code>后面的类型必须为基本类型</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> _ <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~[]<span class="keyword">byte</span>  <span class="comment">// 正确</span></span><br><span class="line">    ~MyInt   <span class="comment">// 错误，~后的类型必须为基本类型 invalid use of ~ (underlying type of MyInt is int)</span></span><br><span class="line">    ~error   <span class="comment">// 错误，~后的类型不能为接口   invalid use of ~ (error is an interface)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口的变化"><a class="markdownIt-Anchor" href="#接口的变化"></a> 接口的变化</h4><h5 id="从方法集method-set到类型集type-set"><a class="markdownIt-Anchor" href="#从方法集method-set到类型集type-set"></a> 从方法集(Method set)到类型集(Type set)</h5><p>在Go1.18之前，Go官方对 <code>接口(interface)</code> 的定义是：接口是一个方法集(method set)</p><p><code>ReadWriter</code> 接口定义了一个接口(方法集)，这个集合中包含了 <code>Read()</code> 和 <code>Write()</code> 这两个方法。所有同时定义了这两种方法的类型被视为实现了这一接口</p><blockquote><p>An interface type specifies a <strong>method set</strong> called its interface</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换个角度重新理解</p><blockquote><p>把 <code>ReaderWriter</code> 接口看成代表了一个 <strong>类型的集合</strong>，所有实现了 <code>Read()</code> <code>Writer()</code> 这两个方法的类型都在接口代表的类型集合当中</p></blockquote><p>接口的定义就从 <strong><code>方法集(method set)</code></strong> 变为了 <strong><code>类型集(type set)</code></strong>。而Go1.18开始就是依据这一点将接口的定义正式更改为了 <strong>类型集(Type set)</strong></p><blockquote><p>An interface type defines a *<strong>type set*</strong> <em>(一个</em>接口类型定义了一个类型集)</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Float <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="keyword">float32</span> | ~<span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T Float] []T</span><br></pre></td></tr></table></figure><p>接口类型 <code>Float</code> 代表了一个 <strong>类型集合</strong>， 所有以 <code>float32</code> <strong>或</strong> <code>float64</code> 为底层类型的类型，都在这一类型集之中</p><p>而 <code>type Slice[T Float] []T</code> 中， <strong>类型约束</strong> 的真正意思是：指定了类型形参可接受的类型集合，只有属于这个集合中的类型才能替换形参用于实例化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s Slice[<span class="keyword">int</span>]      <span class="comment">// int 属于类型集 Float ，所以int可以作为类型实参</span></span><br><span class="line"><span class="comment">// chan int does not implement int|string|float32|float64</span></span><br><span class="line"><span class="keyword">var</span> s Slice[<span class="keyword">chan</span> <span class="keyword">int</span>] <span class="comment">// chan int 类型不在类型集 Float 中，所以错误</span></span><br></pre></td></tr></table></figure><h5 id="接口实现implement定义的变化"><a class="markdownIt-Anchor" href="#接口实现implement定义的变化"></a> 接口实现(implement)定义的变化</h5><p>当满足以下条件时，可以说 <strong>类型 T 实现了接口 I ( type T implements interface I)</strong>：</p><ul><li>T 不是接口时：类型 T 是接口 I 代表的类型集中的一个成员 (T is an element of the type set of I)</li><li>T 是接口时： T 接口代表的类型集是 I 代表的类型集的子集(Type set of T is a subset of the type set of I)</li></ul><h6 id="类型的并集"><a class="markdownIt-Anchor" href="#类型的并集"></a> 类型的并集</h6><p>一直使用的 <code>|</code> 符号就是求类型的并集( <code>union</code> )</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Uint <span class="keyword">interface</span> &#123;  <span class="comment">// 类型集 Uint 是 ~uint 和 ~uint8 等类型的并集</span></span><br><span class="line">    ~<span class="keyword">uint</span> | ~<span class="keyword">uint8</span> | ~<span class="keyword">uint16</span> | ~<span class="keyword">uint32</span> | ~<span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="类型的交集"><a class="markdownIt-Anchor" href="#类型的交集"></a> 类型的交集</h5><p>接口可以不止书写一行，如果一个接口有多行类型定义，那么取它们之间的 <strong>交集</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AllInt <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="keyword">int</span> | ~<span class="keyword">int8</span> | ~<span class="keyword">int16</span> | ~<span class="keyword">int32</span> | ~<span class="keyword">int64</span> | ~<span class="keyword">uint</span> | ~<span class="keyword">uint8</span> | ~<span class="keyword">uint16</span> | ~<span class="keyword">uint32</span> | ~<span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Uint <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="keyword">uint</span> | ~<span class="keyword">uint8</span> | ~<span class="keyword">uint16</span> | ~<span class="keyword">uint32</span> | ~<span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">interface</span> &#123; <span class="comment">// 接口A代表的类型集是 AllInt 和 Uint 的交集</span></span><br><span class="line">    AllInt</span><br><span class="line">    Uint</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">interface</span> &#123; <span class="comment">// 接口B代表的类型集是 AllInt 和 ~int 的交集</span></span><br><span class="line">    AllInt</span><br><span class="line">    ~<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C <span class="keyword">interface</span> &#123; <span class="comment">// 接口C代表的类型集是 int 和 ~int 的交集</span></span><br><span class="line">    <span class="keyword">int</span></span><br><span class="line">    ~<span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接口 A 代表的是 AllInt 与 Uint 的 <strong>交集</strong>，即 <code>~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64</code></li><li>接口 B 代表的则是 AllInt 和 ~int 的<strong>交集</strong>，即 <code>~int</code></li></ul><p>很显然，~int 和 int 的交集只有int一种类型，所以接口C代表的类型集中只有int一种类型</p><h6 id="空集"><a class="markdownIt-Anchor" href="#空集"></a> 空集</h6><p>当多个类型的交集如下面 <code>Bad</code> 这样为空的时候， <code>Bad</code> 这个接口代表的类型集为一个<strong>空集</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Bad <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">float32</span> </span><br><span class="line">&#125; <span class="comment">// 类型 int 和 float32 没有相交的类型，所以接口 Bad 代表的类型集为空</span></span><br></pre></td></tr></table></figure><p><strong>没有任何一种类型属于空集</strong>。虽然 Bad 这样的写法是可以编译的，但实际上并没有什么意义</p><h6 id="空接口和-any"><a class="markdownIt-Anchor" href="#空接口和-any"></a> 空接口和 any</h6><p>接下来说一个特殊的类型集——<code>空接口 interface{}</code> 。因为，Go1.18开始接口的定义发生了改变，所以 <code>interface{}</code> 的定义也发生了一些变更：</p><blockquote><p>空接口代表了所有类型的集合</p></blockquote><p>所以，对于Go1.18之后的空接口应该这样理解：</p><ol><li>虽然空接口内没有写入任何的类型，但它代表的是所有类型的集合，而非一个 <strong>空集</strong></li><li>类型约束中指定 <strong>空接口</strong> 的意思是指定了一个包含所有类型的类型集，并不是类型约束限定了只能使用 <strong>空接口</strong> 来做类型形参</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空接口代表所有类型的集合。写入类型约束意味着所有类型都可拿来做类型实参</span></span><br><span class="line"><span class="keyword">type</span> Slice[T <span class="keyword">interface</span>&#123;&#125;] []T</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 Slice[<span class="keyword">int</span>]    <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> s2 Slice[<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>]  <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> s3 Slice[<span class="keyword">chan</span> <span class="keyword">int</span>]  <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> s4 Slice[<span class="keyword">interface</span>&#123;&#125;]  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>因为空接口是一个包含了所有类型的类型集，所以我们经常会用到它。于是，Go1.18开始提供了一个和空接口 <code>interface{}</code> 等价的新关键词 <code>any</code> ，用来使代码更简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice[T any] []T <span class="comment">// 代码等价于 type Slice[T interface&#123;&#125;] []T</span></span><br></pre></td></tr></table></figure><p>实际上 <code>any</code> 的定义就位于Go语言的 <code>builtin.go</code> 文件中（参考如下）， <code>any</code> 实际上就是 <code>interaface{}</code>的别名(alias)，两者完全等价</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/generic_6.png" alt="generic_6" /></p><p>所以从 Go 1.18 开始，所有可以用到空接口的地方其实都可以直接替换为any，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []any <span class="comment">// 等价于 var s []interface&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]any <span class="comment">// 等价于 var m map[string]interface&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyPrint</span><span class="params">(value any)</span></span>&#123;</span><br><span class="line">    fmt.Println(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="comparable可比较-和-可排序ordered"><a class="markdownIt-Anchor" href="#comparable可比较-和-可排序ordered"></a> comparable(可比较) 和 可排序(ordered)</h5><p>golang中类型的比较情况</p><ul><li><p>Boolean(布尔值)、Integer(整型)、Floating-point(浮点数)、Complex(复数)、String(字符)这些类型毫无疑问可以比较。</p></li><li><p>Poniter (指针) 可以比较：如果两个指针指向同一个变量，或者两个指针类型相同且值都为 nil，则它们相等。注意，指向不同的零大小变量的指针可能相等，也可能不相等。</p></li><li><p>Channel (通道)具有可比性：如果两个通道值是由同一个 make 调用创建的，则它们相等</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>) </span><br><span class="line"> </span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>) </span><br><span class="line"> </span><br><span class="line">c3 := c1 </span><br><span class="line"> </span><br><span class="line">fmt.Println(c3 == c1) <span class="comment">// true </span></span><br><span class="line"> </span><br><span class="line">fmt.Println(c2 == c1) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>Interface (接口值)具有可比性：如果两个接口值具有相同的动态类型和相等的动态值，则它们相等。</p></li><li><p>当类型 X 的值具有可比性且 X 实现 T 时，非接口类型 X 的值 x 和接口类型 T 的值 t 具有可比性。如果 t 的动态类型与 X 相同且 t 的动态值等于 x，则它们相等。</p></li><li><p>如果所有字段都具有可比性，则 struct (结构体值)具有可比性：如果它们对应的非空字段相等，则两个结构体值相等。</p></li><li><p>如果 array(数组)元素类型的值是可比较的，则数组值是可比较的：如果它们对应的元素相等，则两个数组值相等</p></li><li><p>slice、map、function 这些是不可以比较的，但是也有特殊情况，那就是当他们值是 nil 时，可以与 nil 进行比较</p></li></ul><p>对于一些数据类型，需要在类型约束中限制只接受能 <code>!=</code> 和 <code>==</code> 对比的类型，如<code>map</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误。因为 map 中键的类型必须是可进行 != 和 == 比较的类型</span></span><br><span class="line"><span class="comment">// incomparable map key type KEY (missing comparable constraint)</span></span><br><span class="line"><span class="keyword">type</span> MyMap[KEY any, VALUE any] <span class="keyword">map</span>[KEY]VALUE</span><br></pre></td></tr></table></figure><p>所以Go直接内置了一个叫 <code>comparable</code> 的接口，它代表了所有可用 <code>!=</code> 以及 <code>==</code> 对比的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyMap[KEY comparable, VALUE any] <span class="keyword">map</span>[KEY]VALUE <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p><code>comparable</code> 比较容易引起误解的一点是很多人容易把他与可排序搞混淆。可比较指的是 可以执行 <code>!= ==</code> 操作的类型，并没确保这个类型可以执行大小比较（ <code>&gt;,&lt;,&lt;=,&gt;=</code> ）。如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OhMyStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a, b OhMyStruct</span><br><span class="line"></span><br><span class="line">a == b <span class="comment">// 正确。结构体可使用 == 进行比较</span></span><br><span class="line">a != b <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">a &gt; b <span class="comment">// 错误。结构体不可比大小</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span>[<span class="title">E</span> <span class="title">comparable</span>]<span class="params">(s []E, v E)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, vs := <span class="keyword">range</span> s &#123;</span><br><span class="line"><span class="keyword">if</span> v == vs &#123; <span class="keyword">return</span> i &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而可进行大小比较的类型被称为 <code>Orderd</code> 。目前Go语言并没有像 <code>comparable</code> 这样直接内置对应的关键词，所以想要的话需要自己来定义相关接口，比如我们可以参考Go官方包<code>golang.org/x/exp/constraints</code> 如何定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ordered 代表所有可比大小排序的类型</span></span><br><span class="line"><span class="keyword">type</span> Ordered <span class="keyword">interface</span> &#123;</span><br><span class="line">    Integer | Float | ~<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Signed | Unsigned</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Signed <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="keyword">int</span> | ~<span class="keyword">int8</span> | ~<span class="keyword">int16</span> | ~<span class="keyword">int32</span> | ~<span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Unsigned <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="keyword">uint</span> | ~<span class="keyword">uint8</span> | ~<span class="keyword">uint16</span> | ~<span class="keyword">uint32</span> | ~<span class="keyword">uint64</span> | ~<span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Float <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="keyword">float32</span> | ~<span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsSorted</span>[<span class="title">E</span> <span class="title">constraints</span>.<span class="title">Ordered</span>]<span class="params">(x []E)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="built_in">len</span>(x) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">       <span class="keyword">if</span> x[i] &lt; x[i<span class="number">-1</span>] &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里虽然可以直接使用官方包 <a href="https://link.segmentfault.com/?enc=%2BTKLEsgP4x4Vuz7HIDXuKQ%3D%3D.GwSBPmjVaQtpnQxuZogW8Dy1xCAJi0lQKOjCl%2BP3ZQqFi%2FnUmX%2FlfNaE5kUv8%2FkW" target="_blank" rel="noopener">golang.org/x/exp/constraints</a> ，但因为这个包属于实验性质的 x 包，今后可能会发生非常大变动，所以并不推荐直接使用</p></blockquote><h5 id="接口两种类型"><a class="markdownIt-Anchor" href="#接口两种类型"></a> 接口两种类型</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="keyword">string</span> | ~[]<span class="keyword">rune</span></span><br><span class="line"></span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口类型 <code>ReadWriter</code> 代表了一个类型集合，所有以 <code>string</code> 或 []rune <code>为底层类型</code>，并且实现了 <code>Read()</code> <code>Write()</code> 这两个方法的类型都在 <code>ReadWriter</code> 代表的类型集当中，例如：</p><p><code>StringReadWriter</code> 存在于接口 <code>ReadWriter</code> 代表的类型集中，而 <code>BytesReadWriter</code> 因为底层类型是 <code>[]byte</code>（既不是<code>string</code>也是不<code>[]rune</code>） ，所以它不属于 <code>ReadWriter</code> 代表的类型集</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型 StringReadWriter 实现了接口 Readwriter</span></span><br><span class="line"><span class="keyword">type</span> StringReadWriter <span class="keyword">string</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StringReadWriter)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StringReadWriter)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  类型BytesReadWriter 没有实现接口 Readwriter</span></span><br><span class="line"><span class="keyword">type</span> BytesReadWriter []<span class="keyword">byte</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s BytesReadWriter)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s BytesReadWriter)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个 <code>ReadWriter</code> 类型的接口变量，然后接口变量赋值的时候不光要考虑到方法的实现，还必须考虑到具体底层类型？心智负担也太大了吧。是的，为了解决这个问题也为了保持Go语言的兼容性，Go1.18开始将接口分为了两种类型</p><ul><li><strong>基本接口(Basic interface)</strong></li><li><strong>一般接口(General interface)</strong></li></ul><h5 id="基本接口"><a class="markdownIt-Anchor" href="#基本接口"></a> 基本接口</h5><p>接口定义中如果只有方法的话，那么这种接口被称为<strong>基本接口(Basic interface)</strong>。这种接口就是Go1.18之前的接口，用法也基本和Go1.18之前保持一致。基本接口大致可以用于如下几个地方</p><ul><li><p>最常用的，定义接口变量并赋值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyError <span class="keyword">interface</span> &#123; <span class="comment">// 接口中只有方法，所以是基本接口</span></span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法和 Go1.18之前保持一致</span></span><br><span class="line"><span class="keyword">var</span> err MyError = fmt.Errorf(<span class="string">"hello world"</span>)</span><br></pre></td></tr></table></figure></li><li><p>基本接口因为也代表了一个类型集，所以也可用在类型约束中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.Reader 和 io.Writer 都是基本接口，也可以用在类型约束中</span></span><br><span class="line"><span class="keyword">type</span> MySlice[T io.Reader | io.Writer]  []Slice</span><br></pre></td></tr></table></figure></li></ul><h6 id="一般接口general-interface"><a class="markdownIt-Anchor" href="#一般接口general-interface"></a> 一般接口(General interface)</h6><p>如果接口内不光只有方法，还有类型的话，这种接口被称为 <strong>一般接口(General interface)</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Uint <span class="keyword">interface</span> &#123; <span class="comment">// 接口 Uint 中有类型，所以是一般接口</span></span><br><span class="line">    ~<span class="keyword">uint</span> | ~<span class="keyword">uint8</span> | ~<span class="keyword">uint16</span> | ~<span class="keyword">uint32</span> | ~<span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;  <span class="comment">// ReadWriter 接口既有方法也有类型，所以是一般接口</span></span><br><span class="line">    ~<span class="keyword">string</span> | ~[]<span class="keyword">rune</span></span><br><span class="line"></span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一般接口类型不能用来定义变量，只能用于泛型的类型约束中</strong>。所以以下的用法是错误的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Uint <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="keyword">uint</span> | ~<span class="keyword">uint8</span> | ~<span class="keyword">uint16</span> | ~<span class="keyword">uint32</span> | ~<span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> uintInf Uint <span class="comment">// 错误。Uint是一般接口，只能用于类型约束，不得用于变量定义</span></span><br></pre></td></tr></table></figure><p>这一限制保证了一般接口的使用被限定在了泛型之中，不会影响到Go1.18之前的代码，同时也极大减少了书写代码时的心智负担</p><h4 id="泛型接口"><a class="markdownIt-Anchor" href="#泛型接口"></a> 泛型接口</h4><p>所有类型的定义中都可以使用类型形参，所以接口定义自然也可以使用类型形参，观察下面这两个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DataProcessor[T any] <span class="keyword">interface</span> &#123;</span><br><span class="line">    Process(oriData T) (newData T)</span><br><span class="line">    Save(data T) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DataProcessor2[T any] <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> | ~<span class="keyword">struct</span>&#123; Data <span class="keyword">interface</span>&#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line">    Process(data T) (newData T)</span><br><span class="line">    Save(data T) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为引入了类型形参，所以这两个接口是泛型类型。<strong>而泛型类型要使用的话必须传入类型实参实例化才有意义</strong>。所以尝试实例化一下这两个接口。因为 <code>T</code> 的类型约束是 any，所以可以随便挑一个类型来当实参(比如string)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DataProcessor[<span class="keyword">string</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化之后的接口定义相当于如下所示：</span></span><br><span class="line"><span class="keyword">type</span> DataProcessor[<span class="keyword">string</span>] <span class="keyword">interface</span> &#123;</span><br><span class="line">    Process(oriData <span class="keyword">string</span>) (newData <span class="keyword">string</span>)</span><br><span class="line">    Save(data <span class="keyword">string</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过实例化之后就好理解了， <code>DataProcessor[string]</code> 因为只有方法，所以它实际上就是个 <strong>基本接口(Basic interface)</strong>，这个接口包含两个能处理string类型的方法。像下面这样实现了这两个能处理string类型的方法就算实现了这个接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CSVProcessor <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，方法中 oriData 等的类型是 string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c CSVProcessor)</span> <span class="title">Process</span><span class="params">(oriData <span class="keyword">string</span>)</span> <span class="params">(newData <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c CSVProcessor)</span> <span class="title">Save</span><span class="params">(oriData <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CSVProcessor实现了接口 DataProcessor[string] ，所以可赋值</span></span><br><span class="line"><span class="keyword">var</span> processor DataProcessor[<span class="keyword">string</span>] = CSVProcessor&#123;&#125;  </span><br><span class="line">processor.Process(<span class="string">"name,age\nbob,12\njack,30"</span>)</span><br><span class="line">processor.Save(<span class="string">"name,age\nbob,13\njack,31"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误。CSVProcessor没有实现接口 DataProcessor[int]</span></span><br><span class="line"><span class="keyword">var</span> processor2 DataProcessor[<span class="keyword">int</span>] = CSVProcessor&#123;&#125;</span><br></pre></td></tr></table></figure><p>再用同样的方法实例化 <code>DataProcessor2[T]</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DataProcessor2[<span class="keyword">string</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化后的接口定义可视为</span></span><br><span class="line"><span class="keyword">type</span> DataProcessor2[T <span class="keyword">string</span>] <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> | ~<span class="keyword">struct</span>&#123; Data <span class="keyword">interface</span>&#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line">    Process(data <span class="keyword">string</span>) (newData <span class="keyword">string</span>)</span><br><span class="line">    Save(data <span class="keyword">string</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DataProcessor2[string]</code> 因为带有类型并集所以它是 <strong>一般接口(General interface)</strong>，所以实例化之后的这个接口代表的意思是：</p><ol><li>只有实现了 <code>Process(string) string</code> 和 <code>Save(string) error</code> 这两个方法，并且以 <code>int</code> 或 <code>struct{ Data interface{} }</code> 为底层类型的类型才算实现了这个接口</li><li><strong>一般接口(General interface)</strong> 不能用于变量定义只能用于类型约束，所以接口 <code>DataProcessor2[string]</code> 只是定义了一个用于类型约束的类型集</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XMLProcessor 虽然实现了接口 DataProcessor2[string] 的两个方法，但是因为它的底层类型是 []byte，所以依旧是未实现 DataProcessor2[string]</span></span><br><span class="line"><span class="keyword">type</span> XMLProcessor []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c XMLProcessor)</span> <span class="title">Process</span><span class="params">(oriData <span class="keyword">string</span>)</span> <span class="params">(newData <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c XMLProcessor)</span> <span class="title">Save</span><span class="params">(oriData <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JsonProcessor 实现了接口 DataProcessor2[string] 的两个方法，同时底层类型是 struct&#123; Data interface&#123;&#125; &#125;。所以实现了接口 DataProcessor2[string]</span></span><br><span class="line"><span class="keyword">type</span> JsonProcessor <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c JsonProcessor)</span> <span class="title">Process</span><span class="params">(oriData <span class="keyword">string</span>)</span> <span class="params">(newData <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c JsonProcessor)</span> <span class="title">Save</span><span class="params">(oriData <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误。DataProcessor2[string]是一般接口不能用于创建变量</span></span><br><span class="line"><span class="keyword">var</span> processor DataProcessor2[<span class="keyword">string</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确，实例化之后的 DataProcessor2[string] 可用于泛型的类型约束</span></span><br><span class="line"><span class="keyword">type</span> ProcessorList[T DataProcessor2[<span class="keyword">string</span>]] []T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确，接口可以并入其他接口</span></span><br><span class="line"><span class="keyword">type</span> StringProcessor <span class="keyword">interface</span> &#123;</span><br><span class="line">    DataProcessor2[<span class="keyword">string</span>]</span><br><span class="line"></span><br><span class="line">    PrintString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，带方法的一般接口不能作为类型并集的成员</span></span><br><span class="line"><span class="keyword">type</span> StringProcessor <span class="keyword">interface</span> &#123;</span><br><span class="line">    DataProcessor2[<span class="keyword">string</span>] | DataProcessor2[[]<span class="keyword">byte</span>]</span><br><span class="line"></span><br><span class="line">    PrintString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口定义的种种限制规则"><a class="markdownIt-Anchor" href="#接口定义的种种限制规则"></a> 接口定义的种种限制规则</h4><p>Go1.18从开始，在定义类型集(接口)的时候增加了非常多十分琐碎的限制规则，其中很多规则都在之前的内容中介绍过了，但剩下还有一些规则因为找不到好的地方介绍，所以在这里统一介绍下</p><ol><li><p>用 <code>|</code> 连接多个类型的时候，类型之间不能有相交的部分(即必须是不交集):</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，MyInt的底层类型是int,和 ~int 有相交的部分</span></span><br><span class="line"><span class="keyword">type</span> _ <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="keyword">int</span> | MyInt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是相交的类型中是接口的话，则不受这一限制：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> _ <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="keyword">int</span> | <span class="keyword">interface</span>&#123; MyInt &#125;  <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> _ <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span>&#123; ~<span class="keyword">int</span> &#125; | MyInt <span class="comment">// 也正确</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> _ <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span>&#123; ~<span class="keyword">int</span> &#125; | <span class="keyword">interface</span>&#123; MyInt &#125;  <span class="comment">// 也正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类型的并集中不能有类型形参</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInf[T ~<span class="keyword">int</span> | ~<span class="keyword">string</span>] <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="keyword">float32</span> | T  <span class="comment">// 错误。T是类型形参</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInf2[T ~<span class="keyword">int</span> | ~<span class="keyword">string</span>] <span class="keyword">interface</span> &#123;</span><br><span class="line">    T  <span class="comment">// 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接口不能直接或间接地并入自己</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Bad <span class="keyword">interface</span> &#123;</span><br><span class="line">    Bad <span class="comment">// 错误，接口不能直接并入自己</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bad2 <span class="keyword">interface</span> &#123;</span><br><span class="line">    Bad1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bad1 <span class="keyword">interface</span> &#123;</span><br><span class="line">    Bad2 <span class="comment">// 错误，接口Bad1通过Bad2间接并入了自己</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bad3 <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="keyword">int</span> | ~<span class="keyword">string</span> | Bad3 <span class="comment">// 错误，通过类型的并集并入了自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接口的并集成员个数大于一的时候不能直接或间接并入 <code>comparable</code> 接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OK <span class="keyword">interface</span> &#123;</span><br><span class="line">    comparable <span class="comment">// 正确。只有一个类型的时候可以使用 comparable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bad1 <span class="keyword">interface</span> &#123;</span><br><span class="line">    []<span class="keyword">int</span> | comparable <span class="comment">// 错误，类型并集不能直接并入 comparable 接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CmpInf <span class="keyword">interface</span> &#123;</span><br><span class="line">    comparable</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bad2 <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">chan</span> <span class="keyword">int</span> | CmpInf  <span class="comment">// 错误，类型并集通过 CmpInf 间接并入了comparable</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bad3 <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">chan</span> <span class="keyword">int</span> | <span class="keyword">interface</span>&#123;comparable&#125;  <span class="comment">// 理所当然，这样也是不行的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>带方法的接口(无论是基本接口还是一般接口)，都不能写入接口的并集中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _ <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="keyword">int</span> | ~<span class="keyword">string</span> | error <span class="comment">// 错误，error是带方法的接口(一般接口) 不能写入并集中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DataProcessor[T any] <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="keyword">string</span> | ~[]<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">    Process(data T) (newData T)</span><br><span class="line">    Save(data T) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，实例化之后的 DataProcessor[string] 是带方法的一般接口，不能写入类型并集</span></span><br><span class="line"><span class="keyword">type</span> _ <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="keyword">int</span> | ~<span class="keyword">string</span> | DataProcessor[<span class="keyword">string</span>] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bad[T any] <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="keyword">int</span> | ~<span class="keyword">string</span> | DataProcessor[T]  <span class="comment">// 也不行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>泛型并不取代Go1.18之前用接口+反射实现的动态类型，在下面情景的时候非常适合使用泛型：当你需要针对不同类型书写同样的逻辑，使用泛型来简化代码是最好的 (比如你想写个队列，写个链表、栈、堆之类的数据结构）</p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://talkgo.org/t/topic/3582" target="_blank" rel="noopener">https://talkgo.org/t/topic/3582</a></li><li><a href="https://go.dev/doc/tutorial/generics" target="_blank" rel="noopener">https://go.dev/doc/tutorial/generics</a></li><li><a href="https://segmentfault.com/a/1190000041634906" target="_blank" rel="noopener">https://segmentfault.com/a/1190000041634906</a></li><li><a href="https://go.dev/blog/go1.18" target="_blank" rel="noopener">https://go.dev/blog/go1.18</a></li><li><a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md" target="_blank" rel="noopener">https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题背景&quot;&gt;&lt;/a&gt; 问题背景&lt;/h3&gt;
&lt;p&gt;Golang 在1.18 推出了新特性 泛型 Generics&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么要有泛型&lt;/li&gt;
&lt;li&gt;什么是泛
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go入门17-init</title>
    <link href="http://xboom.github.io/2022/09/12/Go/Go%E5%85%A5%E9%97%A817-init/"/>
    <id>http://xboom.github.io/2022/09/12/Go/Go%E5%85%A5%E9%97%A817-init/</id>
    <published>2022-09-12T10:22:10.000Z</published>
    <updated>2022-09-12T10:22:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>见下面的代码输出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> WhatIsThe = AnswerToLife()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AnswerToLife</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123; <span class="comment">// 2</span></span><br><span class="line">    WhatIsThe = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span> WhatIsThe == <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"It's all a lie."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//It's all a lie.</span></span><br></pre></td></tr></table></figure><p>Golang 中 init 的执行顺序</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/hVMYyqi6EU.png" alt="img" /></p><ol><li>如果一个包导入了其他包，则首先初始化导入的包。</li><li>然后初始化当前包的常量。</li><li>接下来初始化当前包的变量。</li><li>最后，调用当前包的 <code>init()</code> 函数</li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://stackoverflow.com/questions/24790175/when-is-the-init-function-run" target="_blank" rel="noopener">https://stackoverflow.com/questions/24790175/when-is-the-init-function-run</a></li><li><a href="https://learnku.com/go/t/47135" target="_blank" rel="noopener">https://learnku.com/go/t/47135</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;见下面的代码输出&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;b
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go入门16-工作区</title>
    <link href="http://xboom.github.io/2022/09/12/Go/Go%E5%85%A5%E9%97%A816-%E5%B7%A5%E4%BD%9C%E5%8C%BA/"/>
    <id>http://xboom.github.io/2022/09/12/Go/Go%E5%85%A5%E9%97%A816-%E5%B7%A5%E4%BD%9C%E5%8C%BA/</id>
    <published>2022-09-12T09:45:46.000Z</published>
    <updated>2022-09-12T09:45:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h3><p>Golang 在1.18 推出了新特性 <strong>workspace</strong> 工作区模式</p><ol><li>为什么要有 <strong>workspace</strong></li><li>什么是 <strong>workspace</strong></li><li>怎么使用 <strong>workspace</strong></li></ol><p>在工作过程中发现，模块的go.mod中添加了很多 <code>replace</code>，其实是为了解决依赖的问题。例如有2个<code>module</code>处于开发阶段，一个是<code>example.com/web</code>，一个是<code>example.com/util</code>。<code>example.com/web</code>依赖<code>example.com/util</code>的函数，当两个模块同时开发过程中，为了 <code>web</code> 模块能够时候用到最新的 <code>util</code> 模块代码，有两种方案</p><p><strong>方案1</strong>：就是将模块及时提交代码到代码仓库</p><ul><li>如果 <code>util</code> 有修改，那么就需要将代码提交到代码仓库，然后打上 tag</li><li>然后使用 go get -u 更新 main 中依赖的 util 的版本号(tag)</li></ul><blockquote><p>缺点：每次需要提交代码并更新到最新</p></blockquote><p><strong>方案2</strong>：使用go.mod中使用<code>replace</code>指令，见代码</p><p>目录结构:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module</span><br><span class="line">|-- web</span><br><span class="line">|    |-- go.mod</span><br><span class="line">     |-- main.go</span><br><span class="line">|-- util</span><br><span class="line">     |-- go.mod</span><br><span class="line">     |-- util.go</span><br></pre></td></tr></table></figure><p>文件<code>web/web.go</code> :</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"example.com/util"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">result := util.Add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件<code>web/go.mod</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module example.com/web</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.18</span></span><br><span class="line"></span><br><span class="line">require <span class="string">"example.com/util"</span> v0<span class="number">.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">replace <span class="string">"example.com/util"</span> =&gt; ../util</span><br></pre></td></tr></table></figure><p>文件<code>util/util.go</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package util</span><br><span class="line"></span><br><span class="line">func Add(a int, b int) int &#123;</span><br><span class="line">return a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件<code>util/go.mod</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module example.com/util</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.18</span></span><br></pre></td></tr></table></figure><p>通过<code>replace</code>指令，使用go命令编译代码的时候，会找到本地的util目录，这样<code>example.com/web</code>就可以使用到本地最新的<code>example.com/util</code>代码</p><blockquote><p>缺点：提交<code>example.com/web</code>这个module的代码到代码仓库时，需要删除最后的replace指令，否则其他开发者下载后会编译报错，因为他们本地可能没有util目录，或者util目录的路径和你的不一样</p></blockquote><h3 id="工作区"><a class="markdownIt-Anchor" href="#工作区"></a> 工作区</h3><p>为了解决方案2的痛点，Go1.18 新增了工作区模式(<strong>workspace mode</strong>)</p><p>去掉 <code>web/go.mod</code> 中的 <code>replace</code>命令</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module example.com/web</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.18</span></span><br><span class="line"></span><br><span class="line">require <span class="string">"example.com/util"</span> v0<span class="number">.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>在 web 模块中执行 <code>go run hello.go</code>，提示找不到依赖模块</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello.<span class="keyword">go</span>:<span class="number">6</span>:<span class="number">2</span>: missing <span class="keyword">go</span>.sum entry <span class="keyword">for</span> module providing <span class="keyword">package</span> example.com/util; to add:</span><br><span class="line">       <span class="keyword">go</span> mod download example.com/util</span><br></pre></td></tr></table></figure><p>使用 <code>go work init web util</code>指定工作模块 <code>web</code> 与 <code>util</code>，会生成 <code>go.work</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go 1.18</span><br><span class="line"></span><br><span class="line">use (</span><br><span class="line">./util</span><br><span class="line">./web</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中 <code>use</code> 用于表示需要指定的模块，再次执行 <code>go run hello.go</code>，则运行成功</p><p>目录结构</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module</span><br><span class="line">|-- go.work</span><br><span class="line">|-- web</span><br><span class="line">|    |-- go.mod</span><br><span class="line">     |-- main.go</span><br><span class="line">|-- util</span><br><span class="line">     |-- go.mod</span><br><span class="line">     |-- util.go</span><br></pre></td></tr></table></figure><h3 id="命令"><a class="markdownIt-Anchor" href="#命令"></a> 命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@13ce5bc74ac3:/code/module-workspace# go help work</span><br><span class="line">Usage:</span><br><span class="line">        go work &lt;command&gt; [arguments]</span><br><span class="line">The commands are:</span><br><span class="line"></span><br><span class="line">        edit        edit go.work from tools or scripts</span><br><span class="line">        init        initialize workspace file</span><br><span class="line">        sync        sync workspace build list to modules</span><br><span class="line">        use         add modules to workspace file</span><br><span class="line"></span><br><span class="line">Use "go help work &lt;command&gt;" for more information about a command.</span><br></pre></td></tr></table></figure><ol><li><p>通常情况下，建议不要提交 go.work 文件到 git上，因为它主要用于本地代码开发</p></li><li><p>推荐在 <code>$GOPATH</code> 路径下执行，生成 go.work 文件</p></li><li><p><code>go work init</code> 初始化工作区文件，用于生成go.work工作区文件</p></li><li><p><code>go work use</code> 添加新的模块到工作区间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> work use ./example 添加一个模块到工作区</span><br><span class="line"><span class="keyword">go</span> work use ./example ./example1 添加多个模块到工作区</span><br><span class="line"><span class="keyword">go</span> work use -r ./example 递归 ./example 目录到当前工作区</span><br></pre></td></tr></table></figure></li><li><p><code>go work edit</code> 用于编辑 go.work文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以使用 edit 命令编辑和手动编辑 go.work 文件效果是相同的 示例:</span></span><br><span class="line"><span class="keyword">go</span> work edit -fmt <span class="keyword">go</span>.work 重新格式化 <span class="keyword">go</span>.work 文件</span><br><span class="line"><span class="keyword">go</span> work edit -replace=github.com/link1st/example=./example <span class="keyword">go</span>.work 替换代码模块</span><br><span class="line"><span class="keyword">go</span> work edit -dropreplace=github.com/link1st/example 删除替换代码模块</span><br><span class="line"><span class="keyword">go</span> work edit -use=./example <span class="keyword">go</span>.work 添加新的模块到工作区</span><br><span class="line"><span class="keyword">go</span> work edit -dropuse=./example <span class="keyword">go</span>.work 从工作区中删除模块</span><br></pre></td></tr></table></figure></li><li><p><code>go work sync</code> 将工作区的构建列表同步到工作区的模块</p></li><li><p><code>go env GOWORK</code> 查看环境变量，查看当前工作区文件路径 可以排查工作区文件是否设置正确，<strong>go.work</strong> 路径找不到可以使用 <code>GOWORK</code> 指定，生成多个<code>go.work</code>则指向最后一次生成的路径</p></li><li><p><code>replace</code> 指令的语法与 go.mod 中的 <code>replace</code> 指令相同，并优先于 go.mod 文件中的替换。这是主要用于覆盖不同工作区中的冲突替换模块</p></li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://go.dev/blog/go1.18" target="_blank" rel="noopener">https://go.dev/blog/go1.18</a></li><li><a href="https://go.dev/doc/tutorial/workspaces" target="_blank" rel="noopener">https://go.dev/doc/tutorial/workspaces</a></li><li><a href="https://tonybai.com/2021/11/12/go-workspace-mode-in-go-1-18/" target="_blank" rel="noopener">https://tonybai.com/2021/11/12/go-workspace-mode-in-go-1-18/</a></li><li><a href="https://go.dev/ref/mod#workspaces" target="_blank" rel="noopener">https://go.dev/ref/mod#workspaces</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题背景&quot;&gt;&lt;/a&gt; 问题背景&lt;/h3&gt;
&lt;p&gt;Golang 在1.18 推出了新特性 &lt;strong&gt;workspace&lt;/strong&gt; 工作区模式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go入门15-Sync</title>
    <link href="http://xboom.github.io/2022/09/10/Go/Go%E5%85%A5%E9%97%A815-Sync/"/>
    <id>http://xboom.github.io/2022/09/10/Go/Go%E5%85%A5%E9%97%A815-Sync/</id>
    <published>2022-09-10T15:06:20.000Z</published>
    <updated>2022-09-10T15:06:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>Golang 源码 sync 包提供了同步操作</p><ol><li>互斥锁 <code>sync.Mutext</code></li><li>读写锁 <code>sync.RWMutex</code></li><li>等待组 <code>sync.WaitGroup</code></li><li>单次操作 <code>sync.Once</code></li><li>内存池 <code>sync.Pool</code></li><li>安全map <code>sync.Map</code></li><li>同步条件 <code>sync.Cond</code></li></ol><h3 id="mutex"><a class="markdownIt-Anchor" href="#mutex"></a> Mutex</h3><ol><li><p><code>Mutex</code>是一把<code>公平锁（Mutex fairness）</code></p></li><li><p><code>Mutex</code> 有两种模式：<strong>正常模式</strong> 和 <strong>饥饿模式</strong></p><ul><li><p><strong>正常模式</strong>：在正常模式，请求锁的 goroutines 是按照先进先出的顺序进行排队行程 <code>waiters</code> 的。 调用 <code>Unlock()</code> 方法释放锁资源时，如果发现有等待唤起的 <code>waiter</code> 时，则会将队头的 <code>waiter</code> 唤起。被唤起后调用CAS方法去尝试 修改锁的状态，如果修改成功则表示占有锁的资源成功。</p><blockquote><p>锁一共有三个状态：锁住状态、唤起状态、饥饿状态</p></blockquote></li><li><p><strong>饥饿模式</strong>：当调用 <code>Unlock()</code>方法释放锁资源的时候，唤起的 <code>waiter</code> <code>G1</code> 需要通过 CAS 操作获取锁资源，如果此时有新请求锁资源的 goroutine <code>G2</code>，那么它们会一起通过 CAS 方法竞争获取锁资源。当不断有<code>G2</code>来进行锁资源争夺，就有可能导致 <code>G1</code> 一直无法获取到 锁资源而<strong>饿死</strong>，所以Go采用<strong>饥饿模式</strong></p><ul><li>当 <code>G1</code> 在超过一定时间获取不到资源之后，会在 <code>Unlock</code> 释放锁资源时，直接将锁的资源交给 <code>G1</code>，并且将当前状态改为 <strong>饥饿模式</strong></li><li>当 <code>G1</code> 获取到锁的所有权时，发现自己是队列中最后一个<code>waiter</code>或者自己等待时间小于<code>1ms</code>，那么锁将切换回<strong>正常模式</strong></li></ul></li></ul></li><li><p><strong>正常模式</strong>拥有非常好的性能表现，因为即使存在阻塞的 <code>waiter</code>，一个goroutine也能够多次获取锁。</p></li><li><p><strong>饥饿模式</strong>对于预防极端的长尾时延(tail latency)</p></li></ol><h4 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h4><p><strong>代码路径</strong>：<code>/go/src/sync/mutex.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">Lock()</span><br><span class="line">Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mutex 是互斥锁。</span></span><br><span class="line"><span class="comment">// 互斥锁的零值是未锁定的互斥锁。</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">state <span class="keyword">int32</span><span class="comment">//锁的状态</span></span><br><span class="line">sema  <span class="keyword">uint32</span>    <span class="comment">//信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mutex 结构体有两个字段：</p><ol><li><code>state</code>: 表示当前互斥锁的状态</li><li><code>sema</code>: 是个信号量变量，用来控制等待 goroutine 的阻塞休眠和唤醒</li></ol><blockquote><p>注意，首次使用后不要进行Mutex的值拷贝，否则 Mutex 会失效</p></blockquote><p><code>state</code> 状态字段代表多个意思，<code>mutexWaiterShift = 3</code>低三位记录三种状态，剩下的位置，用来表示可以有<code>1&lt;&lt;(32-3)</code>个 Goroutine 等待互斥锁的释放</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/20201218225206.png" alt="Group 1" /></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// 表示当前对象锁的状态 0-未锁住，1-已锁住</span></span><br><span class="line">mutexWoken <span class="comment">//表示当前对象是否被唤醒 0-唤醒，1-未唤醒</span></span><br><span class="line">mutexStarving <span class="comment">//表示当前对象是否为饥饿模式 0-正常模式，1为饥饿模式</span></span><br><span class="line">mutexWaiterShift = <span class="literal">iota</span> <span class="comment">//从倒数第四位往前的bit位表示在排队等待的goroutine</span></span><br><span class="line">  starvationThresholdNs = <span class="number">1e6</span>  <span class="comment">//1ms</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="自旋"><a class="markdownIt-Anchor" href="#自旋"></a> 自旋</h4><p>互斥锁中提到了比较重要的自旋操作</p><p><strong>runtime_canSpin</strong>：比较保守的自旋，golang中自旋锁并不会一直自旋下去，在runtime包中<code>runtime_canSpin</code>方法做了一些限制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断能否自旋</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_canSpin</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. i 大于 active_spin = 4 的时候不能自旋</span></span><br><span class="line">  <span class="comment">// 2. 机器是单核 的时候不能自旋</span></span><br><span class="line">  <span class="comment">// 3. gomaxprocs 小于 (闲置的p + 自旋的m + 1) 的时候不能自旋</span></span><br><span class="line">  <span class="comment">// 4. 本地队列不为空 的时候不能自旋</span></span><br><span class="line"><span class="keyword">if</span> i &gt;= active_spin || ncpu &lt;= <span class="number">1</span> || gomaxprocs &lt;= <span class="keyword">int32</span>(sched.npidle+sched.nmspinning)+<span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p := getg().m.p.ptr(); !runqempty(p) &#123;  <span class="comment">//本地可运行G队列不为空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**runtime_doSpin：**会调用<code>procyield</code>函数，该函数也是汇编语言实现。函数内部循环调用PAUSE指令。PAUSE指令什么都不做，但是会消耗CPU时间，在执行PAUSE指令时，CPU不会对它做不必要的优化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_doSpin</span><span class="params">()</span></span> &#123;</span><br><span class="line">procyield(active_spin_cnt)<span class="comment">//自旋操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEXT runtime·procyield(SB),NOSPLIT,$<span class="number">0</span><span class="number">-0</span></span><br><span class="line">MOVLcycles+<span class="number">0</span>(FP), AX</span><br><span class="line">again:</span><br><span class="line">PAUSE<span class="comment">//空命令</span></span><br><span class="line">SUBL$<span class="number">1</span>, AX</span><br><span class="line">JNZagain</span><br><span class="line">RET</span><br></pre></td></tr></table></figure><h4 id="lock"><a class="markdownIt-Anchor" href="#lock"></a> Lock</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line"><span class="comment">//...竞争检测</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Slow path (outlined so that the fast path can be inlined)</span></span><br><span class="line">m.lockSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加锁首先会使用 <code>CompareAndSwapInt32</code> 看能不能拿到锁，否则进入到 <code>lockSlow</code> 流程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果*addr中的值 与 old 相等，则将 *addr与 new进行交换，并返回true,否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt32</span><span class="params">(addr *<span class="keyword">int32</span>, old, <span class="built_in">new</span> <span class="keyword">int32</span>)</span> <span class="params">(swapped <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure><h5 id="lockslow"><a class="markdownIt-Anchor" href="#lockslow"></a> lockSlow</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">lockSlow</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> waitStartTime <span class="keyword">int64</span><span class="comment">//当前groutine的等待时间</span></span><br><span class="line">starving := <span class="literal">false</span><span class="comment">//当前goroutine是否是饥饿标记</span></span><br><span class="line">awoke := <span class="literal">false</span><span class="comment">//当前goroutine是否是唤醒标记</span></span><br><span class="line">iter := <span class="number">0</span><span class="comment">//当前goroutine自旋次数自旋次数</span></span><br><span class="line">old := m.state<span class="comment">//copy锁的状态为历史状态</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在饥饿模式不进行自旋，锁的所有权会直接移交给waiters。</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 当锁是locked状态并且当前goroutine可以自旋时，开始自旋。</span></span><br><span class="line"> <span class="comment">// 当锁是starving状态，就直接false，不自旋</span></span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line"><span class="comment">// 触发自旋是有意义的。</span></span><br><span class="line"><span class="comment">// 尝试设置woken标志来通知unlock，以便不唤起其他阻塞的goroutines</span></span><br><span class="line"><span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">        <span class="comment">// 如果当前goroutine是未唤醒状态，互斥锁也是未唤醒状态，并且互斥锁的waiter数量不等于0，</span></span><br><span class="line"><span class="comment">// 就比较锁的最新状态（m.state）和历史状态（old），如果未发生改变，将锁的状态更新为woken。</span></span><br><span class="line"><span class="comment">// 并且设置当前goroutine为awoke状态。</span></span><br><span class="line">awoke = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">//自旋</span></span><br><span class="line">runtime_doSpin()</span><br><span class="line">      <span class="comment">//自旋次数增加</span></span><br><span class="line">iter++</span><br><span class="line">      <span class="comment">// copy锁的状态为历史状态，自旋期间其他goroutine可能修改了state，所以要更新</span></span><br><span class="line">old = m.state</span><br><span class="line">      <span class="comment">// 继续尝试自旋</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此时，到这里有两个可能：</span></span><br><span class="line">    <span class="comment">//1. 锁的状态发生了变化(唤起状态、饥饿状态)</span></span><br><span class="line">    <span class="comment">//2. 无法继续进行自旋</span></span><br><span class="line">    <span class="built_in">new</span> := old <span class="comment">// copy锁的历史状态为new状态(为什么不是直接获取m.state)</span></span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 如果锁的历史状态（old）不是starving状态，将锁的新状态（new）更新为locked状态</span></span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">new</span> |= mutexLocked</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 如果锁的历史状态（old）是locked状态或者是starving状态，将锁的waiter数量加1</span></span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift<span class="comment">//注意 waiter数量怎样记录数量的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前goroutine是starving状态且锁的历史状态（old）是locked状态，将锁的新状态(new）更新为starving状态</span></span><br><span class="line"><span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">new</span> |= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前goroutine是awoke状态</span></span><br><span class="line"><span class="keyword">if</span> awoke &#123;</span><br><span class="line"><span class="comment">// 锁的状态是非唤醒状态则直接报错</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"sync: inconsistent mutex state"</span>)</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// &amp;^ 是 bit clear (AND NOT)</span></span><br><span class="line"><span class="comment">// 取消锁的新状态（new）的woken状态标志。</span></span><br><span class="line"><span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 比较锁的最新状态（m.state）和历史状态（old），如果未发生改变，那么更新为new。</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">      <span class="comment">//如果cas更新成功，并且锁的历史状态（old）即不是locked也不是starving，那么结束循环，通过CAS加锁成功。</span></span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果之前已经等待，将排在队列前面。</span></span><br><span class="line"><span class="comment">// 当前goroutine是否等待过。</span></span><br><span class="line">queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 如果开始等待时间为0，更新为当前时间为开始等待时间。</span></span><br><span class="line"><span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">waitStartTime = runtime_nanotime()</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 通过信号量获取锁</span></span><br><span class="line"><span class="comment">// runtime实现代码：https://github.com/golang/go/blob/go1.15.5/src/runtime/sema.go#L69-L72</span></span><br><span class="line"><span class="comment">// runtime信号量获取：https://github.com/golang/go/blob/go1.15.5/src/runtime/sema.go#L98-L153</span></span><br><span class="line">runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 如果当前goroutine是starving状态或者等待时间大于1ms，更新当前goroutine为starving状态。</span></span><br><span class="line">starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 更新锁的历史状态（old）</span></span><br><span class="line">      old = m.state</span><br><span class="line">      </span><br><span class="line"><span class="comment">//锁是饥饿状态</span></span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123; </span><br><span class="line"><span class="comment">// 如果当前goroutine是唤醒状态并且锁在饥饿模式，</span></span><br><span class="line"><span class="comment">// 锁的所有权转移给当前goroutine，但是锁处于不一致的状态中：mutexLocked没有设置</span></span><br><span class="line"><span class="comment">// 并且我们将任然被认为是waiter。这个状态需要被修复。</span></span><br><span class="line"><span class="comment">// 如果锁的历史状态（old）是locked或者woken的，或者waiters的数量不为0，触发锁状态异常。</span></span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"sync: inconsistent mutex state"</span>)</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 当前goroutine获取锁，waiter数量-1</span></span><br><span class="line">delta := <span class="keyword">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前goroutine不是starving状态或者锁的历史状态（old）的waiter数量是1，delta减去3。</span></span><br><span class="line"><span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// 退出饥饿模式</span></span><br><span class="line"><span class="comment">// 在这里这么做至关重要，还要考虑等待时间。</span></span><br><span class="line"><span class="comment">// 饥饿模式是非常低效率的，一旦两个goroutine将互斥锁切换为饥饿模式，它们便可以无限锁。</span></span><br><span class="line">delta -= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 更新锁的状态</span></span><br><span class="line">atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line"><span class="keyword">break</span><span class="comment">//退出自旋</span></span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 当前goroutine更新为awoke状态</span></span><br><span class="line">awoke = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 当前goroutine自旋次数清零</span></span><br><span class="line">iter = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 更新锁的历史状态（old） //当在处理 new 状态的时候 锁的状态发生了变化，那么重新复制 old 再进行逻辑判断</span></span><br><span class="line">old = m.state</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//for end</span></span><br><span class="line"><span class="comment">//...竞争判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="unlock"><a class="markdownIt-Anchor" href="#unlock"></a> Unlock</h4><p>解锁的前提是加锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//竞争..</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果waiter数量为0，三个标志位去除locked后也为0，那么可以直接解锁了。</span></span><br><span class="line"><span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123;</span><br><span class="line">m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="unlockslow"><a class="markdownIt-Anchor" href="#unlockslow"></a> unlockSlow</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">unlockSlow</span><span class="params">(<span class="built_in">new</span> <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123; <span class="comment">// 当new不是锁住状态</span></span><br><span class="line">throw(<span class="string">"sync: unlock of unlocked mutex"</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//如果不是饥饿模式</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">old := <span class="built_in">new</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 如果waiter数量为0，锁的三个标志位任一非0，直接返回</span></span><br><span class="line"><span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尝试将锁更新为woken状态，如果成功了，就通过信号量去唤醒goroutine</span></span><br><span class="line"><span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">old = m.state</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Starving mode: handoff mutex ownership to the next waiter, and yield</span></span><br><span class="line"><span class="comment">// our time slice so that the next waiter can start to run immediately.</span></span><br><span class="line"><span class="comment">// Note: mutexLocked is not set, the waiter will set it after wakeup.</span></span><br><span class="line"><span class="comment">// But mutex is still considered locked if mutexStarving is set,</span></span><br><span class="line"><span class="comment">// so new coming goroutines won't acquire it.</span></span><br><span class="line">    <span class="comment">// 饥饿模式直接手把手交接锁的控制权</span></span><br><span class="line">runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><ol><li>互斥锁只有在普通模式才能进入自旋</li><li>能够自旋的条件：a. 需要运行在多 CPU 的机器上；b. 当前的Goroutine 为了获取该锁进入自旋的次数小于四次；c. 当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空</li><li>一旦当前 Goroutine 能够进入自旋就会调用runtime.sync_runtime_doSpin 和 runtime.procyield 并执行 30 次的 PAUSE 指令，该指令只会占用 CPU 并消耗 CPU 时间</li></ol><h3 id="rwmutex"><a class="markdownIt-Anchor" href="#rwmutex"></a> RWMutex</h3><p>读写互斥锁 sync.RWMutex 是细粒度的互斥锁，它不限制资源的并发读，但是读写、写写操作无法并行执行</p><h4 id="实现原理-2"><a class="markdownIt-Anchor" href="#实现原理-2"></a> 实现原理</h4><p><strong>代码路径</strong>：/go/src/sync/rwmutex.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">w           Mutex  <span class="comment">// 复制原子锁的能力</span></span><br><span class="line">writerSem   <span class="keyword">uint32</span> <span class="comment">// 写等待读完成信号量</span></span><br><span class="line">readerSem   <span class="keyword">uint32</span> <span class="comment">// 读等待写完成信号量</span></span><br><span class="line">readerCount <span class="keyword">int32</span>  <span class="comment">// 当前正在执行的读操作的数量</span></span><br><span class="line">readerWait  <span class="keyword">int32</span>  <span class="comment">// 当写操作被阻塞时等待的读操作个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rwmutexMaxReaders = <span class="number">1</span> &lt;&lt; <span class="number">30</span></span><br></pre></td></tr></table></figure><blockquote><p>同理，首次使用后不要进行值拷贝，否则会失效</p></blockquote><h4 id="写锁"><a class="markdownIt-Anchor" href="#写锁"></a> 写锁</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//竞争检查</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 首先调用锁的能力，阻塞后续的写</span></span><br><span class="line">rw.w.Lock()</span><br><span class="line"><span class="comment">// Announce to readers there is a pending writer.</span></span><br><span class="line">r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line"><span class="comment">// Wait for active readers.</span></span><br><span class="line"><span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//竞争检查</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取写锁时会先阻塞写锁的获取，后阻塞读锁的获取，这种策略能够保证读操作不会被连续的写操作饿死</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//竞争检查...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Announce to readers there is no active writer.</span></span><br><span class="line">r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line"><span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123;</span><br><span class="line">race.Enable()</span><br><span class="line">throw(<span class="string">"sync: Unlock of unlocked RWMutex"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Unblock blocked readers, if any.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(r); i++ &#123;</span><br><span class="line">runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Allow other writers to proceed.</span></span><br><span class="line">rw.w.Unlock()</span><br><span class="line"><span class="comment">//竞争检查</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读锁"><a class="markdownIt-Anchor" href="#读锁"></a> 读锁</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//竞争检查...</span></span><br><span class="line"><span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// A writer is pending, wait for it.</span></span><br><span class="line">runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//竞争检查...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//竞争检查...</span></span><br><span class="line"><span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Outlined slow-path to allow the fast-path to be inlined</span></span><br><span class="line">rw.rUnlockSlow(r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//竞争检查...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">rUnlockSlow</span><span class="params">(r <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders &#123;</span><br><span class="line">race.Enable()</span><br><span class="line">throw(<span class="string">"sync: RUnlock of unlocked RWMutex"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A writer is pending.</span></span><br><span class="line"><span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// The last reader unblocks the writer.</span></span><br><span class="line">runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="waitgroup"><a class="markdownIt-Anchor" href="#waitgroup"></a> WaitGroup</h3><p><code>WaitGroup</code> 等待一组 goroutine 完成，主 goroutine 调用 <code>Add</code> 设置数量要等待的 goroutine。然后每个 goroutine 完成后运行并调用 <code>Done</code>。同时，等待可用于阻塞，直到所有 goroutine 完成。</p><p>代码路径：<code>go/src/sync/waitgroup.go</code></p><h4 id="实现原理-3"><a class="markdownIt-Anchor" href="#实现原理-3"></a> 实现原理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">noCopy noCopy</span><br><span class="line"></span><br><span class="line"><span class="comment">// 64 位值：高 32 位是计数器，低 32 位是等待者的数量。</span></span><br><span class="line"><span class="comment">// 64位原子操作需要64位对齐，但是32位编译器只保证 64 位字段是 32 位对齐的。</span></span><br><span class="line"><span class="comment">// 出于这个原因，在 32 位架构上，需要检查 state()，判断 state1 是否对齐并自动“交换”字段顺序</span></span><br><span class="line">state1 <span class="keyword">uint64</span></span><br><span class="line">state2 <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同理，首次使用后不要进行值拷贝，否则会失效</p></blockquote><h4 id="state"><a class="markdownIt-Anchor" href="#state"></a> state</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">state</span><span class="params">()</span> <span class="params">(statep *<span class="keyword">uint64</span>, semap *<span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> unsafe.Alignof(wg.state1) == <span class="number">8</span> || <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;wg.state1))%<span class="number">8</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// state1 is 64-bit aligned: nothing to do.</span></span><br><span class="line"><span class="keyword">return</span> &amp;wg.state1, &amp;wg.state2</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// state1 is 32-bit aligned but not 64-bit aligned: this means that</span></span><br><span class="line"><span class="comment">// (&amp;state1)+4 is 64-bit aligned.</span></span><br><span class="line">state := (*[<span class="number">3</span>]<span class="keyword">uint32</span>)(unsafe.Pointer(&amp;wg.state1))</span><br><span class="line"><span class="keyword">return</span> (*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;state[<span class="number">1</span>])), &amp;state[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="adddone"><a class="markdownIt-Anchor" href="#adddone"></a> Add/Done</h4><p><code>Add(n)</code> 表示添加一个等待</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">statep, semap := wg.state()</span><br><span class="line"><span class="comment">//竞争检查...</span></span><br><span class="line">state := atomic.AddUint64(statep, <span class="keyword">uint64</span>(delta)&lt;&lt;<span class="number">32</span>)</span><br><span class="line">v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">w := <span class="keyword">uint32</span>(state)</span><br><span class="line"><span class="comment">//竞争检查...</span></span><br><span class="line"><span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"sync: negative WaitGroup counter"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; delta &gt; <span class="number">0</span> &amp;&amp; v == <span class="keyword">int32</span>(delta) &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"sync: WaitGroup misuse: Add called concurrently with Wait"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// This goroutine has set counter to 0 when waiters &gt; 0.</span></span><br><span class="line"><span class="comment">// Now there can't be concurrent mutations of state:</span></span><br><span class="line"><span class="comment">// - Adds must not happen concurrently with Wait,</span></span><br><span class="line"><span class="comment">// - Wait does not increment waiters if it sees counter == 0.</span></span><br><span class="line"><span class="comment">// Still do a cheap sanity check to detect WaitGroup misuse.</span></span><br><span class="line"><span class="keyword">if</span> *statep != state &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"sync: WaitGroup misuse: Add called concurrently with Wait"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Reset waiters count to 0.</span></span><br><span class="line">*statep = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">runtime_Semrelease(semap, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Done()</code> 操作其实是 减1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="wait"><a class="markdownIt-Anchor" href="#wait"></a> Wait</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">statep, semap := wg.state()</span><br><span class="line">  </span><br><span class="line"><span class="comment">//竞争检查...</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">state := atomic.LoadUint64(statep)</span><br><span class="line">v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">w := <span class="keyword">uint32</span>(state)</span><br><span class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Counter is 0, no need to wait.</span></span><br><span class="line"><span class="comment">//竞争检查...</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Increment waiters count.</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//竞争检查...</span></span><br><span class="line">runtime_Semacquire(semap)</span><br><span class="line"><span class="keyword">if</span> *statep != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"sync: WaitGroup is reused before previous Wait has returned"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//竞争检查...</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="once"><a class="markdownIt-Anchor" href="#once"></a> Once</h3><p><code>Once</code> 是一个仅执行一次操作的对象</p><h4 id="使用例子"><a class="markdownIt-Anchor" href="#使用例子"></a> 使用例子</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d sync.Once</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">d.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hello</span></span><br></pre></td></tr></table></figure><p>循环执行打印输出操作，不同的是使用 <code>sync.Once</code> 对象执行打印方法，仅执行一次。并发执行效果一致</p><h4 id="实现原理-4"><a class="markdownIt-Anchor" href="#实现原理-4"></a> 实现原理</h4><p>代码路径：<code>/go/src/sync/once.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">done <span class="keyword">uint32</span><span class="comment">//done 表示动作是否已经执行</span></span><br><span class="line">m    Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行函数逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123;<span class="comment">//如果不等于0直接退出</span></span><br><span class="line"><span class="comment">// Outlined slow-path to allow inlining of the fast-path.</span></span><br><span class="line">o.doSlow(f)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">doSlow</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">o.m.Lock()</span><br><span class="line"><span class="keyword">defer</span> o.m.Unlock()<span class="comment">//通过获取锁来进行done状态修改</span></span><br><span class="line"><span class="keyword">if</span> o.done == <span class="number">0</span> &#123;<span class="comment">//这里直接使用o.done</span></span><br><span class="line"><span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>直接使用 <code>o.done == 0</code> 判断是否执行过的原因是上面获取到了写锁</li><li>将 <code>atomic.StoreUint32(&amp;o.done, 1)</code>放置在 <code>f()</code> 的后面从而保证当 <code>done</code> 变化，<code>f()</code> 已经执行完毕</li></ol><p>在注释中，它提到了另外一种错误的实现方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapUint32(&amp;o.done, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Do()</code> 保证当它返回时，f 已经完成。此实现不会实现该保证：给定两个同时调用，cas 的获胜者将调用 f，第二个会立即返回，没有等待第一个对 f 的调用完成。</p><h3 id="cond"><a class="markdownIt-Anchor" href="#cond"></a> Cond</h3><p><code>sync.Cond</code> 条件变量用来协调想要访问共享资源的那些 goroutine，当共享资源的状态发生变化的时候，它可以用来通知被互斥锁阻塞的 goroutine</p><ol><li>它和互斥锁的区别是：互斥锁 <code>sync.Mutex</code> 通常用来保护临界区和共享资源，条件变量 <code>sync.Cond</code> 用来协调想要访问共享资源的 goroutine</li><li>注意点：每个Cond都会关联一个 Lock(<code>*sync.Mutex</code> or <code>*sync.RWMutex</code>)，当修改条件或者调用Wait方法时，必须加锁保护condition</li></ol><h4 id="使用案例"><a class="markdownIt-Anchor" href="#使用案例"></a> 使用案例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">(name <span class="keyword">string</span>, c *sync.Cond)</span></span> &#123;</span><br><span class="line">c.L.Lock()</span><br><span class="line"><span class="keyword">for</span> !done &#123;</span><br><span class="line">log.Println(name, <span class="string">"starts wait"</span>)</span><br><span class="line">c.Wait()</span><br><span class="line">log.Println(name, <span class="string">"end wait"</span>)</span><br><span class="line">&#125;</span><br><span class="line">c.L.Unlock()</span><br><span class="line">  log.Println(name, <span class="string">"end reading"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(name <span class="keyword">string</span>, c *sync.Cond)</span></span> &#123;</span><br><span class="line">log.Println(name, <span class="string">"starts writing"</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">c.L.Lock()</span><br><span class="line">done = <span class="literal">true</span></span><br><span class="line">c.L.Unlock()</span><br><span class="line">log.Println(name, <span class="string">"wakes all"</span>)</span><br><span class="line">c.Broadcast()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">cond := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> read(<span class="string">"reader1"</span>, cond)</span><br><span class="line"><span class="keyword">go</span> read(<span class="string">"reader2"</span>, cond)</span><br><span class="line"><span class="keyword">go</span> read(<span class="string">"reader3"</span>, cond)</span><br><span class="line">write(<span class="string">"writer"</span>, cond)</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>done</code> 即互斥锁需要保护的条件变量。</li><li><code>read()</code> 调用 <code>Wait()</code> 等待通知，直到 done 为 true。</li><li><code>write()</code> 接收数据，接收完成后，将 done 置为 true，调用 <code>Broadcast()</code> 通知所有等待的协程。</li><li><code>write()</code> 中的暂停了 1s，一方面是模拟耗时，另一方面是确保前面的 3 个 read 协程都执行到 <code>Wait()</code>，处于等待状态。main 函数最后暂停了 3s，确保所有操作执行完毕</li></ul><p>运行结果如下；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2022/09/10 22:40:00 writer starts writing</span><br><span class="line">2022/09/10 22:40:00 reader1 starts wait</span><br><span class="line">2022/09/10 22:40:00 reader2 starts wait</span><br><span class="line">2022/09/10 22:40:00 reader3 starts wait</span><br><span class="line">2022/09/10 22:40:01 writer wakes all</span><br><span class="line">2022/09/10 22:40:01 reader3 end wait</span><br><span class="line">2022/09/10 22:40:01 reader3 end reading</span><br><span class="line">2022/09/10 22:40:01 reader1 end wait</span><br><span class="line">2022/09/10 22:40:01 reader1 end reading</span><br><span class="line">2022/09/10 22:40:01 reader2 end wait</span><br><span class="line">2022/09/10 22:40:01 reader2 end reading</span><br></pre></td></tr></table></figure><p>注意点：</p><ol><li>每次都是 <code>end reading</code> 下一个才会开始执行，原因其实是 <code>c.L.Unlock()</code>，只有释放锁然后其他<code>Wait()</code>中才能获取写锁继续执行</li><li>因为 <code>done = false</code> 所以所有的 <strong>reader</strong> 都进入 wait，但是在构建条件 sync.Cond的时候传入的是锁，那么它又是怎么跟 done 以及 Broadcast 联系在一起的呢？其实没有关系，<code>done</code> 只是用于判断是否重复进入 <code>Wait()</code></li></ol><p>当去掉 done 的变换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(name <span class="keyword">string</span>, c *sync.Cond)</span></span> &#123;</span><br><span class="line">log.Println(name, <span class="string">"starts writing"</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="comment">// c.L.Lock()</span></span><br><span class="line"><span class="comment">// done = true</span></span><br><span class="line"><span class="comment">// c.L.Unlock()</span></span><br><span class="line">log.Println(name, <span class="string">"wakes all"</span>)</span><br><span class="line">c.Broadcast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果变成了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2022</span>/<span class="number">09</span>/<span class="number">10</span> <span class="number">22</span>:<span class="number">46</span>:<span class="number">14</span> writer starts writing</span><br><span class="line"><span class="number">2022</span>/<span class="number">09</span>/<span class="number">10</span> <span class="number">22</span>:<span class="number">46</span>:<span class="number">14</span> reader3 starts wait</span><br><span class="line"><span class="number">2022</span>/<span class="number">09</span>/<span class="number">10</span> <span class="number">22</span>:<span class="number">46</span>:<span class="number">14</span> reader1 starts wait</span><br><span class="line"><span class="number">2022</span>/<span class="number">09</span>/<span class="number">10</span> <span class="number">22</span>:<span class="number">46</span>:<span class="number">14</span> reader2 starts wait</span><br><span class="line"><span class="number">2022</span>/<span class="number">09</span>/<span class="number">10</span> <span class="number">22</span>:<span class="number">46</span>:<span class="number">15</span> writer wakes all</span><br><span class="line"><span class="number">2022</span>/<span class="number">09</span>/<span class="number">10</span> <span class="number">22</span>:<span class="number">46</span>:<span class="number">15</span> reader2 end wait</span><br><span class="line"><span class="number">2022</span>/<span class="number">09</span>/<span class="number">10</span> <span class="number">22</span>:<span class="number">46</span>:<span class="number">15</span> reader2 starts wait</span><br><span class="line"><span class="number">2022</span>/<span class="number">09</span>/<span class="number">10</span> <span class="number">22</span>:<span class="number">46</span>:<span class="number">15</span> reader3 end wait</span><br><span class="line"><span class="number">2022</span>/<span class="number">09</span>/<span class="number">10</span> <span class="number">22</span>:<span class="number">46</span>:<span class="number">15</span> reader3 starts wait</span><br><span class="line"><span class="number">2022</span>/<span class="number">09</span>/<span class="number">10</span> <span class="number">22</span>:<span class="number">46</span>:<span class="number">15</span> reader1 end wait</span><br><span class="line"><span class="number">2022</span>/<span class="number">09</span>/<span class="number">10</span> <span class="number">22</span>:<span class="number">46</span>:<span class="number">15</span> reader1 starts wait</span><br></pre></td></tr></table></figure><p>可以看出来，当 <code>Broadcast</code>的时候 wait 才会返回，由于 done 没有变化，所以<strong>reader</strong>重新进入了<code>Wait</code>状态</p><h4 id="实现原理-5"><a class="markdownIt-Anchor" href="#实现原理-5"></a> 实现原理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">noCopy noCopy</span><br><span class="line"></span><br><span class="line"><span class="comment">// L is held while observing or changing the condition</span></span><br><span class="line">L Locker</span><br><span class="line"></span><br><span class="line">notify  notifyList</span><br><span class="line">checker copyChecker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> &#123;</span><br><span class="line">wait   <span class="keyword">uint32</span></span><br><span class="line">notify <span class="keyword">uint32</span></span><br><span class="line">lock   <span class="keyword">uintptr</span> <span class="comment">// key field of the mutex</span></span><br><span class="line">head   unsafe.Pointer</span><br><span class="line">tail   unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> copyChecker <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否复制过</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *copyChecker)</span> <span class="title">check</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uintptr</span>(*c) != <span class="keyword">uintptr</span>(unsafe.Pointer(c)) &amp;&amp;</span><br><span class="line">!atomic.CompareAndSwapUintptr((*<span class="keyword">uintptr</span>)(c), <span class="number">0</span>, <span class="keyword">uintptr</span>(unsafe.Pointer(c))) &amp;&amp;</span><br><span class="line"><span class="keyword">uintptr</span>(*c) != <span class="keyword">uintptr</span>(unsafe.Pointer(c)) &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"sync.Cond is copied"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span> *<span class="title">Cond</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Cond&#123;L: l&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li><code>noCopy</code> 只在 <code>go vet</code> 语法检测的时候有效。即使发生拷贝，编译与运行都能正常的运行</li></ol><h5 id="wait-2"><a class="markdownIt-Anchor" href="#wait-2"></a> Wait</h5><p><code>Wait()</code>会自动释放<code>c.L</code>，并挂起调用者的goroutine。之后恢复执行，<code>Wait()</code>会在返回时对<code>c.L</code>加锁。除非被Signal或者Broadcast唤醒，否则<code>Wait()</code>不会返回。由于<code>Wait()</code>第一次恢复时，<code>C.L</code>并没有加锁，所以当Wait返回时，调用者通常并不能假设条件为真。取而代之的是, 调用者应该在循环中调用Wait。(简单来说，只要想使用condition，就必须加锁)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.checker.check()</span><br><span class="line">t := runtime_notifyListAdd(&amp;c.notify)<span class="comment">//添加通知</span></span><br><span class="line">c.L.Unlock()<span class="comment">//释放锁</span></span><br><span class="line">runtime_notifyListWait(&amp;c.notify, t)<span class="comment">//等待通知 </span></span><br><span class="line">c.L.Lock()    <span class="comment">//加锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对条件的检查，使用了 <code>for !condition()</code> 而非 <code>if</code>，是因为当前协程被唤醒时，条件不一定符合要求，需要再次 Wait 等待下次被唤醒。为了保险起见，使用 <code>for</code> 能够确保条件符合要求后，再执行后续的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c.L.Lock()</span><br><span class="line"><span class="keyword">for</span> !condition() &#123;</span><br><span class="line">    c.Wait()</span><br><span class="line">&#125;</span><br><span class="line">... <span class="built_in">make</span> use of condition ...</span><br><span class="line">c.L.Unlock()</span><br></pre></td></tr></table></figure><h5 id="singal"><a class="markdownIt-Anchor" href="#singal"></a> Singal</h5><p><code>Signal</code>只唤醒1个等待c的goroutine。</p><p>调用Signal的时候，可以加锁，也可以不加锁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.checker.check()</span><br><span class="line">runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="boardcase"><a class="markdownIt-Anchor" href="#boardcase"></a> Boardcase</h5><p><code>Broadcast</code>会唤醒所有等待c 的 goroutine</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.checker.check()</span><br><span class="line">runtime_notifyListNotifyAll(&amp;c.notify)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3><ol><li>这里一直出现的 <code>race</code> 到底是干嘛的后续文章说明</li><li>这里一直出现的 <code>runtime_Semacquire</code> 是干嘛的后续文章说明</li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://www.modb.pro/db/170131" target="_blank" rel="noopener">https://www.modb.pro/db/170131</a></li><li><a href="https://vearne.cc/archives/680" target="_blank" rel="noopener">https://vearne.cc/archives/680</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Golang 源码 sync 包提供了同步操作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;互斥锁 &lt;code&gt;sync.Mutext&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;读写锁 &lt;code&gt;sync.RWMutex&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;等待组 &lt;code&gt;sync.WaitGrou
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go入门13-style</title>
    <link href="http://xboom.github.io/2022/09/10/Go/Go%E5%85%A5%E9%97%A813-style/"/>
    <id>http://xboom.github.io/2022/09/10/Go/Go%E5%85%A5%E9%97%A813-style/</id>
    <published>2022-09-10T15:05:52.000Z</published>
    <updated>2022-09-10T15:05:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>所有代码都应该通过<code>golint</code>和<code>go vet</code>的检查并无错误。建议将编辑器设置为：</p><ul><li>保存时运行 <code>goimports</code></li><li>运行 <code>golint</code> 和 <code>go vet</code> 检查错误</li></ul><h2 id="指导原则"><a class="markdownIt-Anchor" href="#指导原则"></a> 指导原则</h2><h3 id="指向-interface-的指针"><a class="markdownIt-Anchor" href="#指向-interface-的指针"></a> 指向 interface 的指针</h3><p>应该将接口作为值进行传递，在这样的传递过程中，实质上传递的底层数据仍然可以是指针。接口实质上在底层用两个字段表示：</p><ol><li>一个指向某些特定类型信息的指针。可以将其视为&quot;type&quot;。</li><li>数据指针。如果存储的数据是指针，则直接存储。如果存储的数据是一个值，则存储指向该值的指针。</li></ol><p>如果希望接口方法修改基础数据，则必须使用指针传递 (将对象指针赋值给接口变量)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> F <span class="keyword">interface</span> &#123;</span><br><span class="line">  f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S1)</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S2)</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f1.f() 无法修改底层数据</span></span><br><span class="line"><span class="comment">// f2.f() 可以修改底层数据，给接口变量 f2 赋值时使用的是对象指针</span></span><br><span class="line"><span class="keyword">var</span> f1 F = S1&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f2 F = &amp;S2&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="interface-合理性验证"><a class="markdownIt-Anchor" href="#interface-合理性验证"></a> Interface 合理性验证</h3><p>在编译时验证接口的符合性。这包括：</p><ul><li>将实现特定接口的导出类型作为接口 API 的一部分进行检查</li><li>实现同一接口的 (导出和非导出) 类型属于实现类型的集合</li><li>任何违反接口合理性检查的场景，都会终止编译，并通知给用户</li></ul><blockquote><p>上面 3 条是编译器对接口的检查机制，错误使用接口会在编译期报错。所以可以利用这个机制让部分问题在编译期暴露&gt;</p></blockquote><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 Handler 没有实现 http.Handler，会在运行时报错</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">ServeHTTP</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  w http.ResponseWriter,</span></span></span><br><span class="line"><span class="function"><span class="params">  r *http.Request,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于触发编译期的接口的合理性检查机制</span></span><br><span class="line"><span class="comment">// 如果 Handler 没有实现 http.Handler，会在编译期报错</span></span><br><span class="line"><span class="keyword">var</span> _ http.Handler = (*Handler)(<span class="literal">nil</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">ServeHTTP</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  w http.ResponseWriter,</span></span></span><br><span class="line"><span class="function"><span class="params">  r *http.Request,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>如果 <code>*Handler</code> 与 <code>http.Handler</code> 的接口不匹配，那么语句 <code>var _ http.Handler = (*Handler)(nil)</code> 将无法编译通过。</p><blockquote><p><strong>赋值的右边应该是断言类型的零值。对于指针类型（如 <code>*Handler</code>）、切片和映射，这是 <code>nil</code>；对于结构类型，这是空结构。</strong></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LogHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">  h   http.Handler</span><br><span class="line">  log *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _ http.Handler = LogHandler&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h LogHandler)</span> <span class="title">ServeHTTP</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  w http.ResponseWriter,</span></span></span><br><span class="line"><span class="function"><span class="params">  r *http.Request,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接收器-receiver-与接口"><a class="markdownIt-Anchor" href="#接收器-receiver-与接口"></a> 接收器 (receiver) 与接口</h3><p>使用值接收器的方法既可以通过值调用，也可以通过指针调用。带指针接收器的方法只能通过指针或 <a href="https://golang.org/ref/spec#Method_values" target="_blank" rel="noopener">addressable values</a> 调用。</p><p>例如，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">  data <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S)</span> <span class="title">Read</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s.data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S)</span> <span class="title">Write</span><span class="params">(str <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  s.data = str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sVals := <span class="keyword">map</span>[<span class="keyword">int</span>]S&#123;<span class="number">1</span>: &#123;<span class="string">"A"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过值只能调用 Read</span></span><br><span class="line">sVals[<span class="number">1</span>].Read()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这不能编译通过：Cannot call pointer method on 'sVals[1]'</span></span><br><span class="line"><span class="comment">// sVals[1].Write("test")</span></span><br><span class="line"></span><br><span class="line">sPtrs := <span class="keyword">map</span>[<span class="keyword">int</span>]*S&#123;<span class="number">1</span>: &#123;<span class="string">"A"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过指针既可以调用 Read，也可以调用 Write 方法</span></span><br><span class="line">sPtrs[<span class="number">1</span>].Read()</span><br><span class="line">sPtrs[<span class="number">1</span>].Write(<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>map[int]*S{1: {&quot;A&quot;}}</code> 与 <code>map[int]s{1: {&quot;A&quot;}}</code> 都是用 <code>{&quot;A&quot;}</code> 进行初始化</p></blockquote><p>类似的，即使方法有了值接收器，也同样可以用指针接收器来满足接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> F <span class="keyword">interface</span> &#123;</span><br><span class="line">  f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S1)</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S2)</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">s1Val := S1&#123;&#125;</span><br><span class="line">s1Ptr := &amp;S1&#123;&#125;</span><br><span class="line">s2Val := S2&#123;&#125;</span><br><span class="line">s2Ptr := &amp;S2&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i F</span><br><span class="line">i = s1Val</span><br><span class="line">i = s1Ptr</span><br><span class="line">i = s2Ptr</span><br><span class="line"></span><br><span class="line"><span class="comment">//  下面代码无法通过编译。因为 s2Val 是一个值，而 S2 的 f 方法中没有使用值接收器</span></span><br><span class="line"><span class="comment">//   i = s2Val</span></span><br></pre></td></tr></table></figure><p><a href="https://golang.org/doc/effective_go.html" target="_blank" rel="noopener">Effective Go</a> 中有一段关于 <a href="https://golang.org/doc/effective_go.html#pointers_vs_values" target="_blank" rel="noopener">pointers vs. values</a> 的精彩讲解。</p><p>补充：</p><ul><li>一个类型可以有值接收器方法集和指针接收器方法集<ul><li>值接收器方法集是指针接收器方法集的子集，反之不是</li></ul></li><li>规则<ul><li>值对象只可以使用值接收器方法集</li><li>指针对象可以使用 值接收器方法集 + 指针接收器方法集</li></ul></li><li>接口的匹配 (或者叫实现)<ul><li>类型实现了接口的所有方法，叫匹配</li><li>具体的讲，要么是类型的值方法集匹配接口，要么是指针方法集匹配接口</li></ul></li></ul><p>具体的匹配分两种：</p><ul><li>值方法集和接口匹配<ul><li>给接口变量赋值的不管是值还是指针对象，都 ok，因为都包含值方法集</li></ul></li><li>指针方法集和接口匹配<ul><li>只能将指针对象赋值给接口变量，因为只有指针方法集和接口匹配</li><li>如果将值对象赋值给接口变量，会在编译期报错 (会触发接口合理性检查机制)</li></ul></li></ul><p>为啥 i = s2Val 会报错，因为值方法集和接口不匹配。</p><h3 id="零值-mutex-是有效的"><a class="markdownIt-Anchor" href="#零值-mutex-是有效的"></a> 零值 Mutex 是有效的</h3><p>零值 <code>sync.Mutex</code> 和 <code>sync.RWMutex</code> 是有效的。所以指向 mutex 的指针基本是不必要的。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mu := <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line">mu.Lock()</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">mu.Lock()</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>如果使用结构体指针，mutex 应该作为结构体的非指针字段。即使该结构体不被导出，也不要直接把 mutex 嵌入到结构体中。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SMap <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.Mutex</span><br><span class="line"></span><br><span class="line">  data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSMap</span><span class="params">()</span> *<span class="title">SMap</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;SMap&#123;</span><br><span class="line">    data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SMap)</span> <span class="title">Get</span><span class="params">(k <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  m.Lock()</span><br><span class="line">  <span class="keyword">defer</span> m.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> m.data[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SMap <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line"></span><br><span class="line">  data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSMap</span><span class="params">()</span> *<span class="title">SMap</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;SMap&#123;</span><br><span class="line">    data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SMap)</span> <span class="title">Get</span><span class="params">(k <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  m.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> m.data[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><p><code>Mutex</code> 字段， <code>Lock</code> 和 <code>Unlock</code> 方法是 <code>SMap</code> 导出的 API 中不刻意说明的一部分。</p> </td><td><p><code>mutex</code> 及其方法是 <code>SMap</code> 的实现细节，对其调用者不可见。</p> </td></tr> </tbody></table><h3 id="在边界处拷贝-slices-和-maps"><a class="markdownIt-Anchor" href="#在边界处拷贝-slices-和-maps"></a> 在边界处拷贝 Slices 和 Maps</h3><p>slices 和 maps 包含了指向底层数据的指针，因此在需要复制它们时要特别注意。</p><h4 id="接收-slices-和-maps"><a class="markdownIt-Anchor" href="#接收-slices-和-maps"></a> 接收 Slices 和 Maps</h4><p>请记住，当 map 或 slice 作为函数参数传入时，如果存储了对它们的引用，则用户可以对其进行修改。</p><table><thead><tr><th>Bad</th> <th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span> <span class="title">SetTrips</span><span class="params">(trips []Trip)</span></span> &#123;</span><br><span class="line">  d.trips = trips</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trips := ...</span><br><span class="line">d1.SetTrips(trips)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要修改 d1.trips 吗？</span></span><br><span class="line">trips[<span class="number">0</span>] = ...</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span> <span class="title">SetTrips</span><span class="params">(trips []Trip)</span></span> &#123;</span><br><span class="line">  d.trips = <span class="built_in">make</span>([]Trip, <span class="built_in">len</span>(trips))</span><br><span class="line">  <span class="built_in">copy</span>(d.trips, trips)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trips := ...</span><br><span class="line">d1.SetTrips(trips)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里修改 trips[0]，但不会影响到 d1.trips</span></span><br><span class="line">trips[<span class="number">0</span>] = ...</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h4 id="返回-slices-或-maps"><a class="markdownIt-Anchor" href="#返回-slices-或-maps"></a> 返回 slices 或 maps</h4><p>同样，请注意用户对暴露内部状态的 map 或 slice 的修改。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line"></span><br><span class="line">  counters <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Snapshot 返回当前状态。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span> <span class="title">Snapshot</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">int</span></span> &#123;</span><br><span class="line">  s.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s.counters</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// snapshot 不再受互斥锁保护</span></span><br><span class="line"><span class="comment">// 因此对 snapshot 的任何访问都将受到数据竞争的影响</span></span><br><span class="line"><span class="comment">// 影响 stats.counters</span></span><br><span class="line">snapshot := stats.Snapshot()</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line"></span><br><span class="line">  counters <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span> <span class="title">Snapshot</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">int</span></span> &#123;</span><br><span class="line">  s.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  result := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(s.counters))</span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> s.counters &#123;</span><br><span class="line">    result[k] = v</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// snapshot 现在是一个拷贝</span></span><br><span class="line">snapshot := stats.Snapshot()</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="使用-defer-释放资源"><a class="markdownIt-Anchor" href="#使用-defer-释放资源"></a> 使用 defer 释放资源</h3><p>使用 defer 释放资源，诸如文件和锁。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">p.Lock()</span><br><span class="line"><span class="keyword">if</span> p.count &lt; <span class="number">10</span> &#123;</span><br><span class="line">  p.Unlock()</span><br><span class="line">  <span class="keyword">return</span> p.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.count++</span><br><span class="line">newCount := p.count</span><br><span class="line">p.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newCount</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当有多个 return 分支时，很容易遗忘 unlock</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.count &lt; <span class="number">10</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.count++</span><br><span class="line"><span class="keyword">return</span> p.count</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更可读</span></span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>Defer 的开销非常小，只有可以证明函数执行时间处于纳秒级的程度时，才应避免这样做。使用 defer 提升可读性是值得的，因为使用它们的成本微不足道。尤其适用于那些不仅仅是简单内存访问的较大的方法，在这些方法中其他计算的资源消耗远超过 <code>defer</code>。</p><h3 id="channel-的-size-要么是-1要么是无缓冲的"><a class="markdownIt-Anchor" href="#channel-的-size-要么是-1要么是无缓冲的"></a> Channel 的 size 要么是 1，要么是无缓冲的</h3><p>channel 通常 size 应为 1 或是无缓冲的。默认情况下，channel 是无缓冲的，其 size 为零。任何其他尺寸都必须经过严格的审查。需要考虑如何确定大小，考虑是什么阻止了 channel 在高负载下和阻塞写时的写入，以及当这种情况发生时系统逻辑有哪些变化。(翻译解释：按照原文意思是需要界定通道边界，竞态条件，以及逻辑上下文梳理)</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应该足以满足任何情况！</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">64</span>)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大小：1</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 或者</span></span><br><span class="line"><span class="comment">// 无缓冲 channel，大小为 0</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="枚举从-1-开始"><a class="markdownIt-Anchor" href="#枚举从-1-开始"></a> 枚举从 1 开始</h3><p>在 Go 中引入枚举的标准方法是声明一个自定义类型和一个使用了 iota 的 const 组。由于变量的默认值为 0，因此通常应以非零值开头枚举。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add=0, Subtract=1, Multiply=2</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add=1, Subtract=2, Multiply=3</span></span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>在某些情况下，使用零值是有意义的（枚举从零开始），例如，当零值是理想的默认行为时。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LogOutput <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  LogToStdout LogOutput = <span class="literal">iota</span></span><br><span class="line">  LogToFile</span><br><span class="line">  LogToRemote</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LogToStdout=0, LogToFile=1, LogToRemote=2</span></span><br></pre></td></tr></table></figure><h3 id="使用-time-处理时间"><a class="markdownIt-Anchor" href="#使用-time-处理时间"></a> 使用 time 处理时间</h3><p>时间处理很复杂。关于时间的错误假设通常包括以下几点。</p><ol><li>一天有 24 小时</li><li>一小时有 60 分钟</li><li>一周有七天</li><li>一年 365 天</li><li><a href="https://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time" target="_blank" rel="noopener">还有更多</a></li></ol><p>例如，<em>1</em> 表示在一个时间点上加上 24 小时并不总是产生一个新的日历日。</p><p>因此，在处理时间时始终使用 <a href="https://golang.org/pkg/time/" target="_blank" rel="noopener"><code>&quot;time&quot;</code></a> 包，因为它有助于以更安全、更准确的方式处理这些不正确的假设。</p><h4 id="使用-timetime-表达瞬时时间"><a class="markdownIt-Anchor" href="#使用-timetime-表达瞬时时间"></a> 使用 <code>time.Time</code> 表达瞬时时间</h4><p>在处理时间的瞬间时使用 <a href="https://golang.org/pkg/time/#Time" target="_blank" rel="noopener"><code>time.Time</code></a>，在比较、添加或减去时间时使用 <code>time.Time</code> 中的方法。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isActive</span><span class="params">(now, start, stop <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> start &lt;= now &amp;&amp; now &lt; stop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isActive</span><span class="params">(now, start, stop time.Time)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (start.Before(now) || start.Equal(now)) &amp;&amp; now.Before(stop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h4 id="使用-timeduration-表达时间段"><a class="markdownIt-Anchor" href="#使用-timeduration-表达时间段"></a> 使用 <code>time.Duration</code> 表达时间段</h4><p>在处理时间段时使用 <a href="https://golang.org/pkg/time/#Duration" target="_blank" rel="noopener"><code>time.Duration</code></a> .</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll</span><span class="params">(delay <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    time.Sleep(time.Duration(delay) * time.Millisecond)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">poll(<span class="number">10</span>) <span class="comment">// 是几秒钟还是几毫秒？</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll</span><span class="params">(delay time.Duration)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    time.Sleep(delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">poll(<span class="number">10</span>*time.Second)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>回到第一个例子，在一个时间瞬间加上 24 小时，用于添加时间的方法取决于意图。如果想要下一个日历日 (当前天的下一天) 的同一个时间点，应该使用 <a href="https://golang.org/pkg/time/#Time.AddDate" target="_blank" rel="noopener"><code>Time.AddDate</code></a>。但是，如果想保证某一时刻比前一时刻晚 24 小时，应该使用 <a href="https://golang.org/pkg/time/#Time.Add" target="_blank" rel="noopener"><code>Time.Add</code></a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newDay := t.AddDate(<span class="number">0</span> <span class="comment">/* years */</span>, <span class="number">0</span> <span class="comment">/* months */</span>, <span class="number">1</span> <span class="comment">/* days */</span>)</span><br><span class="line">maybeNewDay := t.Add(<span class="number">24</span> * time.Hour)</span><br></pre></td></tr></table></figure><h4 id="对外部系统使用-timetime-和-timeduration"><a class="markdownIt-Anchor" href="#对外部系统使用-timetime-和-timeduration"></a> 对外部系统使用 <code>time.Time</code> 和 <code>time.Duration</code></h4><p>尽可能在与外部系统的交互中使用 <code>time.Duration</code> 和 <code>time.Time</code> 例如 :</p><ul><li><p>Command-line 标志: <a href="https://golang.org/pkg/flag/" target="_blank" rel="noopener"><code>flag</code></a> 通过 <a href="https://golang.org/pkg/time/#ParseDuration" target="_blank" rel="noopener"><code>time.ParseDuration</code></a> 支持 <code>time.Duration</code></p></li><li><p>JSON: <a href="https://golang.org/pkg/encoding/json/" target="_blank" rel="noopener"><code>encoding/json</code></a> 通过其 <a href="https://golang.org/pkg/time/#Time.UnmarshalJSON" target="_blank" rel="noopener"><code>UnmarshalJSON</code> method</a> 方法支持将 <code>time.Time</code> 编码为 <a href="https://tools.ietf.org/html/rfc3339" target="_blank" rel="noopener">RFC 3339</a> 字符串</p></li><li><p>SQL: <a href="https://golang.org/pkg/database/sql/" target="_blank" rel="noopener"><code>database/sql</code></a> 支持将 <code>DATETIME</code> 或 <code>TIMESTAMP</code> 列转换为 <code>time.Time</code>，如果底层驱动程序支持则返回</p></li><li><p>YAML: <a href="https://godoc.org/gopkg.in/yaml.v2" target="_blank" rel="noopener"><code>gopkg.in/yaml.v2</code></a> 支持将 <code>time.Time</code> 作为 <a href="https://tools.ietf.org/html/rfc3339" target="_blank" rel="noopener">RFC 3339</a> 字符串，并通过 <a href="https://golang.org/pkg/time/#ParseDuration" target="_blank" rel="noopener"><code>time.ParseDuration</code></a> 支持 <code>time.Duration</code>。</p></li></ul><p>当不能在这些交互中使用 <code>time.Duration</code> 时，请使用 <code>int</code> 或 <code>float64</code>，并在字段名称中包含单位。</p><p>例如，由于 <code>encoding/json</code> 不支持 <code>time.Duration</code>，因此该单位包含在字段的名称中。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;"interval": 2&#125;</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">  Interval <span class="keyword">int</span> <span class="string">`json:"interval"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;"intervalMillis": 2000&#125;</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">  IntervalMillis <span class="keyword">int</span> <span class="string">`json:"intervalMillis"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>当在这些交互中不能使用 <code>time.Time</code> 时，除非达成一致，否则使用 <code>string</code> 和 <a href="https://tools.ietf.org/html/rfc3339" target="_blank" rel="noopener">RFC 3339</a> 中定义的格式时间戳。默认情况下，<a href="https://golang.org/pkg/time/#Time.UnmarshalText" target="_blank" rel="noopener"><code>Time.UnmarshalText</code></a> 使用此格式，并可通过 <a href="https://golang.org/pkg/time/#RFC3339" target="_blank" rel="noopener"><code>time.RFC3339</code></a> 在 <code>Time.Format</code> 和 <code>time.Parse</code> 中使用。</p><p>尽管这在实践中并不成问题，但请记住，<code>&quot;time&quot;</code> 包不支持解析闰秒时间戳（<a href="https://github.com/golang/go/issues/8728" target="_blank" rel="noopener">8728</a>），也不在计算中考虑闰秒（<a href="https://github.com/golang/go/issues/15190" target="_blank" rel="noopener">15190</a>）。如果比较两个时间瞬间，则差异将不包括这两个瞬间之间可能发生的闰秒。</p><h3 id="errors"><a class="markdownIt-Anchor" href="#errors"></a> Errors</h3><h4 id="错误类型"><a class="markdownIt-Anchor" href="#错误类型"></a> 错误类型</h4><p>声明错误的选项很少。在选择最适合的用例的选项之前，请考虑以下事项。</p><ul><li>调用者是否需要匹配错误以便他们可以处理它？<br />如果是，必须通过声明顶级错误变量或自定义类型来支持 <a href="https://golang.org/pkg/errors/#Is" target="_blank" rel="noopener"><code>errors.Is</code></a> 或 <a href="https://golang.org/pkg/errors/#As" target="_blank" rel="noopener"><code>errors.As</code></a> 函数。</li><li>错误消息是否为静态字符串，还是需要上下文信息的动态字符串？<br />如果是静态字符串，可以使用 <a href="https://golang.org/pkg/errors/#New" target="_blank" rel="noopener"><code>errors.New</code></a>，但对于后者，必须使用 <a href="https://golang.org/pkg/fmt/#Errorf" target="_blank" rel="noopener"><code>fmt.Errorf</code></a> 或自定义错误类型。</li><li>是否正在传递由下游函数返回的新错误？<br />如果是这样，请参阅<a href="#%E9%94%99%E8%AF%AF%E5%8C%85%E8%A3%85">错误包装部分</a>。</li></ul><table><thead><tr><th>错误匹配？</th><th>错误消息</th><th>指导</th></tr></thead><tbody><tr><td>No</td><td>static</td><td><a href="https://golang.org/pkg/errors/#New" target="_blank" rel="noopener"><code>errors.New</code></a></td></tr><tr><td>No</td><td>dynamic</td><td><a href="https://golang.org/pkg/fmt/#Errorf" target="_blank" rel="noopener"><code>fmt.Errorf</code></a></td></tr><tr><td>Yes</td><td>static</td><td>top-level <code>var</code> with <a href="https://golang.org/pkg/errors/#New" target="_blank" rel="noopener"><code>errors.New</code></a></td></tr><tr><td>Yes</td><td>dynamic</td><td>custom <code>error</code> type</td></tr></tbody></table><p>例如，使用 <a href="https://golang.org/pkg/errors/#New" target="_blank" rel="noopener"><code>errors.New</code></a> 表示带有静态字符串的错误。<br />如果调用者需要匹配并处理此错误，则将此错误导出为变量以支持将其与 <code>errors.Is</code> 匹配。</p><table><thead><tr><th>无错误匹配</th><th>错误匹配</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.New(<span class="string">"could not open"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="comment">// Can't handle the error.</span></span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrCouldNotOpen = errors.New(<span class="string">"could not open"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ErrCouldNotOpen</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> errors.Is(err, foo.ErrCouldNotOpen) &#123;</span><br><span class="line">    <span class="comment">// handle the error</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>对于动态字符串的错误，<br />如果调用者不需要匹配它，则使用 <a href="https://golang.org/pkg/fmt/#Errorf" target="_blank" rel="noopener"><code>fmt.Errorf</code></a>，<br />如果调用者确实需要匹配它，则自定义 <code>error</code>。</p><table><thead><tr><th>无错误匹配</th><th>错误匹配</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(file <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Errorf(<span class="string">"file %q not found"</span>, file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(<span class="string">"testfile.txt"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="comment">// Can't handle the error.</span></span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NotFoundError <span class="keyword">struct</span> &#123;</span><br><span class="line">  File <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *NotFoundError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">"file %q not found"</span>, e.File)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(file <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;NotFoundError&#123;File: file&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(<span class="string">"testfile.txt"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> notFound *NotFoundError</span><br><span class="line">  <span class="keyword">if</span> errors.As(err, &amp;notFound) &#123;</span><br><span class="line">    <span class="comment">// handle the error</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>请注意，如果从包中导出错误变量或类型，<br />它们将成为包的公共 API 的一部分。</p><h4 id="错误包装"><a class="markdownIt-Anchor" href="#错误包装"></a> 错误包装</h4><p>如果调用其他方法时出现错误, 通常有三种处理方式可以选择：</p><ul><li>将原始错误原样返回</li><li>使用 <code>fmt.Errorf</code> 搭配 <code>%w</code> 将错误添加进上下文后返回</li><li>使用 <code>fmt.Errorf</code> 搭配 <code>%v</code> 将错误添加进上下文后返回</li></ul><p>如果没有要添加的其他上下文，则按原样返回原始错误。<br />这将保留原始错误类型和消息。<br />这非常适合底层错误消息有足够的信息来追踪它来自哪里的错误。</p><p>否则，尽可能在错误消息中添加上下文<br />这样就不会出现诸如“连接被拒绝”之类的模糊错误，<br />会收到更多有用的错误，例如“调用服务 foo：连接被拒绝”。</p><p>使用 <code>fmt.Errorf</code> 为错误添加上下文，根据调用者是否应该能够匹配和提取根本原因，在 <code>%w</code> 或 <code>%v</code> 动词之间进行选择。</p><ul><li>如果调用者应该可以访问底层错误，请使用 <code>%w</code>。<br />对于大多数包装错误，这是一个很好的默认值，<br />但请注意，调用者可能会开始依赖此行为。因此，对于包装错误是已知<code>var</code>或类型的情况，请将其作为函数契约的一部分进行记录和测试。</li><li>使用 <code>%v</code> 来混淆底层错误。<br />调用者将无法匹配它，但如果需要，可以在将来切换到 <code>%w</code>。</li></ul><p>在为返回的错误添加上下文时，通过避免使用&quot;failed to&quot;之类的短语来保持上下文简洁，当错误通过堆栈向上渗透时，它会一层一层被堆积起来：</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s, err := store.New()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(</span><br><span class="line">        <span class="string">"failed to create new store: %w"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s, err := store.New()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(</span><br><span class="line">        <span class="string">"new store: %w"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">failed to x: failed to y: failed to create new store: the error</span><br></pre></td></tr></table></figure></td><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x: y: new store: the error</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>然而，一旦错误被发送到另一个系统，应该清楚消息是一个错误（例如<code>err</code> 标签或日志中的&quot;Failed&quot;前缀）。</p><p>另见 <a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" target="_blank" rel="noopener">不要只检查错误，优雅地处理它们</a>。</p><h4 id="错误命名"><a class="markdownIt-Anchor" href="#错误命名"></a> 错误命名</h4><p>对于存储为全局变量的错误值，<br />根据是否导出，使用前缀 <code>Err</code> 或 <code>err</code>。<br />请看指南 <a href="#%E5%AF%B9%E4%BA%8E%E6%9C%AA%E5%AF%BC%E5%87%BA%E7%9A%84%E9%A1%B6%E5%B1%82%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F%E4%BD%BF%E7%94%A8_%E4%BD%9C%E4%B8%BA%E5%89%8D%E7%BC%80">对于未导出的顶层常量和变量，使用_作为前缀</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// 导出以下两个错误，以便此包的用户可以将它们与 errors.Is 进行匹配。</span></span><br><span class="line"></span><br><span class="line">  ErrBrokenLink = errors.New(<span class="string">"link is broken"</span>)</span><br><span class="line">  ErrCouldNotOpen = errors.New(<span class="string">"could not open"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个错误没有被导出，因为不想让它成为公共 API 的一部分。 可能仍然在带有错误的包内使用它。</span></span><br><span class="line"></span><br><span class="line">  errNotFound = errors.New(<span class="string">"not found"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对于自定义错误类型，请改用后缀 <code>Error</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样，这个错误被导出，以便这个包的用户可以将它与 errors.As 匹配。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NotFoundError <span class="keyword">struct</span> &#123;</span><br><span class="line">  File <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *NotFoundError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">"file %q not found"</span>, e.File)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并且这个错误没有被导出，因为不想让它成为公共 API 的一部分。 仍然可以在带有 errors.As 的包中使用它。</span></span><br><span class="line"><span class="keyword">type</span> resolveError <span class="keyword">struct</span> &#123;</span><br><span class="line">  Path <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *resolveError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">"resolve %q"</span>, e.Path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理断言失败"><a class="markdownIt-Anchor" href="#处理断言失败"></a> 处理断言失败</h3><p><a href="https://golang.org/ref/spec#Type_assertions" target="_blank" rel="noopener">类型断言</a> 将会在检测到不正确的类型时，以单一返回值形式返回 panic。 因此，请始终使用“逗号 ok”习语。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t := i.(<span class="keyword">string</span>)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t, ok := i.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">  <span class="comment">// 优雅地处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="不要使用-panic"><a class="markdownIt-Anchor" href="#不要使用-panic"></a> 不要使用 panic</h3><p>在生产环境中运行的代码必须避免出现 panic。panic 是 <a href="https://en.wikipedia.org/wiki/Cascading_failure" target="_blank" rel="noopener">级联失败</a> 的主要根源 。如果发生错误，该函数必须返回错误，并允许调用方决定如何处理它。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"an argument is required"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  run(os.Args[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"an argument is required"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := run(os.Args[<span class="number">1</span>:]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Fprintln(os.Stderr, err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p><code>panic/recover</code> 不是错误处理策略。仅当发生不可恢复的事情（例如：<code>nil</code> 引用）时，程序才必须 <code>panic</code>。程序初始化是一个例外：程序启动时应使程序中止的不良情况可能会引起 panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _statusTemplate = template.Must(template.New(<span class="string">"name"</span>).Parse(<span class="string">"_statusHTML"</span>))</span><br></pre></td></tr></table></figure><p>即使在测试代码中，也优先使用<code>t.Fatal</code>或者<code>t.FailNow</code>而不是 panic 来确保失败被标记。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestFoo(t *testing.T)</span></span><br><span class="line">f, err := ioutil.TempFile(<span class="string">""</span>, <span class="string">"test"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">"failed to set up test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestFoo(t *testing.T)</span></span><br><span class="line">f, err := ioutil.TempFile(<span class="string">""</span>, <span class="string">"test"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  t.Fatal(<span class="string">"failed to set up test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="使用-gouberorgatomic"><a class="markdownIt-Anchor" href="#使用-gouberorgatomic"></a> 使用 <a href="http://go.uber.org/atomic" target="_blank" rel="noopener">go.uber.org/atomic</a></h3><p>使用 [<code>sync/atomic</code>] 包的原子操作对原始类型 (<code>int32</code>, <code>int64</code>等）进行操作，因为很容易忘记使用原子操作来读取或修改变量。</p><p>[<code>go.uber.org/atomic</code>] 通过隐藏基础类型为这些操作增加了类型安全性。此外，它包括一个方便的<code>atomic.Bool</code>类型。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> foo <span class="keyword">struct</span> &#123;</span><br><span class="line">  running <span class="keyword">int32</span>  <span class="comment">// atomic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f* foo)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> atomic.SwapInt32(&amp;f.running, <span class="number">1</span>) == <span class="number">1</span> &#123;</span><br><span class="line">     <span class="comment">// already running…</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// start the Foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span> <span class="title">isRunning</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> f.running == <span class="number">1</span>  <span class="comment">// race!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> foo <span class="keyword">struct</span> &#123;</span><br><span class="line">  running atomic.Bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> f.running.Swap(<span class="literal">true</span>) &#123;</span><br><span class="line">     <span class="comment">// already running…</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// start the Foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span> <span class="title">isRunning</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> f.running.Load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="避免可变全局变量"><a class="markdownIt-Anchor" href="#避免可变全局变量"></a> 避免可变全局变量</h3><p>使用选择依赖注入方式避免改变全局变量。既适用于函数指针又适用于其他值类型</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sign.go</span></span><br><span class="line"><span class="keyword">var</span> _timeNow = time.Now</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sign</span><span class="params">(msg <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  now := _timeNow()</span><br><span class="line">  <span class="keyword">return</span> signWithTime(msg, now)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sign.go</span></span><br><span class="line"><span class="keyword">type</span> signer <span class="keyword">struct</span> &#123;</span><br><span class="line">  now <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSigner</span><span class="params">()</span> *<span class="title">signer</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;signer&#123;</span><br><span class="line">    now: time.Now,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *signer)</span> <span class="title">Sign</span><span class="params">(msg <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  now := s.now()</span><br><span class="line">  <span class="keyword">return</span> signWithTime(msg, now)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sign_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSign</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  oldTimeNow := _timeNow</span><br><span class="line">  _timeNow = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> someFixedTime</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; _timeNow = oldTimeNow &#125;()</span><br><span class="line">  assert.Equal(t, want, sign(give))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sign_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSigner</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  s := newSigner()</span><br><span class="line">  s.now = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> someFixedTime</span><br><span class="line">  &#125;</span><br><span class="line">  assert.Equal(t, want, s.Sign(give))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="避免在公共结构中嵌入类型"><a class="markdownIt-Anchor" href="#避免在公共结构中嵌入类型"></a> 避免在公共结构中嵌入类型</h3><p>这些嵌入的类型泄漏实现细节、禁止类型演化和模糊的文档。</p><p>假设使用共享的 <code>AbstractList</code> 实现了多种列表类型，请避免在具体的列表实现中嵌入 <code>AbstractList</code>。<br />相反，只需手动将方法写入具体的列表，该列表将委托给抽象列表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AbstractList <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 添加将实体添加到列表中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span> <span class="title">Add</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除从列表中移除实体。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span> <span class="title">Remove</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcreteList 是一个实体列表。</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  *AbstractList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcreteList 是一个实体列表。</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  list *AbstractList</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加将实体添加到列表中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span> <span class="title">Add</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  l.list.Add(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除从列表中移除实体。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span> <span class="title">Remove</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  l.list.Remove(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>Go 允许 <a href="https://golang.org/doc/effective_go.html#embedding" target="_blank" rel="noopener">类型嵌入</a> 作为继承和组合之间的折衷。外部类型获取嵌入类型的方法的隐式副本。默认情况下，这些方法委托给嵌入实例的同一方法。</p><p>结构还获得与类型同名的字段。所以，如果嵌入的类型是 public，那么字段是 public。为了保持向后兼容性，外部类型的每个未来版本都必须保留嵌入类型。</p><p>很少需要嵌入类型。<br />这是一种方便，可以帮助避免编写冗长的委托方法。</p><p>即使嵌入兼容的抽象列表 <em>interface</em>，而不是结构体，这将为开发人员提供更大的灵活性来改变未来，但仍然泄露了具体列表使用抽象实现的细节。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractList 是各种实体列表的通用实现。</span></span><br><span class="line"><span class="keyword">type</span> AbstractList <span class="keyword">interface</span> &#123;</span><br><span class="line">  Add(Entity)</span><br><span class="line">  Remove(Entity)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ConcreteList 是一个实体列表。</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  AbstractList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcreteList 是一个实体列表。</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  list AbstractList</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加将实体添加到列表中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span> <span class="title">Add</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  l.list.Add(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除从列表中移除实体。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span> <span class="title">Remove</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  l.list.Remove(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>无论是使用嵌入结构还是嵌入接口，都会限制类型的演化。</p><ul><li>向嵌入接口添加方法是一个破坏性的改变。</li><li>从嵌入结构体删除方法是一个破坏性改变。</li><li>删除嵌入类型是一个破坏性的改变。</li><li>即使使用满足相同接口的类型替换嵌入类型，也是一个破坏性的改变。</li></ul><p>尽管编写这些委托方法是乏味的，但是额外的工作隐藏了实现细节，留下了更多的更改机会，还消除了在文档中发现完整列表接口的间接性操作。</p><h3 id="避免使用内置名称"><a class="markdownIt-Anchor" href="#避免使用内置名称"></a> 避免使用内置名称</h3><p>Go <a href="https://golang.org/ref/spec" target="_blank" rel="noopener">语言规范</a> 概述了几个内置的，不应在 Go 项目中使用的 <a href="https://golang.org/ref/spec#Predeclared_identifiers" target="_blank" rel="noopener">预先声明的标识符</a>。</p><p>根据上下文的不同，将这些标识符作为名称重复使用，将在当前作用域（或任何嵌套作用域）中隐藏原始标识符，或者混淆代码。<br />在最好的情况下，编译器会报错；在最坏的情况下，这样的代码可能会引入潜在的、难以恢复的错误。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> error <span class="keyword">string</span></span><br><span class="line"><span class="comment">// `error` 作用域隐式覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleErrorMessage</span><span class="params">(error <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// `error` 作用域隐式覆盖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errorMessage <span class="keyword">string</span></span><br><span class="line"><span class="comment">// `error` 指向内置的非覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleErrorMessage</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// `error` 指向内置的非覆盖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 虽然这些字段在技术上不构成阴影，但`error`或`string`字符串的重映射现在是不明确的。</span></span><br><span class="line">    error  error</span><br><span class="line">    <span class="keyword">string</span> <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// `error` 和 `f.error` 在视觉上是相似的</span></span><br><span class="line">    <span class="keyword">return</span> f.error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="comment">// `string` and `f.string` 在视觉上是相似的</span></span><br><span class="line">    <span class="keyword">return</span> f.<span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// `error` and `string` 现在是明确的。</span></span><br><span class="line">    err error</span><br><span class="line">    str <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> f.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> f.str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>注意，编译器在使用预先分隔的标识符时不会生成错误，<br />但是诸如<code>go vet</code>之类的工具会正确地指出这些和其他情况下的隐式问题。</p><h3 id="避免使用-init"><a class="markdownIt-Anchor" href="#避免使用-init"></a> 避免使用 <code>init()</code></h3><p>尽可能避免使用<code>init()</code>。当<code>init()</code>是不可避免或可取的，代码应先尝试：</p><ol><li>无论程序环境或调用如何，都要完全确定。</li><li>避免依赖于其他<code>init()</code>函数的顺序或副作用。虽然<code>init()</code>顺序是明确的，但代码可以更改，<br />因此<code>init()</code>函数之间的关系可能会使代码变得脆弱和容易出错。</li><li>避免访问或操作全局或环境状态，如机器信息、环境变量、工作目录、程序参数/输入等。</li><li>避免<code>I/O</code>，包括文件系统、网络和系统调用。</li></ol><blockquote><p>init 调用顺序</p><ol><li>在同一个 package 中，可以多个文件中定义 init 方法，按照<strong>文件名先后</strong>执行各个文件中的 init 方法</li><li><strong>在同一个 go 文件中，可以重复定义 init 方法</strong>，按照在代码中<strong>编写顺序</strong>依次执行不同的 init 方法</li><li>对于不同的 package，<ul><li>如果不相互依赖的话，按照 main 包中 import 的顺序调用其包中的 <code>init()</code> 函数</li><li>如果 package 存在依赖，调用顺序为最后被依赖的最先被初始化，例如：导入顺序 main –&gt; A –&gt; B –&gt; C，则初始化顺序为 C –&gt; B –&gt; A –&gt; main，一次执行对应的 init 方法</li></ul></li></ol></blockquote><p>不能满足这些要求的代码可能属于要作为<code>main()</code>调用的一部分(或程序生命周期中的其他地方)，或者作为<code>main()</code>本身的一部分写入。特别是，打算由其他程序使用的库应该特别注意完全确定性，而不是执行“init magic”</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _defaultFoo Foo</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _defaultFoo = Foo&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _defaultFoo = Foo&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or，为了更好的可测试性：</span></span><br><span class="line"><span class="keyword">var</span> _defaultFoo = defaultFoo()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">defaultFoo</span><span class="params">()</span> <span class="title">Foo</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Foo&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _config Config</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Bad: 基于当前目录</span></span><br><span class="line">    cwd, _ := os.Getwd()</span><br><span class="line">    <span class="comment">// Bad: I/O</span></span><br><span class="line">    raw, _ := ioutil.ReadFile(</span><br><span class="line">        path.Join(cwd, <span class="string">"config"</span>, <span class="string">"config.yaml"</span>),</span><br><span class="line">    )</span><br><span class="line">    yaml.Unmarshal(raw, &amp;_config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadConfig</span><span class="params">()</span> <span class="title">Config</span></span> &#123;</span><br><span class="line">    cwd, err := os.Getwd()</span><br><span class="line">    <span class="comment">// handle err</span></span><br><span class="line">    raw, err := ioutil.ReadFile(</span><br><span class="line">        path.Join(cwd, <span class="string">"config"</span>, <span class="string">"config.yaml"</span>),</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// handle err</span></span><br><span class="line">    <span class="keyword">var</span> config Config</span><br><span class="line">    yaml.Unmarshal(raw, &amp;config)</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>考虑到上述情况，在某些情况下，<code>init()</code>可能更可取或是必要的，可能包括：</p><ul><li><p>不能表示为单个赋值的复杂表达式。</p></li><li><p>可插入的钩子，如<code>database/sql</code>、编码类型注册表等。</p></li><li><p>对 <a href="https://cloud.google.com/functions/docs/bestpractices/tips#use_global_variables_to_reuse_objects_in_future_invocations" target="_blank" rel="noopener">Google Cloud Functions</a> 和其他形式的确定性预计算的优化。</p></li></ul><h3 id="追加时优先指定切片容量"><a class="markdownIt-Anchor" href="#追加时优先指定切片容量"></a> 追加时优先指定切片容量</h3><p>追加时优先指定切片容量，在尽可能的情况下，在初始化要追加的切片时为<code>make()</code>提供一个容量值。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">  data := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++&#123;</span><br><span class="line">    data = <span class="built_in">append</span>(data, k)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">  data := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, size)</span><br><span class="line">  <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++&#123;</span><br><span class="line">    data = <span class="built_in">append</span>(data, k)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkBad-4    100000000    2.48s</span><br></pre></td></tr></table></figure></td><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkGood-4   100000000    0.21s</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="主函数退出方式-exit"><a class="markdownIt-Anchor" href="#主函数退出方式-exit"></a> 主函数退出方式 (Exit)</h3><p>Go 程序使用 <a href="https://golang.org/pkg/os/#Exit" target="_blank" rel="noopener"><code>os.Exit</code></a> 或者 <a href="https://golang.org/pkg/log/#Fatal" target="_blank" rel="noopener"><code>log.Fatal*</code></a> 立即退出 (使用<code>panic</code>不是退出程序的好方法，请 <a href="#%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8-panic">不要使用 panic</a>。)</p><p><strong>仅在<code>main()</code></strong> 中调用其中一个 <code>os.Exit</code> 或者 <code>log.Fatal*</code>。所有其他函数应将错误返回到信号失败中。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  body := readFile(path)</span><br><span class="line">  fmt.Println(body)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  f, err := os.Open(path)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  b, err := ioutil.ReadAll(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">string</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  body, err := readFile(path)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(body)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">  f, err := os.Open(path)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  b, err := ioutil.ReadAll(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">string</span>(b), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>原则上：退出的具有多种功能的程序存在一些问题：</p><ul><li>不明显的控制流：任何函数都可以退出程序，因此很难对控制流进行推理。</li><li>难以测试：退出程序的函数也将退出调用它的测试。这使得函数很难测试，并引入了跳过 <code>go test</code> 尚未运行的其他测试的风险。</li><li>跳过清理：当函数退出程序时，会跳过已经进入<code>defer</code>队列里的函数调用。这增加了跳过重要清理任务的风险。</li></ul><h4 id="一次性退出"><a class="markdownIt-Anchor" href="#一次性退出"></a> 一次性退出</h4><p>如果可能的话，<code>main（）</code>函数中 <strong>最多一次</strong> 调用 <code>os.Exit</code>或者<code>log.Fatal</code>。如果有多个错误场景停止程序执行，请将该逻辑放在单独的函数下并从中返回错误。<br />这会缩短 <code>main()</code> 函数，并将所有关键业务逻辑放入一个单独的、可测试的函数中。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  args := os.Args[<span class="number">1</span>:]</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">"missing file"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  name := args[<span class="number">0</span>]</span><br><span class="line">  f, err := os.Open(name)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> f.Close()</span><br><span class="line">  <span class="comment">// 如果调用 log.Fatal 在这条线之后</span></span><br><span class="line">  <span class="comment">// f.Close 将会被执行。</span></span><br><span class="line">  b, err := ioutil.ReadAll(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  args := os.Args[<span class="number">1</span>:]</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"missing file"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  name := args[<span class="number">0</span>]</span><br><span class="line">  f, err := os.Open(name)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> f.Close()</span><br><span class="line">  b, err := ioutil.ReadAll(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="在序列化结构中使用字段标记"><a class="markdownIt-Anchor" href="#在序列化结构中使用字段标记"></a> 在序列化结构中使用字段标记</h3><p>任何序列化到JSON、YAML，或其他支持基于标记的字段命名的格式应使用相关标记进行注释。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stock <span class="keyword">struct</span> &#123;</span><br><span class="line">  Price <span class="keyword">int</span></span><br><span class="line">  Name  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">bytes, err := json.Marshal(Stock&#123;</span><br><span class="line">  Price: <span class="number">137</span>,</span><br><span class="line">  Name:  <span class="string">"UBER"</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stock <span class="keyword">struct</span> &#123;</span><br><span class="line">  Price <span class="keyword">int</span>    <span class="string">`json:"price"`</span></span><br><span class="line">  Name  <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">  <span class="comment">// Safe to rename Name to Symbol.</span></span><br><span class="line">&#125;</span><br><span class="line">bytes, err := json.Marshal(Stock&#123;</span><br><span class="line">  Price: <span class="number">137</span>,</span><br><span class="line">  Name:  <span class="string">"UBER"</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>理论上：<br />结构的序列化形式是不同系统之间的契约。<br />对序列化表单结构（包括字段名）的更改会破坏此约定。在标记中指定字段名使约定明确，<br />它还可以通过重构或重命名字段来防止意外违反约定。</p><h2 id="性能"><a class="markdownIt-Anchor" href="#性能"></a> 性能</h2><p>性能方面的特定准则只适用于高频场景。</p><h3 id="优先使用-strconv-而不是-fmt"><a class="markdownIt-Anchor" href="#优先使用-strconv-而不是-fmt"></a> 优先使用 strconv 而不是 fmt</h3><p>将原语转换为字符串或从字符串转换时，<code>strconv</code>速度比<code>fmt</code>快。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  s := fmt.Sprint(rand.Int())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  s := strconv.Itoa(rand.Int())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkFmtSprint-4    143 ns&#x2F;op    2 allocs&#x2F;op</span><br></pre></td></tr></table></figure></td><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkStrconv-4    64.2 ns&#x2F;op    1 allocs&#x2F;op</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="避免字符串到字节的转换"><a class="markdownIt-Anchor" href="#避免字符串到字节的转换"></a> 避免字符串到字节的转换</h3><p>不要反复从固定字符串创建字节 slice。相反，请执行一次转换并捕获结果。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  w.Write([]<span class="keyword">byte</span>(<span class="string">"Hello world"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data := []<span class="keyword">byte</span>(<span class="string">"Hello world"</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  w.Write(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></tr><tr><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkBad-4   50000000   22.2 ns&#x2F;op</span><br></pre></td></tr></table></figure></td><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkGood-4  500000000   3.25 ns&#x2F;op</span><br></pre></td></tr></table></figure></td></tr></tbody></table><blockquote><p>即使是内容相同的字符串，它们都会单独在分配一块内存</p><p>另外在测试的时候发现：字符串常量无法获取地址！！！，因为取值符号&amp; 仅适用于堆栈内存或堆内存中的值，即可以实际写入的值。表达式和常量(它们本身是程序本身)实际上存储在内存中，但无法写入该内存。因此，能够引入该内存就没有意义</p></blockquote><h3 id="指定容器容量"><a class="markdownIt-Anchor" href="#指定容器容量"></a> 指定容器容量</h3><p>尽可能指定容器容量，以便为容器预先分配内存。这将在添加元素时最小化后续分配（通过复制和调整容器大小）。</p><h4 id="指定-map-容量提示"><a class="markdownIt-Anchor" href="#指定-map-容量提示"></a> 指定 Map 容量提示</h4><p>在尽可能的情况下，在使用 <code>make()</code> 初始化的时候提供容量信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[T1]T2, hint)</span><br></pre></td></tr></table></figure><p>向<code>make()</code>提供容量提示会在初始化时尝试调整 map 的大小，这将减少在将元素添加到 map 时为 map 重新分配内存。</p><p>注意，与 slices 不同。<strong>map capacity 提示并不保证完全的抢占式分配，而是用于估计所需的 hashmap bucket 的数量</strong>。因此，在将元素添加到 map 时，甚至在指定 map 容量时，仍可能发生分配。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]os.FileInfo)</span><br><span class="line"></span><br><span class="line">files, _ := ioutil.ReadDir(<span class="string">"./files"</span>)</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;</span><br><span class="line">    m[f.Name()] = f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">files, _ := ioutil.ReadDir(<span class="string">"./files"</span>)</span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]os.FileInfo, <span class="built_in">len</span>(files))</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;</span><br><span class="line">    m[f.Name()] = f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><p><code>m</code> 是在没有大小提示的情况下创建的； 在运行时可能会有更多分配。</p></td><td><p><code>m</code> 是有大小提示创建的；在运行时可能会有更少的分配。</p></td></tr></tbody></table><h4 id="指定切片容量"><a class="markdownIt-Anchor" href="#指定切片容量"></a> 指定切片容量</h4><p>在尽可能的情况下，在使用<code>make()</code>初始化切片时提供容量信息，特别是在追加切片时。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, length, capacity)</span><br></pre></td></tr></table></figure><p>与 maps 不同，slice capacity 不是一个提示：编译器将为提供给<code>make()</code>的 slice 的容量分配足够的内存，<br />这意味着后续的 append()`操作将导致零分配（直到 slice 的长度与容量匹配，在此之后，任何 append 都可能调整大小以容纳其他元素）。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">  data := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++&#123;</span><br><span class="line">    data = <span class="built_in">append</span>(data, k)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">  data := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, size)</span><br><span class="line">  <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++&#123;</span><br><span class="line">    data = <span class="built_in">append</span>(data, k)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkBad-4    100000000    2.48s</span><br></pre></td></tr></table></figure></td><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkGood-4   100000000    0.21s</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h2 id="规范"><a class="markdownIt-Anchor" href="#规范"></a> 规范</h2><h3 id="避免过长的行"><a class="markdownIt-Anchor" href="#避免过长的行"></a> 避免过长的行</h3><p>避免使用需要读者水平滚动或过度转动头部的代码行。建议将行长度限制为 <strong>99 characters</strong> (99 个字符)。但这不是硬性限制。允许代码超过此限制。</p><h3 id="一致性"><a class="markdownIt-Anchor" href="#一致性"></a> 一致性</h3><p>本文中概述的一些标准都是客观性的评估，是根据场景、上下文、或者主观性的判断；</p><p>但是最重要的是，<strong>保持一致</strong>.</p><p>一致性的代码更容易维护、是更合理的、需要更少的学习成本、并且随着新的约定出现或者出现错误后更容易迁移、更新、修复 bug</p><p>相反，在一个代码库中包含多个完全不同或冲突的代码风格会导致维护成本开销、不确定性和认知偏差。所有这些都会直接导致速度降低、代码审查痛苦、而且增加 bug 数量。</p><p>将这些标准应用于代码库时，建议在 package（或更大）级别进行更改，子包级别的应用程序通过将多个样式引入到同一代码中，违反了上述关注点。</p><h3 id="相似的声明放在一组"><a class="markdownIt-Anchor" href="#相似的声明放在一组"></a> 相似的声明放在一组</h3><p>Go 语言支持将相似的声明放在一个组内。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"a"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"b"</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"a"</span></span><br><span class="line">  <span class="string">"b"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>这同样适用于常量、变量和类型声明：</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Area <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> Volume <span class="keyword">float64</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">  Area <span class="keyword">float64</span></span><br><span class="line">  Volume <span class="keyword">float64</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p><strong>仅将相关的声明放在一组。不要将不相关的声明放在一组。</strong></p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">  EnvVar = <span class="string">"MY_ENV"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> EnvVar = <span class="string">"MY_ENV"</span></span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>分组使用的位置没有限制，例如：可以在函数内部使用它们：</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  red := color.New(<span class="number">0xff0000</span>)</span><br><span class="line">  green := color.New(<span class="number">0x00ff00</span>)</span><br><span class="line">  blue := color.New(<span class="number">0x0000ff</span>)</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> (</span><br><span class="line">    red   = color.New(<span class="number">0xff0000</span>)</span><br><span class="line">    green = color.New(<span class="number">0x00ff00</span>)</span><br><span class="line">    blue  = color.New(<span class="number">0x0000ff</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>例外：如果变量声明与其他变量相邻，则应将变量声明（尤其是函数内部的声明）分组在一起。对一起声明的变量执行此操作，即使它们不相关。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *client)</span> <span class="title">request</span><span class="params">()</span></span> &#123;</span><br><span class="line">  caller := c.name</span><br><span class="line">  format := <span class="string">"json"</span></span><br><span class="line">  timeout := <span class="number">5</span>*time.Second</span><br><span class="line">  <span class="keyword">var</span> err error</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *client)</span> <span class="title">request</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> (</span><br><span class="line">    caller  = c.name</span><br><span class="line">    format  = <span class="string">"json"</span></span><br><span class="line">    timeout = <span class="number">5</span>*time.Second</span><br><span class="line">    err error</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="import-分组"><a class="markdownIt-Anchor" href="#import-分组"></a> import 分组</h3><p>导入应该分为两组：</p><ul><li>标准库</li><li>其他库</li></ul><p>默认情况下，这是 goimports 应用的分组。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">  <span class="string">"go.uber.org/atomic"</span></span><br><span class="line">  <span class="string">"golang.org/x/sync/errgroup"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line">  <span class="string">"go.uber.org/atomic"</span></span><br><span class="line">  <span class="string">"golang.org/x/sync/errgroup"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="包名"><a class="markdownIt-Anchor" href="#包名"></a> 包名</h3><p>当命名包时，请按下面规则选择一个名称：</p><ul><li><strong>全部小写。没有大写或下划线</strong>。</li><li>大多数使用命名导入的情况下，不需要重命名。</li><li>简短而简洁。请记住，在每个使用的地方都完整标识了该名称。</li><li><strong>不用复数</strong>。例如<code>net/url</code>，而不是<code>net/urls</code>。</li><li><strong>不要用“common”，“util”，“shared”或“lib”</strong>。这些是不好的，信息量不足的名称。</li></ul><p>另请参阅 <a href="https://blog.golang.org/package-names" target="_blank" rel="noopener">Go 包命名规则</a> 和 <a href="https://rakyll.org/style-packages/" target="_blank" rel="noopener">Go 包样式指南</a>.</p><h3 id="函数名"><a class="markdownIt-Anchor" href="#函数名"></a> 函数名</h3><p>遵循 Go 社区关于使用 <a href="https://golang.org/doc/effective_go.html#mixed-caps" target="_blank" rel="noopener">MixedCaps 作为函数名</a> 的约定。有一个例外，为了对相关的测试用例进行分组，函数名可能包含下划线，如：<code>TestMyFunction_WhatIsBeingTested</code>.</p><h3 id="导入别名"><a class="markdownIt-Anchor" href="#导入别名"></a> 导入别名</h3><p><strong>如果程序包名称与导入路径的最后一个元素不匹配，则必须使用导入别名</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">  client <span class="string">"example.com/client-go"</span></span><br><span class="line">  trace <span class="string">"example.com/trace/v2"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在所有其他情况下，除非导入之间有直接冲突，否则应避免导入别名。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line">  nettrace <span class="string">"golang.net/x/trace"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">  <span class="string">"runtime/trace"</span></span><br><span class="line"></span><br><span class="line">  nettrace <span class="string">"golang.net/x/trace"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="函数分组与顺序"><a class="markdownIt-Anchor" href="#函数分组与顺序"></a> 函数分组与顺序</h3><ul><li>函数应按粗略的调用顺序排序。</li><li>同一文件中的函数应按接收者分组。</li></ul><p>因此，导出的函数应先出现在文件中，放在<code>struct</code>, <code>const</code>, <code>var</code>定义的后面。</p><p>在定义类型之后，但在接收者的其余方法之前，可能会出现一个 <code>newXYZ()</code>/<code>NewXYZ()</code></p><p>由于函数是按接收者分组的，因此普通工具函数应在文件末尾出现。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Cost</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> calcCost(s.weights)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> something <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCost</span><span class="params">(n []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSomething</span><span class="params">()</span> *<span class="title">something</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;something&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> something <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSomething</span><span class="params">()</span> *<span class="title">something</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;something&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Cost</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> calcCost(s.weights)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCost</span><span class="params">(n []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="减少嵌套"><a class="markdownIt-Anchor" href="#减少嵌套"></a> 减少嵌套</h3><p>代码应通过尽可能先处理错误情况/特殊情况并尽早返回或继续循环来减少嵌套。减少嵌套多个级别的代码的代码量。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">  <span class="keyword">if</span> v.F1 == <span class="number">1</span> &#123;</span><br><span class="line">    v = process(v)</span><br><span class="line">    <span class="keyword">if</span> err := v.Call(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">      v.Send()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">"Invalid v: %v"</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">  <span class="keyword">if</span> v.F1 != <span class="number">1</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">"Invalid v: %v"</span>, v)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v = process(v)</span><br><span class="line">  <span class="keyword">if</span> err := v.Call(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  v.Send()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="不必要的-else"><a class="markdownIt-Anchor" href="#不必要的-else"></a> 不必要的 else</h3><p>如果在 if 的两个分支中都设置了变量，则可以将其替换为单个 if。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> b &#123;</span><br><span class="line">  a = <span class="number">100</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  a = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> b &#123;</span><br><span class="line">  a = <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="顶层变量声明"><a class="markdownIt-Anchor" href="#顶层变量声明"></a> 顶层变量声明</h3><p>在顶层，使用标准<code>var</code>关键字。<strong>请勿指定类型</strong>，除非它与表达式的类型不同。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _s <span class="keyword">string</span> = F()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"A"</span> &#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _s = F()</span><br><span class="line"><span class="comment">// 由于 F 已经明确了返回一个字符串类型，因此没有必要显式指定_s 的类型</span></span><br><span class="line"><span class="comment">// 还是那种类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"A"</span> &#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>如果表达式的类型与所需的类型不完全匹配，请指定类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"error"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span> <span class="title">myError</span></span> &#123; <span class="keyword">return</span> myError&#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _e error = F()</span><br><span class="line"><span class="comment">// F 返回一个 myError 类型的实例，但是要 error 类型</span></span><br></pre></td></tr></table></figure><h3 id="对于未导出的顶层常量和变量使用_作为前缀"><a class="markdownIt-Anchor" href="#对于未导出的顶层常量和变量使用_作为前缀"></a> 对于未导出的顶层常量和变量，使用_作为前缀</h3><p>在未导出的顶级<code>vars</code>和<code>consts</code>， 前面加上前缀_，以使它们在使用时明确表示它们是全局符号。</p><p>基本依据：<strong>顶级变量和常量具有包范围作用域</strong>。使用通用名称可能很容易在其他文件中意外使用错误的值。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  defaultPort = <span class="number">8080</span></span><br><span class="line">  defaultUser = <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">  defaultPort := <span class="number">9090</span></span><br><span class="line">  ...</span><br><span class="line">  fmt.Println(<span class="string">"Default port"</span>, defaultPort)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We will not see a compile error if the first line of</span></span><br><span class="line">  <span class="comment">// Bar() is deleted.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  _defaultPort = <span class="number">8080</span></span><br><span class="line">  _defaultUser = <span class="string">"user"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p><strong>例外</strong>：未导出的错误值可以使用不带下划线的前缀 <code>err</code>。 参见<a href="#%E9%94%99%E8%AF%AF%E5%91%BD%E5%90%8D">错误命名</a>。</p><h3 id="结构体中的嵌入"><a class="markdownIt-Anchor" href="#结构体中的嵌入"></a> 结构体中的嵌入</h3><p>嵌入式类型（例如 mutex）应位于结构体内的字段列表的顶部，并且必须有一个空行将嵌入式字段与常规字段分隔开。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">  version <span class="keyword">int</span></span><br><span class="line">  http.Client</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">  http.Client</span><br><span class="line"></span><br><span class="line">  version <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>内嵌应该提供切实的好处，比如以语义上合适的方式添加或增强功能。它应该在对用户没有任何不利影响的情况下使用。（另请参见：<a href="#%E9%81%BF%E5%85%8D%E5%9C%A8%E5%85%AC%E5%85%B1%E7%BB%93%E6%9E%84%E4%B8%AD%E5%B5%8C%E5%85%A5%E7%B1%BB%E5%9E%8B">避免在公共结构中嵌入类型</a>）。例外：即使在未导出类型中，<code>Mutex</code> 也不应该作为内嵌字段。另请参见：<a href="#%E9%9B%B6%E5%80%BC-mutex-%E6%98%AF%E6%9C%89%E6%95%88%E7%9A%84">零值 Mutex 是有效的</a>。</p><p>嵌入 <strong>不应该</strong>:</p><ul><li>纯粹是为了美观或方便。</li><li>使外部类型更难构造或使用。</li><li>影响外部类型的零值。如果外部类型有一个有用的零值，则在嵌入内部类型之后应该仍然有一个有用的零值。</li><li>作为嵌入内部类型的副作用，从外部类型公开不相关的函数或字段。</li><li>公开未导出的类型。</li><li>影响外部类型的复制形式。</li><li>更改外部类型的 API 或类型语义。</li><li>嵌入内部类型的非规范形式。</li><li>公开外部类型的实现详细信息。</li><li>允许用户观察或控制类型内部。</li><li>通过包装的方式改变内部函数的一般行为，这种包装方式会给用户带来一些意料之外情况。</li></ul><p>简单地说，有意识地和有目的地嵌入。一种很好的测试体验是，<br />“是否所有这些导出的内部方法/字段都将直接添加到外部类型”<br />如果答案是<code>some</code>或<code>no</code>，不要嵌入内部类型 - 而是使用字段。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Bad: A.Lock() and A.Unlock() 现在可用</span></span><br><span class="line">    <span class="comment">// 不提供任何功能性好处，并允许用户控制有关 A 的内部细节。</span></span><br><span class="line">    sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> countingWriteCloser <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Good: Write() 在外层提供用于特定目的，</span></span><br><span class="line">    <span class="comment">// 并且委托工作到内部类型的 Write() 中。</span></span><br><span class="line">    io.WriteCloser</span><br><span class="line">    count <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *countingWriteCloser)</span> <span class="title">Write</span><span class="params">(bs []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    w.count += <span class="built_in">len</span>(bs)</span><br><span class="line">    <span class="keyword">return</span> w.WriteCloser.Write(bs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Bad: 指针更改零值的有用性</span></span><br><span class="line">    io.ReadWriter</span><br><span class="line">    <span class="comment">// other fields</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// later</span></span><br><span class="line"><span class="keyword">var</span> b Book</span><br><span class="line">b.Read(...)  <span class="comment">// panic: nil pointer</span></span><br><span class="line">b.String()   <span class="comment">// panic: nil pointer</span></span><br><span class="line">b.Write(...) <span class="comment">// panic: nil pointer</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Good: 有用的零值</span></span><br><span class="line">    bytes.Buffer</span><br><span class="line">    <span class="comment">// other fields</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// later</span></span><br><span class="line"><span class="keyword">var</span> b Book</span><br><span class="line">b.Read(...)  <span class="comment">// ok</span></span><br><span class="line">b.String()   <span class="comment">// ok</span></span><br><span class="line">b.Write(...) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></td></tr><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    sync.WaitGroup</span><br><span class="line">    bytes.Buffer</span><br><span class="line">    url.URL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    mtx sync.Mutex</span><br><span class="line">    wg  sync.WaitGroup</span><br><span class="line">    buf bytes.Buffer</span><br><span class="line">    url url.URL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="本地变量声明"><a class="markdownIt-Anchor" href="#本地变量声明"></a> 本地变量声明</h3><p>如果将变量明确设置为某个值，则应使用短变量声明形式 (<code>:=</code>)。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"foo"</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"foo"</span></span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>但是，在某些情况下，<code>var</code> 使用关键字时默认值会更清晰。例如，<a href="https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices" target="_blank" rel="noopener">声明空切片</a>。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(list []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  filtered := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">10</span> &#123;</span><br><span class="line">      filtered = <span class="built_in">append</span>(filtered, v)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(list []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> filtered []<span class="keyword">int</span></span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">10</span> &#123;</span><br><span class="line">      filtered = <span class="built_in">append</span>(filtered, v)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="nil-是一个有效的-slice"><a class="markdownIt-Anchor" href="#nil-是一个有效的-slice"></a> nil 是一个有效的 slice</h3><p><code>nil</code> 是一个有效的长度为 0 的 <code>slice</code>，这意味着，</p><ul><li><p><strong>不应明确返回长度为零的切片。应该返回<code>nil</code> 来代替</strong>。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x == <span class="string">""</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x == <span class="string">""</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table></li><li><p><strong>要检查切片是否为空</strong>，请始终使用<code>len(s) == 0</code>。而非 <code>nil</code>。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">(s []<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s == <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">(s []<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(s) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table></li><li><p><strong>零值切片（用<code>var</code>声明的切片）可立即使用</strong>，无需调用<code>make()</code>创建。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nums := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// or, nums := make([]int)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add1 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add2 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add1 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add2 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table></li></ul><p>记住，<strong>虽然 nil 切片是有效的切片，但它不等于长度为 0 的切片</strong>（一个为 nil，另一个不是），并且在不同的情况下（例如序列化），这两个切片的处理方式可能不同。</p><h3 id="缩小变量作用域"><a class="markdownIt-Anchor" href="#缩小变量作用域"></a> 缩小变量作用域</h3><p>如果有可能，尽量缩小变量作用范围。除非它与 <a href="#%E5%87%8F%E5%B0%91%E5%B5%8C%E5%A5%97">减少嵌套</a>的规则冲突。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := ioutil.WriteFile(name, data, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := ioutil.WriteFile(name, data, <span class="number">0644</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>如果需要在 if 之外使用函数调用的结果，则不应尝试缩小范围。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> data, err := ioutil.ReadFile(name); err == <span class="literal">nil</span> &#123;</span><br><span class="line">  err = cfg.Decode(data)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(cfg)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err<span class="comment">//注意这个err的范围</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data, err := ioutil.ReadFile(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := cfg.Decode(data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(cfg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>注意 <code>if</code> 中变量的范围</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">"err test"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> v, err := f1(); err == <span class="literal">nil</span> &#123; <span class="comment">//为了在 else中打印 err 这里使用 ==</span></span><br><span class="line">    a := <span class="number">1</span><span class="comment">//</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%v %v"</span>, err, v)</span><br><span class="line">    fmt.Printf(<span class="string">"%v"</span>, a)<span class="comment">//编译错误，undefined: a</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="避免参数语义不明确-avoid-naked-parameters"><a class="markdownIt-Anchor" href="#避免参数语义不明确-avoid-naked-parameters"></a> 避免参数语义不明确 (Avoid Naked Parameters)</h3><p>函数调用中的<code>意义不明确的参数</code>可能会损害可读性。当参数名称的含义不明显时，请为参数添加 C 样式注释 (<code>/* ... */</code>)</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func printInfo(name string, isLocal, done bool)</span></span><br><span class="line"></span><br><span class="line">printInfo(<span class="string">"foo"</span>, <span class="literal">true</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func printInfo(name string, isLocal, done bool)</span></span><br><span class="line"></span><br><span class="line">printInfo(<span class="string">"foo"</span>, <span class="literal">true</span> <span class="comment">/* isLocal */</span>, <span class="literal">true</span> <span class="comment">/* done */</span>)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>对于上面的示例代码，还有一种更好的处理方式是将上面的 <code>bool</code> 类型换成自定义类型。将来，该参数可以支持不仅仅局限于两个状态（true/false）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Region <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  UnknownRegion Region = <span class="literal">iota</span></span><br><span class="line">  Local</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  StatusReady Status= <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  StatusDone</span><br><span class="line">  <span class="comment">// Maybe we will have a StatusInProgress in the future.</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">(name <span class="keyword">string</span>, region Region, status Status)</span></span></span><br></pre></td></tr></table></figure><h3 id="使用原始字符串字面值避免转义"><a class="markdownIt-Anchor" href="#使用原始字符串字面值避免转义"></a> 使用原始字符串字面值，避免转义</h3><p>Go 支持使用 <a href="https://golang.org/ref/spec#raw_string_lit" target="_blank" rel="noopener">原始字符串字面值</a>，也就是 &quot; ` &quot; 来表示原生字符串，在需要转义的场景下，应该尽量使用这种方案来替换。</p><p>可以跨越多行并包含引号。使用这些字符串可以避免更难阅读的手工转义的字符串。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wantError := <span class="string">"unknown name:\"test\""</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wantError := <span class="string">`unknown error:"test"`</span></span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="初始化结构体"><a class="markdownIt-Anchor" href="#初始化结构体"></a> 初始化结构体</h3><h4 id="使用字段名初始化结构"><a class="markdownIt-Anchor" href="#使用字段名初始化结构"></a> 使用字段名初始化结构</h4><p>初始化结构时，<strong>几乎应该始终指定字段名</strong>。目前由 <a href="https://golang.org/cmd/vet/" target="_blank" rel="noopener"><code>go vet</code></a> 强制执行。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k := User&#123;<span class="string">"John"</span>, <span class="string">"Doe"</span>, <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">k := User&#123;</span><br><span class="line">    FirstName: <span class="string">"John"</span>,</span><br><span class="line">    LastName: <span class="string">"Doe"</span>,</span><br><span class="line">    Admin: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>例外：<strong>当有 3 个或更少的字段时，测试表中的字段名<em>may</em>可以省略</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  op Operation</span><br><span class="line">  want <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;Add, <span class="string">"add"</span>&#125;,</span><br><span class="line">  &#123;Subtract, <span class="string">"subtract"</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="省略结构中的零值字段"><a class="markdownIt-Anchor" href="#省略结构中的零值字段"></a> 省略结构中的零值字段</h4><p>初始化具有字段名的结构时，<strong>除非提供有意义的上下文，否则忽略值为零的字段</strong>。也就是，让自动将这些设置为零值</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;</span><br><span class="line">  FirstName: <span class="string">"John"</span>,</span><br><span class="line">  LastName: <span class="string">"Doe"</span>,</span><br><span class="line">  MiddleName: <span class="string">""</span>,</span><br><span class="line">  Admin: <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;</span><br><span class="line">  FirstName: <span class="string">"John"</span>,</span><br><span class="line">  LastName: <span class="string">"Doe"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>这有助于通过省略该上下文中的默认值来减少阅读的障碍。只指定有意义的值。</p><p>在字段名提供有意义上下文的地方包含零值。例如，<a href="#%E8%A1%A8%E9%A9%B1%E5%8A%A8%E6%B5%8B%E8%AF%95">表驱动测试</a> 中的测试用例可以受益于字段的名称，即使它们是零值的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  give <span class="keyword">string</span></span><br><span class="line">  want <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;give: <span class="string">"0"</span>, want: <span class="number">0</span>&#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对零值结构使用-var"><a class="markdownIt-Anchor" href="#对零值结构使用-var"></a> 对零值结构使用 <code>var</code></h4><p>如果在声明中省略了结构的所有字段，请使用 <code>var</code> 声明结构。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user User</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>这将零值结构与那些具有类似于为 <a href="#%E5%88%9D%E5%A7%8B%E5%8C%96-maps">初始化 Maps</a> 创建的，区别于非零值字段的结构区分开来，<br />并与更喜欢的 <a href="https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices" target="_blank" rel="noopener">声明空切片</a> 方式相匹配。</p><h4 id="初始化-struct-引用"><a class="markdownIt-Anchor" href="#初始化-struct-引用"></a> 初始化 Struct 引用</h4><p>在初始化结构引用时，请使用<code>&amp;T{}</code>代替<code>new(T)</code>，以使其与结构体初始化一致。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sval := T&#123;Name: <span class="string">"foo"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inconsistent</span></span><br><span class="line">sptr := <span class="built_in">new</span>(T)</span><br><span class="line">sptr.Name = <span class="string">"bar"</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sval := T&#123;Name: <span class="string">"foo"</span>&#125;</span><br><span class="line"></span><br><span class="line">sptr := &amp;T&#123;Name: <span class="string">"bar"</span>&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="初始化-maps"><a class="markdownIt-Anchor" href="#初始化-maps"></a> 初始化 Maps</h3><p>对于空 map 请使用 <code>make(..)</code> 初始化， 并且 map 是通过编程方式填充的。<br />这使得 map 初始化在表现上不同于声明，并且它还可以方便地在 make 后添加大小提示。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// m1 读写安全;</span></span><br><span class="line">  <span class="comment">// m2 在写入时会 panic</span></span><br><span class="line">  m1 = <span class="keyword">map</span>[T1]T2&#123;&#125;</span><br><span class="line">  m2 <span class="keyword">map</span>[T1]T2</span><br><span class="line">)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// m1 读写安全;</span></span><br><span class="line">  <span class="comment">// m2 在写入时会 panic</span></span><br><span class="line">  m1 = <span class="built_in">make</span>(<span class="keyword">map</span>[T1]T2)</span><br><span class="line">  m2 <span class="keyword">map</span>[T1]T2</span><br><span class="line">)</span><br></pre></td></tr></table></figure></td></tr><tr><td><p>声明和初始化看起来非常相似的。</p></td><td><p>声明和初始化看起来差别非常大。</p></td></tr></tbody></table><p>在尽可能的情况下，请在初始化时提供 map 容量大小，详细请看 <a href="#%E6%8C%87%E5%AE%9AMap%E5%AE%B9%E9%87%8F%E6%8F%90%E7%A4%BA">指定 Map 容量提示</a>。另外，如果 map 包含固定的元素列表，则使用 map literals(map 初始化列表) 初始化映射。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[T1]T2, <span class="number">3</span>)</span><br><span class="line">m[k1] = v1</span><br><span class="line">m[k2] = v2</span><br><span class="line">m[k3] = v3</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[T1]T2&#123;</span><br><span class="line">  k1: v1,</span><br><span class="line">  k2: v2,</span><br><span class="line">  k3: v3,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>基本准则是：<strong>在初始化时使用 map 初始化列表 来添加一组固定的元素。否则使用 <code>make</code> (如果可以，请尽量指定 map 容量)</strong>。</p><h3 id="字符串-string-format"><a class="markdownIt-Anchor" href="#字符串-string-format"></a> 字符串 string format</h3><p>如果在函数外声明<code>Printf</code>-style 函数的格式字符串，请将其设置为<code>const</code>常量。这有助于<code>go vet</code>对格式字符串执行静态分析。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg := <span class="string">"unexpected values %v, %v\n"</span></span><br><span class="line">fmt.Printf(msg, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> msg = <span class="string">"unexpected values %v, %v\n"</span></span><br><span class="line">fmt.Printf(msg, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="命名-printf-样式的函数"><a class="markdownIt-Anchor" href="#命名-printf-样式的函数"></a> 命名 Printf 样式的函数</h3><p>声明<code>Printf</code>-style 函数时，请确保<code>go vet</code>可以检测到它并检查格式字符串。</p><p>这意味着应尽可能使用预定义的<code>Printf</code>-style 函数名称。<code>go vet</code>将默认检查这些。有关更多信息，请参见 <a href="https://golang.org/cmd/vet/#hdr-Printf_family" target="_blank" rel="noopener">Printf 系列</a>。</p><p>如果不能使用预定义的名称，请以 f 结束选择的名称：<code>Wrapf</code>，而不是<code>Wrap</code>。<code>go vet</code>可以要求检查特定的 Printf 样式名称，但名称必须以<code>f</code>结尾。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go vet -printfuncs=wrapf,statusf</span></span><br></pre></td></tr></table></figure><p>另请参阅 <a href="https://kuzminva.wordpress.com/2017/11/07/go-vet-printf-family-check/" target="_blank" rel="noopener">go vet: Printf family check</a>.</p><h2 id="编程模式"><a class="markdownIt-Anchor" href="#编程模式"></a> 编程模式</h2><h3 id="表驱动测试"><a class="markdownIt-Anchor" href="#表驱动测试"></a> 表驱动测试</h3><p>当测试逻辑是重复的时候，通过  <a href="https://blog.golang.org/subtests" target="_blank" rel="noopener">subtests</a> 使用 table 驱动的方式编写 case 代码看上去会更简洁。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestSplitHostPort(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">host, port, err := net.SplitHostPort(<span class="string">"192.0.2.0:8000"</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">"192.0.2.0"</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">"8000"</span>, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(<span class="string">"192.0.2.0:http"</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">"192.0.2.0"</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">"http"</span>, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(<span class="string">":8000"</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">""</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">"8000"</span>, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(<span class="string">"1:8"</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">"1"</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">"8"</span>, port)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestSplitHostPort(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  give     <span class="keyword">string</span></span><br><span class="line">  wantHost <span class="keyword">string</span></span><br><span class="line">  wantPort <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">"192.0.2.0:8000"</span>,</span><br><span class="line">    wantHost: <span class="string">"192.0.2.0"</span>,</span><br><span class="line">    wantPort: <span class="string">"8000"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">"192.0.2.0:http"</span>,</span><br><span class="line">    wantHost: <span class="string">"192.0.2.0"</span>,</span><br><span class="line">    wantPort: <span class="string">"http"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">":8000"</span>,</span><br><span class="line">    wantHost: <span class="string">""</span>,</span><br><span class="line">    wantPort: <span class="string">"8000"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">"1:8"</span>,</span><br><span class="line">    wantHost: <span class="string">"1"</span>,</span><br><span class="line">    wantPort: <span class="string">"8"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">  t.Run(tt.give, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    host, port, err := net.SplitHostPort(tt.give)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line">    assert.Equal(t, tt.wantHost, host)</span><br><span class="line">    assert.Equal(t, tt.wantPort, port)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>很明显，使用 test table 的方式在代码逻辑扩展的时候，比如新增 test case，都会显得更加的清晰。</p><p>遵循这样的约定：将结构体切片称为<code>tests</code>。 每个测试用例称为<code>tt</code>。此外，鼓励使用<code>give</code>和<code>want</code>前缀说明每个测试用例的输入和输出值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  give     <span class="keyword">string</span></span><br><span class="line">  wantHost <span class="keyword">string</span></span><br><span class="line">  wantPort <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并行测试，比如一些专门的循环（例如，生成goroutine或捕获引用作为循环体的一部分的那些循环）<br />必须注意在循环的范围内显式地分配循环变量，以确保它们保持预期的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  give <span class="keyword">string</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">  tt := tt <span class="comment">// for t.Parallel</span></span><br><span class="line">  t.Run(tt.give, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    t.Parallel()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，由于下面使用了<code>t.Parallel()</code>，必须声明一个作用域为循环迭代的<code>tt</code>变量。<br />如果不这样做，大多数或所有测试都会收到一个意外的<code>tt</code>值，或者一个在运行时发生变化的值。</p><h3 id="功能选项"><a class="markdownIt-Anchor" href="#功能选项"></a> 功能选项</h3><p>功能选项是一种模式，可以在其中声明一个不透明 Option 类型，该类型在某些内部结构中记录信息。接受这些选项的可变编号，并根据内部结构上的选项记录的全部信息采取行动。</p><p>将此模式用于需要扩展的构造函数和其他公共 API 中的可选参数，尤其是在这些功能上已经具有三个或更多参数的情况下。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package db</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  addr <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  cache <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  logger *zap.Logger</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*Connection, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package db</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCache</span><span class="params">(c <span class="keyword">bool</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithLogger</span><span class="params">(log *zap.Logger)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open creates a connection.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  addr <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  opts ...Option,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*Connection, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><p>必须始终提供缓存和记录器参数，即使用户希望使用默认值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.Open(addr, db.DefaultCache, zap.NewNop())</span><br><span class="line">db.Open(addr, db.DefaultCache, log)</span><br><span class="line">db.Open(addr, <span class="literal">false</span> <span class="comment">/* cache */</span>, zap.NewNop())</span><br><span class="line">db.Open(addr, <span class="literal">false</span> <span class="comment">/* cache */</span>, log)</span><br></pre></td></tr></table></figure></td><td><p>只有在需要时才提供选项。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.Open(addr)</span><br><span class="line">db.Open(addr, db.WithLogger(log))</span><br><span class="line">db.Open(addr, db.WithCache(<span class="literal">false</span>))</span><br><span class="line">db.Open(</span><br><span class="line">  addr,</span><br><span class="line">  db.WithCache(<span class="literal">false</span>),</span><br><span class="line">  db.WithLogger(log),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>我建议实现此模式的方法是使用一个 <code>Option</code> 接口，该接口保存一个未导出的方法，在一个未导出的 <code>options</code> 结构上记录选项。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> options <span class="keyword">struct</span> &#123;</span><br><span class="line">  cache  <span class="keyword">bool</span></span><br><span class="line">  logger *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;</span><br><span class="line">  apply(*options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cacheOption <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cacheOption)</span> <span class="title">apply</span><span class="params">(opts *options)</span></span> &#123;</span><br><span class="line">  opts.cache = <span class="keyword">bool</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCache</span><span class="params">(c <span class="keyword">bool</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> cacheOption(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> loggerOption <span class="keyword">struct</span> &#123;</span><br><span class="line">  Log *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l loggerOption)</span> <span class="title">apply</span><span class="params">(opts *options)</span></span> &#123;</span><br><span class="line">  opts.logger = l.Log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithLogger</span><span class="params">(log *zap.Logger)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> loggerOption&#123;Log: log&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open creates a connection.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  addr <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  opts ...Option,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*Connection, error)</span></span> &#123;</span><br><span class="line">  options := options&#123;</span><br><span class="line">    cache:  defaultCache,</span><br><span class="line">    logger: zap.NewNop(),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> _, o := <span class="keyword">range</span> opts &#123;</span><br><span class="line">    o.apply(&amp;options)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：还有一种使用闭包实现这个模式的方法，但是相信上面的模式为作者提供了更多的灵活性，并且更容易对用户进行调试和测试。特别是，在不可能进行比较的情况下它允许在测试和模拟中对选项进行比较。此外，它还允许选项实现其他接口，包括 <code>fmt.Stringer</code>，允许用户读取选项的字符串表示形式。</p><p>还可以参考下面资料：</p><ul><li><p><a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html" target="_blank" rel="noopener">Self-referential functions and the design of options</a></p></li><li><p><a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis" target="_blank" rel="noopener">Functional options for friendly APIs</a></p></li></ul><h2 id="linting"><a class="markdownIt-Anchor" href="#linting"></a> Linting</h2><p>比任何 “blessed” linter 集更重要的是，lint 在一个代码库中始终保持一致。</p><p>建议至少使用以下 linters，因为我认为它们有助于发现最常见的问题，并在不需要规定的情况下为代码质量建立一个高标准：</p><ul><li><p><a href="https://github.com/kisielk/errcheck" target="_blank" rel="noopener">errcheck</a> 以确保错误得到处理</p></li><li><p><a href="https://godoc.org/golang.org/x/tools/cmd/goimports" target="_blank" rel="noopener">goimports</a> 格式化代码和管理 imports</p></li><li><p><a href="https://github.com/golang/lint" target="_blank" rel="noopener">golint</a> 指出常见的文体错误</p></li><li><p><a href="https://golang.org/cmd/vet/" target="_blank" rel="noopener">govet</a> 分析代码中的常见错误</p></li><li><p><a href="https://staticcheck.io/" target="_blank" rel="noopener">staticcheck</a> 各种静态分析检查</p></li></ul><h3 id="lint-runners"><a class="markdownIt-Anchor" href="#lint-runners"></a> Lint Runners</h3><p>推荐 <a href="https://github.com/golangci/golangci-lint" target="_blank" rel="noopener">golangci-lint</a> 作为 go-to lint 的运行程序，这主要是因为它在较大的代码库中的性能以及能够同时配置和使用许多规范。这个 repo 有一个示例配置文件 <a href="https://github.com/uber-go/guide/blob/master/.golangci.yml" target="_blank" rel="noopener">.golangci.yml</a> 和推荐的 linter 设置。</p><p>golangci-lint 有 <a href="https://golangci-lint.run/usage/linters/" target="_blank" rel="noopener">various-linters</a> 可供使用。建议将上述 linters 作为基本 set，鼓励团队添加对他们的项目有意义的任何附加 linters。</p><h2 id="stargazers-over-time"><a class="markdownIt-Anchor" href="#stargazers-over-time"></a> Stargazers over time</h2><p><a href="https://starchart.cc/xxjwxc/uber_go_guide_cn" target="_blank" rel="noopener"><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/uber_go_guide_cn.svg" alt="Stargazers over time" /></a></p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://github.com/xxjwxc/uber_go_guide_cn" target="_blank" rel="noopener">https://github.com/xxjwxc/uber_go_guide_cn</a></li><li><a href="https://golang.org/doc/effective_go.html" target="_blank" rel="noopener">https://golang.org/doc/effective_go.html</a></li><li><a href="https://github.com/golang/go/wiki/CommonMistakes" target="_blank" rel="noopener">https://github.com/golang/go/wiki/CommonMistakes</a></li><li><a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="noopener">https://github.com/golang/go/wiki/CodeReviewComments</a></li><li><a href="https://go.dev/doc/effective_go#pointers_vs_values" target="_blank" rel="noopener">https://go.dev/doc/effective_go#pointers_vs_values</a></li><li><a href="https://go.dev/ref/spec#Method_values" target="_blank" rel="noopener">https://go.dev/ref/spec#Method_values</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;所有代码都应该通过&lt;code&gt;golint&lt;/code&gt;和&lt;code&gt;go vet&lt;/code&gt;的检查并无错误。建议将编辑器设置为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保存时运行 &lt;code&gt;goimports&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;运行 &lt;code&gt;golint&lt;/co
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-概述</title>
    <link href="http://xboom.github.io/2022/08/14/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E8%BF%B0/"/>
    <id>http://xboom.github.io/2022/08/14/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E8%BF%B0/</id>
    <published>2022-08-14T12:00:54.000Z</published>
    <updated>2022-08-14T12:00:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>设计模式</strong>是软件设计中常见问题的典型解决方案。 它们就像能根据需求进行调整的预制蓝图， 可用于解决代码中反复出现的设计问题</p><p>模式根据其目的来分类：</p><ul><li><strong>创建型模式</strong>提供创建对象的机制， 增加已有代码的灵活性和可复用性</li><li><strong>结构型模式</strong>介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效</li><li><strong>行为模式</strong>负责对象间的高效沟通和职责委派</li></ul><h3 id="创建型模式"><a class="markdownIt-Anchor" href="#创建型模式"></a> 创建型模式</h3><ol><li><a href="https://www.yuankang.top/2022/07/19/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">单例模式(Singleton Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/07/19/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/" target="_blank" rel="noopener">简单工厂模式(Simple Factory Pattern)</a></li><li><a href="https://www.yuankang.top/2022/07/19/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">工厂方法模式(Factory Method Pattern)</a></li><li><a href="https://www.yuankang.top/2022/07/19/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/" target="_blank" rel="noopener">抽象工厂模式(Abstract Factory)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">建造者模式(Builder Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">原型模式(Prototype Design Pattern)</a></li></ol><h3 id="结构性模式"><a class="markdownIt-Anchor" href="#结构性模式"></a> 结构性模式</h3><ol><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">代理模式(Proxy Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">桥接模式(Bridge Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">装饰器模式(Decorator Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">适配器模式(Adapter Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">门面模式(Facade Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">组合模式(Composite Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">享元模式(Flyweight Design Pattern)</a></li></ol><h3 id="行为模式"><a class="markdownIt-Anchor" href="#行为模式"></a> 行为模式</h3><ol><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">观察者模式(Observer Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">模板模式(Template Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">策略模式(Strategy Method Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">职责链模式(Chain Of Responsibility Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">状态模式(State  Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">迭代器模式(Iterator Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">访问者模式(Visitor Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">备忘录模式(Memento Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">命令模式(Command Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">解释器模式(Interpreter Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">中介模式(Mediator Design Pattern)</a></li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://lailin.xyz/post/go-design-pattern.html" target="_blank" rel="noopener">https://lailin.xyz/post/go-design-pattern.html</a></li><li><a href="https://docs.microsoft.com/zh-cn/azure/architecture/patterns/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/azure/architecture/patterns/</a></li><li><a href="https://github.com/senghoo/golang-design-pattern" target="_blank" rel="noopener">https://github.com/senghoo/golang-design-pattern</a></li><li><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;设计模式&lt;/strong&gt;是软件设计中常见问题的典型解决方案。 它们就像能根据需求进行调整的预制蓝图， 可用于解决代码中反复出现的设计问题&lt;/p&gt;
&lt;p&gt;模式根据其目的来分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建型模式&lt;/strong&gt;提供创建对
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="http://xboom.github.io/2022/08/14/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/14/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-14T11:11:29.000Z</published>
    <updated>2022-08-14T11:11:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个类只允许创建一个对象(或实例)，那这个类就是一个单例类，这种设计模式就叫做单例设计模式(Singleton Design Pattern)</p><p>单例模式分为 <code>饿汉式</code> 和 <code>懒汉式</code> 两种实现</p><ol><li><strong>饿汉式</strong>：初始化的时候已经创建好实例</li><li><strong>懒汉式</strong>：只有在调用的时候才会初始化</li></ol><p>构建的时候注意：</p><ol><li>构造函数是私有访问权限(防止被其他地方重新构建)</li><li>构建的时候考虑并发情况</li><li>考虑是否支持延迟加载</li></ol><h3 id="饿汉式"><a class="markdownIt-Anchor" href="#饿汉式"></a> 饿汉式</h3><h4 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="comment">// Singleton 饿汉式单例</span></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> singleton *Singleton</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">singleton = &amp;Singleton&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetInstance 获取实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">Singleton</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> singleton</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetInstance</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">assert.Equal(t, singleton.GetInstance(), singleton.GetInstance()) <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkGetInstanceParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line"><span class="keyword">if</span> singleton.GetInstance() != singleton.GetInstance() &#123;</span><br><span class="line">b.Errorf(<span class="string">"test fail"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性能测试结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkGetInstanceParallel-8   1000000000         0.234 ns/op</span><br></pre></td></tr></table></figure><h3 id="懒汉式"><a class="markdownIt-Anchor" href="#懒汉式"></a> 懒汉式</h3><h4 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Singleton 是单例模式接口，导出的</span></span><br><span class="line"><span class="comment">// 通过该接口可以避免 GetInstance 返回一个包私有类型的指针</span></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">interface</span> &#123;</span><br><span class="line">foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// singleton 是单例模式类，包私有的</span></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s singleton)</span> <span class="title">foo</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">instance *singleton</span><br><span class="line">once     sync.Once</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//GetInstance 用于获取单例模式对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> <span class="title">Singleton</span></span> &#123;</span><br><span class="line">once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">instance = &amp;singleton&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单元测试-2"><a class="markdownIt-Anchor" href="#单元测试-2"></a> 单元测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetLazyInstance</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">assert.Equal(t, singleton.GetLazyInstance(), singleton.GetLazyInstance())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkGetLazyInstanceParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line"><span class="keyword">if</span> singleton.GetLazyInstance() != singleton.GetLazyInstance() &#123;</span><br><span class="line">b.Errorf(<span class="string">"test fail"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性能测试结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkGetLazyInstanceParallel-8   1000000000         0.816 ns/op</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>可拓展性差，如果需要多实例对象可能比较麻烦，适用于单实例对象</li><li>可测试性差，因为是唯一实例，进行多场景修改实例进行测试可能会比较麻烦</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://lailin.xyz/post/singleton.html" target="_blank" rel="noopener">https://lailin.xyz/post/singleton.html</a></li><li><a href="https://github.com/senghoo/golang-design-pattern/blob/master/03_singleton/singleton.go" target="_blank" rel="noopener">https://github.com/senghoo/golang-design-pattern/blob/master/03_singleton/singleton.go</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个类只允许创建一个对象(或实例)，那这个类就是一个单例类，这种设计模式就叫做单例设计模式(Singleton Design Pattern)&lt;/p&gt;
&lt;p&gt;单例模式分为 &lt;code&gt;饿汉式&lt;/code&gt; 和 &lt;code&gt;懒汉式&lt;/code&gt; 两种实现&lt;/p&gt;
&lt;ol&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-组合模式</title>
    <link href="http://xboom.github.io/2022/08/14/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/14/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-14T10:02:10.000Z</published>
    <updated>2022-08-14T10:02:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>组合模式</strong>是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们</p><h3 id="实现代码"><a class="markdownIt-Anchor" href="#实现代码"></a> 实现代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> composite</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Component <span class="keyword">interface</span> &#123;</span><br><span class="line">Parent() Component</span><br><span class="line">SetParent(Component)</span><br><span class="line">Name() <span class="keyword">string</span></span><br><span class="line">SetName(<span class="keyword">string</span>)</span><br><span class="line">AddChild(Component)</span><br><span class="line">Print(<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">LeafNode = <span class="literal">iota</span></span><br><span class="line">CompositeNode</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewComponent</span><span class="params">(kind <span class="keyword">int</span>, name <span class="keyword">string</span>)</span> <span class="title">Component</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c Component</span><br><span class="line"><span class="keyword">switch</span> kind &#123;</span><br><span class="line"><span class="keyword">case</span> LeafNode:</span><br><span class="line">c = NewLeaf()</span><br><span class="line"><span class="keyword">case</span> CompositeNode:</span><br><span class="line">c = NewComposite()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.SetName(name)</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> component <span class="keyword">struct</span> &#123;</span><br><span class="line">parent Component</span><br><span class="line">name   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *component)</span> <span class="title">Parent</span><span class="params">()</span> <span class="title">Component</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.parent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *component)</span> <span class="title">SetParent</span><span class="params">(parent Component)</span></span> &#123;</span><br><span class="line">c.parent = parent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *component)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *component)</span> <span class="title">SetName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">c.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *component)</span> <span class="title">AddChild</span><span class="params">(Component)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *component)</span> <span class="title">Print</span><span class="params">(<span class="keyword">string</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Leaf <span class="keyword">struct</span> &#123;</span><br><span class="line">component</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLeaf</span><span class="params">()</span> *<span class="title">Leaf</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Leaf&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Leaf)</span> <span class="title">Print</span><span class="params">(pre <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s-%s\n"</span>, pre, c.Name())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Composite <span class="keyword">struct</span> &#123;</span><br><span class="line">component</span><br><span class="line">childs []Component</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewComposite</span><span class="params">()</span> *<span class="title">Composite</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Composite&#123;</span><br><span class="line">childs: <span class="built_in">make</span>([]Component, <span class="number">0</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Composite)</span> <span class="title">AddChild</span><span class="params">(child Component)</span></span> &#123;</span><br><span class="line">child.SetParent(c)</span><br><span class="line">c.childs = <span class="built_in">append</span>(c.childs, child)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Composite)</span> <span class="title">Print</span><span class="params">(pre <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s+%s\n"</span>, pre, c.Name())</span><br><span class="line">pre += <span class="string">" "</span></span><br><span class="line"><span class="keyword">for</span> _, comp := <span class="keyword">range</span> c.childs &#123;</span><br><span class="line">comp.Print(pre)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> composite</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleComposite</span><span class="params">()</span></span> &#123;</span><br><span class="line">root := NewComponent(CompositeNode, <span class="string">"root"</span>)</span><br><span class="line">c1 := NewComponent(CompositeNode, <span class="string">"c1"</span>)</span><br><span class="line">c2 := NewComponent(CompositeNode, <span class="string">"c2"</span>)</span><br><span class="line">c3 := NewComponent(CompositeNode, <span class="string">"c3"</span>)</span><br><span class="line"></span><br><span class="line">l1 := NewComponent(LeafNode, <span class="string">"l1"</span>)</span><br><span class="line">l2 := NewComponent(LeafNode, <span class="string">"l2"</span>)</span><br><span class="line">l3 := NewComponent(LeafNode, <span class="string">"l3"</span>)</span><br><span class="line"></span><br><span class="line">root.AddChild(c1)</span><br><span class="line">root.AddChild(c2)</span><br><span class="line">c1.AddChild(c3)</span><br><span class="line">c1.AddChild(l1)</span><br><span class="line">c2.AddChild(l2)</span><br><span class="line">c2.AddChild(l3)</span><br><span class="line"></span><br><span class="line">root.Print(<span class="string">""</span>)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// +root</span></span><br><span class="line"><span class="comment">//  +c1</span></span><br><span class="line"><span class="comment">//   +c3</span></span><br><span class="line"><span class="comment">//   -l1</span></span><br><span class="line"><span class="comment">//  +c2</span></span><br><span class="line"><span class="comment">//   -l2</span></span><br><span class="line"><span class="comment">//   -l3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li>可以利用多态和递归机制更方便地使用复杂树结构。</li><li><em>开闭原则</em>。 无需更改现有代码， 就可以在应用中添加新元素， 使其成为对象树的一部分</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/composite" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/composite</a></li><li><a href="https://lailin.xyz/post/composite.html" target="_blank" rel="noopener">https://lailin.xyz/post/composite.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;组合模式&lt;/strong&gt;是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们&lt;/p&gt;
&lt;h3 id=&quot;实现代码&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#实现代码&quot;&gt;&lt;/a&gt; 实现代码
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-解释器模式</title>
    <link href="http://xboom.github.io/2022/08/14/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/14/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-14T09:58:57.000Z</published>
    <updated>2022-08-14T09:58:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>解释器模式</strong>定义一套语言文法，并设计该语言解释器，使用户能使用特定文法控制解释器行为。解释器模式的意义在于，它分离多种复杂功能的实现，每个功能只需关注自身的解释。对于调用者不用关心内部的解释器的工作，只需要用简单的方式组合命令就可以</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> interpreter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点解释 接口</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">interface</span> &#123;</span><br><span class="line">Interpret() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="keyword">type</span> ValNode <span class="keyword">struct</span> &#123;</span><br><span class="line">val <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *ValNode)</span> <span class="title">Interpret</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> n.val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左右节点</span></span><br><span class="line"><span class="keyword">type</span> AddNode <span class="keyword">struct</span> &#123;</span><br><span class="line">left, right Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左右节点 解释器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *AddNode)</span> <span class="title">Interpret</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> n.left.Interpret() + n.right.Interpret()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最小节点</span></span><br><span class="line"><span class="keyword">type</span> MinNode <span class="keyword">struct</span> &#123;</span><br><span class="line">left, right Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最小节点解释器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *MinNode)</span> <span class="title">Interpret</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> n.left.Interpret() - n.right.Interpret()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解释器</span></span><br><span class="line"><span class="keyword">type</span> Parser <span class="keyword">struct</span> &#123;</span><br><span class="line">exp   []<span class="keyword">string</span></span><br><span class="line">index <span class="keyword">int</span></span><br><span class="line">prev  Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Parser)</span> <span class="title">Parse</span><span class="params">(exp <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">p.exp = strings.Split(exp, <span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p.index &gt;= <span class="built_in">len</span>(p.exp) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> p.exp[p.index] &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">p.prev = p.newAddNode()</span><br><span class="line"><span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">p.prev = p.newMinNode()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">p.prev = p.newValNode()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Parser)</span> <span class="title">newAddNode</span><span class="params">()</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">p.index++</span><br><span class="line"><span class="keyword">return</span> &amp;AddNode&#123;</span><br><span class="line">left:  p.prev,</span><br><span class="line">right: p.newValNode(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Parser)</span> <span class="title">newMinNode</span><span class="params">()</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">p.index++</span><br><span class="line"><span class="keyword">return</span> &amp;MinNode&#123;</span><br><span class="line">left:  p.prev,</span><br><span class="line">right: p.newValNode(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Parser)</span> <span class="title">newValNode</span><span class="params">()</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">v, _ := strconv.Atoi(p.exp[p.index])</span><br><span class="line">p.index++</span><br><span class="line"><span class="keyword">return</span> &amp;ValNode&#123;</span><br><span class="line">val: v,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Parser)</span> <span class="title">Result</span><span class="params">()</span> <span class="title">Node</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> p.prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> interpreter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestInterpreter</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">p := &amp;Parser&#123;&#125;</span><br><span class="line">p.Parse(<span class="string">"1 + 2 + 3 - 4 + 5 - 6"</span>)</span><br><span class="line">res := p.Result().Interpret()</span><br><span class="line">expect := <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> res != expect &#123;</span><br><span class="line">t.Fatalf(<span class="string">"expect %d got %d"</span>, expect, res)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h3><ol><li>自定义实现一个自定义接口告警规则功能</li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://lailin.xyz/post/interpreter.html" target="_blank" rel="noopener">https://lailin.xyz/post/interpreter.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;解释器模式&lt;/strong&gt;定义一套语言文法，并设计该语言解释器，使用户能使用特定文法控制解释器行为。解释器模式的意义在于，它分离多种复杂功能的实现，每个功能只需关注自身的解释。对于调用者不用关心内部的解释器的工作，只需要用简单的方式组合命令就可以&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-中介模式</title>
    <link href="http://xboom.github.io/2022/08/14/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/14/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-14T09:46:21.000Z</published>
    <updated>2022-08-14T09:46:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>中介者模式</strong>是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mediator</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//CD驱动 对象</span></span><br><span class="line"><span class="keyword">type</span> CDDriver <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CDDriver 读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CDDriver)</span> <span class="title">ReadData</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.Data = <span class="string">"music,image"</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"CDDriver: reading data %s\n"</span>, c.Data)</span><br><span class="line">GetMediatorInstance().changed(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CPU 对象</span></span><br><span class="line"><span class="keyword">type</span> CPU <span class="keyword">struct</span> &#123;</span><br><span class="line">Video <span class="keyword">string</span></span><br><span class="line">Sound <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CPU 处理数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CPU)</span> <span class="title">Process</span><span class="params">(data <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">sp := strings.Split(data, <span class="string">","</span>)</span><br><span class="line">c.Sound = sp[<span class="number">0</span>]</span><br><span class="line">c.Video = sp[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"CPU: split data with Sound %s, Video %s\n"</span>, c.Sound, c.Video)</span><br><span class="line">GetMediatorInstance().changed(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VideoCard 驱动</span></span><br><span class="line"><span class="keyword">type</span> VideoCard <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VideoCard 播放</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VideoCard)</span> <span class="title">Display</span><span class="params">(data <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">v.Data = data</span><br><span class="line">fmt.Printf(<span class="string">"VideoCard: display %s\n"</span>, v.Data)</span><br><span class="line">GetMediatorInstance().changed(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SoundCard 对象</span></span><br><span class="line"><span class="keyword">type</span> SoundCard <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SoundCard 播放</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SoundCard)</span> <span class="title">Play</span><span class="params">(data <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">s.Data = data</span><br><span class="line">fmt.Printf(<span class="string">"SoundCard: play %s\n"</span>, s.Data)</span><br><span class="line">GetMediatorInstance().changed(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中介</span></span><br><span class="line"><span class="keyword">type</span> Mediator <span class="keyword">struct</span> &#123;</span><br><span class="line">CD    *CDDriver</span><br><span class="line">CPU   *CPU</span><br><span class="line">Video *VideoCard</span><br><span class="line">Sound *SoundCard</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mediator *Mediator</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetMediatorInstance</span><span class="params">()</span> *<span class="title">Mediator</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> mediator == <span class="literal">nil</span> &#123;<span class="comment">//单例模式-懒汉模式</span></span><br><span class="line">mediator = &amp;Mediator&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mediator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mediator)</span> <span class="title">changed</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> inst := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *CDDriver:</span><br><span class="line">m.CPU.Process(inst.Data)</span><br><span class="line"><span class="keyword">case</span> *CPU:</span><br><span class="line">m.Sound.Play(inst.Sound)</span><br><span class="line">m.Video.Display(inst.Video)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mediator</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMediator</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">mediator := GetMediatorInstance()</span><br><span class="line">mediator.CD = &amp;CDDriver&#123;&#125;</span><br><span class="line">mediator.CPU = &amp;CPU&#123;&#125;</span><br><span class="line">mediator.Video = &amp;VideoCard&#123;&#125;</span><br><span class="line">mediator.Sound = &amp;SoundCard&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Tiggle</span></span><br><span class="line">mediator.CD.ReadData()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mediator.CD.Data != <span class="string">"music,image"</span> &#123;</span><br><span class="line">t.Fatalf(<span class="string">"CD unexpect data %s"</span>, mediator.CD.Data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mediator.CPU.Sound != <span class="string">"music"</span> &#123;</span><br><span class="line">t.Fatalf(<span class="string">"CPU unexpect sound data %s"</span>, mediator.CPU.Sound)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mediator.CPU.Video != <span class="string">"image"</span> &#123;</span><br><span class="line">t.Fatalf(<span class="string">"CPU unexpect video data %s"</span>, mediator.CPU.Video)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mediator.Video.Data != <span class="string">"image"</span> &#123;</span><br><span class="line">t.Fatalf(<span class="string">"VidoeCard unexpect data %s"</span>, mediator.Video.Data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mediator.Sound.Data != <span class="string">"music"</span> &#123;</span><br><span class="line">t.Fatalf(<span class="string">"SoundCard unexpect data %s"</span>, mediator.Sound.Data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><ol><li>当一些对象和其他对象紧密耦合以致难以对其进行修改时</li><li>当组件因过于依赖其他组件而无法在不同应用中复用时，可使用中介者模式</li><li>如果为了能在不同情景下复用一些基本行为，导致需要被迫创建大量组件子类时</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li><em>单一职责原则</em>。 可以将多个组件间的交流抽取到同一位置， 使其更易于理解和维护。</li><li><em>开闭原则</em>。 无需修改实际组件就能增加新的中介者</li><li>可以减轻应用中多个组件间的耦合情况。</li><li>可以更方便地复用各个组件。</li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/mediator" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/mediator</a></li><li><a href="https://lailin.xyz/post/mediator.html" target="_blank" rel="noopener">https://lailin.xyz/post/mediator.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;中介者模式&lt;/strong&gt;是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; h
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-状态模式</title>
    <link href="http://xboom.github.io/2022/08/14/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/14/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-14T09:45:54.000Z</published>
    <updated>2022-08-14T09:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>状态模式</strong>是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> state</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Week <span class="keyword">interface</span> &#123;</span><br><span class="line">Today()</span><br><span class="line">Next(*DayContext)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DayContext <span class="keyword">struct</span> &#123;</span><br><span class="line">today Week</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDayContext</span><span class="params">()</span> *<span class="title">DayContext</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;DayContext&#123;</span><br><span class="line">today: &amp;Sunday&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DayContext)</span> <span class="title">Today</span><span class="params">()</span></span> &#123;</span><br><span class="line">d.today.Today()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DayContext)</span> <span class="title">Next</span><span class="params">()</span></span> &#123;</span><br><span class="line">d.today.Next(d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Sunday <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Sunday)</span> <span class="title">Today</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Sunday\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Sunday)</span> <span class="title">Next</span><span class="params">(ctx *DayContext)</span></span> &#123;</span><br><span class="line">ctx.today = &amp;Monday&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monday <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Monday)</span> <span class="title">Today</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Monday\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Monday)</span> <span class="title">Next</span><span class="params">(ctx *DayContext)</span></span> &#123;</span><br><span class="line">ctx.today = &amp;Tuesday&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Tuesday <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Tuesday)</span> <span class="title">Today</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Tuesday\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Tuesday)</span> <span class="title">Next</span><span class="params">(ctx *DayContext)</span></span> &#123;</span><br><span class="line">ctx.today = &amp;Wednesday&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Wednesday <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Wednesday)</span> <span class="title">Today</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Wednesday\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Wednesday)</span> <span class="title">Next</span><span class="params">(ctx *DayContext)</span></span> &#123;</span><br><span class="line">ctx.today = &amp;Thursday&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Thursday <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Thursday)</span> <span class="title">Today</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Thursday\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Thursday)</span> <span class="title">Next</span><span class="params">(ctx *DayContext)</span></span> &#123;</span><br><span class="line">ctx.today = &amp;Friday&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Friday <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Friday)</span> <span class="title">Today</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Friday\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Friday)</span> <span class="title">Next</span><span class="params">(ctx *DayContext)</span></span> &#123;</span><br><span class="line">ctx.today = &amp;Saturday&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Saturday <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Saturday)</span> <span class="title">Today</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Saturday\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Saturday)</span> <span class="title">Next</span><span class="params">(ctx *DayContext)</span></span> &#123;</span><br><span class="line">ctx.today = &amp;Sunday&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> state</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleWeek</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := NewDayContext()</span><br><span class="line">todayAndNext := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx.Today()</span><br><span class="line">ctx.Next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">todayAndNext()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Sunday</span></span><br><span class="line"><span class="comment">// Monday</span></span><br><span class="line"><span class="comment">// Tuesday</span></span><br><span class="line"><span class="comment">// Wednesday</span></span><br><span class="line"><span class="comment">// Thursday</span></span><br><span class="line"><span class="comment">// Friday</span></span><br><span class="line"><span class="comment">// Saturday</span></span><br><span class="line"><span class="comment">// Sunday</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><ol><li>模式建议将所有特定于状态的代码抽取到一组独立的类中。 这样一来可以在独立于其他状态的情况下添加新状态或修改已有状态， 从而减少维护成本</li><li>状态模式会将这些条件语句的分支抽取到相应状态类的方法中。 同时还可以清除主要类中与特定状态相关的临时成员变量和帮手方法代码</li><li>状态模式让你能够生成状态类层次结构， 通过将公用代码抽取到抽象基类中来减少重复</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li><em>单一职责原则</em>。 将与特定状态相关的代码放在单独的类中。</li><li><em>开闭原则</em>。 无需修改已有状态类和上下文就能引入新状态。</li><li>通过消除臃肿的状态机条件语句简化上下文代码。</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/state" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/state</a></li><li><a href="https://lailin.xyz/post/state.html" target="_blank" rel="noopener">https://lailin.xyz/post/state.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;状态模式&lt;/strong&gt;是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#代码实现&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-模板方法模式</title>
    <link href="http://xboom.github.io/2022/08/14/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/14/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-14T09:41:09.000Z</published>
    <updated>2022-08-14T09:41:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>模板方法模式</strong>是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤</p><p>举个 例子，假设现在要做一个短信推送的系统，那么需要</p><ol><li>检查短信字数是否超过限制</li><li>检查手机号是否正确</li><li>发送短信</li><li>返回状态</li></ol><p>可以发现，在发送短信的时候由于不同的供应商调用的接口不同，所以会有一些实现上的差异，但短信推送的算法（业务逻辑）是固定的</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> templatemethod</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Downloader <span class="keyword">interface</span> &#123;</span><br><span class="line">Download(uri <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> template <span class="keyword">struct</span> &#123;</span><br><span class="line">implement</span><br><span class="line">uri <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> implement <span class="keyword">interface</span> &#123;</span><br><span class="line">download()</span><br><span class="line">save()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTemplate</span><span class="params">(impl implement)</span> *<span class="title">template</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;template&#123;</span><br><span class="line">implement: impl,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *template)</span> <span class="title">Download</span><span class="params">(uri <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">t.uri = uri</span><br><span class="line">fmt.Print(<span class="string">"prepare downloading\n"</span>)</span><br><span class="line">t.implement.download()</span><br><span class="line">t.implement.save()</span><br><span class="line">fmt.Print(<span class="string">"finish downloading\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *template)</span> <span class="title">save</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Print(<span class="string">"default save\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HTTPDownloader <span class="keyword">struct</span> &#123;</span><br><span class="line">*template</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHTTPDownloader</span><span class="params">()</span> <span class="title">Downloader</span></span> &#123;</span><br><span class="line">downloader := &amp;HTTPDownloader&#123;&#125;</span><br><span class="line">template := newTemplate(downloader)</span><br><span class="line">downloader.template = template</span><br><span class="line"><span class="keyword">return</span> downloader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *HTTPDownloader)</span> <span class="title">download</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"download %s via http\n"</span>, d.uri)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*HTTPDownloader)</span> <span class="title">save</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"http save\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FTPDownloader <span class="keyword">struct</span> &#123;</span><br><span class="line">*template</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFTPDownloader</span><span class="params">()</span> <span class="title">Downloader</span></span> &#123;</span><br><span class="line">downloader := &amp;FTPDownloader&#123;&#125;</span><br><span class="line">template := newTemplate(downloader)</span><br><span class="line">downloader.template = template</span><br><span class="line"><span class="keyword">return</span> downloader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *FTPDownloader)</span> <span class="title">download</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"download %s via ftp\n"</span>, d.uri)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> templatemethod</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleHTTPDownloader</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> downloader Downloader = NewHTTPDownloader()</span><br><span class="line"></span><br><span class="line">downloader.Download(<span class="string">"http://example.com/abc.zip"</span>)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// prepare downloading</span></span><br><span class="line"><span class="comment">// download http://example.com/abc.zip via http</span></span><br><span class="line"><span class="comment">// http save</span></span><br><span class="line"><span class="comment">// finish downloading</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleFTPDownloader</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> downloader Downloader = NewFTPDownloader()</span><br><span class="line"></span><br><span class="line">downloader.Download(<span class="string">"ftp://example.com/abc.zip"</span>)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// prepare downloading</span></span><br><span class="line"><span class="comment">// download ftp://example.com/abc.zip via ftp</span></span><br><span class="line"><span class="comment">// default save</span></span><br><span class="line"><span class="comment">// finish downloading</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h3><ol><li>模板方法将整个算法转换为一系列独立的步骤， 以便子类能对其进行扩展， 同时还可让超类中所定义的结构保持完整</li><li>在将算法转换为模板方法时， 你可将相似的实现步骤提取到超类中以去除重复代码。 子类间各不同的代码可继续保留在子类中</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>可仅允许客户端重写一个大型算法中的特定部分， 使得算法其他部分修改对其所造成的影响减小。</li><li>可将重复代码提取到一个超类中</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;模板方法模式&lt;/strong&gt;是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤&lt;/p&gt;
&lt;p&gt;举个 例子，假设现在要做一个短信推送的系统，那么需要&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检查短信字数是否超过限制&lt;/l
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-访问者模式</title>
    <link href="http://xboom.github.io/2022/08/14/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/14/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-14T09:32:12.000Z</published>
    <updated>2022-08-14T09:32:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>访问者模式</strong>是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> visitor</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者 接口</span></span><br><span class="line"><span class="keyword">type</span> Customer <span class="keyword">interface</span> &#123;</span><br><span class="line">Accept(Visitor)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问者 接口</span></span><br><span class="line"><span class="keyword">type</span> Visitor <span class="keyword">interface</span> &#123;</span><br><span class="line">Visit(Customer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//企业消费者</span></span><br><span class="line"><span class="keyword">type</span> EnterpriseCustomer <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者池</span></span><br><span class="line"><span class="keyword">type</span> CustomerCol <span class="keyword">struct</span> &#123;</span><br><span class="line">customers []Customer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加消费者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CustomerCol)</span> <span class="title">Add</span><span class="params">(customer Customer)</span></span> &#123;</span><br><span class="line">c.customers = <span class="built_in">append</span>(c.customers, customer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收访问者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CustomerCol)</span> <span class="title">Accept</span><span class="params">(visitor Visitor)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, customer := <span class="keyword">range</span> c.customers &#123;</span><br><span class="line">customer.Accept(visitor)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEnterpriseCustomer</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">EnterpriseCustomer</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;EnterpriseCustomer&#123;</span><br><span class="line">name: name,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *EnterpriseCustomer)</span> <span class="title">Accept</span><span class="params">(visitor Visitor)</span></span> &#123;</span><br><span class="line">visitor.Visit(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IndividualCustomer <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewIndividualCustomer</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">IndividualCustomer</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;IndividualCustomer&#123;</span><br><span class="line">name: name,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *IndividualCustomer)</span> <span class="title">Accept</span><span class="params">(visitor Visitor)</span></span> &#123;</span><br><span class="line">visitor.Visit(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceRequestVisitor <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*ServiceRequestVisitor)</span> <span class="title">Visit</span><span class="params">(customer Customer)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> c := customer.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *EnterpriseCustomer:</span><br><span class="line">fmt.Printf(<span class="string">"serving enterprise customer %s\n"</span>, c.name)</span><br><span class="line"><span class="keyword">case</span> *IndividualCustomer:</span><br><span class="line">fmt.Printf(<span class="string">"serving individual customer %s\n"</span>, c.name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// only for enterprise</span></span><br><span class="line"><span class="keyword">type</span> AnalysisVisitor <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*AnalysisVisitor)</span> <span class="title">Visit</span><span class="params">(customer Customer)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> c := customer.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *EnterpriseCustomer:</span><br><span class="line">fmt.Printf(<span class="string">"analysis enterprise customer %s\n"</span>, c.name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> visitor</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleRequestVisitor</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := &amp;CustomerCol&#123;&#125;</span><br><span class="line">c.Add(NewEnterpriseCustomer(<span class="string">"A company"</span>))</span><br><span class="line">c.Add(NewEnterpriseCustomer(<span class="string">"B company"</span>))</span><br><span class="line">c.Add(NewIndividualCustomer(<span class="string">"bob"</span>))</span><br><span class="line">c.Accept(&amp;ServiceRequestVisitor&#123;&#125;)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// serving enterprise customer A company</span></span><br><span class="line"><span class="comment">// serving enterprise customer B company</span></span><br><span class="line"><span class="comment">// serving individual customer bob</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleAnalysis</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := &amp;CustomerCol&#123;&#125;</span><br><span class="line">c.Add(NewEnterpriseCustomer(<span class="string">"A company"</span>))</span><br><span class="line">c.Add(NewIndividualCustomer(<span class="string">"bob"</span>))</span><br><span class="line">c.Add(NewEnterpriseCustomer(<span class="string">"B company"</span>))</span><br><span class="line">c.Accept(&amp;AnalysisVisitor&#123;&#125;)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// analysis enterprise customer A company</span></span><br><span class="line"><span class="comment">// analysis enterprise customer B company</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><ol><li>访问者模式通过在访问者对象中为多个目标类提供相同操作的变体， 让你能在属于不同类的一组对象上执行同一操作</li><li>该模式会将所有非主要的行为抽取到一组访问者类中， 使得程序的主要类能更专注于主要的工作</li><li>可将该行为抽取到单独的访问者类中， 只需实现接收相关类的对象作为参数的访问者方法并将其他方法留空即可。</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li><em>开闭原则</em>。 可以引入在不同类对象上执行的新行为， 且无需对这些类做出修改。</li><li><em>单一职责原则</em>。 可将同一行为的不同版本移到同一个类中。</li><li>访问者对象可以在与各种对象交互时收集一些有用的信息。 当你想要遍历一些复杂的对象结构 （例如对象树）， 并在结构中的每个对象上应用访问者时， 这些信息可能会有所帮助</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/visitor" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/visitor</a></li><li><a href="https://lailin.xyz/post/visitor.html" target="_blank" rel="noopener">https://lailin.xyz/post/visitor.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;访问者模式&lt;/strong&gt;是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#代码实现&quot;&gt;&lt;/a&gt; 代码实现&lt;/h3&gt;
&lt;figure cl
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-策略模式</title>
    <link href="http://xboom.github.io/2022/08/14/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/14/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-14T09:14:10.000Z</published>
    <updated>2022-08-14T09:14:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>策略模式</strong>是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//支付结构体</span></span><br><span class="line"><span class="keyword">type</span> Payment <span class="keyword">struct</span> &#123;</span><br><span class="line">context  *PaymentContext</span><br><span class="line">strategy PaymentStrategy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//支付上下文</span></span><br><span class="line"><span class="keyword">type</span> PaymentContext <span class="keyword">struct</span> &#123;</span><br><span class="line">Name, CardID <span class="keyword">string</span></span><br><span class="line">Money        <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建新的支付对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPayment</span><span class="params">(name, cardid <span class="keyword">string</span>, money <span class="keyword">int</span>, strategy PaymentStrategy)</span> *<span class="title">Payment</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Payment&#123;</span><br><span class="line">context: &amp;PaymentContext&#123;</span><br><span class="line">Name:   name,</span><br><span class="line">CardID: cardid,</span><br><span class="line">Money:  money,</span><br><span class="line">&#125;,</span><br><span class="line">strategy: strategy,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据策略进行支付</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Payment)</span> <span class="title">Pay</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.strategy.Pay(p.context)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PaymentStrategy <span class="keyword">interface</span> &#123;</span><br><span class="line">Pay(*PaymentContext)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cash <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Cash)</span> <span class="title">Pay</span><span class="params">(ctx *PaymentContext)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Pay $%d to %s by cash"</span>, ctx.Money, ctx.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bank <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Bank)</span> <span class="title">Pay</span><span class="params">(ctx *PaymentContext)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Pay $%d to %s by bank account %s"</span>, ctx.Money, ctx.Name, ctx.CardID)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExamplePayByCash</span><span class="params">()</span></span> &#123;</span><br><span class="line">payment := NewPayment(<span class="string">"Ada"</span>, <span class="string">""</span>, <span class="number">123</span>, &amp;Cash&#123;&#125;)</span><br><span class="line">payment.Pay()</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Pay $123 to Ada by cash</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExamplePayByBank</span><span class="params">()</span></span> &#123;</span><br><span class="line">payment := NewPayment(<span class="string">"Bob"</span>, <span class="string">"0002"</span>, <span class="number">888</span>, &amp;Bank&#123;&#125;)</span><br><span class="line">payment.Pay()</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Pay $888 to Bob by bank account 0002</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><ol><li>当想使用对象中各种不同的算法变体，并希望能在运行时切换算法时</li><li>当有许多仅在执行某些行为时略有不同的相似类时</li><li>如果算法在上下文的逻辑中不是特别重要，使用该模式能将类的业务逻辑与其算法实现细节隔离开来</li><li>当类中使用了复杂条件运算符以在同一算法的不同变体中切换时</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li>可以在运行时切换对象内的算法。</li><li>可以将算法的实现和使用算法的代码隔离开来。</li><li>可以使用组合来代替继承。</li><li><em>开闭原则</em>。 无需对上下文进行修改就能够引入新的策略</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/strategy" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/strategy</a></li><li><a href="https://lailin.xyz/post/strategy.html" target="_blank" rel="noopener">https://lailin.xyz/post/strategy.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;策略模式&lt;/strong&gt;是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#代码实现&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-观察者模式</title>
    <link href="http://xboom.github.io/2022/08/14/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/14/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-14T08:44:02.000Z</published>
    <updated>2022-08-14T08:44:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>观察者模式</strong>是一种行为设计模式，允许你定义一种订阅机制，可在对象事件发生时通知多个“观察” 该对象的其他对象</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> observer</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象</span></span><br><span class="line"><span class="keyword">type</span> Subject <span class="keyword">struct</span> &#123;</span><br><span class="line">observers []Observer<span class="comment">//观察者</span></span><br><span class="line">context   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSubject</span><span class="params">()</span> *<span class="title">Subject</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Subject&#123;</span><br><span class="line">observers: <span class="built_in">make</span>([]Observer, <span class="number">0</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加观察者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Subject)</span> <span class="title">Attach</span><span class="params">(o Observer)</span></span> &#123;</span><br><span class="line">s.observers = <span class="built_in">append</span>(s.observers, o)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知观察者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Subject)</span> <span class="title">notify</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, o := <span class="keyword">range</span> s.observers &#123;</span><br><span class="line">o.Update(s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新上下文</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Subject)</span> <span class="title">UpdateContext</span><span class="params">(context <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">s.context = context</span><br><span class="line">s.notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//订阅接口</span></span><br><span class="line"><span class="keyword">type</span> Observer <span class="keyword">interface</span> &#123;</span><br><span class="line">Update(*Subject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">Reader</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Reader&#123;</span><br><span class="line">name: name,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">Update</span><span class="params">(s *Subject)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s receive %s\n"</span>, r.name, s.context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> observer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleObserver</span><span class="params">()</span></span> &#123;</span><br><span class="line">subject := NewSubject()</span><br><span class="line">reader1 := NewReader(<span class="string">"reader1"</span>)</span><br><span class="line">reader2 := NewReader(<span class="string">"reader2"</span>)</span><br><span class="line">reader3 := NewReader(<span class="string">"reader3"</span>)</span><br><span class="line">subject.Attach(reader1)</span><br><span class="line">subject.Attach(reader2)</span><br><span class="line">subject.Attach(reader3)</span><br><span class="line"></span><br><span class="line">subject.UpdateContext(<span class="string">"observer mode"</span>)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// reader1 receive observer mode</span></span><br><span class="line"><span class="comment">// reader2 receive observer mode</span></span><br><span class="line"><span class="comment">// reader3 receive observer mode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><ol><li>当一个对象状态的改变需要改变其他对象，或实际对象是事先未知的或动态变化的时</li><li>当应用中的一些对象必须观察其他对象时，但仅能在有限时间内或特定情况下使用</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li><em>开闭原则</em>。 <strong>无需修改发布者代码就能引入新的订阅者类</strong> (如果是发布者接口则可轻松引入发布者类)，<code>channel</code> 也存在类似功能。</li><li>可以在运行时建立对象之间的联系。</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/observer" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/observer</a></li><li><a href="https://lailin.xyz/post/observer.html" target="_blank" rel="noopener">https://lailin.xyz/post/observer.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;观察者模式&lt;/strong&gt;是一种行为设计模式，允许你定义一种订阅机制，可在对象事件发生时通知多个“观察” 该对象的其他对象&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#代码实现&quot;&gt;&lt;/a&gt; 代
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-备忘录模式</title>
    <link href="http://xboom.github.io/2022/08/14/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/14/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-14T08:23:49.000Z</published>
    <updated>2022-08-14T08:23:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>备忘录模式</strong>是一种行为设计模式，允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memento</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//备忘录 接口</span></span><br><span class="line"><span class="keyword">type</span> Memento <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Game 结构</span></span><br><span class="line"><span class="keyword">type</span> Game <span class="keyword">struct</span> &#123;</span><br><span class="line">hp, mp <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// game 备忘录(拥有相同的接口)</span></span><br><span class="line"><span class="keyword">type</span> gameMemento <span class="keyword">struct</span> &#123;</span><br><span class="line">hp, mp <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Game)</span> <span class="title">Play</span><span class="params">(mpDelta, hpDelta <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">g.mp += mpDelta</span><br><span class="line">g.hp += hpDelta</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回 Game 内部成员</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Game)</span> <span class="title">Save</span><span class="params">()</span> <span class="title">Memento</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;gameMemento&#123;</span><br><span class="line">hp: g.hp,</span><br><span class="line">mp: g.mp,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存 备忘录内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Game)</span> <span class="title">Load</span><span class="params">(m Memento)</span></span> &#123;</span><br><span class="line">gm := m.(*gameMemento)</span><br><span class="line">g.mp = gm.mp</span><br><span class="line">g.hp = gm.hp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Game)</span> <span class="title">Status</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Current HP:%d, MP:%d\n"</span>, g.hp, g.mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memento</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleGame</span><span class="params">()</span></span> &#123;</span><br><span class="line">game := &amp;Game&#123;</span><br><span class="line">hp: <span class="number">10</span>,</span><br><span class="line">mp: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">game.Status()</span><br><span class="line">progress := game.Save()</span><br><span class="line"></span><br><span class="line">game.Play(<span class="number">-2</span>, <span class="number">-3</span>)</span><br><span class="line">game.Status()</span><br><span class="line"></span><br><span class="line">game.Load(progress)</span><br><span class="line">game.Status()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Current HP:10, MP:10</span></span><br><span class="line"><span class="comment">// Current HP:7, MP:8</span></span><br><span class="line"><span class="comment">// Current HP:10, MP:10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><ol><li>当需要创建对象状态快照来恢复其之前的状态时</li><li>当直接访问对象的成员变量、获取器或设置器将导致封装被突破时</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li>可以在不破坏对象封装情况的前提下创建对象状态快照</li><li>可以通过让负责人维护原发器状态历史记录来简化原发器代码</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/memento" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/memento</a></li><li><a href="https://lailin.xyz/post/memento.html" target="_blank" rel="noopener">https://lailin.xyz/post/memento.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;备忘录模式&lt;/strong&gt;是一种行为设计模式，允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#代码实现&quot;&gt;&lt;/a&gt; 代码实现&lt;/h3&gt;

      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
</feed>
