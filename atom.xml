<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XBoom Dove</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xboom.github.io/"/>
  <updated>2022-07-31T03:01:41.292Z</updated>
  <id>http://xboom.github.io/</id>
  
  <author>
    <name>XBoom Dove</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微服务-缓存一致性</title>
    <link href="http://xboom.github.io/2022/07/28/Microservices/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>http://xboom.github.io/2022/07/28/Microservices/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</id>
    <published>2022-07-28T00:39:54.767Z</published>
    <updated>2022-07-31T03:01:41.292Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h3><p>一致性有很多种</p><ul><li><strong>强一致性</strong>：保证写入后立即可以读取</li><li><strong>弱一致性</strong>：在系统写入后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态</li><li><strong>最终一致性</strong>：最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态</li></ul><p>缓存可以提升性能、缓解数据库压力，使用缓存也会导致数据<strong>不一致性</strong>的问题</p><p>缓存系统的数据一致性通常包括持久化层和缓存层的一致性、以及多级缓存之间的一致性，这里讨论是前者。持久化层和缓存层的一致性问题也通常被称为双写一致性问题。</p><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>引入 <code>Cache</code> 之后，延迟或程序失败等都会导致缓存和实际存储层数据不一致，下面几种模式减少不一致风险</p><ol><li>Cache-Aside Pattern，即旁路缓存模式</li><li>Read-Through/Write-Through，读写穿透模式</li><li>Write behind，异步缓存写入模式</li></ol><h4 id="cache-aside"><a class="markdownIt-Anchor" href="#cache-aside"></a> Cache-Aside</h4><h5 id="读模式"><a class="markdownIt-Anchor" href="#读模式"></a> 读模式</h5><p>当缓存命中则直接返回，否则从数据库读取数据并更新缓存</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/cache-same-6.png" alt="cache-same-6" style="zoom:67%;" /><h5 id="写模式"><a class="markdownIt-Anchor" href="#写模式"></a> 写模式</h5><p>首先更新数据库，然后删除缓存</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/cache-same-8.png" alt="cache-same-3" style="zoom:67%;" /><p><strong>问题1</strong>：为什么是删除缓存，而不是更新缓存</p><ol><li>如果缓存需要通过大量的计算(联表查询更新)，那么更新缓存会是一笔不小的开销</li><li>另外如果写操作比较多，可能存在刚更新的缓存还没有读取就又要更新的情况(称为<strong>缓存扰动</strong>)，所以此模式适用于读多写少的模式</li><li>等到读请求未命中再去更新，符合懒加载思路</li><li>并发更新可能导致缓存落后与数据库，读请求读到的仍然是旧缓存</li></ol><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/cache-same-8.png" alt="cache-same-8" style="zoom:67%;" /><p><strong>问题2</strong>：为什么是先更新数据库，而不是先删除缓存</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/cahche-same-10.png" alt="cahche-same-10" style="zoom:67%;" /><p>数据库查询请求往往比更新请求更快，可能这种异常更容易出现</p><h4 id="readwrite-through"><a class="markdownIt-Anchor" href="#readwrite-through"></a> Read/Write Through</h4><h5 id="读模式-2"><a class="markdownIt-Anchor" href="#读模式-2"></a> 读模式</h5><p>当缓存命中则直接返回，否则从数据库读取数据并更新缓存</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/cache-same-8.png" alt="cache-same-6" style="zoom: 50%;" /><p><strong>Read/Write Through</strong>模式中，服务端把缓存作为主要数据存储。应用程序跟数据库缓存交互，都是通过<strong>抽象缓存层</strong>完成的</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/cache-same-8.png" alt="cache-same-11" style="zoom: 50%;" /><h5 id="写模式-2"><a class="markdownIt-Anchor" href="#写模式-2"></a> 写模式</h5><p>Write Through模式在发生Cache Miss的时候，只会在读请求中更新缓存。</p><ul><li><p>写请求在发生Cache Miss的时候不会更新缓存，而是直接写入数据库；</p></li><li><p>如果命中缓存则先更新缓存，由缓存自己再将数据写回到数据库中</p></li></ul><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/cache-same-8.png" alt="cache-same-12" style="zoom: 50%;" /><p>注意这个时候如果命中缓存，是先更新缓存的。也就说和 Cache-Aside一样存在并发场景下的一致性问题</p><p>这个策略的核心原则：<strong>用户只与缓存打交道，由缓存组件和DB通信，写入或者读取数据</strong>。在一些本地进程缓存组件可以考虑这种策略</p><p><strong>Write-Through</strong> 存在的缺陷：写数据时缓存和数据库同步，但是我们知道这两块存储介质的速度差几个数量级，对写入性能是有很大影响。那我们是否异步更新数据库</p><h4 id="write-behind"><a class="markdownIt-Anchor" href="#write-behind"></a> Write behind</h4><p><strong>Write behind</strong> 跟有相似的地方，都是由<code>Cache Provider</code>来负责缓存和数据库的读写。它两又有个很大的不同：<strong>Read/Write Through</strong>是同步更新缓存和数据的，<strong>Write Behind</strong>则是只更新缓存，不直接更新数据库，通过<strong>批量异步</strong>的方式来更新数据库</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/cache-same-8.png" alt="cache-same-13" style="zoom:50%;" /><p>缓存和数据库的一致性不强，<strong>对一致性要求高的系统要谨慎使用</strong>。但是它适合频繁写的场景，MySQL的<strong>InnoDB Buffer Pool机制</strong>就使用到这种模式</p><h4 id="延时双删"><a class="markdownIt-Anchor" href="#延时双删"></a> 延时双删</h4><p>延时双删主要用于 Redis主从节点的场景，延时的原因是，mysql 和 redis 主从节点数据不是实时同步的，同步数据需要时间。</p><ol><li>服务节点删除 redis 主库数据</li><li>服务节点修改 mysql 主库数据</li><li>服务节点使得当前业务处理 <code>等待一段时间</code>，等 redis 和 mysql 主从节点数据同步成功。</li><li>服务节点从 redis 主库删除数据。</li><li>当前或其它服务节点读取 redis 从库数据，发现 redis 从库没有数据，从 mysql 从库读取数据，并写入 redis 主库</li></ol><p>注意：</p><ol><li>延时双删，有等待环节，如果系统要求低延时，这种场景就不合适了。</li><li>延时双删，不适合“秒杀”这种频繁修改数据和要求数据强一致的场景。</li><li>延时双删，延时时间是一个预估值，不能确保 mysql 和 redis 数据在这个时间段内都实时同步或持久化成功了</li></ol><h4 id="重试保障"><a class="markdownIt-Anchor" href="#重试保障"></a> 重试保障</h4><h5 id="方案1服务自行订阅删除缓存消息"><a class="markdownIt-Anchor" href="#方案1服务自行订阅删除缓存消息"></a> 方案1：服务自行订阅删除缓存消息</h5><ol><li>更新数据库数据；</li><li>缓存因为种种问题删除失败；</li><li>将需要删除的key发送至消息队列；</li><li>自己消费消息，获得需要删除的key；</li><li>继续重试删除操作，直到成功</li></ol><h5 id="方案2利用第三方服务删除缓存"><a class="markdownIt-Anchor" href="#方案2利用第三方服务删除缓存"></a> 方案2：利用第三方服务删除缓存</h5><ol><li>更新数据库数据；</li><li>数据库会将操作信息写入binlog日志当中；</li><li>订阅程序提取出所需要的数据以及key；</li><li>另起一段非业务代码，获得该信息；</li><li>尝试删除缓存操作，发现删除失败；</li><li>将这些信息发送至消息队列；</li><li>重新从消息队列中获得该数据，重试操作</li></ol><p>注意：</p><ol><li>删除缓存也可能存储缓存击穿的问题<ul><li>在 <a href="https://www.yuankang.top/2022/07/19/GoZero/GoZero8-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98/" target="_blank" rel="noopener">GoZero8-数据库缓存中</a>中使用共享调用的方式(类似自旋锁)进行数据查询</li></ul></li><li>使用<strong>方案1</strong>进行消息订阅的时候可能出现消息队列也失败的情况</li></ol><p>强一致性肯定会有性能影响(比如 <code>raft协议</code>需要等待超过半数节点做出响应)，另外强一致性的异常处理</p><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><p>来看看 <code>rockscache</code> 如何解决缓存一致性的，</p><blockquote><p>地址：<a href="https://github.com/dtm-labs/rockscache" target="_blank" rel="noopener">https://github.com/dtm-labs/rockscache</a></p><p>The First Redis Cache Library To Ensure Eventual Consistency And Strong Consistency With DB.</p></blockquote><h4 id="变量定义"><a class="markdownIt-Anchor" href="#变量定义"></a> 变量定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rockscache client 可选参数</span></span><br><span class="line"><span class="keyword">type</span> Options <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">//标记删除key的延时删除时间 默认10s</span></span><br><span class="line">Delay time.Duration </span><br><span class="line">  <span class="comment">//EmptyExpire 是空结果的过期时间。默认为 60 秒</span></span><br><span class="line">EmptyExpire time.Duration</span><br><span class="line"><span class="comment">// LockExpire 是更新缓存时分配的锁的过期时间。默认为 3s</span></span><br><span class="line">LockExpire time.Duration</span><br><span class="line">  <span class="comment">//锁失败后的重试等待时间 100ms</span></span><br><span class="line">LockSleep time.Duration</span><br><span class="line">  <span class="comment">// 等待副本数量</span></span><br><span class="line">WaitReplicas <span class="keyword">int</span></span><br><span class="line">  <span class="comment">// 副本等待超时时间 默认300ms</span></span><br><span class="line">WaitReplicasTimeout time.Duration</span><br><span class="line">  <span class="comment">//随机过期时间，0.1的偏移(缓存雪崩)</span></span><br><span class="line">RandomExpireAdjustment <span class="keyword">float64</span></span><br><span class="line">  <span class="comment">// 标识缓存禁止读，默认关闭。用于缓存宕机时候的降级</span></span><br><span class="line">DisableCacheRead <span class="keyword">bool</span></span><br><span class="line">  <span class="comment">// 标识缓存删除，默认关闭。用于缓存宕机时候的降级</span></span><br><span class="line">DisableCacheDelete <span class="keyword">bool</span></span><br><span class="line">  <span class="comment">// 强一致性，默认关闭</span></span><br><span class="line">StrongConsistency <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lua脚本"><a class="markdownIt-Anchor" href="#lua脚本"></a> lua脚本</h4><p>使用脚本进行redis操作，lua的好处是一次性执行，执行过程其他脚本或命令无法执行(注意不确定参数)。</p><p>这里使用<code>hash</code>进行数据存储，同时保存 <code>key/value</code> 与 <code>key/lock</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">luaGet</span><span class="params">(key <span class="keyword">string</span>, owner <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">res, err := callLua(c.rdb.Context(), c.rdb, <span class="string">` -- luaGet</span></span><br><span class="line"><span class="string">local v = redis.call('HGET', KEYS[1], 'value')//获取值</span></span><br><span class="line"><span class="string">local lu = redis.call('HGET', KEYS[1], 'lockUtil')//获取过期时间</span></span><br><span class="line"><span class="string">if lu ~= false and tonumber(lu) &lt; tonumber(ARGV[1]) or lu == false and v == false then</span></span><br><span class="line"><span class="string">redis.call('HSET', KEYS[1], 'lockUtil', ARGV[2])//如果锁已经过期或者不存在，则更新锁</span></span><br><span class="line"><span class="string">redis.call('HSET', KEYS[1], 'lockOwner', ARGV[3])</span></span><br><span class="line"><span class="string">return &#123; v, 'LOCKED' &#125;</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">return &#123;v, lu&#125;</span></span><br><span class="line"><span class="string">`</span>, []<span class="keyword">string</span>&#123;key&#125;, []<span class="keyword">interface</span>&#123;&#125;&#123;now(), now() + <span class="keyword">int64</span>(c.Options.LockExpire/time.Second), owner&#125;)</span><br><span class="line">debugf(<span class="string">"luaGet return: %v, %v"</span>, res, err)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res.([]<span class="keyword">interface</span>&#123;&#125;), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">luaSet</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">string</span>, expire <span class="keyword">int</span>, owner <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">_, err := callLua(c.rdb.Context(), c.rdb, <span class="string">`-- luaSet</span></span><br><span class="line"><span class="string">local o = redis.call('HGET', KEYS[1], 'lockOwner')</span></span><br><span class="line"><span class="string">if o ~= ARGV[2] then</span></span><br><span class="line"><span class="string">return</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">redis.call('HSET', KEYS[1], 'value', ARGV[1])</span></span><br><span class="line"><span class="string">redis.call('HDEL', KEYS[1], 'lockUtil')</span></span><br><span class="line"><span class="string">redis.call('HDEL', KEYS[1], 'lockOwner')</span></span><br><span class="line"><span class="string">redis.call('EXPIRE', KEYS[1], ARGV[3])</span></span><br><span class="line"><span class="string">`</span>, []<span class="keyword">string</span>&#123;key&#125;, []<span class="keyword">interface</span>&#123;&#125;&#123;value, owner, expire&#125;)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加锁和解锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">LockForUpdate</span><span class="params">(key <span class="keyword">string</span>, owner <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">lockUtil := math.Pow10(<span class="number">10</span>)</span><br><span class="line">res, err := callLua(c.rdb.Context(), c.rdb, <span class="string">` -- luaLock</span></span><br><span class="line"><span class="string">local lu = redis.call('HGET', KEYS[1], 'lockUtil')</span></span><br><span class="line"><span class="string">local lo = redis.call('HGET', KEYS[1], 'lockOwner')</span></span><br><span class="line"><span class="string">if lu == false or tonumber(lu) &lt; tonumber(ARGV[2]) or lo == ARGV[1] then</span></span><br><span class="line"><span class="string">redis.call('HSET', KEYS[1], 'lockUtil', ARGV[2])</span></span><br><span class="line"><span class="string">redis.call('HSET', KEYS[1], 'lockOwner', ARGV[1])</span></span><br><span class="line"><span class="string">return 'LOCKED'</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">return lo</span></span><br><span class="line"><span class="string">`</span>, []<span class="keyword">string</span>&#123;key&#125;, []<span class="keyword">interface</span>&#123;&#125;&#123;owner, lockUtil&#125;)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; res != <span class="string">"LOCKED"</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"%s has been locked by %s"</span>, key, res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">UnlockForUpdate</span><span class="params">(key <span class="keyword">string</span>, owner <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">_, err := callLua(c.rdb.Context(), c.rdb, <span class="string">` -- luaUnlock</span></span><br><span class="line"><span class="string">local lo = redis.call('HGET', KEYS[1], 'lockOwner')</span></span><br><span class="line"><span class="string">if lo == ARGV[1] then</span></span><br><span class="line"><span class="string">redis.call('HSET', KEYS[1], 'lockUtil', 0)</span></span><br><span class="line"><span class="string">redis.call('HDEL', KEYS[1], 'lockOwner')</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">`</span>, []<span class="keyword">string</span>&#123;key&#125;, []<span class="keyword">interface</span>&#123;&#125;&#123;owner&#125;)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读取缓存"><a class="markdownIt-Anchor" href="#读取缓存"></a> 读取缓存</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new a client for rockscache using the default options</span></span><br><span class="line">rc := rockscache.NewClient(redisClient, NewDefaultOptions())</span><br><span class="line"></span><br><span class="line">v, err := rc.Fetch(<span class="string">"key1"</span>, <span class="number">300</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span><span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// fetch data from database or other sources</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"value1"</span>, <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Fetch</span><span class="params">(key <span class="keyword">string</span>, expire time.Duration, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">string</span>, error)</span>) <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">ex := expire - c.Options.Delay - time.Duration(rand.Float64()*c.Options.RandomExpireAdjustment*<span class="keyword">float64</span>(expire))</span><br><span class="line">v, err, _ := c.group.Do(key, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;<span class="comment">//同样使用共享调用进行操作</span></span><br><span class="line"><span class="keyword">if</span> c.Options.DisableCacheRead &#123;<span class="comment">//缓存崩溃直接读数据库</span></span><br><span class="line"><span class="keyword">return</span> fn()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> c.Options.StrongConsistency &#123; <span class="comment">//强一致性</span></span><br><span class="line"><span class="keyword">return</span> c.strongFetch(key, ex, fn)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c.weakFetch(key, ex, fn)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> v.(<span class="keyword">string</span>), err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也提供了忽略锁的操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">RawGet</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.rdb.HGet(c.rdb.Context(), key, <span class="string">"value"</span>).Result()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">RawSet</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">string</span>, expire time.Duration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">err := c.rdb.HSet(c.rdb.Context(), key, <span class="string">"value"</span>, value).Err()</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">//如果过期操作失败了，那么缓存可能永远不过期(根据AOF策略，默认每秒)</span></span><br><span class="line">    <span class="comment">//操作失败可能是网络或者redis宕机，如果是宕机，那么key可能都还没有落盘。所以这里得考虑网络异常情况</span></span><br><span class="line">err = c.rdb.Expire(c.rdb.Context(), key, expire).Err()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="强一致性获取"><a class="markdownIt-Anchor" href="#强一致性获取"></a> 强一致性获取</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">weakFetch</span><span class="params">(key <span class="keyword">string</span>, expire time.Duration, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">string</span>, error)</span>) <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">debugf(<span class="string">"weakFetch: key=%s"</span>, key)</span><br><span class="line">owner := shortuuid.New()</span><br><span class="line">r, err := c.luaGet(key, owner)</span><br><span class="line"><span class="keyword">for</span> err == <span class="literal">nil</span> &amp;&amp; r[<span class="number">0</span>] == <span class="literal">nil</span> &amp;&amp; r[<span class="number">1</span>].(<span class="keyword">string</span>) != locked &#123;</span><br><span class="line">debugf(<span class="string">"empty result for %s locked by other, so sleep %s"</span>, key, c.Options.LockSleep.String())</span><br><span class="line">time.Sleep(c.Options.LockSleep)</span><br><span class="line">r, err = c.luaGet(key, owner)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> r[<span class="number">1</span>] != locked &#123;</span><br><span class="line"><span class="keyword">return</span> r[<span class="number">0</span>].(<span class="keyword">string</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> r[<span class="number">0</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.fetchNew(key, expire, owner, fn)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> withRecover(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">_, _ = c.fetchNew(key, expire, owner, fn)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> r[<span class="number">0</span>].(<span class="keyword">string</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">strongFetch</span><span class="params">(key <span class="keyword">string</span>, expire time.Duration, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">string</span>, error)</span>) <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">debugf(<span class="string">"strongFetch: key=%s"</span>, key)</span><br><span class="line">owner := shortuuid.New()</span><br><span class="line">r, err := c.luaGet(key, owner)</span><br><span class="line"><span class="keyword">for</span> err == <span class="literal">nil</span> &amp;&amp; r[<span class="number">1</span>] != <span class="literal">nil</span> &amp;&amp; r[<span class="number">1</span>] != locked &#123; <span class="comment">// locked by other</span></span><br><span class="line">debugf(<span class="string">"locked by other, so sleep %s"</span>, c.Options.LockSleep)</span><br><span class="line">time.Sleep(c.Options.LockSleep)</span><br><span class="line">r, err = c.luaGet(key, owner)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> r[<span class="number">1</span>] != locked &#123; <span class="comment">// normal value</span></span><br><span class="line"><span class="keyword">return</span> r[<span class="number">0</span>].(<span class="keyword">string</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c.fetchNew(key, expire, owner, fn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">fetchNew</span><span class="params">(key <span class="keyword">string</span>, expire time.Duration, owner <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">string</span>, error)</span>) <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">result, err := fn()<span class="comment">//自定义读取数据</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;<span class="comment">//成功则删除锁</span></span><br><span class="line">_ = c.UnlockForUpdate(key, owner)</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> result == <span class="string">""</span> &#123;<span class="comment">//如果结果为空</span></span><br><span class="line"><span class="keyword">if</span> c.Options.EmptyExpire == <span class="number">0</span> &#123; <span class="comment">// if empty expire is 0, then delete the key</span></span><br><span class="line">err = c.rdb.Del(c.rdb.Context(), key).Err()</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line">expire = c.Options.EmptyExpire</span><br><span class="line">&#125;</span><br><span class="line">err = c.luaSet(key, result, <span class="keyword">int</span>(expire/time.Second), owner)<span class="comment">//更新缓存</span></span><br><span class="line"><span class="keyword">return</span> result, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>应该根据场景来设计合适的方案解决缓存一致性问题</p><ol><li>读多写少的场景下，可以选择采用 <strong>Cache-Aside 结合消费数据库日志做补偿</strong> 的方案</li><li>写多的场景下，可以选择采用 <strong>Write-Through 结合分布式锁</strong>的方案</li><li>写多的极端场景下，可以选择采用 <strong>Write-Behind</strong> 的方案</li><li>可以通过读取 binlog (阿里云canal)异步删除缓存缓存</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://blog.csdn.net/qq_34827674/article/details/123463175" target="_blank" rel="noopener">https://blog.csdn.net/qq_34827674/article/details/123463175</a></li><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/300%E5%88%86%E9%92%9F%E5%90%83%E9%80%8F%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E5%AE%8C" target="_blank" rel="noopener">https://learn.lianglianglee.com/专栏/300分钟吃透分布式缓存-完</a></li><li><a href="https://www.cnblogs.com/rjzheng/p/9041659.html" target="_blank" rel="noopener">分布式之数据库和缓存双写一致性方式解析</a></li><li><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside" target="_blank" rel="noopener">Cache-Aside Pattern</a></li><li><a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf" target="_blank" rel="noopener">Scaling Memcache at Facebook</a></li><li><a href="https://www.w3cschool.cn/architectroad/architectroad-cache-architecture-design.html" target="_blank" rel="noopener">https://www.w3cschool.cn/architectroad/architectroad-cache-architecture-design.html</a></li><li><a href="https://cloud.tencent.com/developer/article/1932934" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1932934</a></li><li><a href="https://segmentfault.com/a/1190000040976439" target="_blank" rel="noopener">https://segmentfault.com/a/1190000040976439</a></li><li><a href="https://talkgo.org/t/topic/1505" target="_blank" rel="noopener">https://talkgo.org/t/topic/1505</a></li><li><a href="https://github.com/dtm-labs/rockscache/blob/main/helper/README-cn.md" target="_blank" rel="noopener">https://github.com/dtm-labs/rockscache/blob/main/helper/README-cn.md</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题背景&quot;&gt;&lt;/a&gt; 问题背景&lt;/h3&gt;
&lt;p&gt;一致性有很多种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;强一致性&lt;/strong&gt;：保证写入后立即可以读取&lt;/li&gt;
&lt;li&gt;&lt;s
      
    
    </summary>
    
    
      <category term="Microservices" scheme="http://xboom.github.io/categories/Microservices/"/>
    
    
      <category term="Microservices" scheme="http://xboom.github.io/tags/Microservices/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-工厂模式</title>
    <link href="http://xboom.github.io/2022/07/19/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/07/19/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-07-19T14:31:29.930Z</published>
    <updated>2022-08-01T13:21:01.453Z</updated>
    
    <content type="html"><![CDATA[<p>一个类只允许创建一个对象(或实例)，那这个类就是一个单例类，这种设计模式就叫做单例设计模式(Singleton Design Pattern)</p><p>单例模式分为 <code>饿汉式</code> 和 <code>懒汉式</code> 两种实现</p><ol><li><strong>饿汉式</strong>：初始化的时候已经创建好实例</li><li><strong>懒汉式</strong>：只有在调用的时候才会初始化</li></ol><p>构建的时候注意：</p><ol><li>构造函数是私有访问权限(防止被其他地方重新构建)</li><li>构建的时候考虑并发情况</li><li>考虑是否支持延迟加载</li></ol><h3 id="饿汉式"><a class="markdownIt-Anchor" href="#饿汉式"></a> 饿汉式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="comment">// Singleton 饿汉式单例</span></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> singleton *Singleton</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">singleton = &amp;Singleton&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetInstance 获取实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">Singleton</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> singleton</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式"><a class="markdownIt-Anchor" href="#懒汉式"></a> 懒汉式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Singleton 是单例模式接口，导出的</span></span><br><span class="line"><span class="comment">// 通过该接口可以避免 GetInstance 返回一个包私有类型的指针</span></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">interface</span> &#123;</span><br><span class="line">foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// singleton 是单例模式类，包私有的</span></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s singleton)</span> <span class="title">foo</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">instance *singleton</span><br><span class="line">once     sync.Once</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//GetInstance 用于获取单例模式对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> <span class="title">Singleton</span></span> &#123;</span><br><span class="line">once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">instance = &amp;singleton&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>可拓展性差，如果需要多实例对象可能比较麻烦</li><li>可测试性差，因为是唯一实例，进行多场景修改实例进行测试可能会比较麻烦</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://lailin.xyz/post/singleton.html" target="_blank" rel="noopener">https://lailin.xyz/post/singleton.html</a></li><li><a href="https://github.com/senghoo/golang-design-pattern/blob/master/03_singleton/singleton.go" target="_blank" rel="noopener">https://github.com/senghoo/golang-design-pattern/blob/master/03_singleton/singleton.go</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个类只允许创建一个对象(或实例)，那这个类就是一个单例类，这种设计模式就叫做单例设计模式(Singleton Design Pattern)&lt;/p&gt;
&lt;p&gt;单例模式分为 &lt;code&gt;饿汉式&lt;/code&gt; 和 &lt;code&gt;懒汉式&lt;/code&gt; 两种实现&lt;/p&gt;
&lt;ol&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>go-zero9-自适应熔断</title>
    <link href="http://xboom.github.io/2022/07/19/GoZero/GoZero9-%E8%87%AA%E9%80%82%E5%BA%94%E7%86%94%E6%96%AD/"/>
    <id>http://xboom.github.io/2022/07/19/GoZero/GoZero9-%E8%87%AA%E9%80%82%E5%BA%94%E7%86%94%E6%96%AD/</id>
    <published>2022-07-19T14:31:29.926Z</published>
    <updated>2022-08-01T10:07:02.530Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h3><p>使用负载均衡策略是一种避免超负载的处理方式，但服务的容量是有限的。部分服务还是会出现超载的情况，如果优雅的处理过载则对可靠的服务至关重要。</p><p>在高并发场景下，为了应对依赖服务过载，服务不可用等情况，提出了熔断、限流与降级方案。这里主要描述熔断的原理，这里存在几个问题：</p><ol><li>都有哪些熔断的解决方案</li><li>熔断器的实现原理是什么</li></ol><p>使用较多的熔断组件：</p><ol><li>hystrix circuit breaker（不再维护）</li><li>hystrix-go</li><li>resilience4j（推荐）</li><li>sentinel（推荐）</li></ol><h3 id="熔断器原理"><a class="markdownIt-Anchor" href="#熔断器原理"></a> 熔断器原理</h3><p>熔断器一般具有三个状态：</p><ol><li><strong>关闭</strong>: 默认状态，请求能被到达目标服务，同时统计在窗口时间成功和失败次数，如果达到错误率阈值将会进入断开状态。</li><li><strong>断开</strong>: 此状态下将会直接返回错误，如果有 fallback 配置则直接调用 fallback 方法。</li><li><strong>半断开</strong>: 进行断开状态会维护一个超时时间，到达超时时间开始进入 <strong>半断开</strong> 状态，尝试允许一部分请求正常通过并统计成功数量，如果请求正常则认为此时目标服务已恢复进入 <strong>关闭</strong> 状态，否则进入 <strong>断开</strong> 状态</li></ol><p>基于熔断器的原理，通常熔断器主要关注以下参数：</p><ol><li>错误比例阈值: 达到该阈值进入 断开 状态</li><li>断开状态超时时间: 超时后进入 半断开 状态</li><li>半断开状态允许请求数量</li><li>窗口时间大小</li></ol><p>这里有更将详细可参考的参考以及算法说明</p><ol><li><a href="https://resilience4j.readme.io/docs/circuitbreaker" target="_blank" rel="noopener">https://resilience4j.readme.io/docs/circuitbreaker</a></li><li><a href="https://sre.google/sre-book/handling-overload/" target="_blank" rel="noopener">https://sre.google/sre-book/handling-overload/</a></li></ol><p>由于<code>go-zero</code> 的熔断器是基于google文章实现，来看下基本算法</p><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><ol><li>无论什么熔断器都得依靠指标统计来转换状态，而统计指标一般要求是最近的一段时间内的数据，所以通常采用一个 <code>滑动时间窗口</code> 数据结构 来存储统计数据。同时熔断器的状态也需要依靠指标统计来实现可观测性。</li><li>外部服务请求结果各式各样，所以需要提供一个自定义的判断方法，判断请求是否成功。熔断器需要实时收集此数据。</li><li>当外部服务被熔断时使用者往往需要自定义快速失败的逻辑，考虑提供自定义的 <code>fallback()</code> 功能。</li></ol><h4 id="接口定义"><a class="markdownIt-Anchor" href="#接口定义"></a> 接口定义</h4><p>代码路径：<code>core/breaker/breaker.go</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 250ms for bucket duration</span></span><br><span class="line">window     = time.Second * <span class="number">10</span></span><br><span class="line">buckets    = <span class="number">40</span></span><br><span class="line">k          = <span class="number">1.5</span></span><br><span class="line">protection = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断断路器是否通过</span></span><br><span class="line">Acceptable <span class="function"><span class="keyword">func</span><span class="params">(err error)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Breaker 断路器</span></span><br><span class="line">Breaker <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// 熔断器名称</span></span><br><span class="line">Name() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查请求是否允许。调用成功则使用 Promise.Accept()，失败则调用 Promise.Reject()，否则表示不许云</span></span><br><span class="line">Allow() (Promise, error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 Breaker 接受，Do 运行给定的请求。</span></span><br><span class="line"><span class="comment">// 如果 Breaker 拒绝请求，Do 立即返回错误。</span></span><br><span class="line"><span class="comment">// 如果请求发生恐慌，Breaker 将其作为错误处理并再次引起同样的恐慌。</span></span><br><span class="line">Do(req <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span>) <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 Breaker 接受，DoWithAcceptable 运行给定的请求。</span></span><br><span class="line"><span class="comment">// 如果 Breaker 拒绝请求，DoWithAcceptable 会立即返回错误。</span></span><br><span class="line"><span class="comment">// 如果请求发生恐慌，Breaker 将其作为错误处理并再次引起同样的恐慌。</span></span><br><span class="line"><span class="comment">// 可接受的检查它是否是一个成功的调用，即使错误不是零。</span></span><br><span class="line">DoWithAcceptable(req <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span>, <span class="title">acceptable</span> <span class="title">Acceptable</span>) <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 Breaker 接受，DoWithFallback 运行给定的请求。</span></span><br><span class="line"><span class="comment">// 如果 Breaker 拒绝请求，DoWithFallback 运行回退。</span></span><br><span class="line"><span class="comment">// 如果请求发生恐慌，Breaker 将其作为错误处理并再次引起同样的恐慌。</span></span><br><span class="line">DoWithFallback(req <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span>, <span class="title">fallback</span> <span class="title">func</span><span class="params">(err error)</span> <span class="title">error</span>) <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 Breaker 接受，DoWithFallbackAcceptable 运行给定的请求。</span></span><br><span class="line"><span class="comment">// DoWithFallbackAcceptable 如果 Breaker 拒绝请求，则运行回退。</span></span><br><span class="line"><span class="comment">// 如果请求发生恐慌，Breaker 将其作为错误处理并再次引起同样的恐慌。</span></span><br><span class="line"><span class="comment">// 可接受的检查它是否是一个成功的调用，即使错误不是零。</span></span><br><span class="line">DoWithFallbackAcceptable(req <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span>, <span class="title">fallback</span> <span class="title">func</span><span class="params">(err error)</span> <span class="title">error</span>, <span class="title">acceptable</span> <span class="title">Acceptable</span>) <span class="title">error</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="断路器"><a class="markdownIt-Anchor" href="#断路器"></a> 断路器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//断路器</span></span><br><span class="line">circuitBreaker <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">throttle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//断路器内部则通过两个接口实现</span></span><br><span class="line">throttle <span class="keyword">interface</span> &#123;</span><br><span class="line">allow() (Promise, error)</span><br><span class="line">doReq(req <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span>, <span class="title">fallback</span> <span class="title">func</span><span class="params">(err error)</span> <span class="title">error</span>, <span class="title">acceptable</span> <span class="title">Acceptable</span>) <span class="title">error</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义断路器对象</span></span><br><span class="line"><span class="keyword">type</span> googleBreaker <span class="keyword">struct</span> &#123;</span><br><span class="line">k     <span class="keyword">float64</span></span><br><span class="line">stat  *collection.RollingWindow<span class="comment">//使用滑动窗口统计最近一段时间数据</span></span><br><span class="line">proba *mathx.Proba</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newGoogleBreaker</span><span class="params">()</span> *<span class="title">googleBreaker</span></span> &#123;</span><br><span class="line">bucketDuration := time.Duration(<span class="keyword">int64</span>(window) / <span class="keyword">int64</span>(buckets))</span><br><span class="line">st := collection.NewRollingWindow(buckets, bucketDuration)</span><br><span class="line"><span class="keyword">return</span> &amp;googleBreaker&#123;</span><br><span class="line">stat:  st,</span><br><span class="line">k:     k,</span><br><span class="line">proba: mathx.NewProba(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据记录"><a class="markdownIt-Anchor" href="#数据记录"></a> 数据记录</h4><p>其实是将成功或者失败记录到滑动窗口中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *googleBreaker)</span> <span class="title">markSuccess</span><span class="params">()</span></span> &#123;</span><br><span class="line">b.stat.Add(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *googleBreaker)</span> <span class="title">markFailure</span><span class="params">()</span></span> &#123;</span><br><span class="line">b.stat.Add(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="请求操作"><a class="markdownIt-Anchor" href="#请求操作"></a> 请求操作</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计滑动窗口中所代表的最近一段时间的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *googleBreaker)</span> <span class="title">history</span><span class="params">()</span> <span class="params">(accepts, total <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">b.stat.Reduce(<span class="function"><span class="keyword">func</span><span class="params">(b *collection.Bucket)</span></span> &#123;</span><br><span class="line">accepts += <span class="keyword">int64</span>(b.Sum)</span><br><span class="line">total += b.Count</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查是否允许</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *googleBreaker)</span> <span class="title">accept</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">accepts, total := b.history()</span><br><span class="line">weightedAccepts := b.k * <span class="keyword">float64</span>(accepts)</span><br><span class="line"><span class="comment">// https://landing.google.com/sre/sre-book/chapters/handling-overload/#eq2101</span></span><br><span class="line">dropRatio := math.Max(<span class="number">0</span>, (<span class="keyword">float64</span>(total-protection)-weightedAccepts)/<span class="keyword">float64</span>(total+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">if</span> dropRatio &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> b.proba.TrueOnProba(dropRatio) &#123;</span><br><span class="line"><span class="keyword">return</span> ErrServiceUnavailable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回断路器权限</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *googleBreaker)</span> <span class="title">allow</span><span class="params">()</span> <span class="params">(internalPromise, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := b.accept(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> googlePromise&#123;</span><br><span class="line">b: b,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *googleBreaker)</span> <span class="title">doReq</span><span class="params">(req <span class="keyword">func</span>()</span> <span class="title">error</span>, <span class="title">fallback</span> <span class="title">func</span><span class="params">(err error)</span> <span class="title">error</span>, <span class="title">acceptable</span> <span class="title">Acceptable</span>) <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := b.accept(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> fallback != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fallback(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">b.markFailure()</span><br><span class="line"><span class="built_in">panic</span>(e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">err := req()</span><br><span class="line"><span class="keyword">if</span> acceptable(err) &#123;<span class="comment">//结果的处理</span></span><br><span class="line">b.markSuccess()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">b.markFailure()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li><p>通过滑动窗口进行最近一段数据(成功失败次数)的统计</p></li><li><p>是否断路则是通过指定的公式计算</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">失</mi><mi mathvariant="normal">败</mi><mi mathvariant="normal">率</mi><mo>=</mo><mi mathvariant="normal">总</mi><mi mathvariant="normal">数</mi><mo>−</mo><mi mathvariant="normal">可</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">收</mi><mi mathvariant="normal">误</mi><mi mathvariant="normal">差</mi><mo>−</mo><mi>k</mi><mo>∗</mo><mi mathvariant="normal">成</mi><mi mathvariant="normal">功</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">失</mi><mi mathvariant="normal">败</mi></mrow><annotation encoding="application/x-tex">失败率 = 总数 - 可接收误差 - k * 成功 / 失败</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">失</span><span class="mord cjk_fallback">败</span><span class="mord cjk_fallback">率</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">总</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">收</span><span class="mord cjk_fallback">误</span><span class="mord cjk_fallback">差</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">功</span><span class="mord">/</span><span class="mord cjk_fallback">失</span><span class="mord cjk_fallback">败</span></span></span></span></span></p></li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://talkgo.org/t/topic/3035" target="_blank" rel="noopener">https://talkgo.org/t/topic/3035</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题背景&quot;&gt;&lt;/a&gt; 问题背景&lt;/h3&gt;
&lt;p&gt;使用负载均衡策略是一种避免超负载的处理方式，但服务的容量是有限的。部分服务还是会出现超载的情况，如果优雅的处理过载则对可靠的服务至关
      
    
    </summary>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/categories/go-zero/"/>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>go-zero8-数据库缓存</title>
    <link href="http://xboom.github.io/2022/07/19/GoZero/GoZero8-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98/"/>
    <id>http://xboom.github.io/2022/07/19/GoZero/GoZero8-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98/</id>
    <published>2022-07-19T14:31:29.925Z</published>
    <updated>2022-07-22T13:54:57.154Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h3><p>在 <a href="https://xboom.github.io/2022/07/19/GoZero/GoZero7-%E8%BF%9B%E7%A8%8B%E5%86%85%E7%BC%93%E5%AD%98/">进程内缓存</a>中说到的是直接在进程进行缓存的自管理，一般应用于业务生成的自定义数据(多副本情况下可能存在缓存一致性问题)。而随着业务量的增加，利用Redis构建专门的数据缓存，加快数据库访问。</p><p>由于数据库数据的特点，那么这里就有几个实现需要注意的点</p><ol><li>数据一致性</li><li>缓存击穿、穿透、雪崩</li><li>缓存访问量、缓存命中率</li></ol><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>源码注释：<code>core/stores/cache</code></p><h4 id="构建缓存对象"><a class="markdownIt-Anchor" href="#构建缓存对象"></a> 构建缓存对象</h4><p>根据缓存节点配置构建一个缓存对象用于业务层进行缓存处理</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/go-zero-cache10.png" alt="go-zero-cache10" />缓存支持通过多节点构建的缓存集群，也支持单个节点结构</p><ol><li>多节点缓存集群通过一致性Hash进行访问，这里的多节点是指多个无关的缓存节点。而每个缓存节点可能都是一个Redis集群</li><li>共享调用防止缓存击穿</li><li>统计将环中命中，DB查询等情况上报给外部</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓存集群对象</span></span><br><span class="line">cacheCluster <span class="keyword">struct</span> &#123;</span><br><span class="line">dispatcher  *hash.ConsistentHash</span><br><span class="line">errNotFound error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于一致性Hash 在 《go-zero-一致性Hash》有说明</p></blockquote><h4 id="集群缓存操作"><a class="markdownIt-Anchor" href="#集群缓存操作"></a> 集群缓存操作</h4><p>集群的缓存操作都是根据一致性<code>Hash</code>算法得出对应节点，然后演变成单节点的缓存操作</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/go-zero-cache13.png" alt="go-zero-cache13" style="zoom:50%;" /><p>与单点不同的是，缓存集群批量删除<code>Key</code>,而<code>Key</code>有可能存在于多个节点上</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/go-zero-cache14.png" alt="go-zero-cache14" style="zoom:50%;" /><p>当<code>keys</code>数量大于1的时候，首先会 <code>for Hash(Key)</code> 找到所有的缓存节点，然后再通过 <code>for del</code></p><ol><li>单次映射<code>Hash</code>节点或者删除<code>Key</code>并不会影响后续操作，而是通过 <code>BatchError</code>记录每一次错误</li><li>通过 <code>make(map[interface{}][]string)</code>保存<strong>节点</strong>与<strong>Key</strong>的关系</li></ol><h4 id="单点缓存操作"><a class="markdownIt-Anchor" href="#单点缓存操作"></a> 单点缓存操作</h4><h5 id="查询缓存"><a class="markdownIt-Anchor" href="#查询缓存"></a> 查询缓存</h5><p>查询缓存的过程其实就是从Redis中获取数据的过程</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/go-zero-cachedb1.png" alt="go-zero-cachedb1" style="zoom: 33%;" /><p>这里有两点需要注意</p><ol><li>当加载数据完毕，有一个将结果与空占位符比较的过程 <code>value = &quot;*&quot;</code>，是为了防止缓存穿透而故意设置的占位符。那么它是什么时候怎么插入的？</li><li>将结果反序列如果失败，那么会去Redis删除这个 <code>Key</code>，表示存储的缓存异常</li></ol><h5 id="设置缓存"><a class="markdownIt-Anchor" href="#设置缓存"></a> 设置缓存</h5><p>设置缓存是直接按照redis语法设置 <code>k/v</code> 与 <code>expire</code></p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/go-zero-cacheDB2.png" alt="go-zero-cacheDB2" style="zoom:50%;" /><h5 id="删除缓存"><a class="markdownIt-Anchor" href="#删除缓存"></a> 删除缓存</h5><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/go-zero-cachedb3.png" alt="go-zero-cachedb3" style="zoom:33%;" /><ol><li>删除缓存时候，如果本身就是一个缓存集群，当对 <code>keys</code>进行批量删除的时候，需要依次删除每一个Key，而不是直接 <code>del(keys...)</code> 删除。</li><li>删除失败这里添加延时任务进行重试，但只会重试一次，失败后直接退出</li></ol><h5 id="获取缓存"><a class="markdownIt-Anchor" href="#获取缓存"></a> 获取缓存</h5><p>获取缓存当缓存数据库没有的时候，就会直接从数据库加载并将数据保存到缓存数据库</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/go-zero-cachedb5.png" alt="go-zero-cachedb5" style="zoom:33%;" /><ol><li>当缓存中没有且数据库中也没有的时候，那么这个时候就会设置占位符(防止缓存穿透)，占位符的过期时间与普通的<code>Key</code>一致</li><li>关于查询数据库操作，这里仅仅是将结果实体传入，由数据层进行数据加载</li><li>当缓存没有的时候，是先查询数据库，然后更新缓存</li></ol><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><p>代码：<code>core/stores/cache/cachenode.go</code></p><p><code>cacheNode</code> 表示是单个缓存节点的对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cacheNode 表示单个缓存节点</span></span><br><span class="line"><span class="keyword">type</span> cacheNode <span class="keyword">struct</span> &#123;</span><br><span class="line">rds            *redis.Redis<span class="comment">//redis句柄</span></span><br><span class="line">expiry         time.Duration <span class="comment">//缓存过期时间</span></span><br><span class="line">notFoundExpiry time.Duration<span class="comment">//</span></span><br><span class="line">barrier        syncx.SingleFlight<span class="comment">//共享调用</span></span><br><span class="line">r              *rand.Rand</span><br><span class="line">lock           *sync.Mutex<span class="comment">//原子锁</span></span><br><span class="line">unstableExpiry mathx.Unstable</span><br><span class="line">  stat           *Stat<span class="comment">//统计(单个节点的统计)</span></span><br><span class="line">errNotFound    error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">notFoundPlaceholder = <span class="string">"*"</span></span><br><span class="line">  <span class="comment">//避免缓存雪崩，这里加上随机过期时间随机值 [0.95, 1.05] * seconds</span></span><br><span class="line">expiryDeviation = <span class="number">0.05</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li>这里几个过期分别有什么作用<ul><li><code>expiry</code>:</li><li><code>notFoundExpiry</code>:</li><li><code>unstableExpiry</code>:</li></ul></li><li>使用共享调用 <code>barrier</code>减少缓存调用</li><li><code>rand.Rand</code> 的随机数</li></ol><h4 id="新建缓存节点"><a class="markdownIt-Anchor" href="#新建缓存节点"></a> 新建缓存节点</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNode</span><span class="params">(rds *redis.Redis, barrier syncx.SingleFlight, st *Stat,</span></span></span><br><span class="line"><span class="function"><span class="params">errNotFound error, opts ...Option)</span> <span class="title">Cache</span></span> &#123;</span><br><span class="line">o := newOptions(opts...)</span><br><span class="line"><span class="keyword">return</span> cacheNode&#123;</span><br><span class="line">rds:            rds,<span class="comment">//redis句柄</span></span><br><span class="line">expiry:         o.Expiry,<span class="comment">//过期时间</span></span><br><span class="line">notFoundExpiry: o.NotFoundExpiry,<span class="comment">//设置占位符过期时间</span></span><br><span class="line">barrier:        barrier,<span class="comment">//共享调用</span></span><br><span class="line">r:              rand.New(rand.NewSource(time.Now().UnixNano())),</span><br><span class="line">lock:           <span class="built_in">new</span>(sync.Mutex),</span><br><span class="line">unstableExpiry: mathx.NewUnstable(expiryDeviation),<span class="comment">//一定范围内过期时间</span></span><br><span class="line">stat:           st,<span class="comment">//统计逻辑</span></span><br><span class="line">errNotFound:    errNotFound,<span class="comment">//找不到缓存</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询缓存-2"><a class="markdownIt-Anchor" href="#查询缓存-2"></a> 查询缓存</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cacheNode)</span> <span class="title">doGetCache</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">c.stat.IncrementTotal()</span><br><span class="line">data, err := c.rds.GetCtx(ctx, key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.stat.IncrementMiss()</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span> &#123;<span class="comment">//数据为空</span></span><br><span class="line">c.stat.IncrementMiss()</span><br><span class="line"><span class="keyword">return</span> c.errNotFound</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.stat.IncrementHit()</span><br><span class="line"><span class="keyword">if</span> data == notFoundPlaceholder &#123;<span class="comment">//防止缓存穿透</span></span><br><span class="line"><span class="keyword">return</span> errPlaceholder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c.processCache(ctx, key, data, v)<span class="comment">//缓存处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cacheNode)</span> <span class="title">processCache</span><span class="params">(ctx context.Context, key, data <span class="keyword">string</span>, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">err := jsonx.Unmarshal([]<span class="keyword">byte</span>(data), v)<span class="comment">//反序列化</span></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//... 日志记录</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> _, e := c.rds.DelCtx(ctx, key); e != <span class="literal">nil</span> &#123;<span class="comment">//删除缓存 </span></span><br><span class="line">logger.Errorf(<span class="string">"delete invalid cache, node: %s, key: %s, value: %s, error: %v"</span>,</span><br><span class="line">c.rds.Addr, key, data, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// returns errNotFound to reload the value by the given queryFn</span></span><br><span class="line"><span class="keyword">return</span> c.errNotFound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设置缓存-2"><a class="markdownIt-Anchor" href="#设置缓存-2"></a> 设置缓存</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cacheNode)</span> <span class="title">SetWithExpireCtx</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, val <span class="keyword">interface</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">expire time.Duration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">data, err := jsonx.Marshal(val)<span class="comment">//序列化</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c.rds.SetexCtx(ctx, key, <span class="keyword">string</span>(data), <span class="keyword">int</span>(expire.Seconds()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取缓存-2"><a class="markdownIt-Anchor" href="#获取缓存-2"></a> 获取缓存</h4><p>获取缓存直接加载加载redis，并根据加载结果进行不同的处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cacheNode)</span> <span class="title">doTake</span><span class="params">(ctx context.Context, v <span class="keyword">interface</span>&#123;&#125;, key <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">query <span class="keyword">func</span>(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span>, <span class="title">cacheVal</span> <span class="title">func</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">logger := logx.WithContext(ctx)</span><br><span class="line">val, fresh, err := c.barrier.DoEx(key, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;<span class="comment">//共享调用加载key</span></span><br><span class="line"><span class="keyword">if</span> err := c.doGetCache(ctx, key, v); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == errPlaceholder &#123;<span class="comment">//如果是占位符直接返回找不到</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, c.errNotFound</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != c.errNotFound &#123;</span><br><span class="line"><span class="comment">//如果是其他错误，直接返回而不要继续将错误蔓延到dbs</span></span><br><span class="line">        <span class="comment">//如果不这样，可能高并发导致redis奔溃之后，dbs也会跟着崩溃</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//数据库查询</span></span><br><span class="line"><span class="keyword">if</span> err = query(v); err == c.errNotFound &#123; </span><br><span class="line">        <span class="comment">//没有找到就设置占位符</span></span><br><span class="line"><span class="keyword">if</span> err = c.setCacheWithNotFound(ctx, key); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Error(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, c.errNotFound</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.stat.IncrementDbFails()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err = cacheVal(v); err != <span class="literal">nil</span> &#123;<span class="comment">//缓存找到的缓存</span></span><br><span class="line">logger.Error(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> jsonx.Marshal(v)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> fresh &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//放在最后的原因是共享调用，这里共享调用不记录到总数中</span></span><br><span class="line">c.stat.IncrementTotal()</span><br><span class="line">c.stat.IncrementHit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> jsonx.Unmarshal(val.([]<span class="keyword">byte</span>), v)<span class="comment">//反序列化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除缓存-2"><a class="markdownIt-Anchor" href="#删除缓存-2"></a> 删除缓存</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cacheNode)</span> <span class="title">DelCtx</span><span class="params">(ctx context.Context, keys ...<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(keys) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger := logx.WithContext(ctx)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(keys) &gt; <span class="number">1</span> &amp;&amp; c.rds.Type == redis.ClusterType &#123;<span class="comment">//如果是集群则for循环批量删除</span></span><br><span class="line"><span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line"><span class="keyword">if</span> _, err := c.rds.DelCtx(ctx, key); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Errorf(<span class="string">"failed to clear cache with key: %q, error: %v"</span>, key, err)</span><br><span class="line">c.asyncRetryDelCache(key)<span class="comment">//失败添加重试任务</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> _, err := c.rds.DelCtx(ctx, keys...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Errorf(<span class="string">"failed to clear cache with keys: %q, error: %v"</span>, formatKeys(keys), err)</span><br><span class="line">c.asyncRetryDelCache(keys...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缓存统计"><a class="markdownIt-Anchor" href="#缓存统计"></a> 缓存统计</h4><p>代码：<code>core/stores/cache/cachestat.go</code></p><p>用于统计缓存情况</p><h5 id="新建统计对象"><a class="markdownIt-Anchor" href="#新建统计对象"></a> 新建统计对象</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewStat returns a Stat.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStat</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">Stat</span></span> &#123;</span><br><span class="line">ret := &amp;Stat&#123;</span><br><span class="line">name: name,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> ret.statLoop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//statLoop 开启统计</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stat)</span> <span class="title">statLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">ticker := time.NewTicker(statInterval)</span><br><span class="line"><span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">total := atomic.SwapUint64(&amp;s.Total, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> total == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算缓存情况</span></span><br><span class="line">hit := atomic.SwapUint64(&amp;s.Hit, <span class="number">0</span>)</span><br><span class="line">percent := <span class="number">100</span> * <span class="keyword">float32</span>(hit) / <span class="keyword">float32</span>(total)<span class="comment">//命中率</span></span><br><span class="line">miss := atomic.SwapUint64(&amp;s.Miss, <span class="number">0</span>)<span class="comment">//未命中</span></span><br><span class="line">dbf := atomic.SwapUint64(&amp;s.DbFails, <span class="number">0</span>)<span class="comment">//数据库调用事变</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//发送统计信息</span></span><br><span class="line">logx.Statf(<span class="string">"dbcache(%s) - qpm: %d, hit_ratio: %.1f%%, hit: %d, miss: %d, db_fails: %d"</span>,s.name, total, percent, hit, miss, dbf)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>协程是一个常驻协程，缺少退出</li><li><code>SwapUint64</code>的作用是：将新的值写入 <code>addr</code>，而返回<code>addr</code>中旧的值</li></ol><h4 id="缓存清理"><a class="markdownIt-Anchor" href="#缓存清理"></a> 缓存清理</h4><p>当缓存删除失败，这里添加一个重试机制</p><h5 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">    <span class="comment">//时间轮</span></span><br><span class="line">timingWheel, err = collection.NewTimingWheel(time.Second, timingWheelSlots, clean)</span><br><span class="line">logx.Must(err)</span><br><span class="line"><span class="comment">//监听系统异常退出</span></span><br><span class="line">proc.AddShutdownListener(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">timingWheel.Drain(clean)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clean 时间轮操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clean</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">taskRunner.Schedule(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">dt := value.(delayTask)</span><br><span class="line">err := dt.task() <span class="comment">//执行任务</span></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">next, ok := nextDelay(dt.delay)<span class="comment">//重复任务设置</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">dt.delay = next</span><br><span class="line">timingWheel.SetTimer(key, dt, next)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">msg := fmt.Sprintf(<span class="string">"retried but failed to clear cache with keys: %q, error: %v"</span>,</span><br><span class="line">formatKeys(dt.keys), err)</span><br><span class="line">logx.Error(msg)</span><br><span class="line">stat.Report(msg)<span class="comment">//暂未实现</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里做了一个动态清理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextDelay</span><span class="params">(delay time.Duration)</span> <span class="params">(time.Duration, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> delay &#123;</span><br><span class="line"><span class="keyword">case</span> time.Second:</span><br><span class="line"><span class="keyword">return</span> time.Second * <span class="number">5</span>, <span class="literal">true</span></span><br><span class="line"><span class="keyword">case</span> time.Second * <span class="number">5</span>:</span><br><span class="line"><span class="keyword">return</span> time.Minute, <span class="literal">true</span></span><br><span class="line"><span class="keyword">case</span> time.Minute:</span><br><span class="line"><span class="keyword">return</span> time.Minute * <span class="number">5</span>, <span class="literal">true</span></span><br><span class="line"><span class="keyword">case</span> time.Minute * <span class="number">5</span>:</span><br><span class="line"><span class="keyword">return</span> time.Hour, <span class="literal">true</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加清理任务"><a class="markdownIt-Anchor" href="#添加清理任务"></a> 添加清理任务</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddCleanTask adds a clean task on given keys.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddCleanTask</span><span class="params">(task <span class="keyword">func</span>()</span> <span class="title">error</span>, <span class="title">keys</span> ...<span class="title">string</span>)</span> &#123;</span><br><span class="line">timingWheel.SetTimer(stringx.Randn(taskKeyLen), delayTask&#123;</span><br><span class="line">delay: time.Second,</span><br><span class="line">task:  task,</span><br><span class="line">keys:  keys,</span><br><span class="line">&#125;, time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><ol><li>采用共享调用的方式防止缓存击穿</li><li>采用占位符方式缓存床头</li><li>设置范围过期时间防止缓存雪崩</li><li>增加重试删除机制(时间轮)</li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://talkgo.org/t/topic/1716" target="_blank" rel="noopener">https://talkgo.org/t/topic/1716</a></li><li><a href="https://talkgo.org/t/topic/1505" target="_blank" rel="noopener">https://talkgo.org/t/topic/1505</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题背景&quot;&gt;&lt;/a&gt; 问题背景&lt;/h3&gt;
&lt;p&gt;在 &lt;a href=&quot;https://xboom.github.io/2022/07/19/GoZero/GoZero7-%E8%B
      
    
    </summary>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/categories/go-zero/"/>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>go-zero7-进程内缓存</title>
    <link href="http://xboom.github.io/2022/07/19/GoZero/GoZero7-%E8%BF%9B%E7%A8%8B%E5%86%85%E7%BC%93%E5%AD%98/"/>
    <id>http://xboom.github.io/2022/07/19/GoZero/GoZero7-%E8%BF%9B%E7%A8%8B%E5%86%85%E7%BC%93%E5%AD%98/</id>
    <published>2022-07-19T14:31:29.923Z</published>
    <updated>2022-07-20T16:53:11.020Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h3><p>缓存，目的是减少繁重的IO操作，增加系统并发能力。之前做的内存方案</p><ol><li>同一类数据，设计一个双链表，然后添加一个定时器，动态删除过期内存。</li><li>实现一个简单的<code>LRU</code>缓存淘汰算法。</li></ol><p>设计内进程内缓存主要需要考虑的是</p><ol><li>可拓展性(缓存不同类型的数据)</li><li>过期处理，怎样才能友好的删除过期数据，不能无限存储<ul><li>定时删除，不断循环所有key。缺点：需要遍历所有key，空耗CPU</li><li>惰性删除，访问的时候判断该键是否。缺点：如果不在访问，那么就会一直存在</li></ul></li><li>如果保障进程内缓存一致性<ul><li>单节点通知：一个节点完成修改，通知其他节点(类似raft，但raft有主)。缺点：时效性、可靠性</li><li><code>MQ</code>订阅通知：一个节点完成修改，通知其他节点进行修改。缺点：缓存维护更复杂</li><li>定时更新：单个节点定时器，定时拉去新数据，更新内存数据。缺点：时效性</li></ul></li></ol><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>这里看看<code>go-zero</code>是如何实现进程缓存设计的</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/go-zero-cache.png" alt="go-zero-cache" style="zoom: 33%;" /><p>从图中可以看出</p><ol><li>缓存被存放在map</li><li><code>LRU</code>(使用<code>双向链表+Map</code>实现)用于对缓存的过期删除</li><li><code>limit</code> 进行缓存数量限制</li><li>定时逻辑则是通过<a href="https://xboom.github.io/2022/07/08/GoZero/GoZero5-%E6%97%B6%E9%97%B4%E8%BD%AE/">时间轮</a>进行管理</li><li>还包含一个统计逻辑，进行缓存命中情况的上报</li></ol><p>接下来看看它们是如何运转起来的</p><h4 id="更新缓存"><a class="markdownIt-Anchor" href="#更新缓存"></a> 更新缓存</h4><p>设置缓存要做三件事情</p><ol><li>更新缓存</li><li>将<code>Key</code>到LRU管理中</li><li>添加或更新定时器</li></ol><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/go-zero-cache15.png" alt="go-zero-cache15" style="zoom: 33%;" /><p><strong>问题1</strong>：图中还有一个获取过期时间的过程，设置缓存的时候不是应该已经设置了过期时间了吗，为什么这个地方还要再次获取？</p><p>其实这里获取的与过期时间近似的时间，目的是防止缓存雪崩</p><p><code>deviation</code>:表示一个正负差值</p><p><code>base</code>:给定的过期时间</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>d</mi><mi>e</mi><mi>v</mi><mi>i</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>−</mo><mn>2</mn><mo>∗</mo><mi>d</mi><mi>e</mi><mi>v</mi><mi>i</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>∗</mo><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">v =  (1 + deviation - 2 * deviation * random) * base</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span></span></span></span></span></p><p><strong>问题2</strong>：原理图中还有一个设置<code>limit</code>的过程，为什么在添加的过程中没有体现？</p><p>其实这是<code>LRU</code>内部实现的时候使用的，当<code>LRU</code>双向链表长度大于<code>limit</code>的时候，会直接删除尾部节点</p><h4 id="查询缓存"><a class="markdownIt-Anchor" href="#查询缓存"></a> 查询缓存</h4><p>当缓存存在的时候，需要更新<code>LRU</code>。这里还添加了一个命中的逻辑</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/go-zero-cache16.png" alt="go-zero-cache16" style="zoom: 33%;" /><h4 id="获取缓存"><a class="markdownIt-Anchor" href="#获取缓存"></a> 获取缓存</h4><p>获取缓存与查询缓存不同的是，如果缓存中不存在，那么需要从DB获取数据并插入到缓存中</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/go-zero-cache18.png" alt="go-zero-cache18" style="zoom:33%;" /><p>注意：</p><ol><li>使用共享调用防止缓存穿透</li><li>查询DB操作其实是自定义操作(所以缓存不关心数据来源)</li><li>当缓存不存在，启动共享调用逻辑的时候它再次查询了一次缓存。因为DB操作是IO操作，而查询缓存是 O(1)的<code>map</code>内存操作</li></ol><h4 id="删除缓存"><a class="markdownIt-Anchor" href="#删除缓存"></a> 删除缓存</h4><p>删除分为定时删除以及主动删除，当未更新定时器的时候，那么到期就会主动删除 <code>K/V</code></p><p>如果是主动删除，则直接删除缓存，LRU 和 定时器</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/go-zero-cache17.png" alt="go-zero-cache17" style="zoom:50%;" /><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><p>代码路径：<code>core/collection/cache.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义缓存可选参数</span></span><br><span class="line">CacheOption <span class="function"><span class="keyword">func</span><span class="params">(cache *Cache)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程内缓存对象</span></span><br><span class="line">Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">name           <span class="keyword">string</span><span class="comment">//缓存名称，默认为 defaultCacheName="proc"</span></span><br><span class="line">lock           sync.Mutex             <span class="comment">//map锁</span></span><br><span class="line">data           <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="comment">//存储缓存</span></span><br><span class="line">expire         time.Duration <span class="comment">//过期时间</span></span><br><span class="line">timingWheel    *TimingWheel <span class="comment">//时间轮</span></span><br><span class="line">lruCache       lru <span class="comment">//LRU 缓存淘汰机制</span></span><br><span class="line">barrier        syncx.SingleFlight <span class="comment">//共享调用</span></span><br><span class="line">  unstableExpiry mathx.Unstable <span class="comment">//随机过期时间差值(防止雪崩)</span></span><br><span class="line">stats          *cacheStat            <span class="comment">//缓存统计</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化缓存"><a class="markdownIt-Anchor" href="#初始化缓存"></a> 初始化缓存</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCache</span><span class="params">(expire time.Duration, opts ...CacheOption)</span> <span class="params">(*Cache, error)</span></span> &#123;</span><br><span class="line">cache := &amp;Cache&#123;</span><br><span class="line">data:           <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;),</span><br><span class="line">expire:         expire,</span><br><span class="line">lruCache:       emptyLruCache,</span><br><span class="line">barrier:        syncx.NewSingleFlight(),<span class="comment">//共享调用</span></span><br><span class="line">unstableExpiry: mathx.NewUnstable(expiryDeviation),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//自定义操作包含 limit设置、缓存过期时间范围 expiryDeviation</span></span><br><span class="line"><span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">opt(cache)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(cache.name) == <span class="number">0</span> &#123;</span><br><span class="line">cache.name = defaultCacheName<span class="comment">//默认名称可以忽略</span></span><br><span class="line">&#125;</span><br><span class="line">cache.stats = newCacheStat(cache.name, cache.size)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//时间轮已经订好了1s时间间隔</span></span><br><span class="line">timingWheel, err := NewTimingWheel(time.Second, slots, <span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">key, ok := k.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cache.Del(key)<span class="comment">//到期删除缓存</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cache.timingWheel = timingWheel</span><br><span class="line"><span class="keyword">return</span> cache, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询缓存-2"><a class="markdownIt-Anchor" href="#查询缓存-2"></a> 查询缓存</h4><p>查询缓存很简单</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get returns the item with the given key from c.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">value, ok := c.doGet(key)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">c.stats.IncrementHit()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.stats.IncrementMiss()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> value, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">doGet</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">c.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.lock.Unlock()</span><br><span class="line"></span><br><span class="line">value, ok := c.data[key]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">c.lruCache.add(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> value, ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设置缓存"><a class="markdownIt-Anchor" href="#设置缓存"></a> 设置缓存</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Set 设置缓存，默认使用缓存过期时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Set</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">c.SetWithExpire(key, value, c.expire)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetWithExpire 设置缓存 自定义过期时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">SetWithExpire</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;, expire time.Duration)</span></span> &#123;</span><br><span class="line">c.lock.Lock()</span><br><span class="line">_, ok := c.data[key]</span><br><span class="line">c.data[key] = value</span><br><span class="line">c.lruCache.add(key)</span><br><span class="line">c.lock.Unlock()</span><br><span class="line"></span><br><span class="line">expiry := c.unstableExpiry.AroundDuration(expire)<span class="comment">//获取过期时间</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">c.timingWheel.MoveTimer(key, expiry)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.timingWheel.SetTimer(key, value, expiry)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取缓存-2"><a class="markdownIt-Anchor" href="#获取缓存-2"></a> 获取缓存</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Take</span><span class="params">(key <span class="keyword">string</span>, fetch <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> val, ok := c.doGet(key); ok &#123;<span class="comment">//查询缓存</span></span><br><span class="line">c.stats.IncrementHit()</span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fresh <span class="keyword">bool</span></span><br><span class="line">val, err := c.barrier.Do(key, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// because O(1) on map search in memory, and fetch is an IO query</span></span><br><span class="line"><span class="comment">// so we do double check, cache might be taken by another call</span></span><br><span class="line">    <span class="comment">// 再进行一次缓存操作</span></span><br><span class="line"><span class="keyword">if</span> val, ok := c.doGet(key); ok &#123;</span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v, e := fetch()</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fresh = <span class="literal">true</span></span><br><span class="line">c.Set(key, v)</span><br><span class="line"><span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> fresh &#123;</span><br><span class="line">c.stats.IncrementMiss()</span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// got the result from previous ongoing query</span></span><br><span class="line">c.stats.IncrementHit()</span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除缓存-2"><a class="markdownIt-Anchor" href="#删除缓存-2"></a> 删除缓存</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Del</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">c.lock.Lock()</span><br><span class="line"><span class="built_in">delete</span>(c.data, key)<span class="comment">//删除k/v</span></span><br><span class="line">c.lruCache.remove(key)<span class="comment">//删除LRU</span></span><br><span class="line">c.lock.Unlock()</span><br><span class="line">c.timingWheel.RemoveTimer(key) <span class="comment">//删除定时器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><ol><li>设置缓存过期时间的时候，设置一个范围时间防止缓存雪崩</li><li>使用共享调用去请求数据防止缓存击穿</li><li>通过LRU进行缓存淘汰，当多副本存在可能存在缓存一致性问题</li><li>统计逻辑用于上报，并没有一个开关(可能存在性能问题)</li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://talkgo.org/t/topic/2263" target="_blank" rel="noopener">https://talkgo.org/t/topic/2263</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题背景&quot;&gt;&lt;/a&gt; 问题背景&lt;/h3&gt;
&lt;p&gt;缓存，目的是减少繁重的IO操作，增加系统并发能力。之前做的内存方案&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同一类数据，设计一个双链表，然后添加一
      
    
    </summary>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/categories/go-zero/"/>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>go-zero10-自适应降载</title>
    <link href="http://xboom.github.io/2022/07/19/GoZero/GoZero10-%E8%87%AA%E9%80%82%E5%BA%94%E9%99%8D%E8%BD%BD/"/>
    <id>http://xboom.github.io/2022/07/19/GoZero/GoZero10-%E8%87%AA%E9%80%82%E5%BA%94%E9%99%8D%E8%BD%BD/</id>
    <published>2022-07-19T14:31:29.919Z</published>
    <updated>2022-08-13T07:07:36.473Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h3><p>调用链路错综复杂，做为服务的提供者需要有一种保护自己的机制，防止调用方无脑调用压垮自己，保证自身服务的高可用。自适应降载能根据服务自身的系统负载动态判断是否需要降载，它的目标：</p><ol><li>保证系统不被拖垮</li><li>在系统稳定的前提下，保持系统的吞吐量</li></ol><p><strong>问题</strong>：服务怎么知道自己需要降载？</p><p>通过<code>CPU负载</code>与<code>并发数</code>判断往往存在较大波动，这种被称为毛刺的现象可能导致系统一致频繁的自动进行降载操作。所以如果能通过统计最近一段时间内的指标均值使均值更加平滑</p><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>统计学上有一种算法：<code>滑动平均（exponential moving average）</code>，用来估算变量的<strong>局部均值</strong>，使得变量的更新与历史一段时间的历史取值有关，无需记录所有的历史局部变量就可以实现平均值估算</p><p>变量 V 在 t 时刻记为 Vt，θt 为变量 V 在 t 时刻的取值，即在不使用滑动平均模型时 Vt=θt，在使用滑动平均模型后，Vt 的更新公式如下：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>t</mi><mo>=</mo><mi>β</mi><mo>⋅</mo><mi>V</mi><mi>t</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mi mathvariant="normal">−</mi><mi>β</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>θ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Vt=β⋅Vt−1+(1−β)⋅θt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">t</span><span class="mord">−</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mord mathdefault">t</span></span></span></span></span></p><ul><li>β = 0 时 Vt = θt</li><li>β = 0.9 时,大致相当于过去 10 个 θt 值的平均</li><li>β = 0.99 时,大致相当于过去 100 个 θt 值的平均</li></ul><p>而统计最近一段时间内的数据则可以使用 <a href="https://www.yuankang.top/2022/01/12/Algorithms%20To%20Live%20By/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/#comments" target="_blank" rel="noopener">滑动窗口算法</a>，接下来看看如何进行自适应降载判断</p><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><p>来看看 <code>go-zero</code> 的自适应降载的实现</p><p>代码：<code>core/load/adaptiveshedder.go</code></p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/gozero-zishiying-1.png" alt="gozero-zishiying-1" style="zoom: 50%;" /><h4 id="使用案例"><a class="markdownIt-Anchor" href="#使用案例"></a> 使用案例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnarySheddingInterceptor</span><span class="params">(shedder load.Shedder, metrics *stat.Metrics)</span> <span class="title">grpc</span>.<span class="title">UnaryServerInterceptor</span></span> &#123;</span><br><span class="line">    ensureSheddingStat()</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        handler grpc.UnaryHandler)</span> <span class="params">(val <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">        sheddingStat.IncrementTotal()</span><br><span class="line">        <span class="keyword">var</span> promise load.Promise</span><br><span class="line">        <span class="comment">// 检查是否被降载</span></span><br><span class="line">        promise, err = shedder.Allow()</span><br><span class="line">        <span class="comment">// 降载，记录相关日志与指标</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            metrics.AddDrop()</span><br><span class="line">            sheddingStat.IncrementDrop()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后回调执行结果</span></span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 执行失败</span></span><br><span class="line">            <span class="keyword">if</span> err == context.DeadlineExceeded &#123;</span><br><span class="line">                promise.Fail()</span><br><span class="line">            <span class="comment">// 执行成功</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sheddingStat.IncrementPass()</span><br><span class="line">                promise.Pass()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="comment">// 执行业务方法</span></span><br><span class="line">        <span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅需要调用 Allow 接口进行降载逻辑初始化</p><ol><li>如果降载 <code>shedder.Allow()</code>，那么直接记录信息并返回</li><li>否则执行业务逻辑<ul><li>成功则执行 <code>promise.Pass</code></li><li>失败则执行  <code>promise.Fail</code>，业务调用错误这种算执行成功，这里使用业务超时(<code>DeadlineExceeded</code>)表示执行失败需要降载。</li></ul></li></ol><p>这里的<code>promise</code>变量就是上图中的返回结果句柄，用于将业务逻辑结果更新到降载器中</p><h4 id="接口定义"><a class="markdownIt-Anchor" href="#接口定义"></a> 接口定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">defaultBuckets = <span class="number">50</span><span class="comment">//默认滑动窗口槽</span></span><br><span class="line">defaultWindow  = time.Second * <span class="number">5</span><span class="comment">//默认滑动窗口大小</span></span><br><span class="line">defaultCpuThreshold = <span class="number">900</span><span class="comment">//CPU阈值</span></span><br><span class="line">defaultMinRt        = <span class="keyword">float64</span>(time.Second / time.Millisecond)<span class="comment">//最小速率</span></span><br><span class="line">flyingBeta      = <span class="number">0.9</span><span class="comment">//平均请求 系数</span></span><br><span class="line">coolOffDuration = time.Second<span class="comment">//冷静时间</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">  <span class="comment">//回到函数结果处理</span></span><br><span class="line">Promise <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// 请求成功时回调此函数</span></span><br><span class="line">Pass()</span><br><span class="line"><span class="comment">// 请求失败时回调此函数</span></span><br><span class="line">Fail()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//降载接口</span></span><br><span class="line">Shedder <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// 降载检查</span></span><br><span class="line">    <span class="comment">// 1. 允许调用，需手动执行 Promise.accept()/reject()上报实际执行任务结构</span></span><br><span class="line">    <span class="comment">// 2. 拒绝调用，将会直接返回err：服务过载错误 ErrServiceOverloaded</span></span><br><span class="line">Allow() (Promise, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShedderOption lets caller customize the Shedder.</span></span><br><span class="line">ShedderOption <span class="function"><span class="keyword">func</span><span class="params">(opts *shedderOptions)</span></span></span><br><span class="line"></span><br><span class="line">shedderOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">window       time.Duration</span><br><span class="line">buckets      <span class="keyword">int</span></span><br><span class="line">cpuThreshold <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">adaptiveShedder <span class="keyword">struct</span> &#123;</span><br><span class="line">cpuThreshold    <span class="keyword">int64</span><span class="comment">//CPU阈值</span></span><br><span class="line">windows         <span class="keyword">int64</span><span class="comment">//滑动窗口大小</span></span><br><span class="line">flying          <span class="keyword">int64</span>   <span class="comment">//调度统计</span></span><br><span class="line">avgFlying       <span class="keyword">float64</span> <span class="comment">//平均调度</span></span><br><span class="line">avgFlyingLock   syncx.SpinLock<span class="comment">//调度锁</span></span><br><span class="line">dropTime        *syncx.AtomicDuration<span class="comment">//降载时间</span></span><br><span class="line">droppedRecently *syncx.AtomicBool<span class="comment">//降载标识</span></span><br><span class="line">passCounter     *collection.RollingWindow<span class="comment">//滑动窗口 通过统计</span></span><br><span class="line">rtCounter       *collection.RollingWindow <span class="comment">//滑动窗口 速率统计</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建一个自适应熔断调度器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAdaptiveShedder</span><span class="params">(opts ...ShedderOption)</span> <span class="title">Shedder</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !enabled.True() &#123;</span><br><span class="line"><span class="keyword">return</span> newNopShedder()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//... 可选参数执行</span></span><br><span class="line">  </span><br><span class="line">bucketDuration := options.window / time.Duration(options.buckets)<span class="comment">//滑动窗口槽的大小</span></span><br><span class="line"><span class="keyword">return</span> &amp;adaptiveShedder&#123;</span><br><span class="line">cpuThreshold:    options.cpuThreshold,<span class="comment">//CPU阈值</span></span><br><span class="line">windows:         <span class="keyword">int64</span>(time.Second / bucketDuration), <span class="comment">//1s滑动窗口个数</span></span><br><span class="line">dropTime:        syncx.NewAtomicDuration(),<span class="comment">//熔断时间</span></span><br><span class="line">droppedRecently: syncx.NewAtomicBool(),<span class="comment">//最近是否熔断</span></span><br><span class="line">passCounter: collection.NewRollingWindow(options.buckets, bucketDuration,</span><br><span class="line">collection.IgnoreCurrentBucket()),<span class="comment">//滑动窗口通过统计</span></span><br><span class="line">rtCounter: collection.NewRollingWindow(options.buckets, bucketDuration,</span><br><span class="line">collection.IgnoreCurrentBucket()),<span class="comment">//滑动窗口速率统计</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="逻辑判断"><a class="markdownIt-Anchor" href="#逻辑判断"></a> 逻辑判断</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//降载入口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(as *adaptiveShedder)</span> <span class="title">Allow</span><span class="params">()</span> <span class="params">(Promise, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> as.shouldDrop() &#123;</span><br><span class="line">as.dropTime.Set(timex.Now())</span><br><span class="line">as.droppedRecently.Set(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrServiceOverloaded</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">as.addFlying(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;promise&#123;</span><br><span class="line">start:   timex.Now(),</span><br><span class="line">shedder: as,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="结果句柄操作"><a class="markdownIt-Anchor" href="#结果句柄操作"></a> 结果句柄操作</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> promise <span class="keyword">struct</span> &#123;</span><br><span class="line">start   time.Duration</span><br><span class="line">shedder *adaptiveShedder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *promise)</span> <span class="title">Fail</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.shedder.addFlying(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *promise)</span> <span class="title">Pass</span><span class="params">()</span></span> &#123;</span><br><span class="line">rt := <span class="keyword">float64</span>(timex.Since(p.start)) / <span class="keyword">float64</span>(time.Millisecond)<span class="comment">//花费的毫秒数</span></span><br><span class="line">p.shedder.addFlying(<span class="number">-1</span>)</span><br><span class="line">p.shedder.rtCounter.Add(math.Ceil(rt))</span><br><span class="line">p.shedder.passCounter.Add(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意</p><ol><li>其中的 <code>p.shedder.addFlying(-1)</code> 也就是说 <code>flying</code> 变量用于更新调度请求数量的</li><li>失败并不会记录到调度统计中，因为计算平均请求不需要失败</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(as *adaptiveShedder)</span> <span class="title">addFlying</span><span class="params">(delta <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">flying := atomic.AddInt64(&amp;as.flying, delta) <span class="comment">//请求数量更新</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当请求完成时更新 avgFlying。</span></span><br><span class="line"><span class="comment">// 这个策略使得 avgFlying 相对 flying 有一点延迟，并且更平滑。</span></span><br><span class="line"><span class="comment">// 当 flying 请求快速增加时，avgFlying 增加较慢，接受更多请求。</span></span><br><span class="line"><span class="comment">// 当 flying 请求快速下降时，avgFlying 下降较慢，接受较少的请求。</span></span><br><span class="line"><span class="comment">// 它使服务尽可能多地处理请求。</span></span><br><span class="line"><span class="keyword">if</span> delta &lt; <span class="number">0</span> &#123;<span class="comment">//当 &lt; 0 表示 请求完成，计算平均请求</span></span><br><span class="line">as.avgFlyingLock.Lock()</span><br><span class="line">as.avgFlying = as.avgFlying*flyingBeta + <span class="keyword">float64</span>(flying)*(<span class="number">1</span>-flyingBeta)<span class="comment">//滑动平均算法</span></span><br><span class="line">as.avgFlyingLock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="cpu超过限制"><a class="markdownIt-Anchor" href="#cpu超过限制"></a> CPU超过限制</h5><p>这里的CPU也是经过定时统计得出的最近一段时间CPU负载，防止毛刺</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemOverloadChecker = <span class="function"><span class="keyword">func</span><span class="params">(cpuThreshold <span class="keyword">int64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> stat.CpuUsage() &gt;= cpuThreshold</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="过载中判断"><a class="markdownIt-Anchor" href="#过载中判断"></a> 过载中判断</h5><p>如果是正在过载中则，超过一段时间冷静期就恢复正常</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/gozero-zishiying-2.png" alt="gozero-zishiying-2" style="zoom:50%;" /><p>过载标识/时间 是当初过载时候设置的 <code>dropTime</code> 与<code>droppedRecently</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//过载中判断</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(as *adaptiveShedder)</span> <span class="title">stillHot</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !as.droppedRecently.True() &#123;<span class="comment">//是否过热中</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dropTime := as.dropTime.Load()<span class="comment">//加载降载时间</span></span><br><span class="line"><span class="keyword">if</span> dropTime == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hot := timex.Since(dropTime) &lt; coolOffDuration<span class="comment">//是否超过冷静期</span></span><br><span class="line"><span class="keyword">if</span> !hot &#123;</span><br><span class="line">as.droppedRecently.Set(<span class="literal">false</span>)<span class="comment">//更新降载标识</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="过载判断"><a class="markdownIt-Anchor" href="#过载判断"></a> 过载判断</h5><p>过载判断 的逻辑是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//平均请求数大于 且 当前未完成请求的数量超过了最大请求数</span></span><br><span class="line">avgFlying &gt; maxFlight &amp;&amp; flying &gt; maxFlight</span><br></pre></td></tr></table></figure><p>这个 最大并发数 又是怎样计算的呢？</p><blockquote><p>当前系统的最大并发数 = 窗口单位时间内的最大通过数量 * 窗口单位时间内的最小响应时间</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(as *adaptiveShedder)</span> <span class="title">maxFlight</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"><span class="comment">// windows = buckets per second</span></span><br><span class="line"><span class="comment">// maxQPS = maxPASS * windows</span></span><br><span class="line"><span class="comment">// minRT = min average response time in milliseconds</span></span><br><span class="line"><span class="comment">// maxQPS * minRT / milliseconds_per_second</span></span><br><span class="line">  <span class="comment">// as.maxPass()*as.windows - 每个桶最大的qps * 1s内包含桶的数量</span></span><br><span class="line">  <span class="comment">// as.minRt()/1e3 - 窗口所有桶中最小的平均响应时间 / 1000ms这里是为了转换成秒</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int64</span>(math.Max(<span class="number">1</span>, <span class="keyword">float64</span>(as.maxPass()*as.windows)*(as.minRt()/<span class="number">1e3</span>)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前滑动窗口中的最大请求的统计</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(as *adaptiveShedder)</span> <span class="title">maxPass</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">float64</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">as.passCounter.Reduce(<span class="function"><span class="keyword">func</span><span class="params">(b *collection.Bucket)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> b.Sum &gt; result &#123;</span><br><span class="line">result = b.Sum</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int64</span>(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前滑动窗口中最小速率的统计</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(as *adaptiveShedder)</span> <span class="title">minRt</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">result := defaultMinRt</span><br><span class="line"></span><br><span class="line">as.rtCounter.Reduce(<span class="function"><span class="keyword">func</span><span class="params">(b *collection.Bucket)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> b.Count &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">avg := math.Round(b.Sum / <span class="keyword">float64</span>(b.Count))</span><br><span class="line"><span class="keyword">if</span> avg &lt; result &#123;</span><br><span class="line">result = avg</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>自适应降载逻辑处理 当请求突然增大的时候，虽然没有达到服务能够承受的极限，也有可能出现降载。因为平均请求数量以及最大请求数量 都超过了最近一段时间能承载的最大水平</li><li>按照第一条逻辑，如果服务刚启动那会请求确实比较多，是不是就会出现降载了。不会，这里在计算 最大并发数的时候，给定了一个最小最大并发数 <code>1 * defaultMinRt / milliseconds_per_second</code> 。也就是并发数低于 1000的时候也不会触发降载</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://talkgo.org/t/topic/3058" target="_blank" rel="noopener">https://talkgo.org/t/topic/3058</a></li><li><a href="https://www.cnblogs.com/wuliytTaotao/p/9479958.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuliytTaotao/p/9479958.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题背景&quot;&gt;&lt;/a&gt; 问题背景&lt;/h3&gt;
&lt;p&gt;调用链路错综复杂，做为服务的提供者需要有一种保护自己的机制，防止调用方无脑调用压垮自己，保证自身服务的高可用。自适应降载能根据服务自
      
    
    </summary>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/categories/go-zero/"/>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>go-zero6-服务管理</title>
    <link href="http://xboom.github.io/2022/07/19/GoZero/GoZero6-%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    <id>http://xboom.github.io/2022/07/19/GoZero/GoZero6-%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/</id>
    <published>2022-07-19T14:31:29.919Z</published>
    <updated>2022-07-20T16:55:50.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h3><p>之前云平台是基于MQ实现的通信机制，后来需要将通信方式切换为Grpc但又不想修改老的接口和自定义逻辑。所以就需要修改原本的库。因为内部包含了配置加载、MQ适配、Grpc功能、服务注册发现、链路追踪、自定义功能(限速、大包处理、调试、过滤、统计、存储…)。这些子服务是相互独立且可选(不启用也可以)，部分存在依赖关系。所以就想着使用服务管理的方式管理这些小功能，并按照期望的方式进行启动运行</p><h3 id="实现方案"><a class="markdownIt-Anchor" href="#实现方案"></a> 实现方案</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"context"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServerNum <span class="keyword">uint8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">DemoA ServerNum = <span class="literal">iota</span></span><br><span class="line">DemoB</span><br><span class="line">    MaxServerNum</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> serverList = []Server&#123;</span><br><span class="line">DemoA: &amp;Server1&#123;&#125;,</span><br><span class="line">DemoB: &amp;Server2&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">interface</span> &#123;</span><br><span class="line">Start(ctx context.Context) (Server, error)<span class="comment">//服务启动</span></span><br><span class="line">ID() <span class="keyword">int</span><span class="comment">//返回服务标志，用于循序启动</span></span><br><span class="line">Close() error<span class="comment">//关闭服务</span></span><br><span class="line">IsOpen() <span class="keyword">bool</span><span class="comment">//是否开启</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Start</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> serverList &#123;</span><br><span class="line">v.Start(ctx)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务管理</span></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务启动入口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span><span class="title">Start</span><span class="params">(ctx context.Context, s Server)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> || !s.IsOpen() &#123;<span class="comment">//未设置对象或未开启则直接退出</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">v, err := s.Start(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">key := v.ID()<span class="comment">//构建k/v进行服务句柄存储</span></span><br><span class="line"><span class="comment">//TODO 这里使用 封装的context</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span><span class="title">Stop</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := MaxServerNum - <span class="number">1</span>; i &gt;=<span class="number">0</span>; i++ &#123;</span><br><span class="line">v := serverList[i]</span><br><span class="line"><span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">v.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>单个服务内的子模块是否相互依赖的，所以这里使用切片进行存储，关闭时按照启动顺序的反方向</li><li>构建 <code>IsOpen</code> 方便根据配置加载服务需要的模块</li><li>服务句柄的存储暂时保存，需要使用服务句柄也许直接使用大写暴露会更好，或者使用不需要句柄的外部函数</li><li>注意服务的常驻等待(例如HTTP服务就是Listen之后不做后续处理，这个时候就需要使用协程拉起)，而所有服务加载完成之后，需要有一个常驻等待逻辑</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Loop</span><span class="params">()</span></span> &#123;</span><br><span class="line">exit := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(exit, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> sig := &lt;- exit:</span><br><span class="line">log.Infof(context.Background(), <span class="string">"recv signal %s"</span>, sig.String())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><p>代码： <code>core/service/servicegroup.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/zeromicro/go-zero/core/service"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// more code</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  group := service.NewServiceGroup()<span class="comment">//初始化管理对象</span></span><br><span class="line">  <span class="keyword">defer</span> group.Stop()<span class="comment">//停止</span></span><br><span class="line">  group.Add(Morning&#123;&#125;)<span class="comment">//添加服务morning</span></span><br><span class="line">  group.Add(Evening&#123;&#125;)<span class="comment">//添加服务evening</span></span><br><span class="line">  group.Start()<span class="comment">//服务开启</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">Starter <span class="keyword">interface</span> &#123;<span class="comment">//开启接口</span></span><br><span class="line">Start()</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">Stopper <span class="keyword">interface</span> &#123;<span class="comment">//停止接口</span></span><br><span class="line">Stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务接口，开启与停止</span></span><br><span class="line">Service <span class="keyword">interface</span> &#123;</span><br><span class="line">Starter</span><br><span class="line">Stopper</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务批量管理接口</span></span><br><span class="line">ServiceGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">services []Service<span class="comment">//切片保存服务</span></span><br><span class="line">stopOnce <span class="function"><span class="keyword">func</span><span class="params">()</span>//停止一次接口</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="初始化对象"><a class="markdownIt-Anchor" href="#初始化对象"></a> 初始化对象</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewServiceGroup returns a ServiceGroup.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServiceGroup</span><span class="params">()</span> *<span class="title">ServiceGroup</span></span> &#123;</span><br><span class="line">sg := <span class="built_in">new</span>(ServiceGroup)</span><br><span class="line">sg.stopOnce = syncx.Once(sg.doStop)<span class="comment">//停止逻辑使用sync.Once 处理</span></span><br><span class="line"><span class="keyword">return</span> sg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="增加对象"><a class="markdownIt-Anchor" href="#增加对象"></a> 增加对象</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Add 服务管理中添加自定义服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sg *ServiceGroup)</span> <span class="title">Add</span><span class="params">(service Service)</span></span> &#123;</span><br><span class="line"><span class="comment">// push front, stop with reverse order.</span></span><br><span class="line">sg.services = <span class="built_in">append</span>([]Service&#123;service&#125;, sg.services...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开启服务"><a class="markdownIt-Anchor" href="#开启服务"></a> 开启服务</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Start 服务管理启动</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sg *ServiceGroup)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">proc.AddShutdownListener(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="comment">//将服务添加到退出监听中</span></span><br><span class="line">log.Println(<span class="string">"Shutting down..."</span>)</span><br><span class="line">sg.stopOnce()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">sg.doStart()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//doStart 开始</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sg *ServiceGroup)</span> <span class="title">doStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">routineGroup := threading.NewRoutineGroup()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> sg.services &#123;</span><br><span class="line">service := sg.services[i]</span><br><span class="line">    routineGroup.RunSafe(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="comment">//使用每个服务使用协程开启(包含panic处理)</span></span><br><span class="line">service.Start()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">routineGroup.Wait()<span class="comment">//等待退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用协程池进行每个服务的启动，所以每个服务启动的顺序是不一定的</li><li>使用RunSafe进行服务启动，所以一个服务panic，另外的服务也能启动</li></ol><h4 id="服务关闭"><a class="markdownIt-Anchor" href="#服务关闭"></a> 服务关闭</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stop stops the ServiceGroup.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sg *ServiceGroup)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;NewCache</span><br><span class="line">   sg.stopOnce()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//停止服务管理(服务初始化的时候已经设置好了)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sg *ServiceGroup)</span> <span class="title">doStop</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, service := <span class="keyword">range</span> sg.services &#123;</span><br><span class="line">service.Stop()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="仅有开启服务"><a class="markdownIt-Anchor" href="#仅有开启服务"></a> 仅有开启服务</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WithStart wraps a start func as a Service.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithStart</span><span class="params">(start <span class="keyword">func</span>()</span>) <span class="title">Service</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> startOnlyService&#123;</span><br><span class="line">start: start,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WithStarter wraps a Starter as a Service.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithStarter</span><span class="params">(start Starter)</span> <span class="title">Service</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> starterOnlyService&#123;</span><br><span class="line">Starter: start,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">stopper <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">startOnlyService <span class="keyword">struct</span> &#123;</span><br><span class="line">start <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">stopper</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">starterOnlyService <span class="keyword">struct</span> &#123;</span><br><span class="line">Starter</span><br><span class="line">stopper</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s stopper)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s startOnlyService)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">s.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>由于子服务无法保证启动顺序，所以各服务之间不能有相互依赖或关联</li><li>使用 <code>stopOnce</code> 防止出现多次调用<code>stop</code>的情况</li><li>使用 <code>proc.AddShutdownListener</code>做退出监听</li></ol><p>优化：</p><ol><li>如果能控制服务启动和调用顺序是否会更好(一个服务内的多个子模块必然存在先后启动关系)，那么停止服务的时候也注意先后关系</li><li>如果使用协程池拉起服务，那么单个服务的异常无法让所有子服务都退出。缺少一个同步退出机制</li><li>使用 <code>startOnlyService</code>是否有点多余，在服务停止中不做任何处理，那么退出时也能正常退出</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://mp.weixin.qq.com/s/G6WG_-C6d-raoRmH4hBjoQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/G6WG_-C6d-raoRmH4hBjoQ</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题背景&quot;&gt;&lt;/a&gt; 问题背景&lt;/h3&gt;
&lt;p&gt;之前云平台是基于MQ实现的通信机制，后来需要将通信方式切换为Grpc但又不想修改老的接口和自定义逻辑。所以就需要修改原本的库。因为内
      
    
    </summary>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/categories/go-zero/"/>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>go-zero5-时间轮</title>
    <link href="http://xboom.github.io/2022/07/08/GoZero/GoZero5-%E6%97%B6%E9%97%B4%E8%BD%AE/"/>
    <id>http://xboom.github.io/2022/07/08/GoZero/GoZero5-%E6%97%B6%E9%97%B4%E8%BD%AE/</id>
    <published>2022-07-07T16:22:06.133Z</published>
    <updated>2022-07-17T08:41:58.841Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h3><p>一个系统中存在着大量的延迟/定时任务：</p><ol><li>在一个间隔时间之后做某事: 例如在最后一次消息发送的5分钟之后, 断开连接</li><li>在一个间隔时间之后不停的做某事: 例如每隔5分钟之后去发送心跳，检测连接是否正常</li></ol><p>如果每个任务都使用自己的调度器来管理任务声明周期的话，浪费CPU的资源而且很低效，比如：</p><ol><li>在定时器的数量增长到百万级之后, 基于最小堆实现的定时器的性能会显著降低</li><li>客户端会定时发送心跳以此来确保连接的可用性。导致每个连接都需要新建一些协程去维护</li></ol><h3 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h3><p>延迟操作，通常可以采用两个方案：</p><ol><li><code>Timer</code>：定时器维护一个优先队列，到时间点执行，然后把需要执行的 <code>task</code> 存储在 <code>map</code> 中</li><li><code>collection</code> 中的 <code>timingWheel</code> ，维护一个存放任务组的数组，每一个槽都维护一个存储 <code>task</code> 的双向链表。开始执行时，计时器每隔指定时间执行一个槽里面的 <code>tasks</code></li></ol><p>时间轮是一种高效来利用线程资源来进行批量化调度的一种调度模型。把大批量的调度任务全部都绑定到同一个的调度器上面，使用这一个调度器来进行所有任务的管理<code>(manager)</code>，触发<code>(trigger)</code>以及运行<code>(runnable)</code></p><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>使用一个 <code>类Map</code> 的结构进行时间轮而构建，其中：</p><ol><li>定时器的间隔就是从第n个槽进入到第n+1个槽的时间</li><li>每个槽中的任务通过双向链表进行存储，定时器到达槽的位置之后，并发处理槽的任务(指定时间相同)</li></ol><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/timingwheel21.png" alt="timingwheel21" style="zoom: 50%;" /><p><strong>问题1</strong>：新建的任务如何添加到对应的位置</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/timingwheel22.png" alt="timingwheel22" style="zoom:50%;" /><p>如上图，槽位<code>(numSlots)</code>为12的时间轮，时间轮的定时间隔<code>(interval)</code>为1s，当前正在执行槽<code>(tickedPos)</code>为1位置的任务。</p><p>当添加一个延时时间<code>(delay)</code>为5s的任务的时候，那么：</p><ol><li>需要等待的间隔数<code>step</code>：<strong><code>step = delay / interval</code></strong>  为 5。</li><li>需要放入的槽的位置<code>position</code>:<strong><code>position = (step + tickedPos) % numSlots</code></strong> 为 6。</li></ol><p><strong>问题2</strong>：新建任务超过槽的数目怎么办？</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/timingwheel24.png" alt="timingwheel24" style="zoom:50%;" /><p>如上图，当添加一个延时时间<code>(delay)</code>为18s的时候，根据上面的计算公司</p><ol><li>需要等待的间隔数<code>step = delay / interval =</code> 18</li><li>需要放入的槽的位置 <code>postion = (step + tickedPos) % numSlots =</code> 6。</li></ol><p>这个时候就出现一个问题，延迟5s的任务和延迟18s的任务会一起在5s后执行，这个时候就出现了多层环的概念</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/timingwheel25.png" alt="timingwheel25" style="zoom:50%;" /><p>当第一层环的时间无法满足任务的延时的时候，可以将任务放置到第n层环上。时间轮还是会按照环的顺序进行执行</p><p>环的位置<code>circle</code>: <strong><code>circle = (steps - 1) / numSlots</code></strong></p><p>所以延时5s的任务它的环 <code>circle = (5 - 1) / 12 = 0</code>，延时18s的任务它的环 <code>circle = (18 -1)/12 = 1</code></p><p>随着时间的推移第一层环完成之后再去执行第二层环</p><p><strong>问题3</strong>：不同环的任务是否都需要构建一个新的环来保存任务</p><p><strong>不需要</strong>，不同环但是槽相同的任务放入到同一个双向链表中，当执行该槽任务的时候，只需要判断当前的任务<code>if circle == 0</code>，否则就不是当前环的任务，将<code>circle -= 1</code></p><p>这样也有一个缺点：就是在遍历槽中任务的时候，虽然不是相同时间执行，但是槽中所有任务都需要遍历。不过一个微服务中定时任务也不会太多，所以缺点基本可以忽略</p><p><strong>问题4</strong>：定时任务时间轮都是是如何处理的</p><p>根据任务类型可以分为<strong>延时任务</strong>与<strong>定时任务</strong>。根据任务执行一次可以分为<strong>执行一次</strong>和<strong>重复执行</strong>。这里有两点需要解决</p><ol><li>不同类型任务的开始时间是怎么计算开始时间的</li><li>需要重复的任务是如何存储的</li></ol><ul><li>延时任务<ul><li>执行一次：根据延时时间计算在时间轮中的位置，定时触发即可</li><li>重复执行：每次执行任务完成，判断任务是否重复，然后重新计算任务位置重新插入即可</li></ul></li><li>定时任务：<ul><li>执行一次：</li></ul></li></ul><p><strong>问题5</strong>：如果一个时间间隔内时间任务处理不过来怎么办</p><p>通过下一节技术内幕来查看处理逻辑。不过可以预想到的是每个槽都会拉起协程来进行任务处理，如果是顺序执行有可能导致部分任务超出执行时间，所以每个任务都会使用一个协程处理，那么这里就可以考虑协程池以及对象池了。</p><p><strong>问题6</strong>：如果一个任务的延时时间小于时间轮的时间片间隔，那么任务何时执行</p><p>这里有两个解决方案，<code>go-zero</code>使用第一种方案：</p><ol><li><p>由于小于延时时间小于时间间隔，那么就认为任务不需要等到下一个时间轮的时间片执行，而是立即执行</p></li><li><p>利用多层环的原理处理更细粒度的任务。这样就不能重用<code>circle</code>的概念，而是需要 <code>sub circle</code>子环概念</p><ul><li><code>circle</code>用来解决延时时间超过当前环的问题</li><li><code>sub circle</code>用来解决更细粒度的时间片需求。缺点就是逻辑结构更复杂，每个<code>sub circle</code>都需要有一个更细的时间粒度</li></ul><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/timingwheel27.png" alt="timingwheel27" style="zoom:33%;" /></li></ol><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><p>代码路径：<code>core/collection/timingwheel.go</code>，前一节就是 <code>go-zero</code> 中时间轮的时间原理</p><h4 id="时间轮对象"><a class="markdownIt-Anchor" href="#时间轮对象"></a> 时间轮对象</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A TimingWheel is a timing wheel object to schedule tasks.</span></span><br><span class="line">TimingWheel <span class="keyword">struct</span> &#123;</span><br><span class="line">interval      time.Duration<span class="comment">//时间划分刻度</span></span><br><span class="line">ticker        timex.Ticker</span><br><span class="line">slots         []*list.List<span class="comment">//数组内为双向链表指针</span></span><br><span class="line">timers        *SafeMap <span class="comment">//</span></span><br><span class="line">tickedPos     <span class="keyword">int</span> <span class="comment">//环的位置</span></span><br><span class="line">numSlots      <span class="keyword">int</span> <span class="comment">//时间槽</span></span><br><span class="line">execute       Execute <span class="comment">//时间点执行任务的方法</span></span><br><span class="line">  <span class="comment">//以下为不同任务的隧道</span></span><br><span class="line">setChannel    <span class="keyword">chan</span> timingEntry<span class="comment">//设置任务隧道</span></span><br><span class="line">moveChannel   <span class="keyword">chan</span> baseEntry<span class="comment">//移动任务隧道</span></span><br><span class="line">removeChannel <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;  <span class="comment">//删除任务隧道</span></span><br><span class="line">drainChannel  <span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span> //并发执行任务隧道</span></span><br><span class="line">stopChannel   <span class="keyword">chan</span> lang.PlaceholderType <span class="comment">//时间轮停止通知隧道</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Execute 执行任务的方法</span></span><br><span class="line">Execute <span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//timingEntry </span></span><br><span class="line">timingEntry <span class="keyword">struct</span> &#123;  <span class="comment">//时间轮实体对象</span></span><br><span class="line">baseEntry</span><br><span class="line">value   <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">circle  <span class="keyword">int</span></span><br><span class="line">diff    <span class="keyword">int</span></span><br><span class="line">removed <span class="keyword">bool</span><span class="comment">//是否删除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//baseEntry 基础属性</span></span><br><span class="line">baseEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">delay time.Duration</span><br><span class="line">key   <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//positionEntry 位置对象</span></span><br><span class="line">positionEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">pos  <span class="keyword">int</span></span><br><span class="line">item *timingEntry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//timingTask 时间任务</span></span><br><span class="line">timingTask <span class="keyword">struct</span> &#123;</span><br><span class="line">key   <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ol><li><p>每个槽中因为是链表，所以并没有数量限制</p></li><li><p>时间轮实体<code>timingEntry</code>中有两个值需要关注 <code>diff</code> 和 <code>removed</code></p></li><li><p>时间轮结构中 <code>timers</code> 作用往下看</p><blockquote><p><code>timers</code> 使用的 <code>SafeMap</code> 不仅仅是为了处理并发安全，还有就是原生<code>map</code>内存泄露问题的临时替代品(详见《GoZero-SafeMap》)</p></blockquote></li></ol><h4 id="初始化时间轮"><a class="markdownIt-Anchor" href="#初始化时间轮"></a> 初始化时间轮</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewTimingWheel 初始化并返回一个时间轮</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimingWheel</span><span class="params">(interval time.Duration, numSlots <span class="keyword">int</span>, execute Execute)</span> <span class="params">(*TimingWheel, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> interval &lt;= <span class="number">0</span> || numSlots &lt;= <span class="number">0</span> || execute == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"interval: %v, slots: %d, execute: %p"</span>,</span><br><span class="line">interval, numSlots, execute)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newTimingWheelWithClock(interval, numSlots, execute, timex.NewTicker(interval))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//newTimingWheelWithClock 初始化时间轮</span></span><br><span class="line"><span class="comment">//interval：时间划分刻度</span></span><br><span class="line"><span class="comment">//numSlots：时间槽</span></span><br><span class="line"><span class="comment">//execute：时间点执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTimingWheelWithClock</span><span class="params">(interval time.Duration, numSlots <span class="keyword">int</span>, execute Execute,</span></span></span><br><span class="line"><span class="function"><span class="params">ticker timex.Ticker)</span> <span class="params">(*TimingWheel, error)</span></span> &#123;</span><br><span class="line">tw := &amp;TimingWheel&#123;</span><br><span class="line">  interval:      interval,                     <span class="comment">// 单个时间格时间间隔</span></span><br><span class="line">    ticker:        ticker,                       <span class="comment">// 定时器，做时间推动，以interval为单位推进</span></span><br><span class="line">    slots:         <span class="built_in">make</span>([]*list.List, numSlots), <span class="comment">// 时间轮</span></span><br><span class="line">    timers:        NewSafeMap(),                 <span class="comment">// 存储task&#123;key, value&#125;的map [执行execute所需要的参数]</span></span><br><span class="line">    tickedPos:     numSlots - <span class="number">1</span>,                 <span class="comment">// at previous virtual circle</span></span><br><span class="line">    execute:       execute,                      <span class="comment">// 执行函数</span></span><br><span class="line">    numSlots:      numSlots,                     <span class="comment">// 初始化 slots num</span></span><br><span class="line">    setChannel:    <span class="built_in">make</span>(<span class="keyword">chan</span> timingEntry),       <span class="comment">// 以下几个channel是做task传递的</span></span><br><span class="line">moveChannel:   <span class="built_in">make</span>(<span class="keyword">chan</span> baseEntry),</span><br><span class="line">removeChannel: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;),</span><br><span class="line">drainChannel:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span>),</span></span><br><span class="line">stopChannel:   <span class="built_in">make</span>(<span class="keyword">chan</span> lang.PlaceholderType),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  tw.initSlots()<span class="comment">//使用list.New()初始化每个槽，构建双向链表保存任务</span></span><br><span class="line"><span class="keyword">go</span> tw.run()<span class="comment">//开启协程，使用channel来做task时间任务接收与处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tw, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据隧道类型等待不同的任务执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-tw.ticker.Chan():</span><br><span class="line">tw.onTick()</span><br><span class="line"><span class="keyword">case</span> task := &lt;-tw.setChannel:<span class="comment">//收到设置任务</span></span><br><span class="line">tw.setTask(&amp;task)</span><br><span class="line"><span class="keyword">case</span> key := &lt;-tw.removeChannel:<span class="comment">//删除隧道</span></span><br><span class="line">tw.removeTask(key)</span><br><span class="line"><span class="keyword">case</span> task := &lt;-tw.moveChannel:<span class="comment">//重复任务隧道</span></span><br><span class="line">tw.moveTask(task)</span><br><span class="line"><span class="keyword">case</span> fn := &lt;-tw.drainChannel:<span class="comment">//并发任务</span></span><br><span class="line">tw.drainAll(fn)</span><br><span class="line"><span class="keyword">case</span> &lt;-tw.stopChannel:<span class="comment">//停止隧道</span></span><br><span class="line">tw.ticker.Stop()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/timingwheel26.png" alt="timingwheel26" style="zoom:33%;" /><p>在时间轮拉起协程进行隧道的监听与处理，这里需要注意的是：</p><ol><li>除了时间轮的定时器隧道，其他隧道都可以通过外部接口将消息传入处理</li><li>其中<code>moveChannel</code>和<code>drainChannel</code>需要解释：<ul><li><code>moveChannel</code>：更新任务延时时间</li><li><code>drainChannel</code>：使用自定义函数并发执行所有任务</li></ul></li></ol><h4 id="添加任务"><a class="markdownIt-Anchor" href="#添加任务"></a> 添加任务</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetTimer 设置过期时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">SetTimer</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;, delay time.Duration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> delay &lt;= <span class="number">0</span> || key == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ErrArgument</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> tw.setChannel &lt;- timingEntry&#123;<span class="comment">//向设置隧道中添加一个基础的任务对象</span></span><br><span class="line">baseEntry: baseEntry&#123;</span><br><span class="line">delay: delay,</span><br><span class="line">key:   key,</span><br><span class="line">&#125;,</span><br><span class="line">value: value,</span><br><span class="line">&#125;:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span><span class="comment">//设置完直接结束</span></span><br><span class="line"><span class="keyword">case</span> &lt;-tw.stopChannel:<span class="comment">//当设置过程中收到退出通知则直接退出</span></span><br><span class="line"><span class="keyword">return</span> ErrClosed</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//setTask 时间轮收到设置任务任务之后进行任务添加</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">setTask</span><span class="params">(task *timingEntry)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> task.delay &lt; tw.interval &#123;<span class="comment">//如果任务延迟时间小于时间轮的刻度，那么延迟时间等于刻度</span></span><br><span class="line">task.delay = tw.interval</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> val, ok := tw.timers.Get(task.key); ok &#123; <span class="comment">//如果已经存在这个任务，更新任务</span></span><br><span class="line">entry := val.(*positionEntry)</span><br><span class="line">entry.item.value = task.value</span><br><span class="line">tw.moveTask(task.baseEntry)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pos, circle := tw.getPositionAndCircle(task.delay) <span class="comment">//根据延时获取任务位置</span></span><br><span class="line">task.circle = circle<span class="comment">//设置任务所在的环</span></span><br><span class="line">tw.slots[pos].PushBack(task) <span class="comment">//将任务添加到对应槽中</span></span><br><span class="line">tw.setTimerPosition(pos, task)  <span class="comment">//更新任务最新位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>在添加任务的时候这里的 value 类型是 <code>interface</code> 类型，而不是指定的任务对象</li><li>注意这里使用 <code>setTimerPosition</code> 又缓存任务，它的作用往下看</li></ul><p>如 <em>实现原理</em> 中介绍的那样计算任务所在的<code>槽</code>以及<code>环</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getPositionAndCircle 获取位置与环</span></span><br><span class="line"><span class="comment">//@param: d 任务延时时间</span></span><br><span class="line"><span class="comment">//@return:</span></span><br><span class="line"><span class="comment">// pos 任务所在槽</span></span><br><span class="line"><span class="comment">// circle 任务环</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">getPositionAndCircle</span><span class="params">(d time.Duration)</span> <span class="params">(pos, circle <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//如果将任务的延迟时间按照时间轮刻度划分，那么 steps 就是在第几个刻度内</span></span><br><span class="line">steps := <span class="keyword">int</span>(d / tw.interval)</span><br><span class="line">  <span class="comment">// 时间轮的相对位置 + 延迟相对时间刻度的位置 % 槽的数量  = 任务在时间轮中的位置</span></span><br><span class="line">pos = (tw.tickedPos + steps) % tw.numSlots</span><br><span class="line">circle = (steps - <span class="number">1</span>) / tw.numSlots</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置任务的位置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//setTimerPosition 设置任务位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">setTimerPosition</span><span class="params">(pos <span class="keyword">int</span>, task *timingEntry)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> val, ok := tw.timers.Get(task.key); ok &#123;<span class="comment">//如果任务缓存已经存在，那么更新槽的位置</span></span><br><span class="line">timer := val.(*positionEntry)</span><br><span class="line">timer.item = task</span><br><span class="line">timer.pos = pos</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tw.timers.Set(task.key, &amp;positionEntry&#123;  <span class="comment">//如果任务缓存不存在，则设置任务缓存</span></span><br><span class="line">pos:  pos,</span><br><span class="line">item: task,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 时间轮中 <code>timers</code>其实是通过<code>key</code>保存任务，并把完成任务和位置都保存</p><h4 id="更新任务"><a class="markdownIt-Anchor" href="#更新任务"></a> 更新任务</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MoveTimer移动任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">MoveTimer</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, delay time.Duration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> delay &lt;= <span class="number">0</span> || key == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ErrArgument</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> tw.moveChannel &lt;- baseEntry&#123;</span><br><span class="line">delay: delay,</span><br><span class="line">key:   key,</span><br><span class="line">&#125;:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;-tw.stopChannel:</span><br><span class="line"><span class="keyword">return</span> ErrClosed</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//moveTask 更新任务执行位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">moveTask</span><span class="params">(task baseEntry)</span></span> &#123;</span><br><span class="line">  val, ok := tw.timers.Get(task.key)  <span class="comment">//通过key获取任务(因为是移动，所以当任务不存在，那么直接结束。)</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timer := val.(*positionEntry)</span><br><span class="line"><span class="keyword">if</span> task.delay &lt; tw.interval &#123;<span class="comment">//如果任务的delay小于时间片，那么立即执行</span></span><br><span class="line">threading.GoSafe(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;   <span class="comment">//拉起协程进行执行</span></span><br><span class="line">tw.execute(timer.item.key, timer.item.value) </span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pos, circle := tw.getPositionAndCircle(task.delay)  <span class="comment">//计算任务位置</span></span><br><span class="line"><span class="keyword">if</span> pos &gt;= timer.pos &#123;</span><br><span class="line">timer.item.circle = circle</span><br><span class="line">timer.item.diff = pos - timer.pos   <span class="comment">//计算任务位置与缓存中任务位置的不同</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> circle &gt; <span class="number">0</span> &#123; <span class="comment">//不是当前环的任务，那么 circl - 1</span></span><br><span class="line">circle--</span><br><span class="line">timer.item.circle = circle</span><br><span class="line">timer.item.diff = tw.numSlots + pos - timer.pos <span class="comment">//不同 加上一个环的槽数，判断位置是否相同</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">timer.item.removed = <span class="literal">true</span></span><br><span class="line">newItem := &amp;timingEntry&#123;</span><br><span class="line">baseEntry: task,</span><br><span class="line">value:     timer.item.value,</span><br><span class="line">&#125;</span><br><span class="line">tw.slots[pos].PushBack(newItem)</span><br><span class="line">tw.setTimerPosition(pos, newItem)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>移动任务<code>MoveTimer(key interface{}, delay time.Duration) error {... }</code>并没有参数 <code>Value</code>，用来移动更新已有的任务</li></ol><h4 id="执行任务"><a class="markdownIt-Anchor" href="#执行任务"></a> 执行任务</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时器触发任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">onTick</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//获取需要执行任务的槽位置</span></span><br><span class="line">  tw.tickedPos = (tw.tickedPos + <span class="number">1</span>) % tw.numSlots </span><br><span class="line">l := tw.slots[tw.tickedPos] <span class="comment">//获取槽的对应链表</span></span><br><span class="line">tw.scanAndRunTasks(l)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">scanAndRunTasks</span><span class="params">(l *list.List)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> tasks []timingTask</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e := l.Front(); e != <span class="literal">nil</span>; &#123;<span class="comment">//遍历链表</span></span><br><span class="line">task := e.Value.(*timingEntry)</span><br><span class="line"><span class="keyword">if</span> task.removed &#123;<span class="comment">//如果任务状态为删除，则从任务链表中删除任务</span></span><br><span class="line">next := e.Next()</span><br><span class="line">l.Remove(e)</span><br><span class="line">e = next</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> task.circle &gt; <span class="number">0</span> &#123; <span class="comment">//如果任务所在的环大于0</span></span><br><span class="line">task.circle--</span><br><span class="line">e = e.Next()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> task.diff &gt; <span class="number">0</span> &#123;   <span class="comment">//如果任务位置发生了变化</span></span><br><span class="line">next := e.Next()</span><br><span class="line">l.Remove(e)<span class="comment">//先删掉任务</span></span><br><span class="line"><span class="comment">// (tw.tickedPos+task.diff)%tw.numSlots</span></span><br><span class="line"><span class="comment">// cannot be the same value of tw.tickedPos</span></span><br><span class="line">pos := (tw.tickedPos + task.diff) % tw.numSlots<span class="comment">//根据任务最新的位置计算位置重新放入任务</span></span><br><span class="line">tw.slots[pos].PushBack(task)</span><br><span class="line">tw.setTimerPosition(pos, task)</span><br><span class="line">task.diff = <span class="number">0</span></span><br><span class="line">e = next</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks = <span class="built_in">append</span>(tasks, timingTask&#123;</span><br><span class="line">key:   task.key,</span><br><span class="line">value: task.value,</span><br><span class="line">&#125;)</span><br><span class="line">next := e.Next()</span><br><span class="line">l.Remove(e)</span><br><span class="line">tw.timers.Del(task.key)</span><br><span class="line">e = next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tw.runTasks(tasks)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">runTasks</span><span class="params">(tasks []timingTask)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(tasks) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> tasks &#123;<span class="comment">//拉起一个协程，不断执行任务(多任务非并发)</span></span><br><span class="line">threading.RunSafe(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">tw.execute(tasks[i].key, tasks[i].value)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：每个任务都使用一个协程进行执行，这里使用的是 <code>go-zero</code>封装的协程池，这个go 会等待所有任务执行完毕才会结束</p><h4 id="删除任务"><a class="markdownIt-Anchor" href="#删除任务"></a> 删除任务</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RemoveTimer removes the task with the given key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">RemoveTimer</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ErrArgument</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> tw.removeChannel &lt;- key:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;-tw.stopChannel:</span><br><span class="line"><span class="keyword">return</span> ErrClosed</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//removeTask</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">removeTask</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">val, ok := tw.timers.Get(key) <span class="comment">//任务不存在</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timer := val.(*positionEntry)</span><br><span class="line">timer.item.removed = <span class="literal">true</span><span class="comment">//增加一个状态表示已经被删除</span></span><br><span class="line">tw.timers.Del(key)         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="排空任务"><a class="markdownIt-Anchor" href="#排空任务"></a> 排空任务</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Drain 使用 fn 排空任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">Drain</span><span class="params">(fn <span class="keyword">func</span>(key, value <span class="keyword">interface</span>&#123;&#125;)</span>) <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> tw.drainChannel &lt;- fn:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;-tw.stopChannel:</span><br><span class="line"><span class="keyword">return</span> ErrClosed</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//drainAll 排空任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">drainAll</span><span class="params">(fn <span class="keyword">func</span>(key, value <span class="keyword">interface</span>&#123;&#125;)</span>)</span> &#123;</span><br><span class="line">runner := threading.NewTaskRunner(drainWorkers)</span><br><span class="line"><span class="keyword">for</span> _, slot := <span class="keyword">range</span> tw.slots &#123;</span><br><span class="line"><span class="keyword">for</span> e := slot.Front(); e != <span class="literal">nil</span>; &#123;</span><br><span class="line">task := e.Value.(*timingEntry)</span><br><span class="line">next := e.Next()</span><br><span class="line">slot.Remove(e)</span><br><span class="line">e = next</span><br><span class="line"><span class="keyword">if</span> !task.removed &#123;</span><br><span class="line">runner.Schedule(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fn(task.key, task.value)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排空任务并不是直接删除，而是提供一个自定义函数接口用于处理剩下的任务，有利于安全退出。但需要注意的是每个任务都会拉一个协程进行处理，也就是不能立即执行 时间轮的 <code>Stop</code></p><h4 id="停止时间轮"><a class="markdownIt-Anchor" href="#停止时间轮"></a> 停止时间轮</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stop stops tw. No more actions after stopping a TimingWheel.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">close</span>(tw.stopChannel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li><code>task</code>从 <code>优先队列 O(nlog(n))</code> 降到 <code>双向链表 O(1)</code>，而执行task也只要轮询一个时间点的tasks <code>O(N)</code>，不需要像优先队列，放入和删除元素 <code>O(nlog(n))</code>。</li><li>时间轮中的多层环是一种虚拟概念，用来记录超出范围(<code>nusSlots * interval</code>)的任务</li><li>使用<code>chan</code>接收外部接口调用的好处是并发安全，当然内部逻辑实现还是需要注意<code>map</code>安全</li></ol><p>补充：</p><ol><li>可以添加一个在协程池中讲到的时间轮状态，保证不会有新的任务在退出的时候加进来</li><li>可以使用协程池和内存池的节省内存空间，但如果协程池处理不过来使后续任务阻塞，可能会导致时间轮功能异常</li><li>分布式系统中系统的定时调用则需要使用分布式定时器，这在另外的章节中学习</li></ol><h3 id="技术应用"><a class="markdownIt-Anchor" href="#技术应用"></a> 技术应用</h3><p>go-zero用于缓存的定时删除</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">timingWheel, err := NewTimingWheel(time.Second, slots, <span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">key, ok := k.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cache.Del(key)<span class="comment">//到达则删除缓存</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cache.timingWheel = timingWheel</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://www.ericcai.fun/detail/16" target="_blank" rel="noopener">https://www.ericcai.fun/detail/16</a></li><li><a href="https://juejin.cn/post/6844904110399946766" target="_blank" rel="noopener">https://juejin.cn/post/6844904110399946766</a></li><li><a href="https://xiaorui.cc/archives/6160" target="_blank" rel="noopener">https://xiaorui.cc/archives/6160</a></li><li><a href="https://zhuanlan.zhihu.com/p/264826698" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/264826698</a></li><li><a href="https://lk668.github.io/2021/04/05/2021-04-05-%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E7%94%A8golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAtimewheel/" target="_blank" rel="noopener">https://lk668.github.io/2021/04/05/2021-04-05-手把手教你如何用golang实现一个timewheel/</a></li><li><a href="https://go-zero.dev/cn/docs/blog/principle/timing-wheel" target="_blank" rel="noopener">https://go-zero.dev/cn/docs/blog/principle/timing-wheel</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题背景&quot;&gt;&lt;/a&gt; 问题背景&lt;/h3&gt;
&lt;p&gt;一个系统中存在着大量的延迟/定时任务：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在一个间隔时间之后做某事: 例如在最后一次消息发送的5分钟之后, 
      
    
    </summary>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/categories/go-zero/"/>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>go-zero4-协程池1</title>
    <link href="http://xboom.github.io/2022/07/06/GoZero/GoZero4-%E5%8D%8F%E7%A8%8B%E6%B1%A01/"/>
    <id>http://xboom.github.io/2022/07/06/GoZero/GoZero4-%E5%8D%8F%E7%A8%8B%E6%B1%A01/</id>
    <published>2022-07-06T13:53:58.640Z</published>
    <updated>2022-07-06T14:55:05.108Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h3><p>需要协程池吗？</p><p>虽然协程非常轻量级的，一般用不上协程池。协程池的作用 无休止地创建大量goroutine，势必会因为对大量go 程的创建、调度和销毁带来性能损耗。 为了解决这个问题，可以引入协程池</p><h3 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h3><p>协程池需要什么？</p><ol><li>协程如何重用、任务如何执行</li><li>协程池支持自定义协程池大小</li><li>如果当前任务数量超过协程池大小，那么当前任务需要等待，等待时间支持超时退出</li><li>协程支持自定义退出</li><li>异常捕获，防止因为单个协程的异常处理导致整个协程池无法使用</li></ol><p>协程池大致的逻辑如下图所示：</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/gopools1.png" alt="gopools1" /></p><h4 id="方案1"><a class="markdownIt-Anchor" href="#方案1"></a> 方案1</h4><p>这是一个网上能搜到的 “100行实现一个协程池”，</p><p><strong>第一步</strong>：定义一个任务</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">    Handler <span class="function"><span class="keyword">func</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line">    Params  []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实是将需要执行的协程方法，使用结构体封装起来</p><p><strong>第二步</strong>：定义一个协程池</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">    capacity       <span class="keyword">uint64</span><span class="comment">//容量</span></span><br><span class="line">    runningWorkers <span class="keyword">uint64</span><span class="comment">//正在运行的协程树</span></span><br><span class="line">    status          <span class="keyword">int64</span>           <span class="comment">//状态(防止在退出过程中，仍然在新建协程)</span></span><br><span class="line">    chTask          <span class="keyword">chan</span> *Task      <span class="comment">//任务队列</span></span><br><span class="line">    PanicHandler   <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span>//<span class="title">panic</span>处理函数</span></span><br><span class="line">    sync.Mutex<span class="comment">//原子锁,用于保证runningWorkers原子数据变化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    RUNNING = <span class="number">1</span></span><br><span class="line">    STOPED = <span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>：利用协程池启动一个协程执行任务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.incRunning()<span class="comment">//增加正在运行的协程数目</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.decRunning()<span class="comment">//结束任务</span></span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p.PanicHandler != <span class="literal">nil</span> &#123;</span><br><span class="line">p.PanicHandler(r)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"Worker panic: %s\n"</span>, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p.checkWorker() <span class="comment">// check worker avoid no worker running</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> task, ok := &lt;-p.chTask:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">task.Handler(task.Params...)<span class="comment">//任务处理</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果任务数量大于0，但是这个时候协程都退出，则再次构建一个协程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">checkWorker</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.runningWorkers == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(p.chTask) &gt; <span class="number">0</span> &#123;</span><br><span class="line">p.run()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协程池的协程不是常驻协程吗，为什么会出现协程数量为0，但是任务大于0的情况呢？</p><p>答：工作协程可能因为 <code>panic</code> 都退出了，那么这个时候就需要有一个重新拉起协程去执行任务</p><p><strong>第四步</strong>：生产任务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Put</span><span class="params">(task *Task)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">p.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.status == STOPED &#123;</span><br><span class="line"><span class="keyword">return</span> ErrPoolAlreadyClosed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run worker</span></span><br><span class="line"><span class="keyword">if</span> p.GetRunningWorkers() &lt; p.GetCap() &#123;</span><br><span class="line">p.run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// send task</span></span><br><span class="line"><span class="keyword">if</span> p.status == RUNNING &#123;</span><br><span class="line">p.chTask &lt;- task</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么在存放任务的时候，会多一个协程池的判断呢？</p><p>答：可能会出现协程池结束关闭的情况，如果这个时候又有新的任务，那就又会创建新的协程去执行</p><p><strong>最后</strong>：关闭协程池</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Close close pool graceful</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !p.setStatus(STOPED) &#123; <span class="comment">// stop put task</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(p.chTask) &gt; <span class="number">0</span> &#123; <span class="comment">// 等待所有的任务都被消费</span></span><br><span class="line">time.Sleep(<span class="number">1e6</span>) <span class="comment">// 防止等待任务清空 cpu 负载突然变大, 这里小睡一下</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(p.chTask)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ol><li>这里添加了协程池的状态，防止退出时候的任务增加</li><li>为什么在退出的时候，如果任务大于0，那么需要 <code>sleep</code> 一下？</li><li>异常捕获之后再次检查是否有协程在执行任务，没有则添加一个协程</li><li>使用无缓冲<code>channel</code>进行任务执行，可能会出现添加任务阻塞的情况</li><li>任务是否可以添加一个运行超时时间，防止单个任务死锁？</li></ol><h4 id="方案2"><a class="markdownIt-Anchor" href="#方案2"></a> 方案2</h4><p>字节跳动开源的协程池，仓库地址：<a href="https://github.com/bytedance/gopkg/tree/develop/util/gopool" target="_blank" rel="noopener">https://github.com/bytedance/gopkg/tree/develop/util/gopool</a></p><p>使用 <strong>生产者-消费者模式</strong> 设计协程池</p><p><strong>第一步</strong>：**协程池 ** 具有的功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">interface</span> &#123;</span><br><span class="line">Name() <span class="keyword">string</span><span class="comment">//协程池名称</span></span><br><span class="line">SetCap(<span class="built_in">cap</span> <span class="keyword">int32</span>)<span class="comment">//协程池容量</span></span><br><span class="line">Go(f <span class="function"><span class="keyword">func</span><span class="params">()</span>)//使用协程执行 <span class="title">f</span></span></span><br><span class="line">CtxGo(ctx context.Context, f <span class="function"><span class="keyword">func</span><span class="params">()</span>) //使用协程执行<span class="title">f</span>并支持参数 <span class="title">ctx</span></span></span><br><span class="line">SetPanicHandler(f <span class="function"><span class="keyword">func</span><span class="params">(context.Context, <span class="keyword">interface</span>&#123;&#125;)</span>) //设置协程处理函数</span></span><br><span class="line">WorkerCount() <span class="keyword">int32</span><span class="comment">//返回正在运行的协程数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>：协程池的结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pool <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span><span class="comment">//协程池名称</span></span><br><span class="line"><span class="built_in">cap</span> <span class="keyword">int32</span><span class="comment">//协程池容量</span></span><br><span class="line">config *Config<span class="comment">//协程池配置</span></span><br><span class="line">taskHead  *task<span class="comment">//任务头部</span></span><br><span class="line">taskTail  *task<span class="comment">//任务尾部</span></span><br><span class="line">    taskLock  sync.Mutex<span class="comment">//任务原子锁(竞争)</span></span><br><span class="line">taskCount <span class="keyword">int32</span><span class="comment">//任务数量</span></span><br><span class="line">workerCount <span class="keyword">int32</span><span class="comment">//正在运行的协程数量</span></span><br><span class="line">panicHandler <span class="function"><span class="keyword">func</span><span class="params">(context.Context, <span class="keyword">interface</span>&#123;&#125;)</span>//<span class="title">Panic</span>处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>：看看 任务 <code>task</code> 的定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> task <span class="keyword">struct</span> &#123;</span><br><span class="line">ctx context.Context</span><br><span class="line">f   <span class="function"><span class="keyword">func</span><span class="params">()</span>//执行函数</span></span><br><span class="line"></span><br><span class="line">next *task<span class="comment">//指向下一个任务的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> taskList <span class="keyword">struct</span> &#123;     <span class="comment">//使用双向链表将任务连接起来</span></span><br><span class="line">sync.Mutex</span><br><span class="line">taskHead *task</span><br><span class="line">taskTail *task</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>：查看协程池是怎么运行的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> taskPool sync.Pool <span class="comment">//对象池</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pool)</span> <span class="title">CtxGo</span><span class="params">(ctx context.Context, f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">t := taskPool.Get().(*task)<span class="comment">//从对象池获取任务对象</span></span><br><span class="line">t.ctx = ctx</span><br><span class="line">t.f = f</span><br><span class="line">p.taskLock.Lock()<span class="comment">//获取任务写锁</span></span><br><span class="line"><span class="keyword">if</span> p.taskHead == <span class="literal">nil</span> &#123;      <span class="comment">//如果任务链表为空则新建，否则插入链表尾部</span></span><br><span class="line">p.taskHead = t</span><br><span class="line">p.taskTail = t</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p.taskTail.next = t</span><br><span class="line">p.taskTail = t</span><br><span class="line">&#125;</span><br><span class="line">p.taskLock.Unlock()<span class="comment">//释放任务写锁</span></span><br><span class="line">atomic.AddInt32(&amp;p.taskCount, <span class="number">1</span>) <span class="comment">//增加任务数量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 如果任务数量大于配置的数量 &amp;&amp; 正在执行的协程数量小于协程池容量，说明任务太多，还有空闲的协程</span></span><br><span class="line"><span class="comment">     那么就开启一个新的协程处理</span></span><br><span class="line"><span class="comment">       如果任务数量小于配置的数量 &amp;&amp; 正在执行的协程数量小于协程池容量。说明任务还不多，就让当前协程顺序执行</span></span><br><span class="line"><span class="comment">    2. 正在执行的协程为0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">if</span> (atomic.LoadInt32(&amp;p.taskCount) &gt;= p.config.ScaleThreshold &amp;&amp; p.WorkerCount() &lt; atomic.LoadInt32(&amp;p.<span class="built_in">cap</span>)) || p.WorkerCount() == <span class="number">0</span> &#123;</span><br><span class="line">p.incWorkerCount()   </span><br><span class="line">w := workerPool.Get().(*worker)</span><br><span class="line">w.pool = p</span><br><span class="line">w.run()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里额外定义了一个 <code>workPool</code>，其实是消费者池</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> workerPool sync.Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> worker <span class="keyword">struct</span> &#123;<span class="comment">//消费者其实是一个协程池</span></span><br><span class="line">pool *pool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123; <span class="comment">//这是一个常驻协程</span></span><br><span class="line"><span class="keyword">var</span> t *task</span><br><span class="line">w.pool.taskLock.Lock()   <span class="comment">//获取任务写锁</span></span><br><span class="line"><span class="keyword">if</span> w.pool.taskHead != <span class="literal">nil</span> &#123; <span class="comment">//获取任务并将任务数量-1</span></span><br><span class="line">t = w.pool.taskHead</span><br><span class="line">w.pool.taskHead = w.pool.taskHead.next</span><br><span class="line">atomic.AddInt32(&amp;w.pool.taskCount, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;<span class="comment">//如果没有任务，那么worker销毁</span></span><br><span class="line"><span class="comment">// if there's no task to do, exit</span></span><br><span class="line">w.<span class="built_in">close</span>()</span><br><span class="line">w.pool.taskLock.Unlock()</span><br><span class="line">w.Recycle()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">w.pool.taskLock.Unlock() <span class="comment">//释放任务写锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;<span class="comment">//异常处理</span></span><br><span class="line"><span class="keyword">if</span> w.pool.panicHandler != <span class="literal">nil</span> &#123;</span><br><span class="line">w.pool.panicHandler(t.ctx, r)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">msg := fmt.Sprintf(<span class="string">"GOPOOL: panic in pool: %s: %v: %s"</span>, w.pool.name, r, debug.Stack())</span><br><span class="line">logger.CtxErrorf(t.ctx, msg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">t.f()<span class="comment">//执行任务 f</span></span><br><span class="line">&#125;()</span><br><span class="line">t.Recycle()<span class="comment">//任务结束后，会收work</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span> <span class="title">close</span><span class="params">()</span></span> &#123;<span class="comment">//减少worker数目</span></span><br><span class="line">w.pool.decWorkerCount()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span> <span class="title">zero</span><span class="params">()</span></span> &#123; <span class="comment">//释放缓存池</span></span><br><span class="line">w.pool = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span> <span class="title">Recycle</span><span class="params">()</span></span> &#123;<span class="comment">//释放worker(存入缓存池)</span></span><br><span class="line">w.zero()</span><br><span class="line">workerPool.Put(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，它还定义了一个 <code>poolMap</code> 用于根据名称注册与使用 多个协程池</p><p><strong>注意</strong>：</p><ol><li>使用双向链表存储任务，表示它理论上支持无限个任务。后面的任务可能存在长时间等待的情况</li><li>使用任务上限的好处是，不是每来一个任务都开启一个协程，而是任务超过一定数量而又空闲的协程才开启新的协程去执行</li></ol><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><p><code>go-zero</code>是如何实现协程池的，代码路径：<code>core/threading</code></p><p><strong>第一步</strong>，定义了<code>recover</code>逻辑，用于 <code>panic</code> 之后的清理操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/rescue/recover.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Recover</span><span class="params">(cleanups ...<span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, cleanup := <span class="keyword">range</span> cleanups &#123;</span><br><span class="line">cleanup()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//logx.ErrorStack(p)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，定义了一个安全运行<code>goroutine</code>的方案 <code>GoSafe</code>，包含处理<code>panic</code>逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GoSafe</span><span class="params">(fn <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="keyword">go</span> RunSafe(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RunSafe</span><span class="params">(fn <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> rescue.Recover()</span><br><span class="line"></span><br><span class="line">fn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TaskRunner</code>： 使用 <code>limitChan</code> 协程池 执行协程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TaskRunner 用于并发控制协程数量</span></span><br><span class="line"><span class="keyword">type</span> TaskRunner <span class="keyword">struct</span> &#123;</span><br><span class="line">limitChan <span class="keyword">chan</span> lang.PlaceholderType</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 TaskRunner 对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTaskRunner</span><span class="params">(concurrency <span class="keyword">int</span>)</span> *<span class="title">TaskRunner</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;TaskRunner&#123;</span><br><span class="line">limitChan: <span class="built_in">make</span>(<span class="keyword">chan</span> lang.PlaceholderType, concurrency),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 任务并发控制下执行 task</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rp *TaskRunner)</span> <span class="title">Schedule</span><span class="params">(task <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">  rp.limitChan &lt;- lang.Placeholder<span class="comment">//limitChan 类似一个并发锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> rescue.Recover(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">&lt;-rp.limitChan</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">task()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：当<code>limitChan</code>满那么任务执行会出现超时，缺乏超时逻辑</p><p><code>WorkerGroup</code>：使用 <code>wokers</code> 并发执行任务 <code>job</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WorkerGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">job     <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">workers <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewWorkerGroup returns a WorkerGroup with given job and workers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorkerGroup</span><span class="params">(job <span class="keyword">func</span>()</span>, <span class="title">workers</span> <span class="title">int</span>) <span class="title">WorkerGroup</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> WorkerGroup&#123;</span><br><span class="line">job:     job,</span><br><span class="line">workers: workers,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start starts a WorkerGroup.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg WorkerGroup)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">group := NewRoutineGroup()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; wg.workers; i++ &#123;</span><br><span class="line">group.RunSafe(wg.job)</span><br><span class="line">&#125;</span><br><span class="line">group.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RoutineGroup</code>: 多协程等待</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RoutineGroup 多协程等待</span></span><br><span class="line"><span class="keyword">type</span> RoutineGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">waitGroup sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRoutineGroup</span><span class="params">()</span> *<span class="title">RoutineGroup</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">new</span>(RoutineGroup)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要引用外部参数，可能被其他协程修改</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *RoutineGroup)</span> <span class="title">Run</span><span class="params">(fn <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">g.waitGroup.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> g.waitGroup.Done()</span><br><span class="line">fn()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不要引用外部参数，可能被其他协程修改</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *RoutineGroup)</span> <span class="title">RunSafe</span><span class="params">(fn <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">g.waitGroup.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">GoSafe(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> g.waitGroup.Done()</span><br><span class="line">fn()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待所有协程结束</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *RoutineGroup)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">g.waitGroup.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 go-zero的<code>threading</code> 并不是真正的协程池，仅仅是提供多种并发执行 <code>goroutine</code>的方法</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>所以从目前来看，实现一个协程池都有哪些值得学习的地方呢？</p><ol><li>将需要使用临时协程执行的函数已任务的形式 <code>任务 -- 协程池(Pool) -- 工人</code>执行</li><li>协程池是有容量限制的，有了容量就有正在运行的协程数</li><li>协程池有状态防止在退出的时候仍然进行任务构建与执行</li><li>协程池有异常捕获机制，保证单个异常不会影响整个协程池</li><li>任务已任务合集的形式存在，让消费者并发消费</li><li>有了异常捕获与任务合集，为了防止工人都发生异常，而还有任务没有执行，则需要有工人唤起机制</li><li>可以使用本地缓存池进行工人的重复利用</li><li>任务合集缓隧道还是双链表、每个任务都构建一个协程还是单个任务多任务执行的选择</li></ol><p>下一节，将学习另外一个协程池 ants 的实现方式</p><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://go-zero.dev/cn/docs/goctl/installation/" target="_blank" rel="noopener">https://go-zero.dev/cn/docs/goctl/installation/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题背景&quot;&gt;&lt;/a&gt; 问题背景&lt;/h3&gt;
&lt;p&gt;需要协程池吗？&lt;/p&gt;
&lt;p&gt;虽然协程非常轻量级的，一般用不上协程池。协程池的作用 无休止地创建大量goroutine，势必会因为对
      
    
    </summary>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/categories/go-zero/"/>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>go-zero3-MapReduce</title>
    <link href="http://xboom.github.io/2022/07/03/GoZero/GoZero3-MapReduce/"/>
    <id>http://xboom.github.io/2022/07/03/GoZero/GoZero3-MapReduce/</id>
    <published>2022-07-03T08:37:40.000Z</published>
    <updated>2022-07-03T08:41:55.313Z</updated>
    
    <content type="html"><![CDATA[<p>什么是<code>MapReduce</code>?</p><p><code>MapReduce</code>是Google提出了一个软件架构，用于大规模数据集的并行运算。</p><p><code>MapReduce</code>通过把对数据集的大规模操作分发给网络上的每个节点实现可靠性；每个节点会周期性的把完成的工作和状态的更新报告回来。如果一个节点保持沉默超过一个预设的时间间隔，主节点记录下这个节点状态为死亡，并把分配给这个节点的数据发到别的节点。</p><p><code>go-zero</code>的<code>MapReduce</code>则借鉴其中的思想，接下来一起看下<code>go-zero</code>是如何应用这一思想的</p><h3 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h3><p>在微服务中开发中，如果多个服务串行依赖的话那么整个<code>API</code>的耗时将会大大增加。通过什么手段来优化？</p><ol><li>传输层面通过<code>MQ</code>的解耦特性来降低<code>API</code>的耗时<ul><li><code>MQ</code>通信效率没有<code>grpc</code>高(消息通过<code>MQ</code>服务器进行中转)</li></ul></li><li>业务层面通过Go语言的<code>WaitGroup</code>工具来进行并发控制<ul><li>自行封装<code>Add</code>与<code>Done</code></li></ul></li></ol><p>实际业务场景中：</p><ul><li>如果接口的多个依赖有一个出错，则期望能立即返回且不必等待所有依赖都执行完毕。已经完成的接口调用也应该回滚</li><li>多个依赖可能有部分依赖之间也存在着相互依赖，或者上下关系</li></ul><p>go-zero的主要应用场景为：需要从不同的<code>rpc</code>服务中获取相应属性组装成复杂对象，比如要查询商品详情：</p><ol><li>商品服务-查询商品属性</li><li>库存服务-查询库存属性</li><li>价格服务-查询价格属性</li><li>营销服务-查询营销属性</li></ol><p>如果是串行调用的话响应时间会随着 <code>rpc</code> 调用次数呈线性增长，简单场景下使用 <code>WaitGroup</code> 也能够满足需求，但如果要对 <code>rpc</code> 调用返回的数据进行校验、数据加工转换、数据汇总呢？</p><p><code>go-zero</code>通过<code>mapreduce</code>来处理这种对输入数据进行处理最后输出清洗数据的问题。是一种经典的模式：<strong>生产者消费者模式</strong>。将数据处理分为三个阶段：</p><ol><li>数据生产 generate(查询，必选)</li><li>数据加工 mapper(加工，可选)</li><li>数据聚合 reducer(聚合，可选)</li></ol><p>利用协程处理以及管道通信，实现数据的加速处理</p><h3 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h3><h4 id="场景1"><a class="markdownIt-Anchor" href="#场景1"></a> 场景1</h4><p>对数据批处理，比如对一批用户id，效验每个用户的合法性并且效验过程中有一个出错就认为效验失败，返回的结果为效验合法的用户id</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mapreduce</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/zeromicro/go-zero/core/mr"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(uids []<span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">r, err := mr.MapReduce(<span class="function"><span class="keyword">func</span><span class="params">(source <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, uid := <span class="keyword">range</span> uids &#123;</span><br><span class="line">source &lt;- uid</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;, writer mr.Writer, cancel <span class="keyword">func</span>(error)</span>)</span> &#123;</span><br><span class="line">uid := item.(<span class="keyword">int</span>)</span><br><span class="line">ok, err := check(uid)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;<span class="comment">//如果校验逻辑有问题，这里执行cancel整个校验过程停止</span></span><br><span class="line">cancel(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ok &#123;<span class="comment">//如果校验失败，那么不返回该uid</span></span><br><span class="line">writer.Write(uid)</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(pipe &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, writer mr.Writer, cancel <span class="keyword">func</span>(error)</span>)</span> &#123;</span><br><span class="line"><span class="keyword">var</span> uids []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> p := <span class="keyword">range</span> pipe &#123;</span><br><span class="line">uids = <span class="built_in">append</span>(uids, p.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line">writer.Write(uids)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"check error: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r.([]<span class="keyword">int</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// do something check user legal</span></span><br><span class="line"><span class="keyword">if</span> uid == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, errors.New(<span class="string">"uid wrong"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实是利用N个协程等待数据生产者的数据传输然后转交给聚合逻辑处理</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/mapReduce-1.png" alt="mapReduce-1" /></p><h4 id="场景2"><a class="markdownIt-Anchor" href="#场景2"></a> 场景2</h4><p>某些功能的结果往往需要依赖多个服务，比如商品详情的结果往往会依赖用户服务、库存服务、订单服务等等，一般被依赖的服务都是以rpc的形式对外提供，为了降低依赖的耗时我们往往需要对依赖做并行处理</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productDetail</span><span class="params">(uid, pid <span class="keyword">int64</span>)</span> <span class="params">(*ProductDetail, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> pd ProductDetail</span><br><span class="line">err := mr.Finish(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">pd.User, err = userRpc.User(uid)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">pd.Store, err = storeRpc.Store(pid)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">pd.Order, err = orderRpc.Order(pid)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"product detail error: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;pd, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><p>源码目录：<code>core/mr/mapreduce.go</code></p><p>其中利用到的对外函数有</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MapReduce 包含数据生产、数据处理以及数据聚合阶段并返回结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapReduce</span><span class="params">(generate GenerateFunc, mapper MapperFunc, reducer ReducerFunc,</span></span></span><br><span class="line"><span class="function"><span class="params">               opts ...Option)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MapReduceChan 包含数据生产、数据处理以及数据聚合阶段并返回结果。其中利用chan代替数据生产</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapReduceChan</span><span class="params">(source &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, mapper MapperFunc, reducer ReducerFunc,</span></span></span><br><span class="line"><span class="function"><span class="params">opts ...Option)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">panicChan := &amp;onceChan&#123;channel: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)&#125;</span><br><span class="line"><span class="keyword">return</span> mapReduceWithPanicChan(source, panicChan, mapper, reducer, opts...)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// ForEach 只包含数据生产和数据处理阶段，但没有任何输出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ForEach</span><span class="params">(generate GenerateFunc, mapper ForEachFunc, opts ...Option)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FinishVoid 并行运行 fns</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FinishVoid</span><span class="params">(fns ...<span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Finish 并行运行 fns，在任何错误时取消</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Finish</span><span class="params">(fns ...<span class="keyword">func</span>()</span> <span class="title">error</span>) <span class="title">error</span></span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//WithWorkers 定义一个 mapreduce 有几个协程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithWorkers</span><span class="params">(workers <span class="keyword">int</span>)</span> <span class="title">Option</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="数据生产阶段"><a class="markdownIt-Anchor" href="#数据生产阶段"></a> 数据生产阶段</h4><p>首先定义 <code>buildSource</code>使用协程进行数据生产</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//buildSource 使用协程执行generate 并将协程的参数一个非缓冲的channel返回。如果generate发生panic，则将错误写入 onceChan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildSource</span><span class="params">(generate GenerateFunc, panicChan *onceChan)</span> <span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">source := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">panicChan.write(r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(source)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">generate(source) <span class="comment">//返回的非缓冲隧道也是数据生产的入口</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> source</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 <code>onceChan</code>则是一个非阻塞会缓冲的channel，当channel中还有数据没有处理完，则直接返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> onceChan <span class="keyword">struct</span> &#123;</span><br><span class="line">channel <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">wrote   <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(oc *onceChan)</span> <span class="title">write</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.AddInt32(&amp;oc.wrote, <span class="number">1</span>) &gt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">oc.channel &lt;- val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据处理阶段"><a class="markdownIt-Anchor" href="#数据处理阶段"></a> 数据处理阶段</h4><p>接着利用<code>mapReduceWithPanicChan</code>进行数据处理<code>mapper</code>和数据聚合<code>reducer</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapReduce</span><span class="params">(generate GenerateFunc, mapper MapperFunc, reducer ReducerFunc,</span></span></span><br><span class="line"><span class="function"><span class="params">opts ...Option)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">panicChan := &amp;onceChan&#123;channel: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)&#125;</span><br><span class="line">source := buildSource(generate, panicChan) <span class="comment">//使用协程执行generate并返回数据生产无缓冲隧道source</span></span><br><span class="line"><span class="keyword">return</span> mapReduceWithPanicChan(source, panicChan, mapper, reducer, opts...) <span class="comment">//将隧道和处理函数传入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//source就是数据来源隧道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapReduceWithPanicChan</span><span class="params">(source &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, panicChan *onceChan, mapper MapperFunc,</span></span></span><br><span class="line"><span class="function"><span class="params">reducer ReducerFunc, opts ...Option)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">options := buildOptions(opts...)</span><br><span class="line"><span class="comment">// output is used to write the final result</span></span><br><span class="line">output := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="comment">//...defer</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//collector 用于从mapper收集数据，消费者是数据聚合</span></span><br><span class="line">collector := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, options.workers)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//done表示结束，所有的mappers和reducer都要结束</span></span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> lang.PlaceholderType)</span><br><span class="line">writer := newGuardedWriter(options.ctx, output, done)</span><br><span class="line"><span class="keyword">var</span> closeOnce sync.Once</span><br><span class="line"><span class="comment">// use atomic.Value to avoid data race</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="comment">//起一个协程进行 数据聚合</span></span><br><span class="line">    <span class="comment">//panic.wirte()</span></span><br><span class="line">reducer(collector, writer, cancel)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> executeMappers(mapperContext&#123; <span class="comment">//进行 数据处理</span></span><br><span class="line">ctx: options.ctx,</span><br><span class="line">mapper: <span class="function"><span class="keyword">func</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;, w Writer)</span></span> &#123;</span><br><span class="line">mapper(item, w, cancel)</span><br><span class="line">&#125;,</span><br><span class="line">source:    source,</span><br><span class="line">panicChan: panicChan,</span><br><span class="line">collector: collector,</span><br><span class="line">doneChan:  done,</span><br><span class="line">workers:   options.workers,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123; <span class="comment">//等待结果</span></span><br><span class="line"><span class="keyword">case</span> &lt;-options.ctx.Done():</span><br><span class="line">cancel(context.DeadlineExceeded)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, context.DeadlineExceeded</span><br><span class="line"><span class="keyword">case</span> v := &lt;-panicChan.channel:</span><br><span class="line"><span class="built_in">panic</span>(v)</span><br><span class="line"><span class="keyword">case</span> v, ok := &lt;-output:</span><br><span class="line"><span class="keyword">if</span> err := retErr.Load(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrReduceNoOutput</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中数据处理阶段又定义了一个协程进行处理</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">executeMappers</span><span class="params">(mCtx mapperContext)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="built_in">close</span>(mCtx.collector)</span><br><span class="line">drain(mCtx.source)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> failed <span class="keyword">int32</span></span><br><span class="line">pool := <span class="built_in">make</span>(<span class="keyword">chan</span> lang.PlaceholderType, mCtx.workers) <span class="comment">//协程池</span></span><br><span class="line">writer := newGuardedWriter(mCtx.ctx, mCtx.collector, mCtx.doneChan)</span><br><span class="line"><span class="keyword">for</span> atomic.LoadInt32(&amp;failed) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-mCtx.ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-mCtx.doneChan:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> pool &lt;- lang.Placeholder:<span class="comment">//这里是定义的N个works的chan，也就是会在下面创建n个协程</span></span><br><span class="line">item, ok := &lt;-mCtx.source</span><br><span class="line"><span class="keyword">if</span> !ok &#123; <span class="comment">//如果来源关闭，那么将pool数据释放</span></span><br><span class="line">&lt;-pool</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">atomic.AddInt32(&amp;failed, <span class="number">1</span>)</span><br><span class="line">mCtx.panicChan.write(r)</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&lt;-pool</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//item:生产的数据</span></span><br><span class="line">        <span class="comment">//writer: 数据处理对象</span></span><br><span class="line">mCtx.mapper(item, writer) <span class="comment">//执行map</span></span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据聚合阶段"><a class="markdownIt-Anchor" href="#数据聚合阶段"></a> 数据聚合阶段</h4><p>最后来看一下是数据处理</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> guardedWriter <span class="keyword">struct</span> &#123;<span class="comment">//写入接口</span></span><br><span class="line">ctx     context.Context<span class="comment">//保证超时退出</span></span><br><span class="line">channel <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;<span class="comment">//接收数据，这里传输的就是 长度为 N 的 collect channel</span></span><br><span class="line">done    &lt;-<span class="keyword">chan</span> lang.PlaceholderType<span class="comment">//主动结束退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newGuardedWriter</span><span class="params">(ctx context.Context, channel <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">done &lt;-<span class="keyword">chan</span> lang.PlaceholderType)</span> <span class="title">guardedWriter</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> guardedWriter&#123;</span><br><span class="line">ctx:     ctx,</span><br><span class="line">channel: channel,</span><br><span class="line">done:    done,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="finish"><a class="markdownIt-Anchor" href="#finish"></a> Finish</h4><p><code>Finish</code>逻辑只进行并发处理，其实内部是将执行函数做为数据生产的生产的数据，然后又数据处理逻辑进行处理</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/mapreduce_finish.png" alt="mapreduce_finish" /></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Finish</span><span class="params">(fns ...<span class="keyword">func</span>()</span> <span class="title">error</span>) <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(fns) == <span class="number">0</span> &#123;<span class="comment">//n个外部调用</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> MapReduceVoid(<span class="function"><span class="keyword">func</span><span class="params">(source <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, fn := <span class="keyword">range</span> fns &#123;</span><br><span class="line">source &lt;- fn<span class="comment">//数据生产者将函数传入</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;, writer Writer, cancel <span class="keyword">func</span>(error)</span>)</span> &#123;</span><br><span class="line">fn := item.(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span>)</span></span><br><span class="line"><span class="keyword">if</span> err := fn(); err != <span class="literal">nil</span> &#123;<span class="comment">//数据处理逻辑执行函数</span></span><br><span class="line">cancel(err)<span class="comment">//这里并没有写入，所以第三个函数其实并没有执行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(pipe &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, cancel <span class="keyword">func</span>(error)</span>)</span> &#123;</span><br><span class="line">&#125;, WithWorkers(<span class="built_in">len</span>(fns)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//底层还是执行的MapReduce逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapReduceVoid</span><span class="params">(generate GenerateFunc, mapper MapperFunc, reducer VoidReducerFunc, opts ...Option)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">_, err := MapReduce(generate, mapper, <span class="function"><span class="keyword">func</span><span class="params">(input &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, writer Writer, cancel <span class="keyword">func</span>(error)</span>)</span> &#123;</span><br><span class="line">reducer(input, cancel)</span><br><span class="line">&#125;, opts...)</span><br><span class="line"><span class="keyword">if</span> errors.Is(err, ErrReduceNoOutput) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3><ol><li>适用于并发无顺序依赖的并发调用，如果是多个调用具有前后依赖关系，依然需要有先后调用顺序(废话)</li><li>也不存在回滚的操作，内部只是将不在等待处理结果直接退出 <code>select</code></li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://talkgo.org/t/topic/1452" target="_blank" rel="noopener">https://talkgo.org/t/topic/1452</a></li><li><a href="https://zh.wikipedia.org/wiki/MapReduce" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/MapReduce</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;什么是&lt;code&gt;MapReduce&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MapReduce&lt;/code&gt;是Google提出了一个软件架构，用于大规模数据集的并行运算。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MapReduce&lt;/code&gt;通过把对数据集的大规模操作分发给网络上的
      
    
    </summary>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/categories/go-zero/"/>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>有趣的算法-老鼠毒药问题</title>
    <link href="http://xboom.github.io/2022/07/02/Interesting%20Algorithm/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%AE%97%E6%B3%95-%E8%80%81%E9%BC%A0%E6%AF%92%E8%8D%AF/"/>
    <id>http://xboom.github.io/2022/07/02/Interesting%20Algorithm/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%AE%97%E6%B3%95-%E8%80%81%E9%BC%A0%E6%AF%92%E8%8D%AF/</id>
    <published>2022-07-02T11:08:45.303Z</published>
    <updated>2022-07-21T02:00:35.046Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h3><p>有 1000 个一模一样的瓶子，其中有 999 瓶是普通的水，有一瓶是毒药。任何喝下毒药的生物都会在一星期之后死亡。现在，你只有 10 只小白鼠和一星期的时间，如何检验出哪个瓶子里有毒药？</p><h3 id="问题分析"><a class="markdownIt-Anchor" href="#问题分析"></a> 问题分析</h3><p>这个题目需要面对几个问题</p><ol><li>因为毒药会在一个星期后生效，而只有一星期的时间，那么只能让老鼠多喝几瓶最后根据老鼠中毒情况判断出哪一瓶有毒</li><li>要喝完这一千瓶，那么每只老鼠要喝很多，如果老鼠们喝的不交叉，那么即使老鼠中毒，也无法区分它喝的哪一瓶有毒</li><li>如果它们喝的有交叉，就需要每一瓶都存在部分老鼠喝了部分老鼠没有喝，且每一瓶喝与不喝的老鼠都不一样</li></ol><p>使用二进制思想(当时就是没想到)</p><p>10个老鼠相当于10位的二进制位，可以表达的最大数量为1024</p><table><thead><tr><th>老鼠</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>如果给瓶子从1开始编号到1000，那么根据数字的二进制位，如果位数上是1的对应的老鼠就要喝掉这一瓶。根据老鼠的生存情况，就可以推断出哪一瓶有毒，假如：500是有毒的，那么它的二进制为 <code>0111110100</code>那么，</p><table><thead><tr><th>老鼠</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>500</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>508</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>510</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>512</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>也就是说：第2、3、4、5、6、8只老鼠会死掉。而喝了508，510、512的老鼠都没有事情</p><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://blog.csdn.net/qq_43827595/article/details/104154716" target="_blank" rel="noopener">https://blog.csdn.net/qq_43827595/article/details/104154716</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题描述&quot;&gt;&lt;/a&gt; 问题描述&lt;/h3&gt;
&lt;p&gt;有 1000 个一模一样的瓶子，其中有 999 瓶是普通的水，有一瓶是毒药。任何喝下毒药的生物都会在一星期之后死亡。现在，你只有 1
      
    
    </summary>
    
    
      <category term="Interesting Algorithm" scheme="http://xboom.github.io/categories/Interesting-Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://xboom.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>有趣的算法-赛马问题</title>
    <link href="http://xboom.github.io/2022/07/02/Interesting%20Algorithm/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%AE%97%E6%B3%95-%E8%B5%9B%E9%A9%AC%E9%97%AE%E9%A2%98/"/>
    <id>http://xboom.github.io/2022/07/02/Interesting%20Algorithm/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%AE%97%E6%B3%95-%E8%B5%9B%E9%A9%AC%E9%97%AE%E9%A2%98/</id>
    <published>2022-07-02T11:08:45.303Z</published>
    <updated>2022-07-09T12:06:06.092Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h3><p>64匹马，8个跑道，问最少比赛多少场，可以选出跑得最快的4匹马。每场比赛每个跑道只允许一匹马，且不存在并列情形</p><h3 id="问题分析"><a class="markdownIt-Anchor" href="#问题分析"></a> 问题分析</h3><p><strong>第一步</strong>：先让马儿跑起来，首先将马儿分批次赛跑，一共需要进行8次赛跑。假设结果如下：</p><table><thead><tr><th>分组</th><th>第一名</th><th>第二名</th><th>第三名</th><th>第四名</th><th>第五名</th><th>第六名</th><th>第七名</th><th>第八名</th></tr></thead><tbody><tr><td>A</td><td>A1</td><td>A2</td><td>A3</td><td>A4</td><td><s>A5</s></td><td><s>A6</s></td><td><s>A7</s></td><td><s>A8</s></td></tr><tr><td>B</td><td>B1</td><td>B2</td><td>B3</td><td>B4</td><td><s>B5</s></td><td><s>B6</s></td><td><s>B7</s></td><td><s>B8</s></td></tr><tr><td>C</td><td>C1</td><td>C2</td><td>C3</td><td>C4</td><td><s>C5</s></td><td><s>C6</s></td><td><s>C7</s></td><td><s>C8</s></td></tr><tr><td>D</td><td>D1</td><td>D2</td><td>D3</td><td>D4</td><td><s>D5</s></td><td><s>D6</s></td><td><s>D7</s></td><td><s>D8</s></td></tr><tr><td>E</td><td>E1</td><td>E2</td><td>E3</td><td>E4</td><td><s>E5</s></td><td><s>E6</s></td><td><s>E7</s></td><td><s>E8</s></td></tr><tr><td>F</td><td>F1</td><td>F2</td><td>F3</td><td>F4</td><td><s>F5</s></td><td><s>F6</s></td><td><s>F7</s></td><td><s>F8</s></td></tr><tr><td>G</td><td>G1</td><td>G2</td><td>G3</td><td>G4</td><td><s>G5</s></td><td><s>G6</s></td><td><s>G7</s></td><td><s>G8</s></td></tr><tr><td>H</td><td>H1</td><td>H2</td><td>H3</td><td>H4</td><td><s>H5</s></td><td><s>H6</s></td><td><s>H7</s></td><td><s>H8</s></td></tr></tbody></table><p>可直接排除各组最后四名赛马，剩余<code>64-4*8=32</code>匹赛马待定</p><p><strong>第二步</strong>：将每一组中的第一名进行赛跑(如果每一组选多个参加赛马，那样就存在重复比赛)，需要进行1次赛跑。假设结果如下：</p><table><thead><tr><th>分组</th><th>第一名</th><th>第二名</th><th>第三名</th><th>第四名</th><th>第五名</th><th>第六名</th><th>第七名</th><th>第八名</th></tr></thead><tbody><tr><td>1</td><td><strong>A1</strong></td><td>B1</td><td>C1</td><td>D1</td><td><s>E1</s></td><td><s>F1</s></td><td><s>G1</s></td><td><s>H2</s></td></tr></tbody></table><p>可直接排除各组最后四名赛马，也就是后四组全部淘汰，剩余 <code>32 - 4 * 4 = 16</code>，其中第一名已经知道就是<code>A1</code></p><p>需要注意的是：这里还可以继续排除</p><ol><li>因为在头名争夺中 <code>D1</code>只能排第四，所以<code>D1</code>最快也是第四，D组剩余被淘汰</li><li>同理C组最多只有2名在前4</li><li>同理B组最多只有1名在前4</li></ol><table><thead><tr><th>分组</th><th>第一名</th><th>第二名</th><th>第三名</th><th>第四名</th></tr></thead><tbody><tr><td>A</td><td><strong>A1</strong></td><td>A2</td><td>A3</td><td>A4</td></tr><tr><td>B</td><td>B1</td><td>B2</td><td>B3</td><td><s>B4</s></td></tr><tr><td>C</td><td>C1</td><td>C2</td><td><s>C3</s></td><td><s>C4</s></td></tr><tr><td>D</td><td>D1</td><td><s>D2</s></td><td><s>D3</s></td><td><s>D4</s></td></tr></tbody></table><p>所以剩余需要确认的数量为 16 - 1 - 3 - 2 - 1 = 9。</p><p><strong>第三步</strong>：剩余的9匹赛马中需要选出8匹马再次进行一次赛马</p><p>这里是否有一匹特殊的马，不需要参与赛跑进行这一次赛马就能得出结果？</p><ol><li>排除A组中的3匹马中的一匹，那么除非B1都输或者都赢，否则B1以及后面的排名不确定。也就是排除前面的对后面影响较大</li><li>排除D1/C2，那么可能无法确认D1与C2谁是第四</li><li>排除C1与排除其他一样，可能无法确认自己和它身后的排名</li></ol><p>所以，这里最好从D1与C2中排除一个进行赛跑，如果这一轮得出结果，那么就不用跑。如果没有得出结论就再跑一次</p><p>因为所有赛马的第一名已经确认是第一，所以剩下的比赛就是确认 <code>2 - 4</code> 名次，C1要是所有赛马的前四名，这次必须跑入前三。</p><p>第一种可能：C1第三名或者第三名之后，那么比赛结束，一共经过了 <code>8 + 1 + 1 = 10</code> 赛出前四名</p><p>第二种可能：C1排在第二名，也就是说 C2 和 D1 无法确认谁是第四个，那么就需要加赛一场。排除前三，剩余的马再比一场。一共经过了 <code>8 + 1 + 1 + 1 = 11</code></p><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/103572219" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/103572219</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题描述&quot;&gt;&lt;/a&gt; 问题描述&lt;/h3&gt;
&lt;p&gt;64匹马，8个跑道，问最少比赛多少场，可以选出跑得最快的4匹马。每场比赛每个跑道只允许一匹马，且不存在并列情形&lt;/p&gt;
&lt;h3 id
      
    
    </summary>
    
    
      <category term="Interesting Algorithm" scheme="http://xboom.github.io/categories/Interesting-Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://xboom.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>go-zero2-共享调用</title>
    <link href="http://xboom.github.io/2022/06/28/GoZero/GoZero2-%E5%85%B1%E4%BA%AB%E8%B0%83%E7%94%A8/"/>
    <id>http://xboom.github.io/2022/06/28/GoZero/GoZero2-%E5%85%B1%E4%BA%AB%E8%B0%83%E7%94%A8/</id>
    <published>2022-06-27T16:55:17.000Z</published>
    <updated>2022-07-02T14:45:14.537Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h3><p>并发场景下，可能会有多个线程（协程）同时请求同一份资源，如果每个请求都要走一遍资源的请求过程，除了比较低效之外，还会对资源服务造成并发的压力。</p><p>例如：</p><ol><li>缓存失效的同时多个请求同时到达某服务请求相同资源，这些请求会继续访问DB做查询，会引起数据库压力瞬间增大。而使用 <code>SharedCalls</code> 可以使得同时多个请求只需要发起一次拿结果的调用，其他请求&quot;坐享其成&quot;。有效减少了资源服务的并发压力，可以有效防止缓存击穿</li><li>云平台服务众多，使用<code>grpc</code>通信的时候不期望每个服务之间都建立链接，而只在向对端发送消息的时候，才在服务之间建立通信。老的逻辑是当开始建立连接的时候会将创建改为正在创建链接，后续消息会因为正在建立链接会直接返回错误或阻塞等待结果(自行实现)，而使用<code>SharedCalls</code>可以短时间内等待链接建立然后继续发送消息</li></ol><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/sharecalls.png" alt="sharecalls" /></p><h3 id="演示代码"><a class="markdownIt-Anchor" href="#演示代码"></a> 演示代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> round = <span class="number">5</span></span><br><span class="line">  var wg sync.WaitGroup</span><br><span class="line">  barrier := syncx.NewSharedCalls()</span><br><span class="line"></span><br><span class="line">  wg.Add(round)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; round; i++ &#123;</span><br><span class="line">    <span class="comment">// 多个线程同时执行</span></span><br><span class="line">    <span class="function">go <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      defer wg.Done()</span><br><span class="line">      <span class="comment">// 可以看到，多个线程在同一个 key 上去请求资源，获取资源的实际函数只会被调用一次</span></span><br><span class="line">      val, err := barrier.Do(<span class="string">"once"</span>, func() (interface&#123;&#125;, error) &#123;</span><br><span class="line">        <span class="comment">// sleep 1秒，为了让多个线程同时取 once 这个 key 上的数据</span></span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        <span class="comment">// 生成了一个随机的 id</span></span><br><span class="line">        <span class="keyword">return</span> stringx.RandId(), nil</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><p>文件目录：<code>core/syncx/singleflight.go</code></p><p><code>SingleFlight</code> 通过为并发的请求根据相同的key提供相同的结果</p><p>一共提供了 <code>Do</code> 与 <code>DoEx</code> 两种接口</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SingleFlight <span class="keyword">interface</span> &#123;</span><br><span class="line">   Do(key <span class="keyword">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span></span><br><span class="line">   DoEx(key <span class="keyword">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>, error)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> call <span class="keyword">struct</span> &#123;<span class="comment">//代指一次调用</span></span><br><span class="line">wg  sync.WaitGroup  <span class="comment">//用于等待call结束</span></span><br><span class="line">val <span class="keyword">interface</span>&#123;&#125;     </span><br><span class="line">err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flightGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">calls <span class="keyword">map</span>[<span class="keyword">string</span>]*call</span><br><span class="line">lock  sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先查看两个基础函数</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *flightGroup)</span> <span class="title">createCall</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(c *call, done <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 先申请加锁</span></span><br><span class="line">  g.lock.Lock()</span><br><span class="line"><span class="keyword">if</span> c, ok := g.calls[key]; ok &#123;<span class="comment">//如果key存在，那么等待</span></span><br><span class="line"><span class="comment">// 拿到 call 以后，释放锁，此处 call 可能还没有实际数据，只是一个空的内存占位</span></span><br><span class="line">    g.lock.Unlock()</span><br><span class="line"><span class="comment">//调用 wg.Wait，判断是否有其他 goroutine 正在申请资源，如果阻塞，说明有其他 goroutine 正在获取资源</span></span><br><span class="line">    c.wg.Wait()<span class="comment">//等待相同的call的结束</span></span><br><span class="line">    <span class="comment">// 当 wg.Wait 不再阻塞，表示资源获取已经结束，可以直接返回结果</span></span><br><span class="line"><span class="keyword">return</span> c, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = <span class="built_in">new</span>(call)<span class="comment">//创建一个新的call</span></span><br><span class="line">c.wg.Add(<span class="number">1</span>)     <span class="comment">//并为这个call添加一个的等待</span></span><br><span class="line">g.calls[key] = c</span><br><span class="line">g.lock.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *flightGroup)</span> <span class="title">makeCall</span><span class="params">(c *call, key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>)</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">g.lock.Lock()</span><br><span class="line"><span class="built_in">delete</span>(g.calls, key)<span class="comment">//删除</span></span><br><span class="line">g.lock.Unlock()</span><br><span class="line">c.wg.Done()           <span class="comment">//结束call</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">c.val, c.err = fn()   <span class="comment">//执行函数并返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看实现逻辑</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *flightGroup)</span> <span class="title">Do</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">c, done := g.createCall(key)<span class="comment">//根据key定义一个call</span></span><br><span class="line"><span class="keyword">if</span> done &#123;<span class="comment">//如果是等待结束了，且等待结束了，则返回Call的value</span></span><br><span class="line"><span class="keyword">return</span> c.val, c.err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是新的，那么就首次执行call，并返回结果</span></span><br><span class="line">  g.makeCall(c, key, fn)</span><br><span class="line"><span class="keyword">return</span> c.val, c.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *flightGroup)</span> <span class="title">DoEx</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(val <span class="keyword">interface</span>&#123;&#125;, fresh <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">c, done := g.createCall(key)</span><br><span class="line"><span class="keyword">if</span> done &#123; <span class="comment">//等待结束</span></span><br><span class="line"><span class="keyword">return</span> c.val, <span class="literal">false</span>, c.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g.makeCall(c, key, fn)</span><br><span class="line"><span class="keyword">return</span> c.val, <span class="literal">true</span>, c.err <span class="comment">//新的结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewSingleFlight returns a SingleFlight.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSingleFlight</span><span class="params">()</span> <span class="title">SingleFlight</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;flightGroup&#123;</span><br><span class="line">calls: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*call),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DoEx</code> 相较于 <code>Do</code> 中增加了一个 <code>bool</code> 类型的返回值，表示返回的值是共享的还是首次拿到的</p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://talkgo.org/t/topic/968" target="_blank" rel="noopener">https://talkgo.org/t/topic/968</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题背景&quot;&gt;&lt;/a&gt; 问题背景&lt;/h3&gt;
&lt;p&gt;并发场景下，可能会有多个线程（协程）同时请求同一份资源，如果每个请求都要走一遍资源的请求过程，除了比较低效之外，还会对资源服务造成并
      
    
    </summary>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/categories/go-zero/"/>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>go-zero1-架构</title>
    <link href="http://xboom.github.io/2022/06/28/GoZero/GoZero1-%E6%9E%B6%E6%9E%84/"/>
    <id>http://xboom.github.io/2022/06/28/GoZero/GoZero1-%E6%9E%B6%E6%9E%84/</id>
    <published>2022-06-27T16:55:05.000Z</published>
    <updated>2022-07-17T13:54:33.049Z</updated>
    
    <content type="html"><![CDATA[<p><code>go-zero</code> 包含很多微服务治理能力，所以不一定要完整使用go-zero，通过外部引入也是可以的</p><h4 id="go-zero结构"><a class="markdownIt-Anchor" href="#go-zero结构"></a> Go-Zero结构</h4><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220617011432.png" alt="架构图" /></p><p>包含诸多特点：</p><ul><li>强大的工具支持，尽可能少的代码编写</li><li>极简的接口</li><li>完全兼容 net/http</li><li>支持中间件，方便扩展</li><li>高性能</li><li>面向故障编程，弹性设计</li><li>内建服务发现、负载均衡</li><li>内建限流、熔断、降载，且自动触发，自动恢复</li><li>API 参数自动校验</li><li>超时级联控制</li><li>自动缓存控制</li><li>链路跟踪、统计报警等</li><li>高并发支撑，稳定保障了疫情期间每天的流量洪峰</li></ul><p>如下图，我们从多个层面保障了整体服务的高可用：</p><img src="https://raw.githubusercontent.com/zeromicro/zero-doc/main/doc/images/resilience.jpg" alt="弹性设计" style="zoom: 33%;" /><h3 id="框架设计"><a class="markdownIt-Anchor" href="#框架设计"></a> 框架设计</h3><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/architechture.svg" alt="" /></p><p>设计理念：</p><ul><li>保持简单，第一原则</li><li>弹性设计，面向故障编程</li><li>工具大于约定和文档</li><li>高可用</li><li>高并发</li><li>易扩展</li><li>对业务开发友好，封装复杂度</li><li>约束做一件事只有一种方式</li></ul><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><ol><li>防止缓存击穿之共享调用</li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://github.com/zeromicro/go-zero/blob/master/readme-cn.md" target="_blank" rel="noopener">https://github.com/zeromicro/go-zero/blob/master/readme-cn.md</a></li><li><a href="https://talkgo.org/c/go-zero/23" target="_blank" rel="noopener">https://talkgo.org/c/go-zero/23</a></li><li><a href="https://go-zero.dev/cn/docs/design/design" target="_blank" rel="noopener">https://go-zero.dev/cn/docs/design/design</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;go-zero&lt;/code&gt; 包含很多微服务治理能力，所以不一定要完整使用go-zero，通过外部引入也是可以的&lt;/p&gt;
&lt;h4 id=&quot;go-zero结构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#go-zero结构&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/categories/go-zero/"/>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>ETCD入门3-RAFT协议</title>
    <link href="http://xboom.github.io/2022/03/13/ETCD/ETCD%E5%85%A5%E9%97%A83-RAFT%E5%8D%8F%E8%AE%AE/"/>
    <id>http://xboom.github.io/2022/03/13/ETCD/ETCD%E5%85%A5%E9%97%A83-RAFT%E5%8D%8F%E8%AE%AE/</id>
    <published>2022-03-13T02:25:38.000Z</published>
    <updated>2022-06-25T07:00:00.112Z</updated>
    
    <content type="html"><![CDATA[<p>一致性是指在集群中的多个节点在状态上达成一致，常见的一致性协议有Raft、Paxos、ZAB</p><h3 id="基本规则"><a class="markdownIt-Anchor" href="#基本规则"></a> 基本规则</h3><p>任期(Term)：实际上是一个全局的、连续递增的整数。在raft中，每进行一次选举，任期就会+1</p><p>节点存在三种状态分别是：</p><ul><li>Leader节点：可读可写、处理日志复制、保证⼀致性、维护⼼跳</li><li>Follower节点：可进行读操作，写操作需要路由到Leader处理；参与投票，⼀个term任期内只能投⼀次; 当触发 election timeout 时，晋升为 candidate ;(注意读请求模式的线性读)</li><li>Candidate节点：集群的候选者，会发起投票试图当选leader ; 通过 RequestVote 通知其他节点来投票;</li></ul><p>集群中任意一个节点都处于这三个状态之一</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220125000023.png" alt="image-20220125000018705" style="zoom:80%;" /><p>如上图所示</p><ol><li>当etcd节点刚启动的时候，状态机初始化状态为Follower</li><li>为了进行Leader 选举控制有两个时间<ul><li>选举超时时间(election timeout): 每个Follower节点会因为超过选举超时时间还没有收到Leader的心跳而切换程Candidate状态并发起选举。一般为 150ms ~ 300ms，是一个一定范围的随机数(为了保证各节点不是同时发起选举请求)</li><li>心跳超时时间(heartbeat timeout): Leader节点向集群中其他Follower节点发送心跳消息的时间间隔</li></ul></li></ol><h3 id="脑裂问题"><a class="markdownIt-Anchor" href="#脑裂问题"></a> 脑裂问题</h3><p>原本一个集群，被分成了两个集群，同时出现了两个“大脑”，这就是所谓的“脑裂”现象</p><p>ETCD是否有可能出现脑裂？</p><ol><li>第一种情况：两边都得到过半票数而选举出Leader的情况，不可能出现</li><li>第二种情况：两边都无法得到过半票数而无法选举出Leader的情况，则服务端会返回客户端集群不可用</li></ol><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312195949.png" alt="image-20220312195949615" style="zoom:50%;" /><ol start="3"><li><p>第三种情况：Leader 与 其他节点通信异常，导致其他节点重新选出 Leader</p><ul><li><p>Leader 知道与其他节点通信异常</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220313110944.png" alt="image-20220313110426872" /></p><ul><li>由于 leader A ⽆法同步数据到多数节点, 造成 client 写请求失败 ;</li><li>⽹络分区后 follower c 长时间未收到⼼跳, 则触发选举且当选 ;</li><li>client 按照策略⼀直尝试跟可用的节点进⾏请求 ;</li><li>当⽹络恢复后, leader A B 将降为 follower, 并且强制同步 Leader C 的数据 ;</li></ul></li><li><p>Leader 不知道与还不知道与其他节点通信异常</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220313111102.png" alt="image-20220313111102564" /></p><ul><li>在 leader-A 里标记 client 请求为 未提交模式 ;</li><li>follower c 首先触发超时发起选举投票, folower ED 收到更加新的 term 过去的 requestVote, 则回应同意当选 ;</li><li>leader C 可以接收用户的请求, 由于可以拿到⼤多数的回应, 则可以正常提交数据 ;</li><li>当⽹络分区问题解决后, 由于旧集群的Leader A 的term 低于 Leader C , leader A 强制 同步 Leader C的数据;</li></ul></li></ul></li></ol><h3 id="leader选举"><a class="markdownIt-Anchor" href="#leader选举"></a> Leader选举</h3><p>能称为Leader的条件有</p><ul><li>当前集群⽆可用 leader ;</li><li>触发 election timeout ;</li><li>term 任期最新 ;</li><li>log 日志最新 ;</li><li>获取多数投票 ;</li></ul><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312200222.png" alt="image-20220312200222021" /></p><p>流程可以查看：<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></p><p>需要注意的是：</p><ol><li>超过集群半数节点应答，才将日志写入WAL中，也是就如果没有等到半数应答就挂了，那么数据就丢了</li><li>Follower 收到 Leader 的 复制日志 则直接将日志写入 WAL 中</li><li>当Follower收到 Vote Request 也会重置 election timeout 定时器(降低同时出现两个候选人的概率)</li><li>Term 将持续直到某个节点因为心跳超时而从新发起选举</li><li>出现多个候选人都没有称为 Leader，那么选举失败，切换为Follower，等待下一个选举超时</li><li>Leader 宕机后，其他节点重新选出新 Leader。等到旧Leader 恢复，会因为收到新Leader心跳 而自己的 Term 落后，切换成 Follower，更新自己的Term，然后重新投出自己的选票</li></ol><h4 id="基本流程"><a class="markdownIt-Anchor" href="#基本流程"></a> 基本流程</h4><p>将设ETCD集群中有三个节点(A、B、C)</p><img src="/Users/yuankang/Library/Application%20Support/typora-user-images/image-20220306233505794.png" alt="image-20220306233505794" style="zoom:50%;" /><ol><li>初始化，所有节点起初都是 Follower 状态(Term = 0， 得票数 = 0)</li><li>节点 A 由于长时间未收到 Leader 的心跳消息，就会切换成为Candidate 状态并发起选举（节点 A 的选举计时器 （election timer）己被重置）</li><li>节点 A 首先会将自己的选票投给自己，并会向集群中其他节点发送选举请求（ Request Vote ）以获取其选票，此时的节点 B 和节点 C 还都是处于 Term=0 的任期之中，且都是 Follower 状态，均未投出 Term=1 任期中的选票，所以节点 B 和节点 C 在接收到节点 A 的选举请求后会将选票投给节点 A，任期变为1。</li></ol><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220306235342.png" alt="image-20220306235342760" style="zoom:50%;"/><ol start="4"><li><p>在节点 A 收到节点 B、 C 的投票之后，其收到了集群中超过半数的选票，所以在 Terrn = 1 的任期中，该集群的 Leader 节点就是节点 A，其他节点将切换成 Follower 状态，</p><blockquote><p>集群中的节点除 了记录当期任期号(currentTerrn)，还会记录在该任期中当前节点的投票结果(VoteFor）</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220307000505.png" alt="image-20220307000505928" style="zoom:50%;" /></li><li><p>成为 Terrn = 1 任期的 Leader 节点之后，节点 A 会定期向集群中的其他节点发送心跳消息，防止节点 B 和节点 C 中的选举计时器(election timer) 超时而触发新一轮的选举: 当节点 B 和节点 C (Follower) 收到节点 A 的心跳消息之后会重置选举计时器</p><blockquote><p>心跳超时时间（heartbeat timeout）需要远小于选举超时时间(election timeout)</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220307000654.png" alt="image-20220307000653976" style="zoom:50%;" /></li></ol><blockquote><p>Candidate 发起选举前,会先尝试连接集群中的其他节点。如果连接不上，放弃本次选举。这个状态称之为：Prevote</p></blockquote><p>问题1：如果Leader节点频繁宕机，或者选举反复进行，怎么办？</p><p>要求：广播时间 &lt;&lt; 选举超时时间 &lt;&lt; 平均故障间隔时间</p><ul><li>广播时间：节点直接发送心跳信息的完整返回时间 hearthbeat timeout：0.5ms~50ms</li><li>选举超时时间：election timer：200ms~1s</li><li>故障间隔时间：两次故障的平均时间：1个月或更多(保证节点的不要经常出古故障)</li></ul><p>这样最大程度保证：不会频繁选举（广播时间 &lt;&lt; 选举超时时间），故障时间最多为200ms~1s（选举超时时间 &lt;&lt; 平均故障间隔时间）</p><p>问题2：是不是谁先发起了选举请求，谁就得到了Leader？</p><p>不是，除了看先后顺序，还取决于Candidate节点的日志是不是最新最全的日志，否则拒绝投票，防止出现日志（即数据）丢失的情况</p><h4 id="prevote"><a class="markdownIt-Anchor" href="#prevote"></a> Prevote</h4><p>当出现网络分区，节点因为选举超时而不断的进行 term 增加，而 leader 会因为遇到更新的 term 而退化为 follower，为了防止 term不断的新增，使用了 Prevote 措施，变为 candidate 的条件</p><ul><li>询问其他节点是否有可用 leader ;</li><li>可连通绝⼤数节点 ;</li></ul><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220313104101.png" alt="image-20220313104056708" style="zoom:50%;" /><h3 id="日志复制"><a class="markdownIt-Anchor" href="#日志复制"></a> 日志复制</h3><h4 id="基本流程-2"><a class="markdownIt-Anchor" href="#基本流程-2"></a> 基本流程</h4><p>流程动画：<a href="http://thesecretlivesofdata.com/raft/#replication" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/#replication</a></p><p>步骤如下：</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312204541.png" alt="image-20220312204541060"  /><ol><li>Leader 节点接到 client 请求后（如 set a=10）,将本请求计入本地log</li></ol><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312204707.png" alt="image-20220312204707596" /></p><ol start="2"><li>Leader 节点向 Follower1 和 Follower2 发送Append Entries消息（set a=10）</li><li>Follower1 和 Follower2 将此信息计入本地log，并返回给 Leader</li></ol><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312204848.png" alt="image-20220312204848066" /></p><ol><li>Leader 将日志信息置为 已提交(Commited),然后状态机处理。</li><li>响应 client 请求</li><li>向 Follower1 和 Follower2 发送消息，该信息已提交</li><li>Follower1 和 Follower2 接到消息后，修改日志状态，交给自己的状态机处理</li></ol><blockquote><p>存在的问题：计入本地log是否是写入WAL，按照之前的流程是没有的，而是在提交之后，那么Follower又是什么时候写入WAL的？</p></blockquote><h4 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引</h4><p>集群中各个节点都会维护一个本地Log 用于记录更新操作，还会维护 <code>commitlndex</code> 和<code>lastApplied</code> 两个值，它们是本地Log 的索引值</p><ul><li><code>commitlndex</code> 表示的是当前节点已知的、最大的、己提交的日志索引值</li><li><code>lastApplied</code> 表示的是当前节点最后一条被应用到状态机中的日志索引值。</li></ul><p>当节点中的 <code>commitlndex</code> 值大于 <code>lastApplied</code> 值时，会将 <code>lastApplied+ 1</code> ，并将 <code>lastApplied</code> 对应的日志应用到其状态机中。</p><p>除此之外，在Leader还需要了解集群中其他Follower 节点的这些信息，而决定下次发送Append Entries 消息中包含哪些日志记录。为此， Leader 节点会维护 <code>nextlndex[]</code>和 <code>matchlndex[]</code>两个数组，这两个数组中记录的都是日志索引值</p><ul><li><code>nextlndex[]</code> 记录了需要发送给每个Follower 节点的下一条日志的索引值</li><li><code>matchlndex[]</code> 记录了己经复制给每个Follower 节点的最大的日志索引值</li></ul><blockquote><p>一个数组不就可以表达了吗？</p></blockquote><p>例如：</p><p>Follower 节点中最后一条日志的索引值大于等于该 Follower 节点对应的 <code>nextlndex</code> 值，那么通过Append Entries 消息发送从<code>nextlndex</code> 开始的所有日志。之后， Leader节点会检测该 Follower 节点返回的相应响应，</p><ul><li>如果成功则更新相应该Follower 节点对应的 <code>nextlndex</code> 值和<code>matchlndex</code> 值；</li><li>如果因为日志不一致而失败，则减少 <code>nextlndex</code> 值重试。</li></ul><h4 id="一致性复制"><a class="markdownIt-Anchor" href="#一致性复制"></a> 一致性复制</h4><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312211352.png" alt="image-20220312211352566" style="zoom:50%;" /><p>raft 中的每个日志记录都带有 term 和 log index 来唯⼀标识 ;</p><ul><li>日志记录具有两个特性 如果两条不同节点的某两个日志记录具有相同的 term 和 index 号，则两条记录⼀定是完全相同的 ;</li><li>如果两条不同节点的某两个日志记录具有相同的 term 和 index 号，则两 条记录之前的所有记录也⼀定是完全相同的 ;</li></ul><p>以此来判断 leader与 follower 之间的 日志是否相同</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312210348.png" alt="image-20220312210348704" style="zoom:50%;" /><blockquote><p>上图中：a 和 b 的情况是没有完全收到来自 leader 的 AppendEntries RPC, ⽽ c-f 则是带有不同时期的未提交的日志（有可能是他们当 leader 时产⽣的，但没有提交就 crash了）</p></blockquote><ul><li>leader 从来不会覆盖，删除或者修改其日志 ;</li><li>leader 会初始化⼀个数组 nextIndex[], 该结构对应的值表示本 leader 将给对应 follower 发送的下⼀条日志 index ;</li><li>若 follower 对比其前⼀条 log 不⼀致，则会拒绝 leader 发来的请求. 此时 leader 就将其在 nextIndex[] 中的对应值减⼀ ;</li><li>leader 不断重试直到 follower 比对成功, 然后 <strong>follower 接受 AppendEntries RPC, ⼀个个的抛弃所有冲突的日志</strong> ;</li><li>leader 按照自身日志顺序将日志正常复制给 follower，并不断将 nextIndex[] 对应 值 +1，直到对应值 “追上” 自身日志的 index 为⽌;</li></ul><blockquote><p>为什么要一个一个对比，而不直接找到对应的位置，批量复制？=&gt; 通过数组存储的是索引，但是日志比较是通过 index 与 term</p><p>那数组为什么不存 index 与 term? =&gt; 因为本来每个节点的 操作都是不一样的，其他节点无法</p></blockquote><h4 id="异常情况"><a class="markdownIt-Anchor" href="#异常情况"></a> 异常情况</h4><h5 id="场景1"><a class="markdownIt-Anchor" href="#场景1"></a> 场景1：</h5><p>两个Follower 节点不可用，Leader 如何处理请求</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312201120.png" alt="image-20220312201120077" style="zoom:50%;" /><ul><li><p>leader 通过⼼跳已知 follower 已挂, 则直接返回错误 ;</p></li><li><p>leader 不知节点已挂, 同步数据时得知异常; 触发异常触发超时</p></li></ul><h5 id="场景2"><a class="markdownIt-Anchor" href="#场景2"></a> <strong>场景2：</strong></h5><p>提交给Leader后，发生了crash</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312201343.png" alt="image-20220312201343089" style="zoom:50%;" /><ul><li><p>leader 本地已记录 未提交日志, 重启后强制同步新 leader 数据 ;</p></li><li><p>leader 还没记录未提交日志就crash, 丢了就丢了;</p></li></ul><h5 id="场景3"><a class="markdownIt-Anchor" href="#场景3"></a> 场景3</h5><p>复制给 follower-1 后, leader就发⽣了 crash ?</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312202452.png" alt="image-20220312202452036" style="zoom:50%;" /><ul><li>leader 发⽣了重启，集群触发新的选举 ;</li><li>由于 follower-1 的数据较新, 那么该节点会晋升 leader ;</li><li>follower-1 会把 uncommited 的 v=3 同步给其他节点 ;</li><li>follower-1 收到其他节点接收确认后, 进⾏提交日志 ;</li></ul><h5 id="场景4"><a class="markdownIt-Anchor" href="#场景4"></a> 场景4：</h5><p>follower 返回确认消息时, leader 发⽣了 crash ?</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312202600.png" alt="image-20220312202600126" style="zoom:50%;" /><ul><li>三个节点的数据已经⼀致, 都为 uncommited v=3 ; 这时谁当 Leader 都可以 ; 新leader当选后, 需要进⾏同步提交通知 ;</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li>《ETCD技术内幕》</li><li><a href="http://www.xuyasong.com/?p=1706" target="_blank" rel="noopener">http://www.xuyasong.com/?p=1706</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一致性是指在集群中的多个节点在状态上达成一致，常见的一致性协议有Raft、Paxos、ZAB&lt;/p&gt;
&lt;h3 id=&quot;基本规则&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基本规则&quot;&gt;&lt;/a&gt; 基本规则&lt;/h3&gt;
&lt;p&gt;任期(Term)：实际上
      
    
    </summary>
    
    
      <category term="ETCD" scheme="http://xboom.github.io/categories/ETCD/"/>
    
    
      <category term="ETCD" scheme="http://xboom.github.io/tags/ETCD/"/>
    
  </entry>
  
  <entry>
    <title>ETCD入门2-ETCD架构</title>
    <link href="http://xboom.github.io/2022/03/12/ETCD/ETCD%E5%85%A5%E9%97%A82-ETCD%E6%9E%B6%E6%9E%84/"/>
    <id>http://xboom.github.io/2022/03/12/ETCD/ETCD%E5%85%A5%E9%97%A82-ETCD%E6%9E%B6%E6%9E%84/</id>
    <published>2022-03-12T09:31:19.000Z</published>
    <updated>2022-06-25T07:00:00.112Z</updated>
    
    <content type="html"><![CDATA[<h3 id="etcd架构"><a class="markdownIt-Anchor" href="#etcd架构"></a> ETCD架构</h3><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312153557.jpg" alt="img" /></p><ol><li><strong>Client</strong>：客户端库，封装对KVServer、Cluster、Auth、Lease、Watch的API</li><li>API：<ul><li>Raft HTTP：主要用于ETCD集群各节点通信，基于Raft进行数据同步、选主</li><li>gRPC API:  v3 使用 grpc实现服务端与客户端交互，而 v2 使用 http1.X 实现交互</li><li>HTTP: ETCD 支持 HTTP 对外交互接口(v2 与 v3 不能混用)</li></ul></li><li>Raft：选主、日志复制、ReadIndex等为保障节点数据一致性的具体算法实现</li><li>功能逻辑<ul><li>KVServer模块</li><li>Auth鉴权模块</li><li>Lease租约模块：主动上报的检测机制</li><li>Compactor压缩模块</li><li>MVCC模块：treeIndex + boltdb，多版本并发控制，保存一组KV的多个历史版本</li><li>Quota: 配额模块，检查下当前 etcd db 大小加上你请求的 key-value 大小之和是否超过了配额(quota-backend-bytes，默认存储为2G, 最大配额为8G)</li></ul></li><li>存储<ul><li>WAL模块：Write Ahead Log，预写式日志，所有修改在提交前都要写入log文件，保障etcd崩溃了不丢失数据（redo/undo）</li><li>Snapshot：防止WAL文件过多而设置的快照，存储etcd数据状态，某个快照前的日志会变为无效数据。（如每处理1w条日志就进行一次snapshot）</li><li>boltdb模块：嵌入式 K/V 数据库，B+树，保存集群元数据与用户写入的数据</li></ul></li></ol><h4 id="quota-模块"><a class="markdownIt-Anchor" href="#quota-模块"></a> Quota 模块</h4><p>如果超过配额，会产生一个告警(Alarm)请求，告警类型是 NO SPACE，并通过 Raft 日志同步给其它节点，告知 db 无空间了，并将告警持久化存储到 db 中。</p><p>最终，无论是 API 层 gRPC 模块还是负责将 Raft 侧已提交的日志条目应用到状态机的 Apply 模块，都拒绝写入，集群只读。</p><p>常见的 “etcdserver: mvcc: database space exceeded&quot; 错误就是因为Quota 模块检测到 db 大小超限导致的。</p><ul><li>一方面默认 db 配额仅为 2G，当你的业务数据、写入 QPS、Kubernetes 集群规模增大后，你的 etcd db 大小就可能会超过 2G。</li><li>另一方面 etcd 是个 MVCC 数据库，保存了 key 的历史版本，当你未配置压缩策略的时候，随着数据不断写入，db 大小会不断增大，导致超限。</li></ul><p>解决办法</p><ul><li>1）首先当然是调大配额，etcd 社区建议不超过 8G。<ul><li>如果填的是个小于 0 的数，就会禁用配额功能，这可能会让db 大小处于失控，导致性能下降，不建议你禁用配额。</li></ul></li><li>2）检查 etcd 的压缩（compact）配置是否开启、配置是否合理。<ul><li>压缩时只会给旧版本Key打上空闲（Free）标记，后续新的数据写入的时候可复用这块空间，db大小并不会减小。</li><li>如果需要回收空间，减少 db 大小，得使用碎片整理（defrag）， 它会遍历旧的 db 文件数据，写入到一个新的 db 文件。但是它对服务性能有较大影响，不建议你在生产集群频繁使用。</li></ul></li></ul><p>调整后还需要手动发送一个取消告警（etcdctl alarm disarm）的命令，以消除所有告警，否则因为告警的存在，集群还是无法写入。</p><h3 id="写请求处理处理"><a class="markdownIt-Anchor" href="#写请求处理处理"></a> 写请求处理处理</h3><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312155944.png" alt="etcd-write-step" /></p><p>图中流程如下：</p><ol><li><p>客户端会与ETCD每个节点都建立连接，读写grpc请求则通过负载均衡算法随机发送到其中一个节点</p></li><li><p>etcd 节点收到请求后经过 gRPC 拦截器 进入逻辑处理流程(<strong>写入数据的etcd是leader节点，如果是非leader节点则路由到etcd leader节点去</strong>)</p></li><li><p>Quota 进行配额校验，完成后转发给KVServer</p></li><li><p>KVServer 模块生成并提交提案</p><ul><li>打包提案：将 put 写请求内容打包成一个提案消息</li><li>请求限速、检查：在提交提案前，进行如下的一系列检查和限速<ul><li>限速：如果 Raft 模块已提交的日志索引（committed index）比已应用到状态机的日志索引（applied index）超过了 5000，那么它就返回一个&quot;etcdserver: too many requests&quot;错误给 client。</li><li>鉴权：尝试去获取请求中的鉴权信息，若使用了密码鉴权、请求中携带了 token，如果 token 无效，则返回&quot;auth: invalid auth token&quot;错误给 client。</li><li>大包检查：检查写入的包大小是否超过默认的 1.5MB， 如果超过则返回&quot;etcdserver: request is too large&quot;错误给 client</li></ul></li><li>通过检查后会生成一个唯一的 ID，将此请求关联到一个对应的消息通知 channel（用于接收结果，golang 响应处理方式），向Raft模块发起(Propose)一个提案(Proposal)</li></ul><blockquote><p>KVServer 模块会等待此 put 请求，等待写入结果通过消息通知 channel 返回或者超时。etcd 默认超时时间是 7 秒（5 秒磁盘 IO 延时 +2*1 秒竞选超时时间），如果一个请求超时未返回结果，则可能会出现你熟悉的 etcdserver: request timed out 错误</p></blockquote></li><li><p>Raft模块处理提案</p><ul><li>raft模块会首先保存到raftLog的unstable存储部分(raft 仅仅是普通日志作用，unstable 表示存在内存中)</li><li>通过raft协议与集群中其他etcd节点进行交互应答<ul><li>集群中其他节点向leader节点应答接收这条日志数据</li><li>当超过集群半数<code>(N + 1) / 2</code>节点应答这条日志数据时，将这条日志写入到WAL模块中</li></ul></li></ul></li><li><p>通知最上层的etcd server该日志已经commit</p></li><li><p>etcd server调用applierV3模块将日志写入持久化存储中</p><ul><li>首先生成 key 对应的 revision 存入treeindex中</li><li>然后通过revistion - val 持久话到 boltdb中(B+树结构)</li></ul></li></ol><blockquote><p>超过配额怎么办？</p><ol><li>检查 etcd 的压缩（compact）配置是否开启、配置是否合理。</li></ol><ul><li>压缩时只会给旧版本Key打上空闲（Free）标记，后续新的数据写入的时候可复用这块空间，db大小并不会减小。</li></ul><ul><li>如果需要回收空间，减少 db 大小，得使用碎片整理（defrag）， 它会遍历旧的 db 文件数据，写入到一个新的 db 文件。但是它对服务性能有较大影响，不建议你在生产集群频繁使用。</li></ul><ol start="2"><li>调整后还需手动发送取消告警的命令<code>etcdctl alarm disarm</code>，以消除所有告警，否则因为告警的存在，集群还是无法写入</li></ol></blockquote><h3 id="读请求处理流程"><a class="markdownIt-Anchor" href="#读请求处理流程"></a> 读请求处理流程</h3><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312155605.png" alt="etcd-read-process" /></p><h4 id="串行读与线性读"><a class="markdownIt-Anchor" href="#串行读与线性读"></a> 串行读与线性读</h4><p>etcd 为了保证服务高可用，生产环境一般部署多个节点，多节点之间的数据由于延迟等关系可能会存在不一致的情况</p><blockquote><p>不一致原因：虽然是强一致性，但 Leader 收到大部分节点响应就回复客户端，可能存在leader与未回复follower不一致的情况</p></blockquote><p>根据业务场景对数据一致性差异的接受程度，etcd 中有两种读模式。</p><ul><li><strong>串行 (Serializable) 读</strong>：直接读状态机数据返回、无需通过 Raft 协议与集群进行交互，它具有低延时、高吞吐量的特点，适合对数据一致性要求不高的场景。(可能出现当前KV不是最新的情况)</li><li><strong>线性读</strong>：需要经过 Raft 协议模块，反应的是集群共识，因此在延时和吞吐量上相比串行读略差一点，适用于对数据一致性要求高的场景</li></ul><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312210238.png" alt="image-20220312210238211" /></p><p>由于串行读是直接从当前节点获取&quot;最新&quot;数据，可能出现不是真的最新，线性读通过先与集群达成共识再返回结果</p><p>线性读流程具体流程如下：</p><ol><li>当 Follower 收到线性读请求时，首先执行 Read Index 请求， 从 Leader 获取集群最新的已提交的日志索引 (committed index)</li><li>Leader 收到 Read Index 请求时，为防止脑裂等异常场景，会向 Follower 节点发送心跳确认，一半以上节点确认 Leader 身份后才能将已提交的索引 (committed index) 返回给请求节点。</li><li>Follower 节点拿到 Read index 后会和状态机的 applied index进行比较<ul><li>如果 Read index 大于 applied index 则会等待，直到状态机已应用索引 (applied index) 大于等于 Leader 的已提交索引时 (committed Index)才会去通知读请求，数据已赶上 Leader可以去状态机中访问数据了</li><li>否则直接开始读取</li></ul></li></ol><blockquote><p>readIndex 需要请求 leader，那为什么不直接让 leader 返回读请求的结果</p><p><strong>主要是性能因素</strong>，如果将所有读请求都转发到 Leader，会导致 Leader 负载升高，内存、cpu、网络带宽资源都很容易耗尽。特别是expensive request场景，会让 Leader 节点性能会急剧下降。read index 机制的引入，使得每个follower节点都可以处理读请求，极大扩展提升了写性能。</p></blockquote><h4 id="读取流程"><a class="markdownIt-Anchor" href="#读取流程"></a> 读取流程</h4><ol><li><p>从 treeIndex 中获取 key 的版本号</p></li><li><p>再以版本号作为 boltdb 的 key，从 boltdb 中获取其 value 信息</p><ul><li><p>etcd 出于数据一致性、性能等考虑，在访问 boltdb 前，首先会从一个内存读事务 buffer 中，二分查找你要访问 key 是否在 buffer 里面，若命中则直接返回。</p></li><li><p>若 buffer 未命中，此时就真正需要向 boltdb 模块查询数据了。boltdb 使用 B+ tree 来组织用户的 key-value 数据，获取 bucket key 对象后，通过 boltdb 的游标 Cursor 可快速在 B+ tree 找到 key hello 对应的 value 数据，返回给 client。</p><blockquote><p>boltdb 通过 bucket 隔离集群元数据与用户数据</p></blockquote></li></ul></li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="http://www.jcxioo.com/2021/06/14/01_Kubernetes/etcd1%20/" target="_blank" rel="noopener">http://www.jcxioo.com/2021/06/14/01_Kubernetes/etcd1 /</a></li><li><a href="https://www.codedump.info/post/20181125-etcd-server/#wal" target="_blank" rel="noopener">https://www.codedump.info/post/20181125-etcd-server/#wal</a></li><li><a href="https://www.lixueduan.com/post/etcd/07-read-process/" target="_blank" rel="noopener">https://www.lixueduan.com/post/etcd/07-read-process/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;etcd架构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#etcd架构&quot;&gt;&lt;/a&gt; ETCD架构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images-1307117474.cos.ap-guangzhou.myqclou
      
    
    </summary>
    
    
      <category term="ETCD" scheme="http://xboom.github.io/categories/ETCD/"/>
    
    
      <category term="ETCD" scheme="http://xboom.github.io/tags/ETCD/"/>
    
  </entry>
  
  <entry>
    <title>ETCD入门1-ETCD概述</title>
    <link href="http://xboom.github.io/2022/03/12/ETCD/ETCD%E5%85%A5%E9%97%A81-ETCD%E6%A6%82%E8%BF%B0/"/>
    <id>http://xboom.github.io/2022/03/12/ETCD/ETCD%E5%85%A5%E9%97%A81-ETCD%E6%A6%82%E8%BF%B0/</id>
    <published>2022-03-12T07:33:07.000Z</published>
    <updated>2022-06-25T07:00:00.112Z</updated>
    
    <content type="html"><![CDATA[<p>etcd是一个可靠的分布式KV存储系统</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312141241.png" alt="image-20220312141043231" /></p><p>黄色：关联特性</p><p>红色：核心原理</p><h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3><ul><li>简单：提供定义明确且面向用户的API</li><li>安全：支持SSL证书验证</li><li>性能：基准压测支持1w+/sec写入</li><li>可靠：采用Raft协议保证分布式系统数据的可用性和一致性。</li></ul><h3 id="功能特性"><a class="markdownIt-Anchor" href="#功能特性"></a> 功能特性</h3><ul><li><p><strong>KV存储、查询功能</strong>：支持精准查询、range操作、ttl机制、key版本等</p></li><li><p><strong>强一致性</strong>：采用raft协议保证<strong>强一致性</strong></p></li><li><p><strong>高可用性</strong>：提供集群和leader选举机制</p></li><li><p><strong>SSL认证机制</strong></p></li><li><p><strong>Lease 机制</strong>：即租约机制（TTL，Time To Live），Etcd 可以为存储的 Key-Value 对设置租约，当租约到期，Key-Value 将失效删除；同时也支持续约(Keepalive)，通过客户端可以在租约到期之前续约，以避免 Key-Value 对过期失效。</p><blockquote><p>Lease 机制可以保证分布式锁的安全性，为锁对应的 Key 配置租约，即使锁的持有者因故障而不能主动释放锁，锁也会因租约到期而自动释放。</p></blockquote></li><li><p><strong>Revision 机制</strong>：每个 Key 带有一个 Revision 号，每进行一次事务便加一，因此它是全局唯一的，如初始值为 0，进行一次 <code>put(key, value)</code>，Key 的 Revision 变为 1，同样的操作，再进行一次，Revision 变为 2；换成 key1 进行 put(key1, value) 操作，Revision 将变为 3；</p><blockquote><p>通过 Revision 的大小就可以知道写操作的顺序。在实现分布式锁时，多个客户端同时抢锁，根据 Revision 号大小依次获得锁，可以避免 “羊群效应” （也称“惊群效应”），实现公平锁。</p></blockquote></li><li><p><strong>Prefix 机制</strong>：即前缀机制，也称目录机制，例如，一个名为 <code>/mylock</code> 的锁，两个争抢它的客户端进行写操作，实际写入的 Key 分别为：<code>key1=&quot;/mylock/UUID1&quot;,key2=&quot;/mylock/UUID2&quot;</code>，其中，UUID 表示全局唯一的 ID，确保两个 Key 的唯一性。很显然，写操作都会成功，但返回的 Revision 不一样，</p><blockquote><p>如何判断谁获得了锁呢？</p><p>通过前缀“/mylock” 查询，返回包含两个 Key-Value 对的 Key-Value 列表，同时也包含它们的 Revision，通过 Revision 大小，客户端可以判断自己是否获得锁，如果抢锁失败，则等待锁释放（对应的 Key 被删除或者租约过期），然后再判断自己是否可以获得锁。</p></blockquote></li><li><p><strong>Watch 机制</strong>：即监听机制，Watch 机制支持监听某个固定的 Key，也支持监听一个范围（前缀机制），当被监听的 Key 或范围发生变化，客户端将收到通知；</p><blockquote><p>在实现分布式锁时，如果抢锁失败，可通过 Prefix 机制返回的 Key-Value 列表获得 Revision 比自己小且相差最小的 Key（称为 Pre-Key），对 Pre-Key 进行监听，因为只有它释放锁，自己才能获得锁，如果监听到 Pre-Key 的 DELETE 事件，则说明 Pre-Key 已经释放，自己已经持有锁。</p><p>获取Pre-Key 的时候就已经释放了怎么办？Watch需要带上版本</p></blockquote></li></ul><h3 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h3><h4 id="分布式锁"><a class="markdownIt-Anchor" href="#分布式锁"></a> <strong>分布式锁</strong></h4><h5 id="分布式锁-2"><a class="markdownIt-Anchor" href="#分布式锁-2"></a> 分布式锁</h5><p>因为 etcd 使用 Raft 算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁</p><img src="https://static001.infoq.cn/resource/image/46/dc/46ff86e2e2c2157bc3f0409845f0e1dc.jpg" alt="img" style="zoom:50%;" /><p>V3版本接口:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来新建一个mutex</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMutex</span><span class="params">(s *Session, pfx <span class="keyword">string</span>)</span> *<span class="title">Mutex</span></span> </span><br><span class="line"><span class="comment">//它会阻塞直到拿到了锁，并且支持通过context来取消获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><blockquote><p>锁原理详解 TODO</p></blockquote><h5 id="leader选举组件"><a class="markdownIt-Anchor" href="#leader选举组件"></a> <strong>leader选举组件</strong></h5><p>利用分布式锁，实现Leader竞选。而 leader-follower模式来保证有状态服务的高可用</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312152020.jpg" alt="img" /></p><h4 id="注册与发现"><a class="markdownIt-Anchor" href="#注册与发现"></a> 注册与发现</h4><p>本质是：服务端通过(Lessor + keepalive) 进行服务注册与保活，客户端通过(Watch)做到KV实时变化实时感知</p><h5 id="服务注册与发现"><a class="markdownIt-Anchor" href="#服务注册与发现"></a> 服务注册与发现</h5><p>服务端注册信息到注册中心ETCD中，并通过心跳实时检测服务端(lessor + keepalive)。客户端从注册中心获取服务端信息才能建立链接(Watch)</p><img src="https://static001.infoq.cn/resource/image/1b/7d/1beabef5a1168cdc43766903e65f907d.jpg" alt="img" style="zoom:50%;" /><blockquote><ol><li>k8s 中已经有 service，是否还需要使用到注册中心？</li></ol><p>使用grpc构建k8s 服务通信，由于 grpc 使用的是长连接通信，导致消息在多副本情况下只会发往同一个副本</p><ol start="2"><li><p>如何注册服务端信息的</p><p>对应 Key = &lt;标识&gt;.&lt;服务名称&gt;.&lt;版本&gt;.<IP> , Val =&lt;k=v&gt;&amp;&lt;k=v&gt;</p><p>Key: 保存通信信息，当服务端出现变化的时候。客户端即使不解析 Val 也能收到变化</p><p>Val: 可以不定义或者定义每个服务(注意副本)特有信息</p></li></ol></blockquote><h5 id="集群监控"><a class="markdownIt-Anchor" href="#集群监控"></a> 集群监控</h5><p>通过 etcd 来进行监控实现起来非常简单并且实时性强。</p><ol><li>前面几个场景已经提到 Watcher 机制，当某个节点消失或有变动时，Watcher 会第一时间发现并告知用户。</li><li>节点可以设置<code>TTL key</code>，比如每隔 30s 发送一次心跳使代表该机器存活的节点继续存在，否则节点消失。</li></ol><h5 id="分布式通知与协调"><a class="markdownIt-Anchor" href="#分布式通知与协调"></a> <strong>分布式通知与协调</strong></h5><img src="https://static001.infoq.cn/resource/image/38/97/38bee3d541dd88e6f772e64beab92697.jpg" alt="img" style="zoom:50%;" /><ul><li><strong>通过 etcd 进行低耦合的心跳检测</strong>。检测和被检测系统通过 etcd 进行关联降低系统的耦合性。</li><li><strong>通过 etcd 完成系统调度</strong>。某系统有控制台和推送系统两部分组成，控制台的职责是控制推送系统进行相应的推送工作。管理人员在控制台作的一些操作，实际上是修改了 etcd 上某些目录节点的状态，而 etcd 就把这些变化通知给注册了 Watcher 的推送系统客户端，推送系统再作出相应的推送任务。</li><li><strong>通过 etcd 完成工作汇报</strong>。大部分类似的任务分发系统，子任务启动后，到 etcd 来注册一个临时工作目录，并且定时将自己的进度进行汇报（将进度写入到这个临时目录），这样任务管理者就能够实时知道任务进度</li></ul><h5 id="消息订阅和发布"><a class="markdownIt-Anchor" href="#消息订阅和发布"></a> <strong>消息订阅和发布</strong></h5><ul><li><strong>消息发布与订阅</strong></li></ul><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312143719.jpg" alt="img" style="zoom:50%;" /><blockquote><ol><li>配置中心需要考虑分权问题，每个服务对于同一个数据库的访问权限也是不一致的。所以配置信息也有可能不一致。当然不影响进行配置注册</li></ol></blockquote><h5 id="配置中心"><a class="markdownIt-Anchor" href="#配置中心"></a> <strong>配置中心</strong></h5><p>整个平台不同服务包含很多相同配置信息 ，例如: 数据库地址、链路追踪等。可以将这些配置信息注册到注册中心实现动态更新</p><blockquote><p>这里还需要考虑分权问题：即每个服务能够访问的权限、区域不一致，那么每服务甚至副本配置都不一致</p></blockquote><h4 id="负载均衡"><a class="markdownIt-Anchor" href="#负载均衡"></a> <strong>负载均衡</strong></h4><p>在k8s中一般针对多副本场景，由于 grpc 使用的是长连接，k8s service 无法满足负载场景，需要客户端通过获取副本信息实现负载均衡</p><img src="https://static001.infoq.cn/resource/image/67/be/6782904921fa103f42f30113fbf0babe.jpg" alt="img" style="zoom:50%;" /><h4 id="分布式队列"><a class="markdownIt-Anchor" href="#分布式队列"></a> <strong>分布式队列</strong></h4><p>分布式队列的常规用法与场景五中所描述的分布式锁的控制时序用法类似，即创建一个先进先出的队列，保证顺序。</p><p>另一种比较有意思的实现是<strong>在保证队列达到某个条件时再统一按顺序执行</strong>。这种方法的实现可以在 /queue 这个目录中另外建立一个 /queue/condition 节点。</p><ul><li>condition 可以<strong>表示队列大小</strong>。比如一个大的任务需要很多小任务就绪的情况下才能执行，每次有一个小任务就绪，就给这个 condition 数字加 1，直到达到大任务规定的数字，再开始执行队列里的一系列小任务，最终执行大任务。</li><li>condition 可以<strong>表示某个任务在不在队列</strong>。这个任务可以是所有排序任务的首个执行程序，也可以是拓扑结构中没有依赖的点。通常，必须执行这些任务后才能执行队列中的其他任务。</li><li>condition 还可以<strong>表示其它的一类开始执行任务的通知</strong>。可以由控制程序指定，当 condition 出现变化时，开始执行队列任务。</li></ul><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312151607.jpg" alt="img" /></p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="http://www.jcxioo.com/2021/06/14/01_Kubernetes/etcd1%20/" target="_blank" rel="noopener">http://www.jcxioo.com/2021/06/14/01_Kubernetes/etcd1 /</a></li><li><a href="https://www.infoq.cn/article/etcd-interpretation-application-scenario-implement-principle" target="_blank" rel="noopener">https://www.infoq.cn/article/etcd-interpretation-application-scenario-implement-principle</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;etcd是一个可靠的分布式KV存储系统&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312141241.png&quot; alt=&quot;i
      
    
    </summary>
    
    
      <category term="ETCD" scheme="http://xboom.github.io/categories/ETCD/"/>
    
    
      <category term="ETCD" scheme="http://xboom.github.io/tags/ETCD/"/>
    
  </entry>
  
  <entry>
    <title>ETCD入门6-多版本控制</title>
    <link href="http://xboom.github.io/2022/02/23/ETCD/ETCD%E5%85%A5%E9%97%A86-%E5%A4%9A%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    <id>http://xboom.github.io/2022/02/23/ETCD/ETCD%E5%85%A5%E9%97%A86-%E5%A4%9A%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</id>
    <published>2022-02-22T16:41:29.000Z</published>
    <updated>2022-06-25T07:00:00.111Z</updated>
    
    <content type="html"><![CDATA[<p>悲观锁：悲观得认为并发事务会冲突，所以要先拿锁，拿到锁的作修改操作</p><ul><li>读写锁（可多读，写时互斥）、互斥锁（线程互斥）等</li><li>控制粒度太大，高并发下大量事务会被阻塞</li></ul><p>乐观锁：乐观得认为数据不会冲突，但发生冲突时要能检测到</p><ul><li>逻辑时钟（时间戳排序）</li><li>MVCC</li></ul><p>MVCC（Multiversion Concurrency Control）多版本并发控制机制，<strong>保存一个数据的多个历史版本</strong>以解决事务管理中数据隔离的问题，被主流数据库采用，包括Oracle, MySQL等</p><p>写一个数据项时，不是简单的用新值覆盖旧值，而是为这一项添加一个新版本的数据；<br />读一个数据项时，先确定版本，在根据版本找到对应的值；<br />这样保证了读写隔离，无需锁协调。读不会阻塞，适合“读多写少”的etcd</p><ul><li>可以保存一个Key-Value数据的多个历史版本</li><li>每修改（新增/删除）一次都会生成一个新的数据记录</li><li>指定版本号读取数据时，实际访问的是版本号生成的那个时间点的快照</li></ul><blockquote><p>linux中的RCU功能？</p></blockquote><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220223002724.jpg" alt="img" /></p><p>文中涉及的key表示用户输入的键值，K(or Key)表示boltdb持久化存储时的键值</p><ul><li>treeIndex：基于B-tree实现的key的索引，保存用户key与版本号revision的映射关系</li><li>Backend：作持久化KV操作，目前支持boltdb<ul><li>ReadTx 读事务接口</li><li>BatchTx 写事务接口</li><li>Buffer 缓存</li></ul></li><li>boltdb：基于B+ Tree的支持事务的KV嵌入式数据库<ul><li>K：revision</li><li>V：{用户的kv，版本号，lease信息等}</li></ul></li></ul><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220223003043.jpeg" alt="img" /></p><p>etcd中的MVCC存储分为两部分：</p><ol><li>内存中保存的key-revision映射，用于快速点查及范围查询</li><li>磁盘中保存的不同版本的真实数据</li></ol><h3 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h3><h4 id="b-tree"><a class="markdownIt-Anchor" href="#b-tree"></a> <strong>B Tree</strong></h4><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220223003231.jpg" alt="img" /></p><ul><li>树内节点都存数据</li><li>叶子节点都在同一层且无相邻指针</li><li>度：每个节点的子节点的个数，“胖瘦程度”</li></ul><h4 id="b-tree-2"><a class="markdownIt-Anchor" href="#b-tree-2"></a> <strong>B+ Tree</strong></h4><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220223003324.jpeg" alt="简化B+树" /></p><ul><li>数据只在叶子节点</li><li>所有叶子节点增加了一个链指针</li></ul><h4 id="revision"><a class="markdownIt-Anchor" href="#revision"></a> <strong>revision</strong></h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;txID, 0&#125;, &#123;txID, 1&#125;, &#123;txID, 2&#125;...</span></span><br><span class="line"><span class="keyword">type</span> revision <span class="keyword">struct</span> &#123;</span><br><span class="line">main <span class="keyword">int64</span>         <span class="comment">// 事务ID，逻辑时间戳，全局递增不重复</span></span><br><span class="line">sub  <span class="keyword">int64</span>         <span class="comment">// 当前事务内不同的修改操作的编号（put/del），从0开始递增</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一次事务中，每一个修改操作所绑定的 revision 一次为<code>{txID, 0}</code>, <code>{txID, 1}</code>…</p><h4 id="keyindex"><a class="markdownIt-Anchor" href="#keyindex"></a> <strong>keyIndex</strong></h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">type</span> keyIndex <span class="keyword">struct</span> &#123;</span><br><span class="line">    key         []<span class="keyword">byte</span>          <span class="comment">// 用户的key</span></span><br><span class="line">    modified    revision        <span class="comment">// 最后一次修改key时的etcd版本号</span></span><br><span class="line">    generations []generation    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// generation保存了一个key若干代的版本号，每代都包含对key多次修改的版本号列表</span></span><br><span class="line"><span class="comment">// 创建时第0代，删除后生成第1代...</span></span><br><span class="line"><span class="keyword">type</span> generation <span class="keyword">struct</span> &#123;</span><br><span class="line">ver     <span class="keyword">int64</span>               <span class="comment">// 表示key的修改次数</span></span><br><span class="line">created revision            <span class="comment">// 创建时的第一个版本号</span></span><br><span class="line">revs    []revision          <span class="comment">// 每次修改key时的revision追加进此切片</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="treeindex"><a class="markdownIt-Anchor" href="#treeindex"></a> <strong>treeIndex</strong></h4><p>树状索引，内存中维护的B树，加速查询key</p><ul><li>树的每个节点都是一个keyIndex，其实现了Item接口Less方法，就可以通过给定的key快速查找对应的keyIndex</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// github.com/google/btree/btree.go</span></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">interface</span> &#123;</span><br><span class="line">Less(than Item) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// github.com/etcd/mvcc/key_index.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ki *keyIndex)</span> <span class="title">Less</span><span class="params">(b btree.Item)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> bytes.Compare(ki.key, b.(*keyIndex).key) == <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220223003842.jpg" alt="img" /></p><h4 id="backendboltdb"><a class="markdownIt-Anchor" href="#backendboltdb"></a> Backend/boltdb</h4><p>K：版本号，如{2,0}<br />V：mvccpb.KeyValue 包含用户的kv等信息</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mvccpb.KeyValue <span class="keyword">struct</span> &#123;</span><br><span class="line">Key []<span class="keyword">byte</span></span><br><span class="line">CreateRevision <span class="keyword">int64</span>  <span class="comment">// 创建时的版本号</span></span><br><span class="line">ModRevision <span class="keyword">int64</span>     <span class="comment">// 最后一次修改时的版本号</span></span><br><span class="line">Version <span class="keyword">int64</span>         <span class="comment">// 此key修改的次数 = keyIndex.generations[i].ver + 1</span></span><br><span class="line">Value []<span class="keyword">byte</span>          <span class="comment">// 用户数据</span></span><br><span class="line">Lease <span class="keyword">int64</span>           <span class="comment">// 租约</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h3><h4 id="跟新key"><a class="markdownIt-Anchor" href="#跟新key"></a> 跟新key</h4><ol><li>etcdctl put hello world 发起一个写事务</li><li>根据key从treeIndex B树中查对应的keyIndex信息</li><li>若查到为空，则全局版本号自增，默认是1，生成revision{2,0}</li><li>填充mvccpb.KeyValue结构体</li><li>根据带版本号的key通过Backend 的写事务接口batchTx将 key{2,0},value 为 mvccpb.KeyValue 保存到缓存中</li><li>写事务会在buffer中堆积，默认写事务大于1万才会由Backend异步执行持久化</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *storeTxnWrite)</span> <span class="title">put</span><span class="params">(key, value []<span class="keyword">byte</span>, leaseID lease.LeaseID)</span></span> &#123;</span><br><span class="line">rev := tw.beginRev + <span class="number">1</span></span><br><span class="line">c := rev</span><br><span class="line">oldLease := lease.NoLease</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这个key已存在，则时候用它之前创建的</span></span><br><span class="line">_, created, ver, err := tw.s.kvindex.Get(key, rev)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">c = created.main</span><br><span class="line">oldLease = tw.s.le.GetLease(lease.LeaseItem&#123;Key: <span class="keyword">string</span>(key)&#125;)</span><br><span class="line">&#125;</span><br><span class="line">tw.trace.Step(<span class="string">"get key's previous created_revision and leaseID"</span>)</span><br><span class="line">ibytes := newRevBytes()</span><br><span class="line">idxRev := revision&#123;main: rev, sub: <span class="keyword">int64</span>(<span class="built_in">len</span>(tw.changes))&#125;</span><br><span class="line">revToBytes(idxRev, ibytes)</span><br><span class="line"></span><br><span class="line">ver = ver + <span class="number">1</span></span><br><span class="line">kv := mvccpb.KeyValue&#123;</span><br><span class="line">Key:            key,</span><br><span class="line">Value:          value,</span><br><span class="line">CreateRevision: c,</span><br><span class="line">ModRevision:    rev,</span><br><span class="line">Version:        ver,</span><br><span class="line">Lease:          <span class="keyword">int64</span>(leaseID),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d, err := kv.Marshal()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> tw.storeTxnRead.s.lg != <span class="literal">nil</span> &#123;</span><br><span class="line">tw.storeTxnRead.s.lg.Fatal(</span><br><span class="line"><span class="string">"failed to marshal mvccpb.KeyValue"</span>,</span><br><span class="line">zap.Error(err),</span><br><span class="line">)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">plog.Fatalf(<span class="string">"cannot marshal event: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tw.trace.Step(<span class="string">"marshal mvccpb.KeyValue"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以revision为key，kv为value存入</span></span><br><span class="line">tw.tx.UnsafeSeqPut(keyBucketName, ibytes, d)</span><br><span class="line"> </span><br><span class="line">tw.s.kvindex.Put(key, idxRev)</span><br><span class="line">tw.changes = <span class="built_in">append</span>(tw.changes, kv)</span><br><span class="line">tw.trace.Step(<span class="string">"store kv pair into bolt db"</span>)</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *batchTx)</span> <span class="title">unsafePut</span><span class="params">(bucketName []<span class="keyword">byte</span>, key []<span class="keyword">byte</span>, value []<span class="keyword">byte</span>, seq <span class="keyword">bool</span>)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220223004031.jpg" alt="img" /></p><h4 id="lazy-delete-延期删除"><a class="markdownIt-Anchor" href="#lazy-delete-延期删除"></a> lazy delete 延期删除</h4><ol><li>基于更新key的流程，在生成的新版本号后追加一个标志位t</li><li>generation切片中追加一个空的，使得查询比当前版本号更大时拿到的是空</li><li>bolt mvccpb.KeyValue 结构体清空，只有key</li></ol><ul><li>Watch会根据key上的标志位t生成Delete事件</li><li>重启时，可根据boltkey 上的标志位t来重建treeIndex内存树</li><li>真正的删除是通过压缩（compactor）异步完成</li></ul><h4 id="读取key"><a class="markdownIt-Anchor" href="#读取key"></a> 读取key</h4><ol><li>etcdctl get hello 发起一个读事务</li><li>根据key从treeIndex B树中获取版本号，默认读最新，匹配有效generation后返回切片最后一个版本号给读事务</li><li>根据带版本号的key通过Backend 的ConcurrentReadTx 并发读接口去buffer缓存中查，未命中则再去boltdb找</li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><p>1.<a href="http://www.jcxioo.com/2021/07/22/01_Kubernetes/etcd%20mvcc/" target="_blank" rel="noopener">http://www.jcxioo.com/2021/07/22/01_Kubernetes/etcd mvcc/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;悲观锁：悲观得认为并发事务会冲突，所以要先拿锁，拿到锁的作修改操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读写锁（可多读，写时互斥）、互斥锁（线程互斥）等&lt;/li&gt;
&lt;li&gt;控制粒度太大，高并发下大量事务会被阻塞&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;乐观锁：乐观得认为数据不会冲突，但发生冲突时
      
    
    </summary>
    
    
      <category term="ETCD" scheme="http://xboom.github.io/categories/ETCD/"/>
    
    
      <category term="ETCD" scheme="http://xboom.github.io/tags/ETCD/"/>
    
  </entry>
  
  <entry>
    <title>k8s入门5-容器网络之网络栈</title>
    <link href="http://xboom.github.io/2022/02/21/K8S/k8s%E5%85%A5%E9%97%A85-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/"/>
    <id>http://xboom.github.io/2022/02/21/K8S/k8s%E5%85%A5%E9%97%A85-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/</id>
    <published>2022-02-20T16:35:18.000Z</published>
    <updated>2022-06-25T07:00:00.113Z</updated>
    
    <content type="html"><![CDATA[<h3 id="容器网络"><a class="markdownIt-Anchor" href="#容器网络"></a> 容器网络</h3><p>一个 Linux 容器能看见的“网络栈”，实际上是被隔离在它自己的 Network Namespace 当中的</p><p><strong>网络栈</strong>包括：网卡（Network Interface）、回环设备（Loopback Device）、路由表（Routing Table）和 iptables 规则。这些要素就构成了一个进程发起和响应网络请求的基本环境</p><blockquote><p>回环设备是指拿一个大的镜像文件，如xxx.iso或xxx.img等，在此文件内建立一个文件系统，此文件就像一个新的磁盘或光盘设备一样使用。回环可以理解成回复重用，在已有设备上建立文件来模拟物理块设备</p></blockquote><p>一个容器可以声明直接使用宿主机的网络栈（–net=host），即不开启 Network Namespace</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run –d –net=host --name nginx-host nginx</span></span><br></pre></td></tr></table></figure><p>在这种情况下，容器启动后，直接监听的就是宿主机的 80 端口</p><p>优点：可以为容器提供良好的网络性能，不需要进行网络转发操作</p><p>缺点：不可避免地引入共享网络资源的问题，比如端口冲突</p><p>在大多数情况下，还是希望容器进程能使用自己 Network Namespace 里的网络栈，即：拥有属于自己的 IP 地址和端口</p><p><strong>问题1：这个被隔离的容器进程，该如何跟其他 Network Namespace 里的容器进程进行交互呢？</strong></p><p>在 Linux 中，能够起到虚拟交换机作用的网络设备是<strong>网桥（Bridge）</strong>。它是一个工作在数据链路层（Data Link）的设备，主要功能是根据 MAC 地址学习来将数据包转发到网桥的不同端口（Port）上</p><p>Docker 项目会默认在宿主机上创建一个名叫 docker0 的网桥，凡是连接在 docker0 网桥上的容器，就可以通过它来进行通信</p><p><strong>问题2：如果将容器连接到网桥上?</strong></p><p>答案是使用<strong>Veth Pair</strong>，它被创建出来后，总是以两张虚拟网卡（Veth Peer）的形式成对出现的。并且，从其中一个“网卡”发出的数据包，可以直接出现在与它对应的另一张“网卡”上，哪怕这两个“网卡”在不同的 Network Namespace 里，使得 Veth Pair 被用作连接不同 Network Namespace 的“网线”</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20211112211740.png" alt="image-20211112211740772" style="zoom:67%;" /><p>容器里 eth0 的网卡，正是一个 Veth Pair 设备在容器里的这一端</p><p>通过 route 命令查看 nginx-1 容器的路由表，可以看到，这个 eth0 网卡是这个容器里的默认路由设备；所有对 172.17.0.0/16 网段的请求，也会被交给 eth0 来处理（第二条 172.17.0.0 路由规则）</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20211112212150.png" alt="image-20211112212150070" /></p><p>再查看Veth Pair 设备的另一端(宿主机的网络信息)，nginx-1 容器对应的 Veth Pair 设备，在宿主机上是一张虚拟网卡。它的名字叫作 veth5d20cf2</p><blockquote><p>Mac 无法查看，可以通过上面的host模型进行查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --net=host --name nginx-host nginx</span><br></pre></td></tr></table></figure></blockquote><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20211112213515.png" alt="image-20211112213515134" /></p><p>通过 brctl show 的输出，你可以看到这张网卡被“插”在了 docker0 上</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20211112213626.png" alt="image-20211112213626941" /></p><p>如果再在这台宿主机上启动另外一个容器，将会发现一个新的名字 veth7e63610 也插在docker0网桥上</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20211112213911.png" alt="image-20211112213911105" /></p><p>如果在 nginx-1 容器里 ping 一下 nginx-2 容器的 IP 地址（172.17.0.3），就会发现同一宿主机上的两个容器默认就是相互连通的，这是因为：</p><p>nginx-1 容器里访问 nginx-2 容器的 IP 地址（比如 ping 172.17.0.3）的时候，这个目的 IP 地址会匹配到 nginx-1 容器里的第二条路由规则。这条路由规则的网关（Gateway）是 0.0.0.0，这就意味着这是一条直连规则，即：<strong>凡是匹配到这条规则的 IP 包，应该经过本机的 eth0 网卡，通过二层网络直接发往目的主机</strong></p><p>同一个宿主机上的不同容器通过docker0网桥进行通信</p><img src="https://static001.geekbang.org/resource/image/e0/66/e0d28e0371f93af619e91a86eda99a66.png" alt="img" style="zoom:67%;" /><ol><li><p>要通过二层网络到达 nginx-2 容器，就需要有 172.17.0.3 这个 IP 地址对应的 MAC 地址。所以 nginx-1 容器的网络协议栈，就需要通过 eth0 网卡发送一个 ARP 广播，来通过 IP 地址查找对应的 MAC 地址</p><blockquote><p>ARP(Address Resolution Protocol)，是通过三层的 IP 地址找到对应的二层 MAC 地址的协议。</p></blockquote></li><li><p>这个 eth0 网卡是一个 Veth Pair，它的一端在这个 nginx-1 容器的 Network Namespace 里，而另一端则位于宿主机上（Host Namespace），并且被“插”在了宿主机的 docker0 网桥上，变成该网桥的“从设备”。从设备会被“剥夺”调用网络协议栈处理数据包的资格，从而“降级”成为网桥上的一个端口。而这个端口唯一的作用，就是接收流入的数据包，然后把这些数据包，全部交给对应的网桥。</p></li><li><p>docker0 在收到这些 ARP 请求之后，docker0 网桥就会扮演二层交换机的角色，把 ARP 广播转发到其他被“插”在 docker0 上的虚拟网卡上。这样，同样连接在 docker0 上的 nginx-2 容器的网络协议栈就会收到这个 ARP 请求，从而将 172.17.0.3 所对应的 MAC 地址回复给 nginx-1 容器。</p></li><li><p>有了目的 MAC 地址，nginx-1 容器的 eth0 网卡就 ping 包发出去。而根据 Veth Pair 设备的原理，这个数据包会立刻出现在宿主机上的 veth5d20cf2 虚拟网卡上，然后直接流入到了 docker0 网桥里。</p></li><li><p>docker0 继续扮演二层交换机的角色。docker0 网桥根据数据包的目的 MAC 地址，在它的 CAM 表（即交换机通过 MAC 地址学习维护的端口和 MAC 地址的对应表）里查到对应的端口（Port）为：veth7e63610，然后把数据包发往这个端口。而这个端口，正是 nginx-2 容器“插”在 docker0 网桥上的另一块虚拟网卡，当然，它也是一个 Veth Pair 设备。这样，数据包就进入到了 nginx-2 容器的 Network Namespace 里。</p></li><li><p>nginx-2 的网络协议栈就会对请求进行处理，最后将响应（Pong）返回到 nginx-1。</p></li></ol><blockquote><p>在实际的数据传递时，上述数据的传递过程在网络协议栈的不同层次，都有 Linux 内核 Netfilter 参与其中。通过打开 iptables 的 TRACE 功能查看到数据包的传输过程，在 系统日志 /var/log/syslog  或者 var/log/messages 里看到数据包传输的日志，具体方法如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在宿主机上执行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -t raw -A OUTPUT -p icmp -j TRACE</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -t raw -A PREROUTING -p icmp -j TRACE</span></span><br></pre></td></tr></table></figure></blockquote><p><strong>docker0 网桥的工作方式可以理解为，在默认情况下，被限制在 Network Namespace 里的容器进程，实际上是通过 Veth Pair 设备 + 宿主机网桥的方式，实现了跟同其他容器的数据交换</strong></p><p>在一台宿主机上，访问该宿主机上的容器的 IP 地址时，这个请求的数据包，也是先根据路由规则到达 docker0 网桥，然后被转发到对应的 Veth Pair 设备，最后出现在容器里</p><img src="https://static001.geekbang.org/resource/image/9f/01/9fb381d1e49318bb6a67bda3f9db6901.png" alt="img" style="zoom:67%;" /><p>当一个容器试图连接到另外一个宿主机时，比如：ping 10.168.0.3，</p><ol><li>请求数据包首先经过 docker0 网桥出现在宿主机上。</li><li>然后根据宿主机的路由表里的直连路由规则（10.168.0.0/24 via eth0)），对 10.168.0.3 的访问请求就会交给宿主机的 eth0 处理</li><li>这个数据包就会经宿主机的 eth0 网卡转发到宿主机网络上，最终到达 10.168.0.3 对应的宿主机上。</li></ol><img src="https://static001.geekbang.org/resource/image/90/95/90bd630c0723ea8a1fb7ccd738ad1f95.png" alt="img" style="zoom:67%;" /><p><strong>当遇到容器连不通“外网”的时候，先试试 docker0 网桥能不能 ping 通，然后查看一下跟 docker0 和 Veth Pair 设备相关的 iptables 规则是不是有异常</strong></p><p><strong>问题4：如果在另外一台宿主机（比如：10.168.0.3）上，也有一个 Docker 容器。那么，我们的 nginx-1 容器又该如何访问它呢？</strong></p><p>在 Docker 的默认配置下，一台宿主机上的 docker0 网桥，和其他宿主机上的 docker0 网桥，没有任何关联，它们互相之间也没办法连通。所以，连接在这些网桥上的容器，自然也没办法进行通信了</p><p>创建一个整个集群“公用”的网桥，然后把集群里的所有容器都连接到这个网桥上</p><img src="https://static001.geekbang.org/resource/image/b4/3d/b4387a992352109398a66d1dbe6e413d.png" alt="img" style="zoom:67%;" /><p>构建这种容器网络的核心在于：需要在已有的宿主机网络上，再通过软件构建一个覆盖在已有宿主机网络之上的、可以把所有容器连通在一起的虚拟网络，被称为：<strong>Overlay Network（覆盖网络）</strong></p><h3 id="容器跨主机网络"><a class="markdownIt-Anchor" href="#容器跨主机网络"></a> 容器跨主机网络</h3><h4 id="flannel"><a class="markdownIt-Anchor" href="#flannel"></a> Flannel</h4><p>为了解决这个容器“跨主通信”的问题，出现了那么多的容器网络方案。Flannel 项目是 CoreOS 公司主推的容器网络方案。事实上，Flannel 项目本身只是一个框架，真正为我们提供容器网络功能的，是 Flannel 的后端实现</p><p>Flannel 支持三种后端实现，也代表了三种容器跨主网络的主流实现方法</p><ul><li>VXLAN</li><li>host-gw</li><li>UDP</li></ul><h4 id="udp"><a class="markdownIt-Anchor" href="#udp"></a> UDP</h4><p>假设有两台宿主机：</p><ul><li>宿主机 Node1 上有容器 container-1，它的 IP 地址是 100.96.1.2，docker0 网桥的地址是：100.96.1.1/24</li><li>宿主机 Node2 上有容器 container-2，它的 IP 地址是 100.96.2.3，docker0 网桥的地址是：100.96.2.1/24</li></ul><p>第一步：container-1 容器里的进程发起的 IP 包，其源地址就是 100.96.1.2，目的地址就是 100.96.2.3。</p><p>第二步：由于目的地址 100.96.2.3 并不在 Node 1 的 docker0 网桥的网段里，所以这个 IP 包会被交给默认路由规则，通过容器的网关进入 docker0 网桥（如果是同一台宿主机上的容器间通信，走的是直连规则），从而出现在宿主机上。</p><p>第三步：这时候，这个 IP 包的下一个目的地，就取决于宿主机上的路由规则了。此时，Flannel 已经在宿主机上创建出了一系列的路由规则，以 Node 1 为例，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在Node 1上</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ip route</span></span><br><span class="line">default via 10.168.0.1 dev eth0</span><br><span class="line">100.96.0.0/16 dev flannel0  proto kernel  scope link  src 100.96.1.0</span><br><span class="line">100.96.1.0/24 dev docker0  proto kernel  scope link  src 100.96.1.1</span><br><span class="line">10.168.0.0/24 dev eth0  proto kernel  scope link  src 10.168.0.2</span><br></pre></td></tr></table></figure><p>可以看到，由于我们的 IP 包的目的地址是 100.96.2.3，它匹配不到本机 docker0 网桥对应的 100.96.1.0/24 网段，只能匹配到第二条、也就是 100.96.0.0/16 对应的这条路由规则，从而进入到一个叫作 flannel0 的设备中。</p><blockquote><p>flannel0 的设备类型是一个 TUN 设备，TUN 设备是一种工作在三层（Network Layer）的虚拟网络设备。TUN 设备的功能是在操作系统内核和用户应用程序之间传递 IP 包</p><p>当操作系统将一个 IP 包发送给 flannel0 设备之后，flannel0 就会把这个 IP 包，交给创建这个设备的应用程序，也就是 Flannel 进程。这是一个从内核态（Linux 操作系统）向用户态（Flannel 进程）的流动方向。</p><p>反之，如果 Flannel 进程向 flannel0 设备发送了一个 IP 包，那么这个 IP 包就会出现在宿主机网络栈中，然后根据宿主机的路由表进行下一步处理。这是一个从用户态向内核态的流动方向</p></blockquote><p>当 IP 包从容器经过 docker0 出现在宿主机，然后又根据路由表进入 flannel0 设备后，宿主机上的 flanneld 进程（Flannel 项目在每个宿主机上的主进程），就会收到这个 IP 包。然后，flanneld 看到了这个 IP 包的目的地址，是 100.96.2.3，就把它发送给了 Node 2 宿主机。</p><blockquote><p>那么 flannelId 又是如何知道这个IP地址对应的容器运行在Node 2上面呢？</p></blockquote><p>在由 Flannel 管理的容器网络里，一台宿主机上的所有容器，都属于该宿主机被分配的一个“子网”。在例子中，Node 1 的子网是 100.96.1.0/24，container-1 的 IP 地址是 100.96.1.2。Node 2 的子网是 100.96.2.0/24，container-2 的 IP 地址是 100.96.2.3。而这些子网与宿主机的对应关系，正是保存在 Etcd 当中，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> etcdctl ls /coreos.com/network/subnets</span></span><br><span class="line">/coreos.com/network/subnets/100.96.1.0-24</span><br><span class="line">/coreos.com/network/subnets/100.96.2.0-24</span><br><span class="line">/coreos.com/network/subnets/100.96.3.0-24</span><br></pre></td></tr></table></figure><p>所以，flanneld 进程在处理由 flannel0 传入的 IP 包时，就可以根据目的 IP 的地址（比如 100.96.2.3），匹配到对应的子网（比如 100.96.2.0/24），从 Etcd 中找到这个子网对应的宿主机的 IP 地址是 10.168.0.3</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> etcdctl get /coreos.com/network/subnets/100.96.2.0-24</span></span><br><span class="line">&#123;"PublicIP":"10.168.0.3"&#125;</span><br></pre></td></tr></table></figure><p>而对于 flanneld 来说，只要 Node 1 和 Node 2 是互通的，那么 flanneld 作为 Node 1 上的一个普通进程，就一定可以通过上述 IP 地址（10.168.0.3）访问到 Node 2，这没有任何问题</p><p>**flanneld 在收到 container-1 发给 container-2 的 IP 包之后，就会把这个 IP 包直接封装在一个 UDP 包里，然后发送给 Node 2。**这个 UDP 包的源地址，就是 flanneld 所在的 Node 1 的地址，而目的地址，则是 container-2 所在的宿主机 Node 2 的地址。</p><p>当然，这个请求得以完成的原因是，每台宿主机上的 flanneld，都监听着一个 <code>8285</code> 端口，所以 flanneld 只要把 UDP 包发往 Node 2 的 <code>8285</code> 端口即可。</p><p>通过这样一个普通的、宿主机之间的 UDP 通信，一个 UDP 包就从 Node 1 到达了 Node 2。而 Node 2 上监听 8285 端口的进程也是 flanneld，所以这时候，flanneld 就可以从这个 UDP 包里解析出封装在里面的、container-1 发来的原 IP 包。</p><p>而接下来 flanneld 的工作就非常简单了：flanneld 会直接把这个 IP 包发送给它所管理的 TUN 设备，即 flannel0 设备。根据我前面讲解的 TUN 设备的原理，这正是一个从用户态向内核态的流动方向（Flannel 进程向 TUN 设备发送数据包），所以 Linux 内核网络栈就会负责处理这个 IP 包，具体的处理方法，就是通过本机的路由表来寻找这个 IP 包的下一步流向。而 Node 2 上的路由表，跟 Node 1 非常类似，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在Node 2上</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ip route</span></span><br><span class="line">default via 10.168.0.1 dev eth0</span><br><span class="line">100.96.0.0/16 dev flannel0  proto kernel  scope link  src 100.96.2.0</span><br><span class="line">100.96.2.0/24 dev docker0  proto kernel  scope link  src 100.96.2.1</span><br><span class="line">10.168.0.0/24 dev eth0  proto kernel  scope link  src 10.168.0.3</span><br></pre></td></tr></table></figure><p>由于这个 IP 包的目的地址是 100.96.2.3，它跟第三条、也就是 100.96.2.0/24 网段对应的路由规则匹配更加精确。所以，Linux 内核就会按照这条路由规则，把这个 IP 包转发给 docker0 网桥。</p><p>接下来的流程，docker0 网桥会扮演二层交换机的角色，将数据包发送给正确的端口，进而通过 Veth Pair 设备进入到 container-2 的 Network Namespace 里。而 container-2 返回给 container-1 的数据包，则会经过与上述过程完全相反的路径回到 container-1 中。</p><blockquote><p>需要注意的是，上述流程要正确工作还有一个重要的前提，那就是 docker0 网桥的地址范围必须是 Flannel 为宿主机分配的子网。这个很容易实现，以 Node 1 为例，你只需要给它上面的 Docker Daemon 启动时配置如下所示的 bip 参数即可：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> FLANNEL_SUBNET=100.96.1.1/24</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dockerd --bip=<span class="variable">$FLANNEL_SUBNET</span> ...</span></span><br></pre></td></tr></table></figure><p>以上，就是基于 Flannel UDP 模式的跨主通信的基本原理了，如下所示。</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20211112235123.jpg" alt="img" style="zoom:67%;" /><p>可以看到，Flannel UDP 模式提供的其实是一个三层的 Overlay 网络，即：它首先对发出端的 IP 包进行 UDP 封装，然后在接收端进行解封装拿到原始的 IP 包，进而把这个 IP 包转发给目标容器。这就好比，Flannel 在不同宿主机上的两个容器之间打通了一条“隧道”，使得这两个容器可以直接使用 IP 地址进行通信，而无需关心容器和宿主机的分布情况。</p><p>上述 UDP 模式有严重的性能问题，所以已经被废弃了。</p><p>相比于两台宿主机之间的直接通信，基于 Flannel UDP 模式的容器通信多了一个额外的步骤，即 flanneld 的处理过程。而这个过程，由于使用到了 flannel0 这个 TUN 设备，仅在发出 IP 包的过程中，就需要经过三次用户态与内核态之间的数据拷贝，如下所示：</p><img src="https://static001.geekbang.org/resource/image/84/8d/84caa6dc3f9dcdf8b88b56bd2e22138d.png" alt="img" style="zoom:67%;" /><p>可以看到：</p><ol><li>第一次，用户态的容器进程发出的 IP 包经过 docker0 网桥进入内核态；</li><li>第二次，IP 包根据路由表进入 TUN（flannel0）设备，从而回到用户态的 flanneld 进程；</li><li>第三次，flanneld 进行 UDP 封包之后重新进入内核态，将 UDP 包通过宿主机的 eth0 发出去。</li></ol><p>此外，我们还可以看到，Flannel 进行 UDP 封装（Encapsulation）和解封装（Decapsulation）的过程，也都是在用户态完成的。这也正是造成 Flannel UDP 模式性能不好的主要原因</p><h4 id="vxlan"><a class="markdownIt-Anchor" href="#vxlan"></a> VXLAN</h4><p>即 Virtual Extensible LAN（虚拟可扩展局域网），是 Linux 内核本身就支持的一种网络虚似化技术。所以说，VXLAN 可以完全在内核态实现上述封装和解封装的工作，从而通过与前面相似的“隧道”机制，构建出覆盖网络（Overlay Network）</p><p>VXLAN 的覆盖网络的设计思想是：在现有的三层网络之上，“覆盖”一层虚拟的、由内核 VXLAN 模块负责维护的二层网络，使得连接在这个 VXLAN 二层网络上的“主机”（虚拟机或者容器都可以）之间，可以像在同一个局域网（LAN）里那样自由通信。当然，实际上，这些“主机”可能分布在不同的宿主机上，甚至是分布在不同的物理机房里。</p><p>而为了能够在二层网络上打通“隧道”，VXLAN 会在宿主机上设置一个特殊的网络设备作为“隧道”的两端。这个设备就叫作 VTEP，即：VXLAN Tunnel End Point（虚拟隧道端点）。</p><p>而 VTEP 设备的作用，其实跟前面的 flanneld 进程非常相似。只不过，它进行封装和解封装的对象，是二层数据帧（Ethernet frame）；而且这个工作的执行流程，全部是在内核里完成的（因为 VXLAN 本身就是 Linux 内核中的一个模块）。</p><p>上述基于 VTEP 设备进行“隧道”通信的流程，如下所示：</p><img src="https://static001.geekbang.org/resource/image/03/f5/03185fab251a833fef7ed6665d5049f5.jpg" alt="img" style="zoom:67%;" /><p>可以看到，图中每台宿主机上名叫 flannel.1 的设备，就是 VXLAN 所需的 VTEP 设备，它既有 IP 地址，也有 MAC 地址。现在，我们的 container-1 的 IP 地址是 10.1.15.2，要访问的 container-2 的 IP 地址是 10.1.16.3。那么，与前面 UDP 模式的流程类似，当 container-1 发出请求之后，这个目的地址是 10.1.16.3 的 IP 包，会先出现在 docker0 网桥，然后被路由到本机 flannel.1 设备进行处理。也就是说，来到了“隧道”的入口。为了方便叙述，我接下来会把这个 IP 包称为“原始 IP 包”。</p><p>为了能够将“原始 IP 包”封装并且发送到正确的宿主机，VXLAN 就需要找到这条“隧道”的出口，即：目的宿主机的 VTEP 设备。而这个设备的信息，正是每台宿主机上的 flanneld 进程负责维护的。比如，当 Node 2 启动并加入 Flannel 网络之后，在 Node 1（以及所有其他节点）上，flanneld 就会添加一条如下所示的路由规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> route -n</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">...</span><br><span class="line">10.1.16.0       10.1.16.0       255.255.255.0   UG    0      0        0 flannel.1</span><br></pre></td></tr></table></figure><p>这条规则的意思是：凡是发往 10.1.16.0/24 网段的 IP 包，都需要经过 flannel.1 设备发出，并且，它最后被发往的网关地址是：10.1.16.0。从图 3 的 Flannel VXLAN 模式的流程图中我们可以看到，10.1.16.0 正是 Node 2 上的 VTEP 设备（也就是 flannel.1 设备）的 IP 地址。为了方便叙述，接下来我会把 Node 1 和 Node 2 上的 flannel.1 设备分别称为“源 VTEP 设备”和“目的 VTEP 设备”。而这些 VTEP 设备之间，就需要想办法组成一个虚拟的二层网络，即：通过二层数据帧进行通信。</p><p>“源 VTEP 设备”收到“原始 IP 包”后，就要想办法把“原始 IP 包”加上一个目的 MAC 地址，封装成一个二层数据帧，然后发送给“目的 VTEP 设备”（当然，这么做还是因为这个 IP 包的目的地址不是本机）。</p><p><strong>目的 VTEP 设备 的 MAC 地址是什么？</strong></p><p>此时，根据前面的路由记录，我们已经知道了“目的 VTEP 设备”的 IP 地址。而要根据三层 IP 地址查询对应的二层 MAC 地址，这正是 ARP（Address Resolution Protocol ）表的功能。而这里要用到的 ARP 记录，也是 flanneld 进程在 Node 2 节点启动时，自动添加在 Node 1 上的。我们可以通过 ip 命令看到它，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在Node 1上</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ip neigh show dev flannel.1</span></span><br><span class="line">10.1.16.0 lladdr 5e:f8:4f:00:e3:37 PERMANENT</span><br></pre></td></tr></table></figure><p>这条记录的意思非常明确，即：IP 地址 10.1.16.0，对应的 MAC 地址是 5e:f8:4f:00:e3:37。</p><blockquote><p>可以看到，最新版本的 Flannel 并不依赖 L3 MISS 事件和 ARP 学习，而会在每台节点启动时把它的 VTEP 设备对应的 ARP 记录，直接下放到其他每台宿主机上</p></blockquote><p>有了这个“目的 VTEP 设备”的 MAC 地址，Linux 内核就可以开始二层封包工作了。这个二层帧的格式，如下所示：</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20211113001610.jpg" alt="img" /></p><p>可以看到，Linux 内核会把“目的 VTEP 设备”的 MAC 地址，填写在图中的 Inner Ethernet Header 字段，得到一个二层数据帧。需要注意的是，上述封包过程只是加一个二层头，不会改变“原始 IP 包”的内容。所以图中的 Inner IP Header 字段，依然是 container-2 的 IP 地址，即 10.1.16.3。</p><p>但是，上面提到的这些 VTEP 设备的 MAC 地址，对于宿主机网络来说并没有什么实际意义。所以上面封装出来的这个数据帧，并不能在我们的宿主机二层网络里传输。为了方便叙述，我们把它称为“内部数据帧”（Inner Ethernet Frame）。Linux 内核还需要再把“内部数据帧”进一步封装成为宿主机网络里的一个普通的数据帧，好让它“载着”“内部数据帧”，通过宿主机的 eth0 网卡进行传输。我们把这次要封装出来的、宿主机对应的数据帧称为“外部数据帧”（Outer Ethernet Frame）。</p><p>为了实现这个“搭便车”的机制，Linux 内核会在“内部数据帧”前面，加上一个特殊的 VXLAN 头，用来表示这个“乘客”实际上是一个 VXLAN 要使用的数据帧。而这个 VXLAN 头里有一个重要的标志叫作 VNI，它是 VTEP 设备识别某个数据帧是不是应该归自己处理的重要标识。而在 Flannel 中，VNI 的默认值是 1，这也是为何，宿主机上的 VTEP 设备都叫作 flannel.1 的原因，这里的“1”，其实就是 VNI 的值。</p><p>然后，Linux 内核会把这个数据帧封装进一个 UDP 包里发出去。</p><p>所以，跟 UDP 模式类似，在宿主机看来，它会以为自己的 flannel.1 设备只是在向另外一台宿主机的 flannel.1 设备，发起了一次普通的 UDP 链接。它哪里会知道，这个 UDP 包里面，其实是一个完整的二层数据帧。这是不是跟特洛伊木马的故事非常像呢？不过，不要忘了，一个 flannel.1 设备只知道另一端的 flannel.1 设备的 MAC 地址，却不知道对应的宿主机地址是什么。也就是说，这个 UDP 包该发给哪台宿主机呢？在这种场景下，flannel.1 设备实际上要扮演一个“网桥”的角色，在二层网络进行 UDP 包的转发。而在 Linux 内核里面，“网桥”设备进行转发的依据，来自于一个叫作 FDB（Forwarding Database）的转发数据库。</p><p>不难想到，这个 flannel.1“网桥”对应的 FDB 信息，也是 flanneld 进程负责维护的。它的内容可以通过 bridge fdb 命令查看到，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在Node 1上，使用“目的VTEP设备”的MAC地址进行查询</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bridge fdb show flannel.1 | grep 5e:f8:4f:00:e3:37</span></span><br><span class="line">5e:f8:4f:00:e3:37 dev flannel.1 dst 10.168.0.3 self permanent</span><br></pre></td></tr></table></figure><p>可以看到，在上面这条 FDB 记录里，指定了这样一条规则，即：发往我们前面提到的“目的 VTEP 设备”（MAC 地址是 5e:f8:4f:00:e3:37）的二层数据帧，应该通过 flannel.1 设备，发往 IP 地址为 10.168.0.3 的主机。显然，这台主机正是 Node 2，UDP 包要发往的目的地就找到了。</p><p>所以接下来的流程，就是一个正常的、宿主机网络上的封包工作。</p><p>我们知道，UDP 包是一个四层数据包，所以 Linux 内核会在它前面加上一个 IP 头，即原理图中的 Outer IP Header，组成一个 IP 包。并且，在这个 IP 头里，会填上前面通过 FDB 查询出来的目的主机的 IP 地址，即 Node 2 的 IP 地址 10.168.0.3。然后，Linux 内核再在这个 IP 包前面加上二层数据帧头，即原理图中的 Outer Ethernet Header，并把 Node 2 的 MAC 地址填进去。这个 MAC 地址本身，是 Node 1 的 ARP 表要学习的内容，无需 Flannel 维护。这时候，我们封装出来的“外部数据帧”的格式，如下所示：</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20211113001850.jpg" alt="img" /></p><p>这样，封包工作就宣告完成了。接下来，Node 1 上的 flannel.1 设备就可以把这个数据帧从 Node 1 的 eth0 网卡发出去。显然，这个帧会经过宿主机网络来到 Node 2 的 eth0 网卡。这时候，Node 2 的内核网络栈会发现这个数据帧里有 VXLAN Header，并且 VNI=1。所以 Linux 内核会对它进行拆包，拿到里面的内部数据帧，然后根据 VNI 的值，把它交给 Node 2 上的 flannel.1 设备。而 flannel.1 设备则会进一步拆包，取出“原始 IP 包”。接下来就回到了我在上一篇文章中分享的单机容器网络的处理流程。最终，IP 包就进入到了 container-2 容器的 Network Namespace 里。以上，就是 Flannel VXLAN 模式的具体工作原理了。</p><blockquote><p>Flannel 能负责保证二层网络（MAC 地址）的连通性吗？</p></blockquote><h3 id="cni网络插件"><a class="markdownIt-Anchor" href="#cni网络插件"></a> CNI网络插件</h3><p>UDP与VXLAN都需要容器连接在 docker0 网桥上。而网络插件则在宿主机上创建了一个特殊的设备（UDP 模式创建的是 TUN 设备，VXLAN 模式创建的则是 VTEP 设备），docker0 与这个设备之间，通过 IP 转发（路由表）进行协作</p><p>网络插件是通过某种方法，把不同宿主机上的特殊设备连通，从而达到容器跨主机通信的目的。</p><p>Kubernetes 是通过一个叫作 CNI 的接口，维护了一个单独的网桥来代替 docker0。这个网桥的名字就叫作：CNI 网桥，它在宿主机上的设备名称默认是：cni0</p><p>以 Flannel 的 VXLAN 模式为例，在 Kubernetes 环境里，它的工作方式跟我们在上一篇文章中讲解的没有任何不同。只不过，docker0 网桥被替换成了 CNI 网桥而已</p><img src="https://static001.geekbang.org/resource/image/9f/8c/9f11d8716f6d895ff6d1c813d460488c.jpg" alt="img" style="zoom:67%;" /><p>Kubernetes 为 Flannel 分配的子网范围是 10.244.0.0/16。这个参数可以在部署的时候指定</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubeadm init --pod-network-cidr=10.244.0.0/16</span></span><br></pre></td></tr></table></figure><p>也可以在部署完成后，通过修改 kube-controller-manager 的配置文件来指定。这时候，假设 Infra-container-1 要访问 Infra-container-2（也就是 Pod-1 要访问 Pod-2），这个 IP 包的源地址就是 10.244.0.2，目的 IP 地址是 10.244.1.3。而此时，Infra-container-1 里的 eth0 设备，同样是以 Veth Pair 的方式连接在 Node 1 的 cni0 网桥上。所以这个 IP 包就会经过 cni0 网桥出现在宿主机上</p><p>此时，Node 1 上的路由表，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在Node 1上</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> route -n</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">...</span><br><span class="line">10.244.0.0      0.0.0.0         255.255.255.0   U     0      0        0 cni0</span><br><span class="line">10.244.1.0      10.244.1.0      255.255.255.0   UG    0      0        0 flannel.1</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br></pre></td></tr></table></figure><p>因为我们的 IP 包的目的 IP 地址是 10.244.1.3，所以它只能匹配到第二条规则，也就是 10.244.1.0 对应的这条路由规则。可以看到，这条规则指定了本机的 flannel.1 设备进行处理。并且，flannel.1 在处理完后，要将 IP 包转发到的网关（Gateway），正是“隧道”另一端的 VTEP 设备，也就是 Node 2 的 flannel.1 设备。所以，接下来的流程，就跟上一篇文章中介绍过的 Flannel VXLAN 模式完全一样了</p><p>需要注意的是，<strong>CNI 网桥只是接管所有 CNI 插件负责的、即 Kubernetes 创建的容器（Pod）</strong>。而此时，如果你用 docker run 单独启动一个容器，那么 Docker 项目还是会把这个容器连接到 docker0 网桥上。所以这个容器的 IP 地址，一定是属于 docker0 网桥的 172.17.0.0/16 网段。</p><p>Kubernetes 之所以要设置这样一个与 docker0 网桥功能几乎一样的 CNI 网桥，主要原因包括两个方面：</p><ul><li>一方面，Kubernetes 项目并没有使用 Docker 的网络模型（CNM），所以它并不希望、也不具备配置 docker0 网桥的能力；</li><li>另一方面，这还与 Kubernetes 如何配置 Pod，也就是 Infra 容器的 Network Namespace 密切相关。</li></ul><p>Kubernetes 创建一个 Pod 的第一步，就是创建并启动一个 Infra 容器，用来“hold”住这个 Pod 的 Network Namespace。所以，CNI 的设计思想，就是：Kubernetes 在启动 Infra 容器之后，就可以直接调用 CNI 网络插件，为这个 Infra 容器的 Network Namespace，配置符合预期的网络栈。</p><p>那么它是怎么完成这个网络栈的配置的呢？</p><p>在部署 Kubernetes 的时候，有一个步骤是安装 kubernetes-cni 包，它的目的就是在宿主机上安装 CNI 插件所需的基础可执行文件，在安装完成后，你可以在宿主机的 /opt/cni/bin 目录下看到它们，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -al /opt/cni/bin/</span></span><br><span class="line">total 73088</span><br><span class="line">-rwxr-xr-x 1 root root  3890407 Aug 17  2017 bridge</span><br><span class="line">-rwxr-xr-x 1 root root  9921982 Aug 17  2017 dhcp</span><br><span class="line">-rwxr-xr-x 1 root root  2814104 Aug 17  2017 flannel</span><br><span class="line">-rwxr-xr-x 1 root root  2991965 Aug 17  2017 host-local</span><br><span class="line">-rwxr-xr-x 1 root root  3475802 Aug 17  2017 ipvlan</span><br><span class="line">-rwxr-xr-x 1 root root  3026388 Aug 17  2017 loopback</span><br><span class="line">-rwxr-xr-x 1 root root  3520724 Aug 17  2017 macvlan</span><br><span class="line">-rwxr-xr-x 1 root root  3470464 Aug 17  2017 portmap</span><br><span class="line">-rwxr-xr-x 1 root root  3877986 Aug 17  2017 ptp</span><br><span class="line">-rwxr-xr-x 1 root root  2605279 Aug 17  2017 sample</span><br><span class="line">-rwxr-xr-x 1 root root  2808402 Aug 17  2017 tuning</span><br><span class="line">-rwxr-xr-x 1 root root  3475750 Aug 17  2017 vlan</span><br></pre></td></tr></table></figure><p>这些 CNI 的基础可执行文件，按照功能可以分为三类：</p><ul><li>第一类，叫作 Main 插件，它是用来创建具体网络设备的二进制文件。比如，bridge（网桥设备）、ipvlan、loopback（lo 设备）、macvlan、ptp（Veth Pair 设备），以及 vlan。我在前面提到过的 Flannel、Weave 等项目，都属于“网桥”类型的 CNI 插件。所以在具体的实现中，它们往往会调用 bridge 这个二进制文件。</li><li>第二类，叫作 IPAM（IP Address Management）插件，它是负责分配 IP 地址的二进制文件。比如，dhcp，这个文件会向 DHCP 服务器发起请求；host-local，则会使用预先配置的 IP 地址段来进行分配。</li><li>第三类，是由 CNI 社区维护的内置 CNI 插件。比如：<ul><li>flannel，就是专门为 Flannel 项目提供的 CNI 插件；</li><li>tuning，是一个通过 sysctl 调整网络设备参数的二进制文件；</li><li>portmap，是一个通过 iptables 配置端口映射的二进制文件；</li><li>bandwidth，是一个使用 Token Bucket Filter (TBF) 来进行限流的二进制文件。</li></ul></li></ul><p>从这些二进制文件中，我们可以看到，如果要实现一个给 Kubernetes 用的容器网络方案，其实需要做两部分工作，以 Flannel 项目为例：</p><p>首先，实现这个网络方案本身。这一部分需要编写的，其实就是 flanneld 进程里的主要逻辑。比如，创建和配置 flannel.1 设备、配置宿主机路由、配置 ARP 和 FDB 表里的信息等等。然后，实现该网络方案对应的 CNI 插件。这一部分主要需要做的，就是配置 Infra 容器里面的网络栈，并把它连接在 CNI 网桥上。</p><p>由于 Flannel 项目对应的 CNI 插件已经被内置了，所以它无需再单独安装。而对于 Weave、Calico 等其他项目来说，我们就必须在安装插件的时候，把对应的 CNI 插件的可执行文件放在 /opt/cni/bin/ 目录下。</p><blockquote><p>实际上，对于 Weave、Calico 这样的网络方案来说，它们的 DaemonSet 只需要挂载宿主机的 /opt/cni/bin/，就可以实现插件可执行文件的安装了。你可以想一下具体应该怎么做，就当作一个课后小问题留给你去实践了。</p></blockquote><p>接下来，你就需要在宿主机上安装 flanneld（网络方案本身）。而在这个过程中，flanneld 启动后会在每台宿主机上生成它对应的 CNI 配置文件（它其实是一个 ConfigMap），从而告诉 Kubernetes，这个集群要使用 Flannel 作为容器网络方案。</p><p>这个 CNI 配置文件的内容如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">cat</span> <span class="string">/etc/cni/net.d/10-flannel.conflist</span> </span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line">  <span class="attr">"name":</span> <span class="string">"cbr0"</span><span class="string">,</span></span><br><span class="line">  <span class="attr">"plugins":</span> <span class="string">[</span></span><br><span class="line">    <span class="string">&#123;</span></span><br><span class="line">      <span class="attr">"type":</span> <span class="string">"flannel"</span><span class="string">,</span></span><br><span class="line">      <span class="attr">"delegate":</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">"hairpinMode":</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">        <span class="attr">"isDefaultGateway":</span> <span class="literal">true</span></span><br><span class="line">      <span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;,</span></span><br><span class="line">    <span class="string">&#123;</span></span><br><span class="line">      <span class="attr">"type":</span> <span class="string">"portmap"</span><span class="string">,</span></span><br><span class="line">      <span class="attr">"capabilities":</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">"portMappings":</span> <span class="literal">true</span></span><br><span class="line">      <span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="soft-multi-tenancy"><a class="markdownIt-Anchor" href="#soft-multi-tenancy"></a> Soft multi-tenancy</h3><p>为什么说 Kubernetes 只有 soft multi-tenancy？</p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li>《极客时间-深入剖析 Kubernetes》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;容器网络&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#容器网络&quot;&gt;&lt;/a&gt; 容器网络&lt;/h3&gt;
&lt;p&gt;一个 Linux 容器能看见的“网络栈”，实际上是被隔离在它自己的 Network Namespace 当中的&lt;/p&gt;
&lt;p&gt;&lt;st
      
    
    </summary>
    
    
      <category term="k8s" scheme="http://xboom.github.io/categories/k8s/"/>
    
    
      <category term="k8s" scheme="http://xboom.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>k8s入门13-容器网络之Service和Ingress</title>
    <link href="http://xboom.github.io/2022/02/21/K8S/k8s%E5%85%A5%E9%97%A813-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%B9%8BService%E5%92%8CIngress/"/>
    <id>http://xboom.github.io/2022/02/21/K8S/k8s%E5%85%A5%E9%97%A813-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%B9%8BService%E5%92%8CIngress/</id>
    <published>2022-02-20T16:35:06.000Z</published>
    <updated>2022-02-20T16:36:12.237Z</updated>
    
    <content type="html"><![CDATA[<p>Service 暴露给外界的三种方法中有一个叫作 LoadBalancer 类型的 Service，它会为你在 Cloud Provider（比如：Google Cloud 或者 OpenStack）里创建一个与该 Service 对应的负载均衡服务</p><p>由于每个 Service 都要有一个负载均衡服务，为什么没有一个内置一个全局的负载均衡器。通过访问的 URL，把请求转发给不同的后端 Service。</p><p>这种全局的、为了代理不同后端 Service 而设置的负载均衡服务，就是 Kubernetes 里的 Ingress 服务。可以说是 Service 的“Service”。</p><p>举个例子，假如我现在有这样一个站点：<a href="https://cafe.example.com" target="_blank" rel="noopener">https://cafe.example.com</a>。其中，</p><p><a href="https://cafe.example.com/coffee%EF%BC%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E6%98%AF%E2%80%9C%E5%92%96%E5%95%A1%E7%82%B9%E9%A4%90%E7%B3%BB%E7%BB%9F%E2%80%9D%E3%80%82" target="_blank" rel="noopener">https://cafe.example.com/coffee，对应的是“咖啡点餐系统”。</a></p><p><a href="https://cafe.example.com/tea%EF%BC%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E5%88%99%E6%98%AF%E2%80%9C%E8%8C%B6%E6%B0%B4%E7%82%B9%E9%A4%90%E7%B3%BB%E7%BB%9F%E2%80%9D%E3%80%82" target="_blank" rel="noopener">https://cafe.example.com/tea，对应的则是“茶水点餐系统”。</a></p><p>这两个系统，分别由名叫 coffee 和 tea 这样两个 Deployment 来提供服务</p><p>如何能使用 Kubernetes 的 Ingress 来创建一个统一的负载均衡器，从而实现当用户访问不同的域名时，能够访问到不同的 Deployment 呢？</p><p>在 Kubernetes 里就需要通过 Ingress 对象来描述，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cafe-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cafe.example.com</span></span><br><span class="line">    <span class="attr">secretName:</span> <span class="string">cafe-secret</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">cafe.example.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/tea</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">tea-svc</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/coffee</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">coffee-svc</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>在 Kubernetes 里，文件的 <code>rules</code> 字段叫作：IngressRule</p><p>IngressRule 的 Key 就叫做：host。它<strong>必须</strong>是一个标准的域名格式（Fully Qualified Domain Name）的字符串，而不能是 IP 地址。</p><p>而 <code>host</code> 字段定义的值就是这个 Ingress 的入口。当用户访问 <code>cafe.example.com</code> 的时候，实际上访问到的是这个 Ingress 对象。这样，Kubernetes 就能使用 IngressRule 来对你的请求进行下一步转发。</p><p>接下来 IngressRule 规则的定义，则依赖于 <code>path</code> 字段。你可以简单地理解为，这里的每一个 path 都对应一个后端 Service。所以在我们的例子里，我定义了两个 path，它们分别对应 coffee 和 tea 这两个 Deployment 的 Service（即：coffee-svc 和 tea-svc）</p><p>所以所谓 Ingress 对象，其实就是 Kubernetes 项目对“反向代理”的一种抽象。而这个代理服务对应的转发规则，就是 IngressRule。跟 Nginx、HAproxy 等项目的配置文件的写法是一致的。Kubernetes 的用户就无需关心 Ingress 的具体细节了。选择一个具体的 Ingress Controller，把它部署在 Kubernetes 集群里即可</p><p>这个 Ingress Controller 会根据你定义的 Ingress 对象，提供对应的代理能力。目前，业界常用的各种反向代理项目，比如 Nginx、HAProxy、Envoy、Traefik 等，都已经为 Kubernetes 专门维护了对应的 Ingress Controller。</p><p>以最常用的 Nginx Ingress Controller 为例，在用 kubeadm 部署的 Bare-metal 环境中，实践 Ingress 机制的使用过程。</p><p>部署 Nginx Ingress Controller 的方法非常简单，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/mandatory.yaml</span></span><br></pre></td></tr></table></figure><p>在mandatory.yaml这个文件里，正是 Nginx 官方为你维护的 Ingress Controller 的定义。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-configuration</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-ingress-controller</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">      <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">        <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line">      <span class="attr">annotations:</span></span><br><span class="line">        <span class="string">...</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">nginx-ingress-serviceaccount</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-ingress-controller</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.20.0</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/nginx-ingress-controller</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--configmap=$(POD_NAMESPACE)/nginx-configuration</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--publish-service=$(POD_NAMESPACE)/ingress-nginx</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--annotations-prefix=nginx.ingress.kubernetes.io</span></span><br><span class="line">          <span class="attr">securityContext:</span></span><br><span class="line">            <span class="attr">capabilities:</span></span><br><span class="line">              <span class="attr">drop:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">ALL</span></span><br><span class="line">              <span class="attr">add:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">NET_BIND_SERVICE</span></span><br><span class="line">            <span class="comment"># www-data -&gt; 33</span></span><br><span class="line">            <span class="attr">runAsUser:</span> <span class="number">33</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POD_NAME</span></span><br><span class="line">              <span class="attr">valueFrom:</span></span><br><span class="line">                <span class="attr">fieldRef:</span></span><br><span class="line">                  <span class="attr">fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POD_NAMESPACE</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">              <span class="attr">valueFrom:</span></span><br><span class="line">                <span class="attr">fieldRef:</span></span><br><span class="line">                  <span class="attr">fieldPath:</span> <span class="string">metadata.namespace</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">              <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">              <span class="attr">containerPort:</span> <span class="number">443</span></span><br></pre></td></tr></table></figure><p>上述是使用 nginx-ingress-controller 镜像的 Pod。</p><blockquote><p>注意: 这个 Pod 的启动命令需要使用该 Pod 所在的 Namespace 作为参数{POD_NAMESPACE}。而这个信息，当然是通过 Downward API 拿到的，即：Pod 的 env 字段里的定义（env.valueFrom.fieldRef.fieldPath）</p></blockquote><p>而这个 Pod 本身，就是一个监听 Ingress 对象以及它所代理的后端 Service 变化的控制器。</p><p>当一个新的 Ingress 对象由用户创建后，nginx-ingress-controller 就会根据 Ingress 对象里定义的内容，生成一份对应的 Nginx 配置文件（/etc/nginx/nginx.conf），并使用这个配置文件启动一个 Nginx 服务。</p><p>而一旦 Ingress 对象被更新，nginx-ingress-controller 就会更新这个配置文件。需要注意的是，如果这里只是被代理的 Service 对象被更新，nginx-ingress-controller 所管理的 Nginx 服务是不<strong>需要重新加载</strong>（reload）的。这当然是因为 nginx-ingress-controller 通过Nginx Lua方案实现了 Nginx Upstream 的动态配置</p><p>此外，nginx-ingress-controller 还允许你通过 Kubernetes 的 ConfigMap 对象来对上述 Nginx 配置文件进行定制。这个 ConfigMap 的名字，需要以参数的方式传递给 nginx-ingress-controller。而你在这个 ConfigMap 里添加的字段，将会被合并到最后生成的 Nginx 配置文件当中。可以看到，一个 Nginx Ingress Controller 为你提供的服务，其实是一个可以根据 Ingress 对象和被代理后端 Service 的变化，来自动进行更新的 Nginx 负载均衡器。</p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li>《极客时间-深入剖析Kubernetes》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Service 暴露给外界的三种方法中有一个叫作 LoadBalancer 类型的 Service，它会为你在 Cloud Provider（比如：Google Cloud 或者 OpenStack）里创建一个与该 Service 对应的负载均衡服务&lt;/p&gt;
&lt;p&gt;由于每个
      
    
    </summary>
    
    
      <category term="k8s" scheme="http://xboom.github.io/categories/k8s/"/>
    
    
      <category term="k8s" scheme="http://xboom.github.io/tags/k8s/"/>
    
  </entry>
  
</feed>
