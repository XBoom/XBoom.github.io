<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XBoom Dove</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xboom.github.io/"/>
  <updated>2022-07-06T14:47:08.333Z</updated>
  <id>http://xboom.github.io/</id>
  
  <author>
    <name>XBoom Dove</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>go-zero4-协程池1</title>
    <link href="http://xboom.github.io/2022/07/06/GoZero/GoZero4-%E5%8D%8F%E7%A8%8B%E6%B1%A01/"/>
    <id>http://xboom.github.io/2022/07/06/GoZero/GoZero4-%E5%8D%8F%E7%A8%8B%E6%B1%A01/</id>
    <published>2022-07-06T13:53:58.640Z</published>
    <updated>2022-07-06T14:47:08.333Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h3><p>需要协程池吗？</p><p>虽然协程非常轻量级的，一般用不上协程池。协程池的作用 无休止地创建大量goroutine，势必会因为对大量go 程的创建、调度和销毁带来性能损耗。 为了解决这个问题，可以引入协程池</p><h3 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h3><p>协程池需要什么？</p><ol><li>协程如何重用、任务如何执行</li><li>协程池支持自定义协程池大小</li><li>如果当前任务数量超过协程池大小，那么当前任务需要等待，等待时间支持超时退出</li><li>协程支持自定义退出</li><li>异常捕获，防止因为单个协程的异常处理导致整个协程池无法使用</li></ol><p>协程池大致的逻辑如下图所示：</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/gopools1.png" alt="gopools1" /></p><h4 id="方案1"><a class="markdownIt-Anchor" href="#方案1"></a> 方案1</h4><p>这是一个网上能搜到的 “100行实现一个协程池”，</p><p><strong>第一步</strong>：定义一个任务</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">    Handler <span class="function"><span class="keyword">func</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line">    Params  []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实是将需要执行的协程方法，使用结构体封装起来</p><p><strong>第二步</strong>：定义一个协程池</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">    capacity       <span class="keyword">uint64</span><span class="comment">//容量</span></span><br><span class="line">    runningWorkers <span class="keyword">uint64</span><span class="comment">//正在运行的协程树</span></span><br><span class="line">    status          <span class="keyword">int64</span>           <span class="comment">//状态(防止在退出过程中，仍然在新建协程)</span></span><br><span class="line">    chTask          <span class="keyword">chan</span> *Task      <span class="comment">//任务队列</span></span><br><span class="line">    PanicHandler   <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span>//<span class="title">panic</span>处理函数</span></span><br><span class="line">    sync.Mutex<span class="comment">//原子锁,用于保证runningWorkers原子数据变化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    RUNNING = <span class="number">1</span></span><br><span class="line">    STOPED = <span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>：利用协程池启动一个协程执行任务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.incRunning()<span class="comment">//增加正在运行的协程数目</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.decRunning()<span class="comment">//结束任务</span></span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p.PanicHandler != <span class="literal">nil</span> &#123;</span><br><span class="line">p.PanicHandler(r)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"Worker panic: %s\n"</span>, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p.checkWorker() <span class="comment">// check worker avoid no worker running</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> task, ok := &lt;-p.chTask:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">task.Handler(task.Params...)<span class="comment">//任务处理</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果任务数量大于0，但是这个时候协程都退出，则再次构建一个协程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">checkWorker</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.runningWorkers == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(p.chTask) &gt; <span class="number">0</span> &#123;</span><br><span class="line">p.run()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协程池的协程不是常驻协程吗，为什么会出现协程数量为0，但是任务大于0的情况呢？</p><p>答：工作协程可能因为 <code>panic</code> 都退出了，那么这个时候就需要有一个重新拉起协程去执行任务</p><p><strong>第四步</strong>：生产任务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Put</span><span class="params">(task *Task)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">p.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.status == STOPED &#123;</span><br><span class="line"><span class="keyword">return</span> ErrPoolAlreadyClosed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run worker</span></span><br><span class="line"><span class="keyword">if</span> p.GetRunningWorkers() &lt; p.GetCap() &#123;</span><br><span class="line">p.run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// send task</span></span><br><span class="line"><span class="keyword">if</span> p.status == RUNNING &#123;</span><br><span class="line">p.chTask &lt;- task</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么在存放任务的时候，会多一个协程池的判断呢？</p><p>答：可能会出现协程池结束关闭的情况，如果这个时候又有新的任务，那就又会创建新的协程去执行</p><p><strong>最后</strong>：关闭协程池</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Close close pool graceful</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !p.setStatus(STOPED) &#123; <span class="comment">// stop put task</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(p.chTask) &gt; <span class="number">0</span> &#123; <span class="comment">// 等待所有的任务都被消费</span></span><br><span class="line">time.Sleep(<span class="number">1e6</span>) <span class="comment">// 防止等待任务清空 cpu 负载突然变大, 这里小睡一下</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(p.chTask)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ol><li>这里添加了协程池的状态，防止退出时候的任务增加</li><li>为什么在退出的时候，如果任务大于0，那么需要 <code>sleep</code> 一下？</li><li>异常捕获之后再次检查是否有协程在执行任务，没有则添加一个协程</li><li>使用无缓冲<code>channel</code>进行任务执行，可能会出现添加任务阻塞的情况</li><li>任务是否可以添加一个运行超时时间，防止单个任务死锁？</li></ol><h4 id="方案2"><a class="markdownIt-Anchor" href="#方案2"></a> 方案2</h4><p>字节跳动开源的协程池，仓库地址：<a href="https://github.com/bytedance/gopkg/tree/develop/util/gopool" target="_blank" rel="noopener">https://github.com/bytedance/gopkg/tree/develop/util/gopool</a></p><p>使用 <strong>生产者-消费者模式</strong> 设计协程池</p><p><strong>第一步</strong>：**协程池 ** 具有的功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">interface</span> &#123;</span><br><span class="line">Name() <span class="keyword">string</span><span class="comment">//协程池名称</span></span><br><span class="line">SetCap(<span class="built_in">cap</span> <span class="keyword">int32</span>)<span class="comment">//协程池容量</span></span><br><span class="line">Go(f <span class="function"><span class="keyword">func</span><span class="params">()</span>)//使用协程执行 <span class="title">f</span></span></span><br><span class="line">CtxGo(ctx context.Context, f <span class="function"><span class="keyword">func</span><span class="params">()</span>) //使用协程执行<span class="title">f</span>并支持参数 <span class="title">ctx</span></span></span><br><span class="line">SetPanicHandler(f <span class="function"><span class="keyword">func</span><span class="params">(context.Context, <span class="keyword">interface</span>&#123;&#125;)</span>) //设置协程处理函数</span></span><br><span class="line">WorkerCount() <span class="keyword">int32</span><span class="comment">//返回正在运行的协程数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>：协程池的结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pool <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span><span class="comment">//协程池名称</span></span><br><span class="line"><span class="built_in">cap</span> <span class="keyword">int32</span><span class="comment">//协程池容量</span></span><br><span class="line">config *Config<span class="comment">//协程池配置</span></span><br><span class="line">taskHead  *task<span class="comment">//任务头部</span></span><br><span class="line">taskTail  *task<span class="comment">//任务尾部</span></span><br><span class="line">    taskLock  sync.Mutex<span class="comment">//任务原子锁(竞争)</span></span><br><span class="line">taskCount <span class="keyword">int32</span><span class="comment">//任务数量</span></span><br><span class="line">workerCount <span class="keyword">int32</span><span class="comment">//正在运行的协程数量</span></span><br><span class="line">panicHandler <span class="function"><span class="keyword">func</span><span class="params">(context.Context, <span class="keyword">interface</span>&#123;&#125;)</span>//<span class="title">Panic</span>处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>：看看 任务 <code>task</code> 的定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> task <span class="keyword">struct</span> &#123;</span><br><span class="line">ctx context.Context</span><br><span class="line">f   <span class="function"><span class="keyword">func</span><span class="params">()</span>//执行函数</span></span><br><span class="line"></span><br><span class="line">next *task<span class="comment">//指向下一个任务的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> taskList <span class="keyword">struct</span> &#123;     <span class="comment">//使用双向链表将任务连接起来</span></span><br><span class="line">sync.Mutex</span><br><span class="line">taskHead *task</span><br><span class="line">taskTail *task</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>：查看协程池是怎么运行的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> taskPool sync.Pool <span class="comment">//对象池</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pool)</span> <span class="title">CtxGo</span><span class="params">(ctx context.Context, f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">t := taskPool.Get().(*task)<span class="comment">//从对象池获取任务对象</span></span><br><span class="line">t.ctx = ctx</span><br><span class="line">t.f = f</span><br><span class="line">p.taskLock.Lock()<span class="comment">//获取任务写锁</span></span><br><span class="line"><span class="keyword">if</span> p.taskHead == <span class="literal">nil</span> &#123;      <span class="comment">//如果任务链表为空则新建，否则插入链表尾部</span></span><br><span class="line">p.taskHead = t</span><br><span class="line">p.taskTail = t</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p.taskTail.next = t</span><br><span class="line">p.taskTail = t</span><br><span class="line">&#125;</span><br><span class="line">p.taskLock.Unlock()<span class="comment">//释放任务写锁</span></span><br><span class="line">atomic.AddInt32(&amp;p.taskCount, <span class="number">1</span>) <span class="comment">//增加任务数量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 如果任务数量大于配置的数量 &amp;&amp; 正在执行的协程数量小于协程池容量，说明任务太多，还有空闲的协程</span></span><br><span class="line"><span class="comment">     那么就开启一个新的协程处理</span></span><br><span class="line"><span class="comment">       如果任务数量小于配置的数量 &amp;&amp; 正在执行的协程数量小于协程池容量。说明任务还不多，就让当前协程顺序执行</span></span><br><span class="line"><span class="comment">    2. 正在执行的协程为0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">if</span> (atomic.LoadInt32(&amp;p.taskCount) &gt;= p.config.ScaleThreshold &amp;&amp; p.WorkerCount() &lt; atomic.LoadInt32(&amp;p.<span class="built_in">cap</span>)) || p.WorkerCount() == <span class="number">0</span> &#123;</span><br><span class="line">p.incWorkerCount()   </span><br><span class="line">w := workerPool.Get().(*worker)</span><br><span class="line">w.pool = p</span><br><span class="line">w.run()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里额外定义了一个 <code>workPool</code>，其实是消费者池</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> workerPool sync.Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> worker <span class="keyword">struct</span> &#123;<span class="comment">//消费者其实是一个协程池</span></span><br><span class="line">pool *pool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123; <span class="comment">//这是一个常驻协程</span></span><br><span class="line"><span class="keyword">var</span> t *task</span><br><span class="line">w.pool.taskLock.Lock()   <span class="comment">//获取任务写锁</span></span><br><span class="line"><span class="keyword">if</span> w.pool.taskHead != <span class="literal">nil</span> &#123; <span class="comment">//获取任务并将任务数量-1</span></span><br><span class="line">t = w.pool.taskHead</span><br><span class="line">w.pool.taskHead = w.pool.taskHead.next</span><br><span class="line">atomic.AddInt32(&amp;w.pool.taskCount, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;<span class="comment">//如果没有任务，那么worker销毁</span></span><br><span class="line"><span class="comment">// if there's no task to do, exit</span></span><br><span class="line">w.<span class="built_in">close</span>()</span><br><span class="line">w.pool.taskLock.Unlock()</span><br><span class="line">w.Recycle()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">w.pool.taskLock.Unlock() <span class="comment">//释放任务写锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;<span class="comment">//异常处理</span></span><br><span class="line"><span class="keyword">if</span> w.pool.panicHandler != <span class="literal">nil</span> &#123;</span><br><span class="line">w.pool.panicHandler(t.ctx, r)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">msg := fmt.Sprintf(<span class="string">"GOPOOL: panic in pool: %s: %v: %s"</span>, w.pool.name, r, debug.Stack())</span><br><span class="line">logger.CtxErrorf(t.ctx, msg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">t.f()<span class="comment">//执行任务 f</span></span><br><span class="line">&#125;()</span><br><span class="line">t.Recycle()<span class="comment">//任务结束后，会收work</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span> <span class="title">close</span><span class="params">()</span></span> &#123;<span class="comment">//减少worker数目</span></span><br><span class="line">w.pool.decWorkerCount()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span> <span class="title">zero</span><span class="params">()</span></span> &#123; <span class="comment">//释放缓存池</span></span><br><span class="line">w.pool = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span> <span class="title">Recycle</span><span class="params">()</span></span> &#123;<span class="comment">//释放worker(存入缓存池)</span></span><br><span class="line">w.zero()</span><br><span class="line">workerPool.Put(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，它还定义了一个 <code>poolMap</code> 用于根据名称注册与使用 多个协程池</p><p><strong>注意</strong>：</p><ol><li>使用双向链表存储任务，表示它理论上支持无限个任务。后面的任务可能存在长时间等待的情况</li><li>使用任务上限的好处是，不是每来一个任务都开启一个协程，而是任务超过一定数量而又空闲的协程才开启新的协程去执行</li></ol><p>方案3：ants</p><p>内容比较多，将在下一章详细描述</p><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><p><code>go-zero</code>是如何实现协程池的，代码路径：<code>core/threading</code></p><p><strong>第一步</strong>，定义了<code>recover</code>逻辑，用于 <code>panic</code> 之后的清理操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/rescue/recover.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Recover</span><span class="params">(cleanups ...<span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, cleanup := <span class="keyword">range</span> cleanups &#123;</span><br><span class="line">cleanup()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//logx.ErrorStack(p)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，定义了一个安全运行<code>goroutine</code>的方案 <code>GoSafe</code>，包含处理<code>panic</code>逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GoSafe</span><span class="params">(fn <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="keyword">go</span> RunSafe(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RunSafe</span><span class="params">(fn <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> rescue.Recover()</span><br><span class="line"></span><br><span class="line">fn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TaskRunner</code>： 使用 <code>limitChan</code> 协程池 执行协程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TaskRunner 用于并发控制协程数量</span></span><br><span class="line"><span class="keyword">type</span> TaskRunner <span class="keyword">struct</span> &#123;</span><br><span class="line">limitChan <span class="keyword">chan</span> lang.PlaceholderType</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 TaskRunner 对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTaskRunner</span><span class="params">(concurrency <span class="keyword">int</span>)</span> *<span class="title">TaskRunner</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;TaskRunner&#123;</span><br><span class="line">limitChan: <span class="built_in">make</span>(<span class="keyword">chan</span> lang.PlaceholderType, concurrency),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 任务并发控制下执行 task</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rp *TaskRunner)</span> <span class="title">Schedule</span><span class="params">(task <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">  rp.limitChan &lt;- lang.Placeholder<span class="comment">//limitChan 类似一个并发锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> rescue.Recover(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">&lt;-rp.limitChan</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">task()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：当<code>limitChan</code>满那么任务执行会出现超时，缺乏超时逻辑</p><p><code>WorkerGroup</code>：使用 <code>wokers</code> 并发执行任务 <code>job</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WorkerGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">job     <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">workers <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewWorkerGroup returns a WorkerGroup with given job and workers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorkerGroup</span><span class="params">(job <span class="keyword">func</span>()</span>, <span class="title">workers</span> <span class="title">int</span>) <span class="title">WorkerGroup</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> WorkerGroup&#123;</span><br><span class="line">job:     job,</span><br><span class="line">workers: workers,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start starts a WorkerGroup.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg WorkerGroup)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">group := NewRoutineGroup()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; wg.workers; i++ &#123;</span><br><span class="line">group.RunSafe(wg.job)</span><br><span class="line">&#125;</span><br><span class="line">group.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RoutineGroup</code>: 多协程等待</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RoutineGroup 多协程等待</span></span><br><span class="line"><span class="keyword">type</span> RoutineGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">waitGroup sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRoutineGroup</span><span class="params">()</span> *<span class="title">RoutineGroup</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">new</span>(RoutineGroup)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要引用外部参数，可能被其他协程修改</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *RoutineGroup)</span> <span class="title">Run</span><span class="params">(fn <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">g.waitGroup.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> g.waitGroup.Done()</span><br><span class="line">fn()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不要引用外部参数，可能被其他协程修改</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *RoutineGroup)</span> <span class="title">RunSafe</span><span class="params">(fn <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">g.waitGroup.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">GoSafe(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> g.waitGroup.Done()</span><br><span class="line">fn()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待所有协程结束</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *RoutineGroup)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">g.waitGroup.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 go-zero的<code>threading</code> 并不是真正的协程池，仅仅是提供多种并发执行 <code>goroutine</code>的方法</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>所以从目前来看，实现一个协程池都有哪些值得学习的地方呢？</p><ol><li>将需要使用临时协程执行的函数已任务的形式 <code>任务 -- 协程池(Pool) -- 工人</code>执行</li><li>协程池是有容量限制的，有了容量就有正在运行的协程数</li><li>协程池有状态防止在退出的时候仍然进行任务构建与执行</li><li>协程池有异常捕获机制，保证单个异常不会影响整个协程池</li><li>任务已任务合集的形式存在，让消费者并发消费</li><li>有了异常捕获与任务合集，为了防止工人都发生异常，而还有任务没有执行，则需要有工人唤起机制</li><li>可以使用本地缓存池进行工人的重复利用</li></ol><p>下一节，将学习另外一个协程池 ants 的实现方式</p><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://go-zero.dev/cn/docs/goctl/installation/" target="_blank" rel="noopener">https://go-zero.dev/cn/docs/goctl/installation/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题背景&quot;&gt;&lt;/a&gt; 问题背景&lt;/h3&gt;
&lt;p&gt;需要协程池吗？&lt;/p&gt;
&lt;p&gt;虽然协程非常轻量级的，一般用不上协程池。协程池的作用 无休止地创建大量goroutine，势必会因为对
      
    
    </summary>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/categories/go-zero/"/>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>go-zero3-MapReduce</title>
    <link href="http://xboom.github.io/2022/07/03/GoZero/GoZero3-MapReduce/"/>
    <id>http://xboom.github.io/2022/07/03/GoZero/GoZero3-MapReduce/</id>
    <published>2022-07-03T08:37:40.000Z</published>
    <updated>2022-07-03T08:41:55.313Z</updated>
    
    <content type="html"><![CDATA[<p>什么是<code>MapReduce</code>?</p><p><code>MapReduce</code>是Google提出了一个软件架构，用于大规模数据集的并行运算。</p><p><code>MapReduce</code>通过把对数据集的大规模操作分发给网络上的每个节点实现可靠性；每个节点会周期性的把完成的工作和状态的更新报告回来。如果一个节点保持沉默超过一个预设的时间间隔，主节点记录下这个节点状态为死亡，并把分配给这个节点的数据发到别的节点。</p><p><code>go-zero</code>的<code>MapReduce</code>则借鉴其中的思想，接下来一起看下<code>go-zero</code>是如何应用这一思想的</p><h3 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h3><p>在微服务中开发中，如果多个服务串行依赖的话那么整个<code>API</code>的耗时将会大大增加。通过什么手段来优化？</p><ol><li>传输层面通过<code>MQ</code>的解耦特性来降低<code>API</code>的耗时<ul><li><code>MQ</code>通信效率没有<code>grpc</code>高(消息通过<code>MQ</code>服务器进行中转)</li></ul></li><li>业务层面通过Go语言的<code>WaitGroup</code>工具来进行并发控制<ul><li>自行封装<code>Add</code>与<code>Done</code></li></ul></li></ol><p>实际业务场景中：</p><ul><li>如果接口的多个依赖有一个出错，则期望能立即返回且不必等待所有依赖都执行完毕。已经完成的接口调用也应该回滚</li><li>多个依赖可能有部分依赖之间也存在着相互依赖，或者上下关系</li></ul><p>go-zero的主要应用场景为：需要从不同的<code>rpc</code>服务中获取相应属性组装成复杂对象，比如要查询商品详情：</p><ol><li>商品服务-查询商品属性</li><li>库存服务-查询库存属性</li><li>价格服务-查询价格属性</li><li>营销服务-查询营销属性</li></ol><p>如果是串行调用的话响应时间会随着 <code>rpc</code> 调用次数呈线性增长，简单场景下使用 <code>WaitGroup</code> 也能够满足需求，但如果要对 <code>rpc</code> 调用返回的数据进行校验、数据加工转换、数据汇总呢？</p><p><code>go-zero</code>通过<code>mapreduce</code>来处理这种对输入数据进行处理最后输出清洗数据的问题。是一种经典的模式：<strong>生产者消费者模式</strong>。将数据处理分为三个阶段：</p><ol><li>数据生产 generate(查询，必选)</li><li>数据加工 mapper(加工，可选)</li><li>数据聚合 reducer(聚合，可选)</li></ol><p>利用协程处理以及管道通信，实现数据的加速处理</p><h3 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h3><h4 id="场景1"><a class="markdownIt-Anchor" href="#场景1"></a> 场景1</h4><p>对数据批处理，比如对一批用户id，效验每个用户的合法性并且效验过程中有一个出错就认为效验失败，返回的结果为效验合法的用户id</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mapreduce</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/zeromicro/go-zero/core/mr"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(uids []<span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">r, err := mr.MapReduce(<span class="function"><span class="keyword">func</span><span class="params">(source <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, uid := <span class="keyword">range</span> uids &#123;</span><br><span class="line">source &lt;- uid</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;, writer mr.Writer, cancel <span class="keyword">func</span>(error)</span>)</span> &#123;</span><br><span class="line">uid := item.(<span class="keyword">int</span>)</span><br><span class="line">ok, err := check(uid)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;<span class="comment">//如果校验逻辑有问题，这里执行cancel整个校验过程停止</span></span><br><span class="line">cancel(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ok &#123;<span class="comment">//如果校验失败，那么不返回该uid</span></span><br><span class="line">writer.Write(uid)</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(pipe &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, writer mr.Writer, cancel <span class="keyword">func</span>(error)</span>)</span> &#123;</span><br><span class="line"><span class="keyword">var</span> uids []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> p := <span class="keyword">range</span> pipe &#123;</span><br><span class="line">uids = <span class="built_in">append</span>(uids, p.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line">writer.Write(uids)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"check error: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r.([]<span class="keyword">int</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// do something check user legal</span></span><br><span class="line"><span class="keyword">if</span> uid == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, errors.New(<span class="string">"uid wrong"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实是利用N个协程等待数据生产者的数据传输然后转交给聚合逻辑处理</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/mapReduce-1.png" alt="mapReduce-1" /></p><h4 id="场景2"><a class="markdownIt-Anchor" href="#场景2"></a> 场景2</h4><p>某些功能的结果往往需要依赖多个服务，比如商品详情的结果往往会依赖用户服务、库存服务、订单服务等等，一般被依赖的服务都是以rpc的形式对外提供，为了降低依赖的耗时我们往往需要对依赖做并行处理</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productDetail</span><span class="params">(uid, pid <span class="keyword">int64</span>)</span> <span class="params">(*ProductDetail, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> pd ProductDetail</span><br><span class="line">err := mr.Finish(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">pd.User, err = userRpc.User(uid)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">pd.Store, err = storeRpc.Store(pid)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">pd.Order, err = orderRpc.Order(pid)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"product detail error: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;pd, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><p>源码目录：<code>core/mr/mapreduce.go</code></p><p>其中利用到的对外函数有</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MapReduce 包含数据生产、数据处理以及数据聚合阶段并返回结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapReduce</span><span class="params">(generate GenerateFunc, mapper MapperFunc, reducer ReducerFunc,</span></span></span><br><span class="line"><span class="function"><span class="params">               opts ...Option)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MapReduceChan 包含数据生产、数据处理以及数据聚合阶段并返回结果。其中利用chan代替数据生产</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapReduceChan</span><span class="params">(source &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, mapper MapperFunc, reducer ReducerFunc,</span></span></span><br><span class="line"><span class="function"><span class="params">opts ...Option)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">panicChan := &amp;onceChan&#123;channel: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)&#125;</span><br><span class="line"><span class="keyword">return</span> mapReduceWithPanicChan(source, panicChan, mapper, reducer, opts...)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// ForEach 只包含数据生产和数据处理阶段，但没有任何输出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ForEach</span><span class="params">(generate GenerateFunc, mapper ForEachFunc, opts ...Option)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FinishVoid 并行运行 fns</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FinishVoid</span><span class="params">(fns ...<span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Finish 并行运行 fns，在任何错误时取消</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Finish</span><span class="params">(fns ...<span class="keyword">func</span>()</span> <span class="title">error</span>) <span class="title">error</span></span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//WithWorkers 定义一个 mapreduce 有几个协程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithWorkers</span><span class="params">(workers <span class="keyword">int</span>)</span> <span class="title">Option</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="数据生产阶段"><a class="markdownIt-Anchor" href="#数据生产阶段"></a> 数据生产阶段</h4><p>首先定义 <code>buildSource</code>使用协程进行数据生产</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//buildSource 使用协程执行generate 并将协程的参数一个非缓冲的channel返回。如果generate发生panic，则将错误写入 onceChan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildSource</span><span class="params">(generate GenerateFunc, panicChan *onceChan)</span> <span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">source := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">panicChan.write(r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(source)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">generate(source) <span class="comment">//返回的非缓冲隧道也是数据生产的入口</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> source</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 <code>onceChan</code>则是一个非阻塞会缓冲的channel，当channel中还有数据没有处理完，则直接返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> onceChan <span class="keyword">struct</span> &#123;</span><br><span class="line">channel <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">wrote   <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(oc *onceChan)</span> <span class="title">write</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.AddInt32(&amp;oc.wrote, <span class="number">1</span>) &gt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">oc.channel &lt;- val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据处理阶段"><a class="markdownIt-Anchor" href="#数据处理阶段"></a> 数据处理阶段</h4><p>接着利用<code>mapReduceWithPanicChan</code>进行数据处理<code>mapper</code>和数据聚合<code>reducer</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapReduce</span><span class="params">(generate GenerateFunc, mapper MapperFunc, reducer ReducerFunc,</span></span></span><br><span class="line"><span class="function"><span class="params">opts ...Option)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">panicChan := &amp;onceChan&#123;channel: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)&#125;</span><br><span class="line">source := buildSource(generate, panicChan) <span class="comment">//使用协程执行generate并返回数据生产无缓冲隧道source</span></span><br><span class="line"><span class="keyword">return</span> mapReduceWithPanicChan(source, panicChan, mapper, reducer, opts...) <span class="comment">//将隧道和处理函数传入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//source就是数据来源隧道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapReduceWithPanicChan</span><span class="params">(source &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, panicChan *onceChan, mapper MapperFunc,</span></span></span><br><span class="line"><span class="function"><span class="params">reducer ReducerFunc, opts ...Option)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">options := buildOptions(opts...)</span><br><span class="line"><span class="comment">// output is used to write the final result</span></span><br><span class="line">output := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="comment">//...defer</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//collector 用于从mapper收集数据，消费者是数据聚合</span></span><br><span class="line">collector := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, options.workers)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//done表示结束，所有的mappers和reducer都要结束</span></span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> lang.PlaceholderType)</span><br><span class="line">writer := newGuardedWriter(options.ctx, output, done)</span><br><span class="line"><span class="keyword">var</span> closeOnce sync.Once</span><br><span class="line"><span class="comment">// use atomic.Value to avoid data race</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="comment">//起一个协程进行 数据聚合</span></span><br><span class="line">    <span class="comment">//panic.wirte()</span></span><br><span class="line">reducer(collector, writer, cancel)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> executeMappers(mapperContext&#123; <span class="comment">//进行 数据处理</span></span><br><span class="line">ctx: options.ctx,</span><br><span class="line">mapper: <span class="function"><span class="keyword">func</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;, w Writer)</span></span> &#123;</span><br><span class="line">mapper(item, w, cancel)</span><br><span class="line">&#125;,</span><br><span class="line">source:    source,</span><br><span class="line">panicChan: panicChan,</span><br><span class="line">collector: collector,</span><br><span class="line">doneChan:  done,</span><br><span class="line">workers:   options.workers,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123; <span class="comment">//等待结果</span></span><br><span class="line"><span class="keyword">case</span> &lt;-options.ctx.Done():</span><br><span class="line">cancel(context.DeadlineExceeded)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, context.DeadlineExceeded</span><br><span class="line"><span class="keyword">case</span> v := &lt;-panicChan.channel:</span><br><span class="line"><span class="built_in">panic</span>(v)</span><br><span class="line"><span class="keyword">case</span> v, ok := &lt;-output:</span><br><span class="line"><span class="keyword">if</span> err := retErr.Load(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrReduceNoOutput</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中数据处理阶段又定义了一个协程进行处理</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">executeMappers</span><span class="params">(mCtx mapperContext)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="built_in">close</span>(mCtx.collector)</span><br><span class="line">drain(mCtx.source)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> failed <span class="keyword">int32</span></span><br><span class="line">pool := <span class="built_in">make</span>(<span class="keyword">chan</span> lang.PlaceholderType, mCtx.workers) <span class="comment">//协程池</span></span><br><span class="line">writer := newGuardedWriter(mCtx.ctx, mCtx.collector, mCtx.doneChan)</span><br><span class="line"><span class="keyword">for</span> atomic.LoadInt32(&amp;failed) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-mCtx.ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-mCtx.doneChan:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> pool &lt;- lang.Placeholder:<span class="comment">//这里是定义的N个works的chan，也就是会在下面创建n个协程</span></span><br><span class="line">item, ok := &lt;-mCtx.source</span><br><span class="line"><span class="keyword">if</span> !ok &#123; <span class="comment">//如果来源关闭，那么将pool数据释放</span></span><br><span class="line">&lt;-pool</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">atomic.AddInt32(&amp;failed, <span class="number">1</span>)</span><br><span class="line">mCtx.panicChan.write(r)</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&lt;-pool</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//item:生产的数据</span></span><br><span class="line">        <span class="comment">//writer: 数据处理对象</span></span><br><span class="line">mCtx.mapper(item, writer) <span class="comment">//执行map</span></span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据聚合阶段"><a class="markdownIt-Anchor" href="#数据聚合阶段"></a> 数据聚合阶段</h4><p>最后来看一下是数据处理</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> guardedWriter <span class="keyword">struct</span> &#123;<span class="comment">//写入接口</span></span><br><span class="line">ctx     context.Context<span class="comment">//保证超时退出</span></span><br><span class="line">channel <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;<span class="comment">//接收数据，这里传输的就是 长度为 N 的 collect channel</span></span><br><span class="line">done    &lt;-<span class="keyword">chan</span> lang.PlaceholderType<span class="comment">//主动结束退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newGuardedWriter</span><span class="params">(ctx context.Context, channel <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">done &lt;-<span class="keyword">chan</span> lang.PlaceholderType)</span> <span class="title">guardedWriter</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> guardedWriter&#123;</span><br><span class="line">ctx:     ctx,</span><br><span class="line">channel: channel,</span><br><span class="line">done:    done,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="finish"><a class="markdownIt-Anchor" href="#finish"></a> Finish</h4><p><code>Finish</code>逻辑只进行并发处理，其实内部是将执行函数做为数据生产的生产的数据，然后又数据处理逻辑进行处理</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/mapreduce_finish.png" alt="mapreduce_finish" /></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Finish</span><span class="params">(fns ...<span class="keyword">func</span>()</span> <span class="title">error</span>) <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(fns) == <span class="number">0</span> &#123;<span class="comment">//n个外部调用</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> MapReduceVoid(<span class="function"><span class="keyword">func</span><span class="params">(source <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, fn := <span class="keyword">range</span> fns &#123;</span><br><span class="line">source &lt;- fn<span class="comment">//数据生产者将函数传入</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;, writer Writer, cancel <span class="keyword">func</span>(error)</span>)</span> &#123;</span><br><span class="line">fn := item.(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span>)</span></span><br><span class="line"><span class="keyword">if</span> err := fn(); err != <span class="literal">nil</span> &#123;<span class="comment">//数据处理逻辑执行函数</span></span><br><span class="line">cancel(err)<span class="comment">//这里并没有写入，所以第三个函数其实并没有执行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(pipe &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, cancel <span class="keyword">func</span>(error)</span>)</span> &#123;</span><br><span class="line">&#125;, WithWorkers(<span class="built_in">len</span>(fns)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//底层还是执行的MapReduce逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapReduceVoid</span><span class="params">(generate GenerateFunc, mapper MapperFunc, reducer VoidReducerFunc, opts ...Option)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">_, err := MapReduce(generate, mapper, <span class="function"><span class="keyword">func</span><span class="params">(input &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, writer Writer, cancel <span class="keyword">func</span>(error)</span>)</span> &#123;</span><br><span class="line">reducer(input, cancel)</span><br><span class="line">&#125;, opts...)</span><br><span class="line"><span class="keyword">if</span> errors.Is(err, ErrReduceNoOutput) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3><ol><li>适用于并发无顺序依赖的并发调用，如果是多个调用具有前后依赖关系，依然需要有先后调用顺序(废话)</li><li>也不存在回滚的操作，内部只是将不在等待处理结果直接退出 <code>select</code></li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://talkgo.org/t/topic/1452" target="_blank" rel="noopener">https://talkgo.org/t/topic/1452</a></li><li><a href="https://zh.wikipedia.org/wiki/MapReduce" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/MapReduce</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;什么是&lt;code&gt;MapReduce&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MapReduce&lt;/code&gt;是Google提出了一个软件架构，用于大规模数据集的并行运算。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MapReduce&lt;/code&gt;通过把对数据集的大规模操作分发给网络上的
      
    
    </summary>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/categories/go-zero/"/>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>go-zero2-共享调用</title>
    <link href="http://xboom.github.io/2022/06/28/GoZero/GoZero2-%E5%85%B1%E4%BA%AB%E8%B0%83%E7%94%A8/"/>
    <id>http://xboom.github.io/2022/06/28/GoZero/GoZero2-%E5%85%B1%E4%BA%AB%E8%B0%83%E7%94%A8/</id>
    <published>2022-06-27T16:55:17.000Z</published>
    <updated>2022-07-02T14:45:14.537Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h3><p>并发场景下，可能会有多个线程（协程）同时请求同一份资源，如果每个请求都要走一遍资源的请求过程，除了比较低效之外，还会对资源服务造成并发的压力。</p><p>例如：</p><ol><li>缓存失效的同时多个请求同时到达某服务请求相同资源，这些请求会继续访问DB做查询，会引起数据库压力瞬间增大。而使用 <code>SharedCalls</code> 可以使得同时多个请求只需要发起一次拿结果的调用，其他请求&quot;坐享其成&quot;。有效减少了资源服务的并发压力，可以有效防止缓存击穿</li><li>云平台服务众多，使用<code>grpc</code>通信的时候不期望每个服务之间都建立链接，而只在向对端发送消息的时候，才在服务之间建立通信。老的逻辑是当开始建立连接的时候会将创建改为正在创建链接，后续消息会因为正在建立链接会直接返回错误或阻塞等待结果(自行实现)，而使用<code>SharedCalls</code>可以短时间内等待链接建立然后继续发送消息</li></ol><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/sharecalls.png" alt="sharecalls" /></p><h3 id="演示代码"><a class="markdownIt-Anchor" href="#演示代码"></a> 演示代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> round = <span class="number">5</span></span><br><span class="line">  var wg sync.WaitGroup</span><br><span class="line">  barrier := syncx.NewSharedCalls()</span><br><span class="line"></span><br><span class="line">  wg.Add(round)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; round; i++ &#123;</span><br><span class="line">    <span class="comment">// 多个线程同时执行</span></span><br><span class="line">    <span class="function">go <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      defer wg.Done()</span><br><span class="line">      <span class="comment">// 可以看到，多个线程在同一个 key 上去请求资源，获取资源的实际函数只会被调用一次</span></span><br><span class="line">      val, err := barrier.Do(<span class="string">"once"</span>, func() (interface&#123;&#125;, error) &#123;</span><br><span class="line">        <span class="comment">// sleep 1秒，为了让多个线程同时取 once 这个 key 上的数据</span></span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        <span class="comment">// 生成了一个随机的 id</span></span><br><span class="line">        <span class="keyword">return</span> stringx.RandId(), nil</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><p>文件目录：<code>core/syncx/singleflight.go</code></p><p><code>SingleFlight</code> 通过为并发的请求根据相同的key提供相同的结果</p><p>一共提供了 <code>Do</code> 与 <code>DoEx</code> 两种接口</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SingleFlight <span class="keyword">interface</span> &#123;</span><br><span class="line">   Do(key <span class="keyword">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span></span><br><span class="line">   DoEx(key <span class="keyword">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>, error)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> call <span class="keyword">struct</span> &#123;<span class="comment">//代指一次调用</span></span><br><span class="line">wg  sync.WaitGroup  <span class="comment">//用于等待call结束</span></span><br><span class="line">val <span class="keyword">interface</span>&#123;&#125;     </span><br><span class="line">err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flightGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">calls <span class="keyword">map</span>[<span class="keyword">string</span>]*call</span><br><span class="line">lock  sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先查看两个基础函数</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *flightGroup)</span> <span class="title">createCall</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(c *call, done <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 先申请加锁</span></span><br><span class="line">  g.lock.Lock()</span><br><span class="line"><span class="keyword">if</span> c, ok := g.calls[key]; ok &#123;<span class="comment">//如果key存在，那么等待</span></span><br><span class="line"><span class="comment">// 拿到 call 以后，释放锁，此处 call 可能还没有实际数据，只是一个空的内存占位</span></span><br><span class="line">    g.lock.Unlock()</span><br><span class="line"><span class="comment">//调用 wg.Wait，判断是否有其他 goroutine 正在申请资源，如果阻塞，说明有其他 goroutine 正在获取资源</span></span><br><span class="line">    c.wg.Wait()<span class="comment">//等待相同的call的结束</span></span><br><span class="line">    <span class="comment">// 当 wg.Wait 不再阻塞，表示资源获取已经结束，可以直接返回结果</span></span><br><span class="line"><span class="keyword">return</span> c, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = <span class="built_in">new</span>(call)<span class="comment">//创建一个新的call</span></span><br><span class="line">c.wg.Add(<span class="number">1</span>)     <span class="comment">//并为这个call添加一个的等待</span></span><br><span class="line">g.calls[key] = c</span><br><span class="line">g.lock.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *flightGroup)</span> <span class="title">makeCall</span><span class="params">(c *call, key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>)</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">g.lock.Lock()</span><br><span class="line"><span class="built_in">delete</span>(g.calls, key)<span class="comment">//删除</span></span><br><span class="line">g.lock.Unlock()</span><br><span class="line">c.wg.Done()           <span class="comment">//结束call</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">c.val, c.err = fn()   <span class="comment">//执行函数并返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看实现逻辑</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *flightGroup)</span> <span class="title">Do</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">c, done := g.createCall(key)<span class="comment">//根据key定义一个call</span></span><br><span class="line"><span class="keyword">if</span> done &#123;<span class="comment">//如果是等待结束了，且等待结束了，则返回Call的value</span></span><br><span class="line"><span class="keyword">return</span> c.val, c.err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是新的，那么就首次执行call，并返回结果</span></span><br><span class="line">  g.makeCall(c, key, fn)</span><br><span class="line"><span class="keyword">return</span> c.val, c.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *flightGroup)</span> <span class="title">DoEx</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(val <span class="keyword">interface</span>&#123;&#125;, fresh <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">c, done := g.createCall(key)</span><br><span class="line"><span class="keyword">if</span> done &#123; <span class="comment">//等待结束</span></span><br><span class="line"><span class="keyword">return</span> c.val, <span class="literal">false</span>, c.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g.makeCall(c, key, fn)</span><br><span class="line"><span class="keyword">return</span> c.val, <span class="literal">true</span>, c.err <span class="comment">//新的结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewSingleFlight returns a SingleFlight.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSingleFlight</span><span class="params">()</span> <span class="title">SingleFlight</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;flightGroup&#123;</span><br><span class="line">calls: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*call),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DoEx</code> 相较于 <code>Do</code> 中增加了一个 <code>bool</code> 类型的返回值，表示返回的值是共享的还是首次拿到的</p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://talkgo.org/t/topic/968" target="_blank" rel="noopener">https://talkgo.org/t/topic/968</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题背景&quot;&gt;&lt;/a&gt; 问题背景&lt;/h3&gt;
&lt;p&gt;并发场景下，可能会有多个线程（协程）同时请求同一份资源，如果每个请求都要走一遍资源的请求过程，除了比较低效之外，还会对资源服务造成并
      
    
    </summary>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/categories/go-zero/"/>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>go-zero1-架构</title>
    <link href="http://xboom.github.io/2022/06/28/GoZero/GoZero1-%E6%9E%B6%E6%9E%84/"/>
    <id>http://xboom.github.io/2022/06/28/GoZero/GoZero1-%E6%9E%B6%E6%9E%84/</id>
    <published>2022-06-27T16:55:05.000Z</published>
    <updated>2022-07-02T14:39:40.822Z</updated>
    
    <content type="html"><![CDATA[<h4 id="go-zero结构"><a class="markdownIt-Anchor" href="#go-zero结构"></a> Go-Zero结构</h4><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220617011432.png" alt="架构图" /></p><h3 id="主要功能"><a class="markdownIt-Anchor" href="#主要功能"></a> 主要功能</h3><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><ol><li>防止缓存击穿之共享调用</li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://github.com/zeromicro/go-zero/blob/master/readme-cn.md" target="_blank" rel="noopener">https://github.com/zeromicro/go-zero/blob/master/readme-cn.md</a></li><li><a href="https://talkgo.org/c/go-zero/23" target="_blank" rel="noopener">https://talkgo.org/c/go-zero/23</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;go-zero结构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#go-zero结构&quot;&gt;&lt;/a&gt; Go-Zero结构&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images-1307117474.cos.ap-guangzho
      
    
    </summary>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/categories/go-zero/"/>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>ETCD入门3-RAFT协议</title>
    <link href="http://xboom.github.io/2022/03/13/ETCD/ETCD%E5%85%A5%E9%97%A83-RAFT%E5%8D%8F%E8%AE%AE/"/>
    <id>http://xboom.github.io/2022/03/13/ETCD/ETCD%E5%85%A5%E9%97%A83-RAFT%E5%8D%8F%E8%AE%AE/</id>
    <published>2022-03-13T02:25:38.000Z</published>
    <updated>2022-06-25T07:00:00.112Z</updated>
    
    <content type="html"><![CDATA[<p>一致性是指在集群中的多个节点在状态上达成一致，常见的一致性协议有Raft、Paxos、ZAB</p><h3 id="基本规则"><a class="markdownIt-Anchor" href="#基本规则"></a> 基本规则</h3><p>任期(Term)：实际上是一个全局的、连续递增的整数。在raft中，每进行一次选举，任期就会+1</p><p>节点存在三种状态分别是：</p><ul><li>Leader节点：可读可写、处理日志复制、保证⼀致性、维护⼼跳</li><li>Follower节点：可进行读操作，写操作需要路由到Leader处理；参与投票，⼀个term任期内只能投⼀次; 当触发 election timeout 时，晋升为 candidate ;(注意读请求模式的线性读)</li><li>Candidate节点：集群的候选者，会发起投票试图当选leader ; 通过 RequestVote 通知其他节点来投票;</li></ul><p>集群中任意一个节点都处于这三个状态之一</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220125000023.png" alt="image-20220125000018705" style="zoom:80%;" /><p>如上图所示</p><ol><li>当etcd节点刚启动的时候，状态机初始化状态为Follower</li><li>为了进行Leader 选举控制有两个时间<ul><li>选举超时时间(election timeout): 每个Follower节点会因为超过选举超时时间还没有收到Leader的心跳而切换程Candidate状态并发起选举。一般为 150ms ~ 300ms，是一个一定范围的随机数(为了保证各节点不是同时发起选举请求)</li><li>心跳超时时间(heartbeat timeout): Leader节点向集群中其他Follower节点发送心跳消息的时间间隔</li></ul></li></ol><h3 id="脑裂问题"><a class="markdownIt-Anchor" href="#脑裂问题"></a> 脑裂问题</h3><p>原本一个集群，被分成了两个集群，同时出现了两个“大脑”，这就是所谓的“脑裂”现象</p><p>ETCD是否有可能出现脑裂？</p><ol><li>第一种情况：两边都得到过半票数而选举出Leader的情况，不可能出现</li><li>第二种情况：两边都无法得到过半票数而无法选举出Leader的情况，则服务端会返回客户端集群不可用</li></ol><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312195949.png" alt="image-20220312195949615" style="zoom:50%;" /><ol start="3"><li><p>第三种情况：Leader 与 其他节点通信异常，导致其他节点重新选出 Leader</p><ul><li><p>Leader 知道与其他节点通信异常</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220313110944.png" alt="image-20220313110426872" /></p><ul><li>由于 leader A ⽆法同步数据到多数节点, 造成 client 写请求失败 ;</li><li>⽹络分区后 follower c 长时间未收到⼼跳, 则触发选举且当选 ;</li><li>client 按照策略⼀直尝试跟可用的节点进⾏请求 ;</li><li>当⽹络恢复后, leader A B 将降为 follower, 并且强制同步 Leader C 的数据 ;</li></ul></li><li><p>Leader 不知道与还不知道与其他节点通信异常</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220313111102.png" alt="image-20220313111102564" /></p><ul><li>在 leader-A 里标记 client 请求为 未提交模式 ;</li><li>follower c 首先触发超时发起选举投票, folower ED 收到更加新的 term 过去的 requestVote, 则回应同意当选 ;</li><li>leader C 可以接收用户的请求, 由于可以拿到⼤多数的回应, 则可以正常提交数据 ;</li><li>当⽹络分区问题解决后, 由于旧集群的Leader A 的term 低于 Leader C , leader A 强制 同步 Leader C的数据;</li></ul></li></ul></li></ol><h3 id="leader选举"><a class="markdownIt-Anchor" href="#leader选举"></a> Leader选举</h3><p>能称为Leader的条件有</p><ul><li>当前集群⽆可用 leader ;</li><li>触发 election timeout ;</li><li>term 任期最新 ;</li><li>log 日志最新 ;</li><li>获取多数投票 ;</li></ul><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312200222.png" alt="image-20220312200222021" /></p><p>流程可以查看：<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></p><p>需要注意的是：</p><ol><li>超过集群半数节点应答，才将日志写入WAL中，也是就如果没有等到半数应答就挂了，那么数据就丢了</li><li>Follower 收到 Leader 的 复制日志 则直接将日志写入 WAL 中</li><li>当Follower收到 Vote Request 也会重置 election timeout 定时器(降低同时出现两个候选人的概率)</li><li>Term 将持续直到某个节点因为心跳超时而从新发起选举</li><li>出现多个候选人都没有称为 Leader，那么选举失败，切换为Follower，等待下一个选举超时</li><li>Leader 宕机后，其他节点重新选出新 Leader。等到旧Leader 恢复，会因为收到新Leader心跳 而自己的 Term 落后，切换成 Follower，更新自己的Term，然后重新投出自己的选票</li></ol><h4 id="基本流程"><a class="markdownIt-Anchor" href="#基本流程"></a> 基本流程</h4><p>将设ETCD集群中有三个节点(A、B、C)</p><img src="/Users/yuankang/Library/Application%20Support/typora-user-images/image-20220306233505794.png" alt="image-20220306233505794" style="zoom:50%;" /><ol><li>初始化，所有节点起初都是 Follower 状态(Term = 0， 得票数 = 0)</li><li>节点 A 由于长时间未收到 Leader 的心跳消息，就会切换成为Candidate 状态并发起选举（节点 A 的选举计时器 （election timer）己被重置）</li><li>节点 A 首先会将自己的选票投给自己，并会向集群中其他节点发送选举请求（ Request Vote ）以获取其选票，此时的节点 B 和节点 C 还都是处于 Term=0 的任期之中，且都是 Follower 状态，均未投出 Term=1 任期中的选票，所以节点 B 和节点 C 在接收到节点 A 的选举请求后会将选票投给节点 A，任期变为1。</li></ol><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220306235342.png" alt="image-20220306235342760" style="zoom:50%;"/><ol start="4"><li><p>在节点 A 收到节点 B、 C 的投票之后，其收到了集群中超过半数的选票，所以在 Terrn = 1 的任期中，该集群的 Leader 节点就是节点 A，其他节点将切换成 Follower 状态，</p><blockquote><p>集群中的节点除 了记录当期任期号(currentTerrn)，还会记录在该任期中当前节点的投票结果(VoteFor）</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220307000505.png" alt="image-20220307000505928" style="zoom:50%;" /></li><li><p>成为 Terrn = 1 任期的 Leader 节点之后，节点 A 会定期向集群中的其他节点发送心跳消息，防止节点 B 和节点 C 中的选举计时器(election timer) 超时而触发新一轮的选举: 当节点 B 和节点 C (Follower) 收到节点 A 的心跳消息之后会重置选举计时器</p><blockquote><p>心跳超时时间（heartbeat timeout）需要远小于选举超时时间(election timeout)</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220307000654.png" alt="image-20220307000653976" style="zoom:50%;" /></li></ol><blockquote><p>Candidate 发起选举前,会先尝试连接集群中的其他节点。如果连接不上，放弃本次选举。这个状态称之为：Prevote</p></blockquote><p>问题1：如果Leader节点频繁宕机，或者选举反复进行，怎么办？</p><p>要求：广播时间 &lt;&lt; 选举超时时间 &lt;&lt; 平均故障间隔时间</p><ul><li>广播时间：节点直接发送心跳信息的完整返回时间 hearthbeat timeout：0.5ms~50ms</li><li>选举超时时间：election timer：200ms~1s</li><li>故障间隔时间：两次故障的平均时间：1个月或更多(保证节点的不要经常出古故障)</li></ul><p>这样最大程度保证：不会频繁选举（广播时间 &lt;&lt; 选举超时时间），故障时间最多为200ms~1s（选举超时时间 &lt;&lt; 平均故障间隔时间）</p><p>问题2：是不是谁先发起了选举请求，谁就得到了Leader？</p><p>不是，除了看先后顺序，还取决于Candidate节点的日志是不是最新最全的日志，否则拒绝投票，防止出现日志（即数据）丢失的情况</p><h4 id="prevote"><a class="markdownIt-Anchor" href="#prevote"></a> Prevote</h4><p>当出现网络分区，节点因为选举超时而不断的进行 term 增加，而 leader 会因为遇到更新的 term 而退化为 follower，为了防止 term不断的新增，使用了 Prevote 措施，变为 candidate 的条件</p><ul><li>询问其他节点是否有可用 leader ;</li><li>可连通绝⼤数节点 ;</li></ul><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220313104101.png" alt="image-20220313104056708" style="zoom:50%;" /><h3 id="日志复制"><a class="markdownIt-Anchor" href="#日志复制"></a> 日志复制</h3><h4 id="基本流程-2"><a class="markdownIt-Anchor" href="#基本流程-2"></a> 基本流程</h4><p>流程动画：<a href="http://thesecretlivesofdata.com/raft/#replication" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/#replication</a></p><p>步骤如下：</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312204541.png" alt="image-20220312204541060"  /><ol><li>Leader 节点接到 client 请求后（如 set a=10）,将本请求计入本地log</li></ol><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312204707.png" alt="image-20220312204707596" /></p><ol start="2"><li>Leader 节点向 Follower1 和 Follower2 发送Append Entries消息（set a=10）</li><li>Follower1 和 Follower2 将此信息计入本地log，并返回给 Leader</li></ol><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312204848.png" alt="image-20220312204848066" /></p><ol><li>Leader 将日志信息置为 已提交(Commited),然后状态机处理。</li><li>响应 client 请求</li><li>向 Follower1 和 Follower2 发送消息，该信息已提交</li><li>Follower1 和 Follower2 接到消息后，修改日志状态，交给自己的状态机处理</li></ol><blockquote><p>存在的问题：计入本地log是否是写入WAL，按照之前的流程是没有的，而是在提交之后，那么Follower又是什么时候写入WAL的？</p></blockquote><h4 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引</h4><p>集群中各个节点都会维护一个本地Log 用于记录更新操作，还会维护 <code>commitlndex</code> 和<code>lastApplied</code> 两个值，它们是本地Log 的索引值</p><ul><li><code>commitlndex</code> 表示的是当前节点已知的、最大的、己提交的日志索引值</li><li><code>lastApplied</code> 表示的是当前节点最后一条被应用到状态机中的日志索引值。</li></ul><p>当节点中的 <code>commitlndex</code> 值大于 <code>lastApplied</code> 值时，会将 <code>lastApplied+ 1</code> ，并将 <code>lastApplied</code> 对应的日志应用到其状态机中。</p><p>除此之外，在Leader还需要了解集群中其他Follower 节点的这些信息，而决定下次发送Append Entries 消息中包含哪些日志记录。为此， Leader 节点会维护 <code>nextlndex[]</code>和 <code>matchlndex[]</code>两个数组，这两个数组中记录的都是日志索引值</p><ul><li><code>nextlndex[]</code> 记录了需要发送给每个Follower 节点的下一条日志的索引值</li><li><code>matchlndex[]</code> 记录了己经复制给每个Follower 节点的最大的日志索引值</li></ul><blockquote><p>一个数组不就可以表达了吗？</p></blockquote><p>例如：</p><p>Follower 节点中最后一条日志的索引值大于等于该 Follower 节点对应的 <code>nextlndex</code> 值，那么通过Append Entries 消息发送从<code>nextlndex</code> 开始的所有日志。之后， Leader节点会检测该 Follower 节点返回的相应响应，</p><ul><li>如果成功则更新相应该Follower 节点对应的 <code>nextlndex</code> 值和<code>matchlndex</code> 值；</li><li>如果因为日志不一致而失败，则减少 <code>nextlndex</code> 值重试。</li></ul><h4 id="一致性复制"><a class="markdownIt-Anchor" href="#一致性复制"></a> 一致性复制</h4><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312211352.png" alt="image-20220312211352566" style="zoom:50%;" /><p>raft 中的每个日志记录都带有 term 和 log index 来唯⼀标识 ;</p><ul><li>日志记录具有两个特性 如果两条不同节点的某两个日志记录具有相同的 term 和 index 号，则两条记录⼀定是完全相同的 ;</li><li>如果两条不同节点的某两个日志记录具有相同的 term 和 index 号，则两 条记录之前的所有记录也⼀定是完全相同的 ;</li></ul><p>以此来判断 leader与 follower 之间的 日志是否相同</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312210348.png" alt="image-20220312210348704" style="zoom:50%;" /><blockquote><p>上图中：a 和 b 的情况是没有完全收到来自 leader 的 AppendEntries RPC, ⽽ c-f 则是带有不同时期的未提交的日志（有可能是他们当 leader 时产⽣的，但没有提交就 crash了）</p></blockquote><ul><li>leader 从来不会覆盖，删除或者修改其日志 ;</li><li>leader 会初始化⼀个数组 nextIndex[], 该结构对应的值表示本 leader 将给对应 follower 发送的下⼀条日志 index ;</li><li>若 follower 对比其前⼀条 log 不⼀致，则会拒绝 leader 发来的请求. 此时 leader 就将其在 nextIndex[] 中的对应值减⼀ ;</li><li>leader 不断重试直到 follower 比对成功, 然后 <strong>follower 接受 AppendEntries RPC, ⼀个个的抛弃所有冲突的日志</strong> ;</li><li>leader 按照自身日志顺序将日志正常复制给 follower，并不断将 nextIndex[] 对应 值 +1，直到对应值 “追上” 自身日志的 index 为⽌;</li></ul><blockquote><p>为什么要一个一个对比，而不直接找到对应的位置，批量复制？=&gt; 通过数组存储的是索引，但是日志比较是通过 index 与 term</p><p>那数组为什么不存 index 与 term? =&gt; 因为本来每个节点的 操作都是不一样的，其他节点无法</p></blockquote><h4 id="异常情况"><a class="markdownIt-Anchor" href="#异常情况"></a> 异常情况</h4><h5 id="场景1"><a class="markdownIt-Anchor" href="#场景1"></a> 场景1：</h5><p>两个Follower 节点不可用，Leader 如何处理请求</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312201120.png" alt="image-20220312201120077" style="zoom:50%;" /><ul><li><p>leader 通过⼼跳已知 follower 已挂, 则直接返回错误 ;</p></li><li><p>leader 不知节点已挂, 同步数据时得知异常; 触发异常触发超时</p></li></ul><h5 id="场景2"><a class="markdownIt-Anchor" href="#场景2"></a> <strong>场景2：</strong></h5><p>提交给Leader后，发生了crash</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312201343.png" alt="image-20220312201343089" style="zoom:50%;" /><ul><li><p>leader 本地已记录 未提交日志, 重启后强制同步新 leader 数据 ;</p></li><li><p>leader 还没记录未提交日志就crash, 丢了就丢了;</p></li></ul><h5 id="场景3"><a class="markdownIt-Anchor" href="#场景3"></a> 场景3</h5><p>复制给 follower-1 后, leader就发⽣了 crash ?</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312202452.png" alt="image-20220312202452036" style="zoom:50%;" /><ul><li>leader 发⽣了重启，集群触发新的选举 ;</li><li>由于 follower-1 的数据较新, 那么该节点会晋升 leader ;</li><li>follower-1 会把 uncommited 的 v=3 同步给其他节点 ;</li><li>follower-1 收到其他节点接收确认后, 进⾏提交日志 ;</li></ul><h5 id="场景4"><a class="markdownIt-Anchor" href="#场景4"></a> 场景4：</h5><p>follower 返回确认消息时, leader 发⽣了 crash ?</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312202600.png" alt="image-20220312202600126" style="zoom:50%;" /><ul><li>三个节点的数据已经⼀致, 都为 uncommited v=3 ; 这时谁当 Leader 都可以 ; 新leader当选后, 需要进⾏同步提交通知 ;</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li>《ETCD技术内幕》</li><li><a href="http://www.xuyasong.com/?p=1706" target="_blank" rel="noopener">http://www.xuyasong.com/?p=1706</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一致性是指在集群中的多个节点在状态上达成一致，常见的一致性协议有Raft、Paxos、ZAB&lt;/p&gt;
&lt;h3 id=&quot;基本规则&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基本规则&quot;&gt;&lt;/a&gt; 基本规则&lt;/h3&gt;
&lt;p&gt;任期(Term)：实际上
      
    
    </summary>
    
    
      <category term="ETCD" scheme="http://xboom.github.io/categories/ETCD/"/>
    
    
      <category term="ETCD" scheme="http://xboom.github.io/tags/ETCD/"/>
    
  </entry>
  
  <entry>
    <title>ETCD入门2-ETCD架构</title>
    <link href="http://xboom.github.io/2022/03/12/ETCD/ETCD%E5%85%A5%E9%97%A82-ETCD%E6%9E%B6%E6%9E%84/"/>
    <id>http://xboom.github.io/2022/03/12/ETCD/ETCD%E5%85%A5%E9%97%A82-ETCD%E6%9E%B6%E6%9E%84/</id>
    <published>2022-03-12T09:31:19.000Z</published>
    <updated>2022-06-25T07:00:00.112Z</updated>
    
    <content type="html"><![CDATA[<h3 id="etcd架构"><a class="markdownIt-Anchor" href="#etcd架构"></a> ETCD架构</h3><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312153557.jpg" alt="img" /></p><ol><li><strong>Client</strong>：客户端库，封装对KVServer、Cluster、Auth、Lease、Watch的API</li><li>API：<ul><li>Raft HTTP：主要用于ETCD集群各节点通信，基于Raft进行数据同步、选主</li><li>gRPC API:  v3 使用 grpc实现服务端与客户端交互，而 v2 使用 http1.X 实现交互</li><li>HTTP: ETCD 支持 HTTP 对外交互接口(v2 与 v3 不能混用)</li></ul></li><li>Raft：选主、日志复制、ReadIndex等为保障节点数据一致性的具体算法实现</li><li>功能逻辑<ul><li>KVServer模块</li><li>Auth鉴权模块</li><li>Lease租约模块：主动上报的检测机制</li><li>Compactor压缩模块</li><li>MVCC模块：treeIndex + boltdb，多版本并发控制，保存一组KV的多个历史版本</li><li>Quota: 配额模块，检查下当前 etcd db 大小加上你请求的 key-value 大小之和是否超过了配额(quota-backend-bytes，默认存储为2G, 最大配额为8G)</li></ul></li><li>存储<ul><li>WAL模块：Write Ahead Log，预写式日志，所有修改在提交前都要写入log文件，保障etcd崩溃了不丢失数据（redo/undo）</li><li>Snapshot：防止WAL文件过多而设置的快照，存储etcd数据状态，某个快照前的日志会变为无效数据。（如每处理1w条日志就进行一次snapshot）</li><li>boltdb模块：嵌入式 K/V 数据库，B+树，保存集群元数据与用户写入的数据</li></ul></li></ol><h4 id="quota-模块"><a class="markdownIt-Anchor" href="#quota-模块"></a> Quota 模块</h4><p>如果超过配额，会产生一个告警(Alarm)请求，告警类型是 NO SPACE，并通过 Raft 日志同步给其它节点，告知 db 无空间了，并将告警持久化存储到 db 中。</p><p>最终，无论是 API 层 gRPC 模块还是负责将 Raft 侧已提交的日志条目应用到状态机的 Apply 模块，都拒绝写入，集群只读。</p><p>常见的 “etcdserver: mvcc: database space exceeded&quot; 错误就是因为Quota 模块检测到 db 大小超限导致的。</p><ul><li>一方面默认 db 配额仅为 2G，当你的业务数据、写入 QPS、Kubernetes 集群规模增大后，你的 etcd db 大小就可能会超过 2G。</li><li>另一方面 etcd 是个 MVCC 数据库，保存了 key 的历史版本，当你未配置压缩策略的时候，随着数据不断写入，db 大小会不断增大，导致超限。</li></ul><p>解决办法</p><ul><li>1）首先当然是调大配额，etcd 社区建议不超过 8G。<ul><li>如果填的是个小于 0 的数，就会禁用配额功能，这可能会让db 大小处于失控，导致性能下降，不建议你禁用配额。</li></ul></li><li>2）检查 etcd 的压缩（compact）配置是否开启、配置是否合理。<ul><li>压缩时只会给旧版本Key打上空闲（Free）标记，后续新的数据写入的时候可复用这块空间，db大小并不会减小。</li><li>如果需要回收空间，减少 db 大小，得使用碎片整理（defrag）， 它会遍历旧的 db 文件数据，写入到一个新的 db 文件。但是它对服务性能有较大影响，不建议你在生产集群频繁使用。</li></ul></li></ul><p>调整后还需要手动发送一个取消告警（etcdctl alarm disarm）的命令，以消除所有告警，否则因为告警的存在，集群还是无法写入。</p><h3 id="写请求处理处理"><a class="markdownIt-Anchor" href="#写请求处理处理"></a> 写请求处理处理</h3><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312155944.png" alt="etcd-write-step" /></p><p>图中流程如下：</p><ol><li><p>客户端会与ETCD每个节点都建立连接，读写grpc请求则通过负载均衡算法随机发送到其中一个节点</p></li><li><p>etcd 节点收到请求后经过 gRPC 拦截器 进入逻辑处理流程(<strong>写入数据的etcd是leader节点，如果是非leader节点则路由到etcd leader节点去</strong>)</p></li><li><p>Quota 进行配额校验，完成后转发给KVServer</p></li><li><p>KVServer 模块生成并提交提案</p><ul><li>打包提案：将 put 写请求内容打包成一个提案消息</li><li>请求限速、检查：在提交提案前，进行如下的一系列检查和限速<ul><li>限速：如果 Raft 模块已提交的日志索引（committed index）比已应用到状态机的日志索引（applied index）超过了 5000，那么它就返回一个&quot;etcdserver: too many requests&quot;错误给 client。</li><li>鉴权：尝试去获取请求中的鉴权信息，若使用了密码鉴权、请求中携带了 token，如果 token 无效，则返回&quot;auth: invalid auth token&quot;错误给 client。</li><li>大包检查：检查写入的包大小是否超过默认的 1.5MB， 如果超过则返回&quot;etcdserver: request is too large&quot;错误给 client</li></ul></li><li>通过检查后会生成一个唯一的 ID，将此请求关联到一个对应的消息通知 channel（用于接收结果，golang 响应处理方式），向Raft模块发起(Propose)一个提案(Proposal)</li></ul><blockquote><p>KVServer 模块会等待此 put 请求，等待写入结果通过消息通知 channel 返回或者超时。etcd 默认超时时间是 7 秒（5 秒磁盘 IO 延时 +2*1 秒竞选超时时间），如果一个请求超时未返回结果，则可能会出现你熟悉的 etcdserver: request timed out 错误</p></blockquote></li><li><p>Raft模块处理提案</p><ul><li>raft模块会首先保存到raftLog的unstable存储部分(raft 仅仅是普通日志作用，unstable 表示存在内存中)</li><li>通过raft协议与集群中其他etcd节点进行交互应答<ul><li>集群中其他节点向leader节点应答接收这条日志数据</li><li>当超过集群半数<code>(N + 1) / 2</code>节点应答这条日志数据时，将这条日志写入到WAL模块中</li></ul></li></ul></li><li><p>通知最上层的etcd server该日志已经commit</p></li><li><p>etcd server调用applierV3模块将日志写入持久化存储中</p><ul><li>首先生成 key 对应的 revision 存入treeindex中</li><li>然后通过revistion - val 持久话到 boltdb中(B+树结构)</li></ul></li></ol><blockquote><p>超过配额怎么办？</p><ol><li>检查 etcd 的压缩（compact）配置是否开启、配置是否合理。</li></ol><ul><li>压缩时只会给旧版本Key打上空闲（Free）标记，后续新的数据写入的时候可复用这块空间，db大小并不会减小。</li></ul><ul><li>如果需要回收空间，减少 db 大小，得使用碎片整理（defrag）， 它会遍历旧的 db 文件数据，写入到一个新的 db 文件。但是它对服务性能有较大影响，不建议你在生产集群频繁使用。</li></ul><ol start="2"><li>调整后还需手动发送取消告警的命令<code>etcdctl alarm disarm</code>，以消除所有告警，否则因为告警的存在，集群还是无法写入</li></ol></blockquote><h3 id="读请求处理流程"><a class="markdownIt-Anchor" href="#读请求处理流程"></a> 读请求处理流程</h3><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312155605.png" alt="etcd-read-process" /></p><h4 id="串行读与线性读"><a class="markdownIt-Anchor" href="#串行读与线性读"></a> 串行读与线性读</h4><p>etcd 为了保证服务高可用，生产环境一般部署多个节点，多节点之间的数据由于延迟等关系可能会存在不一致的情况</p><blockquote><p>不一致原因：虽然是强一致性，但 Leader 收到大部分节点响应就回复客户端，可能存在leader与未回复follower不一致的情况</p></blockquote><p>根据业务场景对数据一致性差异的接受程度，etcd 中有两种读模式。</p><ul><li><strong>串行 (Serializable) 读</strong>：直接读状态机数据返回、无需通过 Raft 协议与集群进行交互，它具有低延时、高吞吐量的特点，适合对数据一致性要求不高的场景。(可能出现当前KV不是最新的情况)</li><li><strong>线性读</strong>：需要经过 Raft 协议模块，反应的是集群共识，因此在延时和吞吐量上相比串行读略差一点，适用于对数据一致性要求高的场景</li></ul><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312210238.png" alt="image-20220312210238211" /></p><p>由于串行读是直接从当前节点获取&quot;最新&quot;数据，可能出现不是真的最新，线性读通过先与集群达成共识再返回结果</p><p>线性读流程具体流程如下：</p><ol><li>当 Follower 收到线性读请求时，首先执行 Read Index 请求， 从 Leader 获取集群最新的已提交的日志索引 (committed index)</li><li>Leader 收到 Read Index 请求时，为防止脑裂等异常场景，会向 Follower 节点发送心跳确认，一半以上节点确认 Leader 身份后才能将已提交的索引 (committed index) 返回给请求节点。</li><li>Follower 节点拿到 Read index 后会和状态机的 applied index进行比较<ul><li>如果 Read index 大于 applied index 则会等待，直到状态机已应用索引 (applied index) 大于等于 Leader 的已提交索引时 (committed Index)才会去通知读请求，数据已赶上 Leader可以去状态机中访问数据了</li><li>否则直接开始读取</li></ul></li></ol><blockquote><p>readIndex 需要请求 leader，那为什么不直接让 leader 返回读请求的结果</p><p><strong>主要是性能因素</strong>，如果将所有读请求都转发到 Leader，会导致 Leader 负载升高，内存、cpu、网络带宽资源都很容易耗尽。特别是expensive request场景，会让 Leader 节点性能会急剧下降。read index 机制的引入，使得每个follower节点都可以处理读请求，极大扩展提升了写性能。</p></blockquote><h4 id="读取流程"><a class="markdownIt-Anchor" href="#读取流程"></a> 读取流程</h4><ol><li><p>从 treeIndex 中获取 key 的版本号</p></li><li><p>再以版本号作为 boltdb 的 key，从 boltdb 中获取其 value 信息</p><ul><li><p>etcd 出于数据一致性、性能等考虑，在访问 boltdb 前，首先会从一个内存读事务 buffer 中，二分查找你要访问 key 是否在 buffer 里面，若命中则直接返回。</p></li><li><p>若 buffer 未命中，此时就真正需要向 boltdb 模块查询数据了。boltdb 使用 B+ tree 来组织用户的 key-value 数据，获取 bucket key 对象后，通过 boltdb 的游标 Cursor 可快速在 B+ tree 找到 key hello 对应的 value 数据，返回给 client。</p><blockquote><p>boltdb 通过 bucket 隔离集群元数据与用户数据</p></blockquote></li></ul></li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="http://www.jcxioo.com/2021/06/14/01_Kubernetes/etcd1%20/" target="_blank" rel="noopener">http://www.jcxioo.com/2021/06/14/01_Kubernetes/etcd1 /</a></li><li><a href="https://www.codedump.info/post/20181125-etcd-server/#wal" target="_blank" rel="noopener">https://www.codedump.info/post/20181125-etcd-server/#wal</a></li><li><a href="https://www.lixueduan.com/post/etcd/07-read-process/" target="_blank" rel="noopener">https://www.lixueduan.com/post/etcd/07-read-process/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;etcd架构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#etcd架构&quot;&gt;&lt;/a&gt; ETCD架构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images-1307117474.cos.ap-guangzhou.myqclou
      
    
    </summary>
    
    
      <category term="ETCD" scheme="http://xboom.github.io/categories/ETCD/"/>
    
    
      <category term="ETCD" scheme="http://xboom.github.io/tags/ETCD/"/>
    
  </entry>
  
  <entry>
    <title>ETCD入门1-ETCD概述</title>
    <link href="http://xboom.github.io/2022/03/12/ETCD/ETCD%E5%85%A5%E9%97%A81-ETCD%E6%A6%82%E8%BF%B0/"/>
    <id>http://xboom.github.io/2022/03/12/ETCD/ETCD%E5%85%A5%E9%97%A81-ETCD%E6%A6%82%E8%BF%B0/</id>
    <published>2022-03-12T07:33:07.000Z</published>
    <updated>2022-06-25T07:00:00.112Z</updated>
    
    <content type="html"><![CDATA[<p>etcd是一个可靠的分布式KV存储系统</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312141241.png" alt="image-20220312141043231" /></p><p>黄色：关联特性</p><p>红色：核心原理</p><h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3><ul><li>简单：提供定义明确且面向用户的API</li><li>安全：支持SSL证书验证</li><li>性能：基准压测支持1w+/sec写入</li><li>可靠：采用Raft协议保证分布式系统数据的可用性和一致性。</li></ul><h3 id="功能特性"><a class="markdownIt-Anchor" href="#功能特性"></a> 功能特性</h3><ul><li><p><strong>KV存储、查询功能</strong>：支持精准查询、range操作、ttl机制、key版本等</p></li><li><p><strong>强一致性</strong>：采用raft协议保证<strong>强一致性</strong></p></li><li><p><strong>高可用性</strong>：提供集群和leader选举机制</p></li><li><p><strong>SSL认证机制</strong></p></li><li><p><strong>Lease 机制</strong>：即租约机制（TTL，Time To Live），Etcd 可以为存储的 Key-Value 对设置租约，当租约到期，Key-Value 将失效删除；同时也支持续约(Keepalive)，通过客户端可以在租约到期之前续约，以避免 Key-Value 对过期失效。</p><blockquote><p>Lease 机制可以保证分布式锁的安全性，为锁对应的 Key 配置租约，即使锁的持有者因故障而不能主动释放锁，锁也会因租约到期而自动释放。</p></blockquote></li><li><p><strong>Revision 机制</strong>：每个 Key 带有一个 Revision 号，每进行一次事务便加一，因此它是全局唯一的，如初始值为 0，进行一次 <code>put(key, value)</code>，Key 的 Revision 变为 1，同样的操作，再进行一次，Revision 变为 2；换成 key1 进行 put(key1, value) 操作，Revision 将变为 3；</p><blockquote><p>通过 Revision 的大小就可以知道写操作的顺序。在实现分布式锁时，多个客户端同时抢锁，根据 Revision 号大小依次获得锁，可以避免 “羊群效应” （也称“惊群效应”），实现公平锁。</p></blockquote></li><li><p><strong>Prefix 机制</strong>：即前缀机制，也称目录机制，例如，一个名为 <code>/mylock</code> 的锁，两个争抢它的客户端进行写操作，实际写入的 Key 分别为：<code>key1=&quot;/mylock/UUID1&quot;,key2=&quot;/mylock/UUID2&quot;</code>，其中，UUID 表示全局唯一的 ID，确保两个 Key 的唯一性。很显然，写操作都会成功，但返回的 Revision 不一样，</p><blockquote><p>如何判断谁获得了锁呢？</p><p>通过前缀“/mylock” 查询，返回包含两个 Key-Value 对的 Key-Value 列表，同时也包含它们的 Revision，通过 Revision 大小，客户端可以判断自己是否获得锁，如果抢锁失败，则等待锁释放（对应的 Key 被删除或者租约过期），然后再判断自己是否可以获得锁。</p></blockquote></li><li><p><strong>Watch 机制</strong>：即监听机制，Watch 机制支持监听某个固定的 Key，也支持监听一个范围（前缀机制），当被监听的 Key 或范围发生变化，客户端将收到通知；</p><blockquote><p>在实现分布式锁时，如果抢锁失败，可通过 Prefix 机制返回的 Key-Value 列表获得 Revision 比自己小且相差最小的 Key（称为 Pre-Key），对 Pre-Key 进行监听，因为只有它释放锁，自己才能获得锁，如果监听到 Pre-Key 的 DELETE 事件，则说明 Pre-Key 已经释放，自己已经持有锁。</p><p>获取Pre-Key 的时候就已经释放了怎么办？Watch需要带上版本</p></blockquote></li></ul><h3 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h3><h4 id="分布式锁"><a class="markdownIt-Anchor" href="#分布式锁"></a> <strong>分布式锁</strong></h4><h5 id="分布式锁-2"><a class="markdownIt-Anchor" href="#分布式锁-2"></a> 分布式锁</h5><p>因为 etcd 使用 Raft 算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁</p><img src="https://static001.infoq.cn/resource/image/46/dc/46ff86e2e2c2157bc3f0409845f0e1dc.jpg" alt="img" style="zoom:50%;" /><p>V3版本接口:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来新建一个mutex</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMutex</span><span class="params">(s *Session, pfx <span class="keyword">string</span>)</span> *<span class="title">Mutex</span></span> </span><br><span class="line"><span class="comment">//它会阻塞直到拿到了锁，并且支持通过context来取消获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><blockquote><p>锁原理详解 TODO</p></blockquote><h5 id="leader选举组件"><a class="markdownIt-Anchor" href="#leader选举组件"></a> <strong>leader选举组件</strong></h5><p>利用分布式锁，实现Leader竞选。而 leader-follower模式来保证有状态服务的高可用</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312152020.jpg" alt="img" /></p><h4 id="注册与发现"><a class="markdownIt-Anchor" href="#注册与发现"></a> 注册与发现</h4><p>本质是：服务端通过(Lessor + keepalive) 进行服务注册与保活，客户端通过(Watch)做到KV实时变化实时感知</p><h5 id="服务注册与发现"><a class="markdownIt-Anchor" href="#服务注册与发现"></a> 服务注册与发现</h5><p>服务端注册信息到注册中心ETCD中，并通过心跳实时检测服务端(lessor + keepalive)。客户端从注册中心获取服务端信息才能建立链接(Watch)</p><img src="https://static001.infoq.cn/resource/image/1b/7d/1beabef5a1168cdc43766903e65f907d.jpg" alt="img" style="zoom:50%;" /><blockquote><ol><li>k8s 中已经有 service，是否还需要使用到注册中心？</li></ol><p>使用grpc构建k8s 服务通信，由于 grpc 使用的是长连接通信，导致消息在多副本情况下只会发往同一个副本</p><ol start="2"><li><p>如何注册服务端信息的</p><p>对应 Key = &lt;标识&gt;.&lt;服务名称&gt;.&lt;版本&gt;.<IP> , Val =&lt;k=v&gt;&amp;&lt;k=v&gt;</p><p>Key: 保存通信信息，当服务端出现变化的时候。客户端即使不解析 Val 也能收到变化</p><p>Val: 可以不定义或者定义每个服务(注意副本)特有信息</p></li></ol></blockquote><h5 id="集群监控"><a class="markdownIt-Anchor" href="#集群监控"></a> 集群监控</h5><p>通过 etcd 来进行监控实现起来非常简单并且实时性强。</p><ol><li>前面几个场景已经提到 Watcher 机制，当某个节点消失或有变动时，Watcher 会第一时间发现并告知用户。</li><li>节点可以设置<code>TTL key</code>，比如每隔 30s 发送一次心跳使代表该机器存活的节点继续存在，否则节点消失。</li></ol><h5 id="分布式通知与协调"><a class="markdownIt-Anchor" href="#分布式通知与协调"></a> <strong>分布式通知与协调</strong></h5><img src="https://static001.infoq.cn/resource/image/38/97/38bee3d541dd88e6f772e64beab92697.jpg" alt="img" style="zoom:50%;" /><ul><li><strong>通过 etcd 进行低耦合的心跳检测</strong>。检测和被检测系统通过 etcd 进行关联降低系统的耦合性。</li><li><strong>通过 etcd 完成系统调度</strong>。某系统有控制台和推送系统两部分组成，控制台的职责是控制推送系统进行相应的推送工作。管理人员在控制台作的一些操作，实际上是修改了 etcd 上某些目录节点的状态，而 etcd 就把这些变化通知给注册了 Watcher 的推送系统客户端，推送系统再作出相应的推送任务。</li><li><strong>通过 etcd 完成工作汇报</strong>。大部分类似的任务分发系统，子任务启动后，到 etcd 来注册一个临时工作目录，并且定时将自己的进度进行汇报（将进度写入到这个临时目录），这样任务管理者就能够实时知道任务进度</li></ul><h5 id="消息订阅和发布"><a class="markdownIt-Anchor" href="#消息订阅和发布"></a> <strong>消息订阅和发布</strong></h5><ul><li><strong>消息发布与订阅</strong></li></ul><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312143719.jpg" alt="img" style="zoom:50%;" /><blockquote><ol><li>配置中心需要考虑分权问题，每个服务对于同一个数据库的访问权限也是不一致的。所以配置信息也有可能不一致。当然不影响进行配置注册</li></ol></blockquote><h5 id="配置中心"><a class="markdownIt-Anchor" href="#配置中心"></a> <strong>配置中心</strong></h5><p>整个平台不同服务包含很多相同配置信息 ，例如: 数据库地址、链路追踪等。可以将这些配置信息注册到注册中心实现动态更新</p><blockquote><p>这里还需要考虑分权问题：即每个服务能够访问的权限、区域不一致，那么每服务甚至副本配置都不一致</p></blockquote><h4 id="负载均衡"><a class="markdownIt-Anchor" href="#负载均衡"></a> <strong>负载均衡</strong></h4><p>在k8s中一般针对多副本场景，由于 grpc 使用的是长连接，k8s service 无法满足负载场景，需要客户端通过获取副本信息实现负载均衡</p><img src="https://static001.infoq.cn/resource/image/67/be/6782904921fa103f42f30113fbf0babe.jpg" alt="img" style="zoom:50%;" /><h4 id="分布式队列"><a class="markdownIt-Anchor" href="#分布式队列"></a> <strong>分布式队列</strong></h4><p>分布式队列的常规用法与场景五中所描述的分布式锁的控制时序用法类似，即创建一个先进先出的队列，保证顺序。</p><p>另一种比较有意思的实现是<strong>在保证队列达到某个条件时再统一按顺序执行</strong>。这种方法的实现可以在 /queue 这个目录中另外建立一个 /queue/condition 节点。</p><ul><li>condition 可以<strong>表示队列大小</strong>。比如一个大的任务需要很多小任务就绪的情况下才能执行，每次有一个小任务就绪，就给这个 condition 数字加 1，直到达到大任务规定的数字，再开始执行队列里的一系列小任务，最终执行大任务。</li><li>condition 可以<strong>表示某个任务在不在队列</strong>。这个任务可以是所有排序任务的首个执行程序，也可以是拓扑结构中没有依赖的点。通常，必须执行这些任务后才能执行队列中的其他任务。</li><li>condition 还可以<strong>表示其它的一类开始执行任务的通知</strong>。可以由控制程序指定，当 condition 出现变化时，开始执行队列任务。</li></ul><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312151607.jpg" alt="img" /></p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="http://www.jcxioo.com/2021/06/14/01_Kubernetes/etcd1%20/" target="_blank" rel="noopener">http://www.jcxioo.com/2021/06/14/01_Kubernetes/etcd1 /</a></li><li><a href="https://www.infoq.cn/article/etcd-interpretation-application-scenario-implement-principle" target="_blank" rel="noopener">https://www.infoq.cn/article/etcd-interpretation-application-scenario-implement-principle</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;etcd是一个可靠的分布式KV存储系统&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312141241.png&quot; alt=&quot;i
      
    
    </summary>
    
    
      <category term="ETCD" scheme="http://xboom.github.io/categories/ETCD/"/>
    
    
      <category term="ETCD" scheme="http://xboom.github.io/tags/ETCD/"/>
    
  </entry>
  
  <entry>
    <title>架构6-分布式缓存</title>
    <link href="http://xboom.github.io/2022/03/04/FrameWork/%E6%9E%B6%E6%9E%846-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"/>
    <id>http://xboom.github.io/2022/03/04/FrameWork/%E6%9E%B6%E6%9E%846-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</id>
    <published>2022-03-03T16:30:33.000Z</published>
    <updated>2022-06-25T07:00:00.113Z</updated>
    
    <content type="html"><![CDATA[<p>缓存知识点如下：</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220303234240.png" alt="img" /></p><ul><li>首先，要熟练掌握缓存的基础知识，了解缓存常用的分类、读写模式，熟悉缓存的七大经典问题及解决应对之策，同时要从缓存组件的访问协议、Client 入手，熟练掌握如何访问各种缓存组件，如 Memcached、Redis、Pika 等。</li><li>其次，要尽可能深入理解缓存组件的实现方案、设计原理，了解缓存的各种特性、优势和不足，这样在缓存数据与预期不一致时，能够快速定位并解决问题。</li><li>再次，还要多了解线上大中型系统是如何对缓存进行架构设计的。线上系统，业务功能丰富多变，跨域部署环境复杂，而且热点频发，用户习惯迥异。因此，缓存系统在设计之初就要尽量进行良好设计，规划好如何进行Hash及分布、如何保障数据的一致性、如何进行扩容和缩容。当然，缓存体系也需要伴随业务发展持续演进，这就需要对缓存体系进行持续的状态监控、异常报警、故障演练，以确保在故障发生时能及时进行人肉或自动化运维处理，并根据线上状况不断进行优化和改进。</li><li>最后，了解缓存在各种场景下的最佳实践，理解这些最佳实践背后的 Tradeoff，做到知其然知其所以然，以便在实际工作中能举一反三，把知识和经验更好的应用到工作实践中来</li></ul><h3 id="缓存的原理"><a class="markdownIt-Anchor" href="#缓存的原理"></a> 缓存的原理</h3><p>缓存的基本思想、缓存的优点、缓存的代价</p><h4 id="缓存的定义"><a class="markdownIt-Anchor" href="#缓存的定义"></a> 缓存的定义</h4><ul><li>缓存最初的含义，是指用于加速 CPU 数据交换的 RAM，即随机存取存储器，通常这种存储器使用更昂贵但快速的静态 RAM（SRAM）技术，用以对 DRAM进 行加速。这是一个狭义缓存的定义。</li><li>广义缓存的定义则更宽泛，任何可以用于数据高速交换的存储介质都是缓存，可以是硬件也可以是软件</li></ul><h4 id="缓存的基本思想"><a class="markdownIt-Anchor" href="#缓存的基本思想"></a> 缓存的基本思想</h4><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220303234744.png" alt="img" /></p><p>缓存构建的基本思想是利用时间局限性原理，通过空间换时间来达到加速数据获取的目的，同时由于缓存空间的成本较高，在实际设计架构中还要考虑访问延迟和成本的权衡问题。这里面有 3 个关键点。</p><ul><li>一是时间局限性原理，即被获取过一次的数据在未来会被多次引用，比如一条微博被一个人感兴趣并阅读后，它大概率还会被更多人阅读，当然如果变成热门微博后，会被数以百万/千万计算的更多用户查看。</li><li>二是以空间换时间，因为原始数据获取太慢，所以我们开辟一块高速独立空间，提供高效访问，来达到数据获取加速的目的。</li><li>三是性能成本 Tradeoff，构建系统时希望系统的访问性能越高越好，访问延迟越低小越好。但维持相同数据规模的存储及访问，性能越高延迟越小，成本也会越高，所以在系统架构设计时，你需要在系统性能和开发运行成本之间做取舍。比如左边这张图，相同成本的容量，SSD 硬盘容量会比内存大 10～30 倍以上，但读写延迟却高 50～100 倍。</li></ul><p>通过缓存可以 提升访问性能、降低网络拥堵、减轻服务负载、增强可扩展性 但同时 增加系统复杂度、增加成本以及 缓存一致性</p><h3 id="缓存读写模式"><a class="markdownIt-Anchor" href="#缓存读写模式"></a> 缓存读写模式</h3><p>业务系统读写缓存有 3 种模式：</p><ul><li>Cache Aside（旁路缓存）</li><li>Read/Write Through（读写穿透）</li><li>Write Behind Caching（异步缓存写入）</li></ul><h4 id="cache-aside"><a class="markdownIt-Anchor" href="#cache-aside"></a> Cache Aside</h4><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220303235235.png" alt="img" /></p><p>Cache Aside 模式中，业务应用方对于</p><ul><li><p>写: 更新 DB 后，直接将 key 从 cache 中删除，然后由 DB 驱动缓存数据的更新；</p></li><li><p>读: 先读 cache，如果 cache 没有，则读 DB，同时将从 DB 中读取的数据回写到 cache</p></li></ul><blockquote><p>写的时候为什么在更新完数据库之后将数据更新到缓存中？</p></blockquote><p>适用：对数据一致性要求高或者数据缓存更新复杂的业务</p><h4 id="readwrite-through"><a class="markdownIt-Anchor" href="#readwrite-through"></a> Read/Write Through</h4><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220303235549.png" alt="img" /></p><p>Cache Aside 模式，业务应用需同时维护 cache 和 DB 两个数据存储方，过于繁琐，于是就有了 Read/Write Through 模式</p><p>在Read/Write Through模式下，业务应用只关注一个存储服务即可，业务方的读写 cache 和 DB 的操作，都由存储服务代理。存储服务处理</p><ul><li>写：会首先查 cache，如果数据在 cache 中不存在，则只更新 DB，如果数据在 cache 中存在，则先更新 cache，然后更新 DB。</li><li>读：如果命中 cache 直接返回，否则先从 DB 加载，更新 cache 后返回响应</li></ul><blockquote><p>为什么在写操作先更新缓存，如果更新完缓存，但是数据库更新失败怎么办？</p><p>为什么Cache Aside不能使用存储服务代理？</p></blockquote><p>适用：同一业务区分缓存(读写频率高的更新缓存并写入数据库，而操作频率低的直接写入数据库并不写入缓存)</p><h3 id="write-behind-caching"><a class="markdownIt-Anchor" href="#write-behind-caching"></a> Write Behind Caching</h3><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220304000358.png" alt="img" /></p><p>Write Behind Caching 模式与 Read/Write Through 模式类似，也由数据存储服务来管理 cache 和 DB 的读写。不同点是，数据更新时，Read/write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。</p><p>适用：变化频率特变高，对一致性要求不太高的业务(比如计数业务的点赞功能，执行异步批量写入)</p><h3 id="缓存的分类"><a class="markdownIt-Anchor" href="#缓存的分类"></a> 缓存的分类</h3><h4 id="按宿主层次分类"><a class="markdownIt-Anchor" href="#按宿主层次分类"></a> 按宿主层次分类</h4><p>按宿主层次分类的话，缓存一般可以分为本地 Cache、进程间 Cache 和远程 Cache。</p><ul><li>本地 Cache 是指业务进程内的缓存，这类缓存由于在业务系统进程内，所以读写性能超高且无任何网络开销，但不足是会随着业务系统重启而丢失。</li><li>进程间 Cache 是本机独立运行的缓存，这类缓存读写性能较高，不会随着业务系统重启丢数据，并且可以大幅减少网络开销，但不足是业务系统和缓存都在相同宿主机，运维复杂，且存在资源竞争。</li><li>远程 Cache 是指跨机器部署的缓存，这类缓存因为独立设备部署，容量大且易扩展，在互联网企业使用最广泛。不过远程缓存需要跨机访问，在高读写压力下，带宽容易成为瓶颈。</li></ul><p>本地 Cache 的缓存组件有 Ehcache、Guava Cache 等，开发者自己也可以用 Map、Set 等轻松构建一个自己专用的本地 Cache。进程间 Cache 和远程 Cache 的缓存组件相同，只是部署位置的差异罢了，这类缓存组件有 Memcached、Redis、Pika 等。</p><h4 id="按存储介质分类"><a class="markdownIt-Anchor" href="#按存储介质分类"></a> 按存储介质分类</h4><ul><li>内存型缓存将数据存储在内存，读写性能很高，但缓存系统重启或 Crash 后，内存数据会丢失。</li><li>持久化型缓存将数据存储到 SSD/Fusion-IO 硬盘中，相同成本下，这种缓存的容量会比内存型缓存大 1 个数量级以上，而且数据会持久化落地，重启不丢失，但读写性能相对低 1～2 个数量级。Memcached 是典型的内存型缓存，而 Pika 以及其他基于 RocksDB 开发的缓存组件等则属于持久化型缓存。</li></ul><h3 id="缓存架构设计"><a class="markdownIt-Anchor" href="#缓存架构设计"></a> 缓存架构设计</h3><p>根据缓存组件特点确定缓存组件后，需要以下三点来考虑缓存架构设计</p><ol><li>分布式算法：取模还是一致性 Hash 进行分布<ul><li>取模：方案简单，每个 key 只会存在确定的缓存节点</li><li>一致性Hash：方案相对复杂，但失效节点的数据访问均衡分散到其他正常存活的节点，从而保证系统稳定性</li></ul></li><li>分布式读写访问如何实施：由缓存 Client 直接进行 Hash 分布定位读写<ul><li>Client 直接读写：读写性能最佳，但需要 Client 感知分布策略</li><li>Proxy代理访问：业务开发友好，但需要考虑性能瓶颈</li></ul></li><li>缓存的水平迁移:如果待缓存的数据量增长过快，会导致大量缓存数据被剔除，缓存命中率会下降，数据访问性能会随之降低，这样就需要将数据从缓存节点进行动态拆分，把部分数据水平迁移到其他缓存节点</li></ol><h4 id="部署与运维"><a class="markdownIt-Anchor" href="#部署与运维"></a> 部署与运维</h4><p>设计完毕缓存的分布策略后，接下来就要考虑缓存的架构部署及运维管理了。架构部署主要考虑如何对缓存进行分池、分层、分 IDC，以及是否需要进行异构处理。</p><ol><li>核心的、高并发访问的不同数据，需要分别分拆到独立的缓存池中，进行分别访问，避免相互影响；访问量较小、非核心的业务数据，则可以混存。</li><li>对海量数据、访问超过 10～100万 级的业务数据，要考虑分层访问，并且要分摊访问量，避免缓存过载。</li><li>如果业务系统需要多 IDC 部署甚至异地多活，则需要对缓存体系也进行多 IDC 部署，要考虑如何跨 IDC 对缓存数据进行更新，可以采用直接跨 IDC 读写，也可以采用 DataBus 配合队列机进行不同 IDC 的消息同步，然后由消息处理机进行缓存更新，还可以由各个 IDC 的 DB Trigger 进行缓存更新。</li><li>某些极端场景下，还需要把多种缓存组件进行组合使用，通过缓存异构达到最佳读写性能。</li><li>站在系统层面，要想更好得管理缓存，还要考虑缓存的服务化，考虑缓存体系如何更好得进行集群管理、监控运维等。</li></ol><h4 id="常见考量点"><a class="markdownIt-Anchor" href="#常见考量点"></a> 常见考量点</h4><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220307235700.png" alt="img" /></p><h5 id="读写方式"><a class="markdownIt-Anchor" href="#读写方式"></a> 读写方式</h5><p>首先是 value 的读写方式。是全部整体读写，还是只部分读写及变更？是否需要内部计算？比如，用户粉丝数，很多普通用户的粉丝有几千到几万，而大 V 的粉丝更是高达几千万甚至过亿，因此，获取粉丝列表肯定不能采用整体读写的方式，只能部分获取。另外在判断某用户是否关注了另外一个用户时，也不需要拉取该用户的全部关注列表，直接在关注列表上进行检查判断，然后返回 True/False 或 0/1 的方式更为高效</p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/300%E5%88%86%E9%92%9F%E5%90%83%E9%80%8F%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E5%AE%8C" target="_blank" rel="noopener">https://learn.lianglianglee.com/专栏/300分钟吃透分布式缓存-完</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;缓存知识点如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220303234240.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="FrameWork" scheme="http://xboom.github.io/categories/FrameWork/"/>
    
    
      <category term="FrameWork" scheme="http://xboom.github.io/tags/FrameWork/"/>
    
  </entry>
  
  <entry>
    <title>ETCD入门6-多版本控制</title>
    <link href="http://xboom.github.io/2022/02/23/ETCD/ETCD%E5%85%A5%E9%97%A86-%E5%A4%9A%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    <id>http://xboom.github.io/2022/02/23/ETCD/ETCD%E5%85%A5%E9%97%A86-%E5%A4%9A%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</id>
    <published>2022-02-22T16:41:29.000Z</published>
    <updated>2022-06-25T07:00:00.111Z</updated>
    
    <content type="html"><![CDATA[<p>悲观锁：悲观得认为并发事务会冲突，所以要先拿锁，拿到锁的作修改操作</p><ul><li>读写锁（可多读，写时互斥）、互斥锁（线程互斥）等</li><li>控制粒度太大，高并发下大量事务会被阻塞</li></ul><p>乐观锁：乐观得认为数据不会冲突，但发生冲突时要能检测到</p><ul><li>逻辑时钟（时间戳排序）</li><li>MVCC</li></ul><p>MVCC（Multiversion Concurrency Control）多版本并发控制机制，<strong>保存一个数据的多个历史版本</strong>以解决事务管理中数据隔离的问题，被主流数据库采用，包括Oracle, MySQL等</p><p>写一个数据项时，不是简单的用新值覆盖旧值，而是为这一项添加一个新版本的数据；<br />读一个数据项时，先确定版本，在根据版本找到对应的值；<br />这样保证了读写隔离，无需锁协调。读不会阻塞，适合“读多写少”的etcd</p><ul><li>可以保存一个Key-Value数据的多个历史版本</li><li>每修改（新增/删除）一次都会生成一个新的数据记录</li><li>指定版本号读取数据时，实际访问的是版本号生成的那个时间点的快照</li></ul><blockquote><p>linux中的RCU功能？</p></blockquote><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220223002724.jpg" alt="img" /></p><p>文中涉及的key表示用户输入的键值，K(or Key)表示boltdb持久化存储时的键值</p><ul><li>treeIndex：基于B-tree实现的key的索引，保存用户key与版本号revision的映射关系</li><li>Backend：作持久化KV操作，目前支持boltdb<ul><li>ReadTx 读事务接口</li><li>BatchTx 写事务接口</li><li>Buffer 缓存</li></ul></li><li>boltdb：基于B+ Tree的支持事务的KV嵌入式数据库<ul><li>K：revision</li><li>V：{用户的kv，版本号，lease信息等}</li></ul></li></ul><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220223003043.jpeg" alt="img" /></p><p>etcd中的MVCC存储分为两部分：</p><ol><li>内存中保存的key-revision映射，用于快速点查及范围查询</li><li>磁盘中保存的不同版本的真实数据</li></ol><h3 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h3><h4 id="b-tree"><a class="markdownIt-Anchor" href="#b-tree"></a> <strong>B Tree</strong></h4><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220223003231.jpg" alt="img" /></p><ul><li>树内节点都存数据</li><li>叶子节点都在同一层且无相邻指针</li><li>度：每个节点的子节点的个数，“胖瘦程度”</li></ul><h4 id="b-tree-2"><a class="markdownIt-Anchor" href="#b-tree-2"></a> <strong>B+ Tree</strong></h4><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220223003324.jpeg" alt="简化B+树" /></p><ul><li>数据只在叶子节点</li><li>所有叶子节点增加了一个链指针</li></ul><h4 id="revision"><a class="markdownIt-Anchor" href="#revision"></a> <strong>revision</strong></h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;txID, 0&#125;, &#123;txID, 1&#125;, &#123;txID, 2&#125;...</span></span><br><span class="line"><span class="keyword">type</span> revision <span class="keyword">struct</span> &#123;</span><br><span class="line">main <span class="keyword">int64</span>         <span class="comment">// 事务ID，逻辑时间戳，全局递增不重复</span></span><br><span class="line">sub  <span class="keyword">int64</span>         <span class="comment">// 当前事务内不同的修改操作的编号（put/del），从0开始递增</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一次事务中，每一个修改操作所绑定的 revision 一次为<code>{txID, 0}</code>, <code>{txID, 1}</code>…</p><h4 id="keyindex"><a class="markdownIt-Anchor" href="#keyindex"></a> <strong>keyIndex</strong></h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">type</span> keyIndex <span class="keyword">struct</span> &#123;</span><br><span class="line">    key         []<span class="keyword">byte</span>          <span class="comment">// 用户的key</span></span><br><span class="line">    modified    revision        <span class="comment">// 最后一次修改key时的etcd版本号</span></span><br><span class="line">    generations []generation    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// generation保存了一个key若干代的版本号，每代都包含对key多次修改的版本号列表</span></span><br><span class="line"><span class="comment">// 创建时第0代，删除后生成第1代...</span></span><br><span class="line"><span class="keyword">type</span> generation <span class="keyword">struct</span> &#123;</span><br><span class="line">ver     <span class="keyword">int64</span>               <span class="comment">// 表示key的修改次数</span></span><br><span class="line">created revision            <span class="comment">// 创建时的第一个版本号</span></span><br><span class="line">revs    []revision          <span class="comment">// 每次修改key时的revision追加进此切片</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="treeindex"><a class="markdownIt-Anchor" href="#treeindex"></a> <strong>treeIndex</strong></h4><p>树状索引，内存中维护的B树，加速查询key</p><ul><li>树的每个节点都是一个keyIndex，其实现了Item接口Less方法，就可以通过给定的key快速查找对应的keyIndex</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// github.com/google/btree/btree.go</span></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">interface</span> &#123;</span><br><span class="line">Less(than Item) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// github.com/etcd/mvcc/key_index.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ki *keyIndex)</span> <span class="title">Less</span><span class="params">(b btree.Item)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> bytes.Compare(ki.key, b.(*keyIndex).key) == <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220223003842.jpg" alt="img" /></p><h4 id="backendboltdb"><a class="markdownIt-Anchor" href="#backendboltdb"></a> Backend/boltdb</h4><p>K：版本号，如{2,0}<br />V：mvccpb.KeyValue 包含用户的kv等信息</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mvccpb.KeyValue <span class="keyword">struct</span> &#123;</span><br><span class="line">Key []<span class="keyword">byte</span></span><br><span class="line">CreateRevision <span class="keyword">int64</span>  <span class="comment">// 创建时的版本号</span></span><br><span class="line">ModRevision <span class="keyword">int64</span>     <span class="comment">// 最后一次修改时的版本号</span></span><br><span class="line">Version <span class="keyword">int64</span>         <span class="comment">// 此key修改的次数 = keyIndex.generations[i].ver + 1</span></span><br><span class="line">Value []<span class="keyword">byte</span>          <span class="comment">// 用户数据</span></span><br><span class="line">Lease <span class="keyword">int64</span>           <span class="comment">// 租约</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h3><h4 id="跟新key"><a class="markdownIt-Anchor" href="#跟新key"></a> 跟新key</h4><ol><li>etcdctl put hello world 发起一个写事务</li><li>根据key从treeIndex B树中查对应的keyIndex信息</li><li>若查到为空，则全局版本号自增，默认是1，生成revision{2,0}</li><li>填充mvccpb.KeyValue结构体</li><li>根据带版本号的key通过Backend 的写事务接口batchTx将 key{2,0},value 为 mvccpb.KeyValue 保存到缓存中</li><li>写事务会在buffer中堆积，默认写事务大于1万才会由Backend异步执行持久化</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *storeTxnWrite)</span> <span class="title">put</span><span class="params">(key, value []<span class="keyword">byte</span>, leaseID lease.LeaseID)</span></span> &#123;</span><br><span class="line">rev := tw.beginRev + <span class="number">1</span></span><br><span class="line">c := rev</span><br><span class="line">oldLease := lease.NoLease</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这个key已存在，则时候用它之前创建的</span></span><br><span class="line">_, created, ver, err := tw.s.kvindex.Get(key, rev)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">c = created.main</span><br><span class="line">oldLease = tw.s.le.GetLease(lease.LeaseItem&#123;Key: <span class="keyword">string</span>(key)&#125;)</span><br><span class="line">&#125;</span><br><span class="line">tw.trace.Step(<span class="string">"get key's previous created_revision and leaseID"</span>)</span><br><span class="line">ibytes := newRevBytes()</span><br><span class="line">idxRev := revision&#123;main: rev, sub: <span class="keyword">int64</span>(<span class="built_in">len</span>(tw.changes))&#125;</span><br><span class="line">revToBytes(idxRev, ibytes)</span><br><span class="line"></span><br><span class="line">ver = ver + <span class="number">1</span></span><br><span class="line">kv := mvccpb.KeyValue&#123;</span><br><span class="line">Key:            key,</span><br><span class="line">Value:          value,</span><br><span class="line">CreateRevision: c,</span><br><span class="line">ModRevision:    rev,</span><br><span class="line">Version:        ver,</span><br><span class="line">Lease:          <span class="keyword">int64</span>(leaseID),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d, err := kv.Marshal()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> tw.storeTxnRead.s.lg != <span class="literal">nil</span> &#123;</span><br><span class="line">tw.storeTxnRead.s.lg.Fatal(</span><br><span class="line"><span class="string">"failed to marshal mvccpb.KeyValue"</span>,</span><br><span class="line">zap.Error(err),</span><br><span class="line">)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">plog.Fatalf(<span class="string">"cannot marshal event: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tw.trace.Step(<span class="string">"marshal mvccpb.KeyValue"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以revision为key，kv为value存入</span></span><br><span class="line">tw.tx.UnsafeSeqPut(keyBucketName, ibytes, d)</span><br><span class="line"> </span><br><span class="line">tw.s.kvindex.Put(key, idxRev)</span><br><span class="line">tw.changes = <span class="built_in">append</span>(tw.changes, kv)</span><br><span class="line">tw.trace.Step(<span class="string">"store kv pair into bolt db"</span>)</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *batchTx)</span> <span class="title">unsafePut</span><span class="params">(bucketName []<span class="keyword">byte</span>, key []<span class="keyword">byte</span>, value []<span class="keyword">byte</span>, seq <span class="keyword">bool</span>)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220223004031.jpg" alt="img" /></p><h4 id="lazy-delete-延期删除"><a class="markdownIt-Anchor" href="#lazy-delete-延期删除"></a> lazy delete 延期删除</h4><ol><li>基于更新key的流程，在生成的新版本号后追加一个标志位t</li><li>generation切片中追加一个空的，使得查询比当前版本号更大时拿到的是空</li><li>bolt mvccpb.KeyValue 结构体清空，只有key</li></ol><ul><li>Watch会根据key上的标志位t生成Delete事件</li><li>重启时，可根据boltkey 上的标志位t来重建treeIndex内存树</li><li>真正的删除是通过压缩（compactor）异步完成</li></ul><h4 id="读取key"><a class="markdownIt-Anchor" href="#读取key"></a> 读取key</h4><ol><li>etcdctl get hello 发起一个读事务</li><li>根据key从treeIndex B树中获取版本号，默认读最新，匹配有效generation后返回切片最后一个版本号给读事务</li><li>根据带版本号的key通过Backend 的ConcurrentReadTx 并发读接口去buffer缓存中查，未命中则再去boltdb找</li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><p>1.<a href="http://www.jcxioo.com/2021/07/22/01_Kubernetes/etcd%20mvcc/" target="_blank" rel="noopener">http://www.jcxioo.com/2021/07/22/01_Kubernetes/etcd mvcc/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;悲观锁：悲观得认为并发事务会冲突，所以要先拿锁，拿到锁的作修改操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读写锁（可多读，写时互斥）、互斥锁（线程互斥）等&lt;/li&gt;
&lt;li&gt;控制粒度太大，高并发下大量事务会被阻塞&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;乐观锁：乐观得认为数据不会冲突，但发生冲突时
      
    
    </summary>
    
    
      <category term="ETCD" scheme="http://xboom.github.io/categories/ETCD/"/>
    
    
      <category term="ETCD" scheme="http://xboom.github.io/tags/ETCD/"/>
    
  </entry>
  
  <entry>
    <title>k8s入门5-容器网络之网络栈</title>
    <link href="http://xboom.github.io/2022/02/21/K8S/k8s%E5%85%A5%E9%97%A85-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/"/>
    <id>http://xboom.github.io/2022/02/21/K8S/k8s%E5%85%A5%E9%97%A85-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/</id>
    <published>2022-02-20T16:35:18.000Z</published>
    <updated>2022-06-25T07:00:00.113Z</updated>
    
    <content type="html"><![CDATA[<h3 id="容器网络"><a class="markdownIt-Anchor" href="#容器网络"></a> 容器网络</h3><p>一个 Linux 容器能看见的“网络栈”，实际上是被隔离在它自己的 Network Namespace 当中的</p><p><strong>网络栈</strong>包括：网卡（Network Interface）、回环设备（Loopback Device）、路由表（Routing Table）和 iptables 规则。这些要素就构成了一个进程发起和响应网络请求的基本环境</p><blockquote><p>回环设备是指拿一个大的镜像文件，如xxx.iso或xxx.img等，在此文件内建立一个文件系统，此文件就像一个新的磁盘或光盘设备一样使用。回环可以理解成回复重用，在已有设备上建立文件来模拟物理块设备</p></blockquote><p>一个容器可以声明直接使用宿主机的网络栈（–net=host），即不开启 Network Namespace</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run –d –net=host --name nginx-host nginx</span></span><br></pre></td></tr></table></figure><p>在这种情况下，容器启动后，直接监听的就是宿主机的 80 端口</p><p>优点：可以为容器提供良好的网络性能，不需要进行网络转发操作</p><p>缺点：不可避免地引入共享网络资源的问题，比如端口冲突</p><p>在大多数情况下，还是希望容器进程能使用自己 Network Namespace 里的网络栈，即：拥有属于自己的 IP 地址和端口</p><p><strong>问题1：这个被隔离的容器进程，该如何跟其他 Network Namespace 里的容器进程进行交互呢？</strong></p><p>在 Linux 中，能够起到虚拟交换机作用的网络设备是<strong>网桥（Bridge）</strong>。它是一个工作在数据链路层（Data Link）的设备，主要功能是根据 MAC 地址学习来将数据包转发到网桥的不同端口（Port）上</p><p>Docker 项目会默认在宿主机上创建一个名叫 docker0 的网桥，凡是连接在 docker0 网桥上的容器，就可以通过它来进行通信</p><p><strong>问题2：如果将容器连接到网桥上?</strong></p><p>答案是使用<strong>Veth Pair</strong>，它被创建出来后，总是以两张虚拟网卡（Veth Peer）的形式成对出现的。并且，从其中一个“网卡”发出的数据包，可以直接出现在与它对应的另一张“网卡”上，哪怕这两个“网卡”在不同的 Network Namespace 里，使得 Veth Pair 被用作连接不同 Network Namespace 的“网线”</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20211112211740.png" alt="image-20211112211740772" style="zoom:67%;" /><p>容器里 eth0 的网卡，正是一个 Veth Pair 设备在容器里的这一端</p><p>通过 route 命令查看 nginx-1 容器的路由表，可以看到，这个 eth0 网卡是这个容器里的默认路由设备；所有对 172.17.0.0/16 网段的请求，也会被交给 eth0 来处理（第二条 172.17.0.0 路由规则）</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20211112212150.png" alt="image-20211112212150070" /></p><p>再查看Veth Pair 设备的另一端(宿主机的网络信息)，nginx-1 容器对应的 Veth Pair 设备，在宿主机上是一张虚拟网卡。它的名字叫作 veth5d20cf2</p><blockquote><p>Mac 无法查看，可以通过上面的host模型进行查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --net=host --name nginx-host nginx</span><br></pre></td></tr></table></figure></blockquote><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20211112213515.png" alt="image-20211112213515134" /></p><p>通过 brctl show 的输出，你可以看到这张网卡被“插”在了 docker0 上</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20211112213626.png" alt="image-20211112213626941" /></p><p>如果再在这台宿主机上启动另外一个容器，将会发现一个新的名字 veth7e63610 也插在docker0网桥上</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20211112213911.png" alt="image-20211112213911105" /></p><p>如果在 nginx-1 容器里 ping 一下 nginx-2 容器的 IP 地址（172.17.0.3），就会发现同一宿主机上的两个容器默认就是相互连通的，这是因为：</p><p>nginx-1 容器里访问 nginx-2 容器的 IP 地址（比如 ping 172.17.0.3）的时候，这个目的 IP 地址会匹配到 nginx-1 容器里的第二条路由规则。这条路由规则的网关（Gateway）是 0.0.0.0，这就意味着这是一条直连规则，即：<strong>凡是匹配到这条规则的 IP 包，应该经过本机的 eth0 网卡，通过二层网络直接发往目的主机</strong></p><p>同一个宿主机上的不同容器通过docker0网桥进行通信</p><img src="https://static001.geekbang.org/resource/image/e0/66/e0d28e0371f93af619e91a86eda99a66.png" alt="img" style="zoom:67%;" /><ol><li><p>要通过二层网络到达 nginx-2 容器，就需要有 172.17.0.3 这个 IP 地址对应的 MAC 地址。所以 nginx-1 容器的网络协议栈，就需要通过 eth0 网卡发送一个 ARP 广播，来通过 IP 地址查找对应的 MAC 地址</p><blockquote><p>ARP(Address Resolution Protocol)，是通过三层的 IP 地址找到对应的二层 MAC 地址的协议。</p></blockquote></li><li><p>这个 eth0 网卡是一个 Veth Pair，它的一端在这个 nginx-1 容器的 Network Namespace 里，而另一端则位于宿主机上（Host Namespace），并且被“插”在了宿主机的 docker0 网桥上，变成该网桥的“从设备”。从设备会被“剥夺”调用网络协议栈处理数据包的资格，从而“降级”成为网桥上的一个端口。而这个端口唯一的作用，就是接收流入的数据包，然后把这些数据包，全部交给对应的网桥。</p></li><li><p>docker0 在收到这些 ARP 请求之后，docker0 网桥就会扮演二层交换机的角色，把 ARP 广播转发到其他被“插”在 docker0 上的虚拟网卡上。这样，同样连接在 docker0 上的 nginx-2 容器的网络协议栈就会收到这个 ARP 请求，从而将 172.17.0.3 所对应的 MAC 地址回复给 nginx-1 容器。</p></li><li><p>有了目的 MAC 地址，nginx-1 容器的 eth0 网卡就 ping 包发出去。而根据 Veth Pair 设备的原理，这个数据包会立刻出现在宿主机上的 veth5d20cf2 虚拟网卡上，然后直接流入到了 docker0 网桥里。</p></li><li><p>docker0 继续扮演二层交换机的角色。docker0 网桥根据数据包的目的 MAC 地址，在它的 CAM 表（即交换机通过 MAC 地址学习维护的端口和 MAC 地址的对应表）里查到对应的端口（Port）为：veth7e63610，然后把数据包发往这个端口。而这个端口，正是 nginx-2 容器“插”在 docker0 网桥上的另一块虚拟网卡，当然，它也是一个 Veth Pair 设备。这样，数据包就进入到了 nginx-2 容器的 Network Namespace 里。</p></li><li><p>nginx-2 的网络协议栈就会对请求进行处理，最后将响应（Pong）返回到 nginx-1。</p></li></ol><blockquote><p>在实际的数据传递时，上述数据的传递过程在网络协议栈的不同层次，都有 Linux 内核 Netfilter 参与其中。通过打开 iptables 的 TRACE 功能查看到数据包的传输过程，在 系统日志 /var/log/syslog  或者 var/log/messages 里看到数据包传输的日志，具体方法如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在宿主机上执行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -t raw -A OUTPUT -p icmp -j TRACE</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -t raw -A PREROUTING -p icmp -j TRACE</span></span><br></pre></td></tr></table></figure></blockquote><p><strong>docker0 网桥的工作方式可以理解为，在默认情况下，被限制在 Network Namespace 里的容器进程，实际上是通过 Veth Pair 设备 + 宿主机网桥的方式，实现了跟同其他容器的数据交换</strong></p><p>在一台宿主机上，访问该宿主机上的容器的 IP 地址时，这个请求的数据包，也是先根据路由规则到达 docker0 网桥，然后被转发到对应的 Veth Pair 设备，最后出现在容器里</p><img src="https://static001.geekbang.org/resource/image/9f/01/9fb381d1e49318bb6a67bda3f9db6901.png" alt="img" style="zoom:67%;" /><p>当一个容器试图连接到另外一个宿主机时，比如：ping 10.168.0.3，</p><ol><li>请求数据包首先经过 docker0 网桥出现在宿主机上。</li><li>然后根据宿主机的路由表里的直连路由规则（10.168.0.0/24 via eth0)），对 10.168.0.3 的访问请求就会交给宿主机的 eth0 处理</li><li>这个数据包就会经宿主机的 eth0 网卡转发到宿主机网络上，最终到达 10.168.0.3 对应的宿主机上。</li></ol><img src="https://static001.geekbang.org/resource/image/90/95/90bd630c0723ea8a1fb7ccd738ad1f95.png" alt="img" style="zoom:67%;" /><p><strong>当遇到容器连不通“外网”的时候，先试试 docker0 网桥能不能 ping 通，然后查看一下跟 docker0 和 Veth Pair 设备相关的 iptables 规则是不是有异常</strong></p><p><strong>问题4：如果在另外一台宿主机（比如：10.168.0.3）上，也有一个 Docker 容器。那么，我们的 nginx-1 容器又该如何访问它呢？</strong></p><p>在 Docker 的默认配置下，一台宿主机上的 docker0 网桥，和其他宿主机上的 docker0 网桥，没有任何关联，它们互相之间也没办法连通。所以，连接在这些网桥上的容器，自然也没办法进行通信了</p><p>创建一个整个集群“公用”的网桥，然后把集群里的所有容器都连接到这个网桥上</p><img src="https://static001.geekbang.org/resource/image/b4/3d/b4387a992352109398a66d1dbe6e413d.png" alt="img" style="zoom:67%;" /><p>构建这种容器网络的核心在于：需要在已有的宿主机网络上，再通过软件构建一个覆盖在已有宿主机网络之上的、可以把所有容器连通在一起的虚拟网络，被称为：<strong>Overlay Network（覆盖网络）</strong></p><h3 id="容器跨主机网络"><a class="markdownIt-Anchor" href="#容器跨主机网络"></a> 容器跨主机网络</h3><h4 id="flannel"><a class="markdownIt-Anchor" href="#flannel"></a> Flannel</h4><p>为了解决这个容器“跨主通信”的问题，出现了那么多的容器网络方案。Flannel 项目是 CoreOS 公司主推的容器网络方案。事实上，Flannel 项目本身只是一个框架，真正为我们提供容器网络功能的，是 Flannel 的后端实现</p><p>Flannel 支持三种后端实现，也代表了三种容器跨主网络的主流实现方法</p><ul><li>VXLAN</li><li>host-gw</li><li>UDP</li></ul><h4 id="udp"><a class="markdownIt-Anchor" href="#udp"></a> UDP</h4><p>假设有两台宿主机：</p><ul><li>宿主机 Node1 上有容器 container-1，它的 IP 地址是 100.96.1.2，docker0 网桥的地址是：100.96.1.1/24</li><li>宿主机 Node2 上有容器 container-2，它的 IP 地址是 100.96.2.3，docker0 网桥的地址是：100.96.2.1/24</li></ul><p>第一步：container-1 容器里的进程发起的 IP 包，其源地址就是 100.96.1.2，目的地址就是 100.96.2.3。</p><p>第二步：由于目的地址 100.96.2.3 并不在 Node 1 的 docker0 网桥的网段里，所以这个 IP 包会被交给默认路由规则，通过容器的网关进入 docker0 网桥（如果是同一台宿主机上的容器间通信，走的是直连规则），从而出现在宿主机上。</p><p>第三步：这时候，这个 IP 包的下一个目的地，就取决于宿主机上的路由规则了。此时，Flannel 已经在宿主机上创建出了一系列的路由规则，以 Node 1 为例，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在Node 1上</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ip route</span></span><br><span class="line">default via 10.168.0.1 dev eth0</span><br><span class="line">100.96.0.0/16 dev flannel0  proto kernel  scope link  src 100.96.1.0</span><br><span class="line">100.96.1.0/24 dev docker0  proto kernel  scope link  src 100.96.1.1</span><br><span class="line">10.168.0.0/24 dev eth0  proto kernel  scope link  src 10.168.0.2</span><br></pre></td></tr></table></figure><p>可以看到，由于我们的 IP 包的目的地址是 100.96.2.3，它匹配不到本机 docker0 网桥对应的 100.96.1.0/24 网段，只能匹配到第二条、也就是 100.96.0.0/16 对应的这条路由规则，从而进入到一个叫作 flannel0 的设备中。</p><blockquote><p>flannel0 的设备类型是一个 TUN 设备，TUN 设备是一种工作在三层（Network Layer）的虚拟网络设备。TUN 设备的功能是在操作系统内核和用户应用程序之间传递 IP 包</p><p>当操作系统将一个 IP 包发送给 flannel0 设备之后，flannel0 就会把这个 IP 包，交给创建这个设备的应用程序，也就是 Flannel 进程。这是一个从内核态（Linux 操作系统）向用户态（Flannel 进程）的流动方向。</p><p>反之，如果 Flannel 进程向 flannel0 设备发送了一个 IP 包，那么这个 IP 包就会出现在宿主机网络栈中，然后根据宿主机的路由表进行下一步处理。这是一个从用户态向内核态的流动方向</p></blockquote><p>当 IP 包从容器经过 docker0 出现在宿主机，然后又根据路由表进入 flannel0 设备后，宿主机上的 flanneld 进程（Flannel 项目在每个宿主机上的主进程），就会收到这个 IP 包。然后，flanneld 看到了这个 IP 包的目的地址，是 100.96.2.3，就把它发送给了 Node 2 宿主机。</p><blockquote><p>那么 flannelId 又是如何知道这个IP地址对应的容器运行在Node 2上面呢？</p></blockquote><p>在由 Flannel 管理的容器网络里，一台宿主机上的所有容器，都属于该宿主机被分配的一个“子网”。在例子中，Node 1 的子网是 100.96.1.0/24，container-1 的 IP 地址是 100.96.1.2。Node 2 的子网是 100.96.2.0/24，container-2 的 IP 地址是 100.96.2.3。而这些子网与宿主机的对应关系，正是保存在 Etcd 当中，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> etcdctl ls /coreos.com/network/subnets</span></span><br><span class="line">/coreos.com/network/subnets/100.96.1.0-24</span><br><span class="line">/coreos.com/network/subnets/100.96.2.0-24</span><br><span class="line">/coreos.com/network/subnets/100.96.3.0-24</span><br></pre></td></tr></table></figure><p>所以，flanneld 进程在处理由 flannel0 传入的 IP 包时，就可以根据目的 IP 的地址（比如 100.96.2.3），匹配到对应的子网（比如 100.96.2.0/24），从 Etcd 中找到这个子网对应的宿主机的 IP 地址是 10.168.0.3</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> etcdctl get /coreos.com/network/subnets/100.96.2.0-24</span></span><br><span class="line">&#123;"PublicIP":"10.168.0.3"&#125;</span><br></pre></td></tr></table></figure><p>而对于 flanneld 来说，只要 Node 1 和 Node 2 是互通的，那么 flanneld 作为 Node 1 上的一个普通进程，就一定可以通过上述 IP 地址（10.168.0.3）访问到 Node 2，这没有任何问题</p><p>**flanneld 在收到 container-1 发给 container-2 的 IP 包之后，就会把这个 IP 包直接封装在一个 UDP 包里，然后发送给 Node 2。**这个 UDP 包的源地址，就是 flanneld 所在的 Node 1 的地址，而目的地址，则是 container-2 所在的宿主机 Node 2 的地址。</p><p>当然，这个请求得以完成的原因是，每台宿主机上的 flanneld，都监听着一个 <code>8285</code> 端口，所以 flanneld 只要把 UDP 包发往 Node 2 的 <code>8285</code> 端口即可。</p><p>通过这样一个普通的、宿主机之间的 UDP 通信，一个 UDP 包就从 Node 1 到达了 Node 2。而 Node 2 上监听 8285 端口的进程也是 flanneld，所以这时候，flanneld 就可以从这个 UDP 包里解析出封装在里面的、container-1 发来的原 IP 包。</p><p>而接下来 flanneld 的工作就非常简单了：flanneld 会直接把这个 IP 包发送给它所管理的 TUN 设备，即 flannel0 设备。根据我前面讲解的 TUN 设备的原理，这正是一个从用户态向内核态的流动方向（Flannel 进程向 TUN 设备发送数据包），所以 Linux 内核网络栈就会负责处理这个 IP 包，具体的处理方法，就是通过本机的路由表来寻找这个 IP 包的下一步流向。而 Node 2 上的路由表，跟 Node 1 非常类似，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在Node 2上</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ip route</span></span><br><span class="line">default via 10.168.0.1 dev eth0</span><br><span class="line">100.96.0.0/16 dev flannel0  proto kernel  scope link  src 100.96.2.0</span><br><span class="line">100.96.2.0/24 dev docker0  proto kernel  scope link  src 100.96.2.1</span><br><span class="line">10.168.0.0/24 dev eth0  proto kernel  scope link  src 10.168.0.3</span><br></pre></td></tr></table></figure><p>由于这个 IP 包的目的地址是 100.96.2.3，它跟第三条、也就是 100.96.2.0/24 网段对应的路由规则匹配更加精确。所以，Linux 内核就会按照这条路由规则，把这个 IP 包转发给 docker0 网桥。</p><p>接下来的流程，docker0 网桥会扮演二层交换机的角色，将数据包发送给正确的端口，进而通过 Veth Pair 设备进入到 container-2 的 Network Namespace 里。而 container-2 返回给 container-1 的数据包，则会经过与上述过程完全相反的路径回到 container-1 中。</p><blockquote><p>需要注意的是，上述流程要正确工作还有一个重要的前提，那就是 docker0 网桥的地址范围必须是 Flannel 为宿主机分配的子网。这个很容易实现，以 Node 1 为例，你只需要给它上面的 Docker Daemon 启动时配置如下所示的 bip 参数即可：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> FLANNEL_SUBNET=100.96.1.1/24</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dockerd --bip=<span class="variable">$FLANNEL_SUBNET</span> ...</span></span><br></pre></td></tr></table></figure><p>以上，就是基于 Flannel UDP 模式的跨主通信的基本原理了，如下所示。</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20211112235123.jpg" alt="img" style="zoom:67%;" /><p>可以看到，Flannel UDP 模式提供的其实是一个三层的 Overlay 网络，即：它首先对发出端的 IP 包进行 UDP 封装，然后在接收端进行解封装拿到原始的 IP 包，进而把这个 IP 包转发给目标容器。这就好比，Flannel 在不同宿主机上的两个容器之间打通了一条“隧道”，使得这两个容器可以直接使用 IP 地址进行通信，而无需关心容器和宿主机的分布情况。</p><p>上述 UDP 模式有严重的性能问题，所以已经被废弃了。</p><p>相比于两台宿主机之间的直接通信，基于 Flannel UDP 模式的容器通信多了一个额外的步骤，即 flanneld 的处理过程。而这个过程，由于使用到了 flannel0 这个 TUN 设备，仅在发出 IP 包的过程中，就需要经过三次用户态与内核态之间的数据拷贝，如下所示：</p><img src="https://static001.geekbang.org/resource/image/84/8d/84caa6dc3f9dcdf8b88b56bd2e22138d.png" alt="img" style="zoom:67%;" /><p>可以看到：</p><ol><li>第一次，用户态的容器进程发出的 IP 包经过 docker0 网桥进入内核态；</li><li>第二次，IP 包根据路由表进入 TUN（flannel0）设备，从而回到用户态的 flanneld 进程；</li><li>第三次，flanneld 进行 UDP 封包之后重新进入内核态，将 UDP 包通过宿主机的 eth0 发出去。</li></ol><p>此外，我们还可以看到，Flannel 进行 UDP 封装（Encapsulation）和解封装（Decapsulation）的过程，也都是在用户态完成的。这也正是造成 Flannel UDP 模式性能不好的主要原因</p><h4 id="vxlan"><a class="markdownIt-Anchor" href="#vxlan"></a> VXLAN</h4><p>即 Virtual Extensible LAN（虚拟可扩展局域网），是 Linux 内核本身就支持的一种网络虚似化技术。所以说，VXLAN 可以完全在内核态实现上述封装和解封装的工作，从而通过与前面相似的“隧道”机制，构建出覆盖网络（Overlay Network）</p><p>VXLAN 的覆盖网络的设计思想是：在现有的三层网络之上，“覆盖”一层虚拟的、由内核 VXLAN 模块负责维护的二层网络，使得连接在这个 VXLAN 二层网络上的“主机”（虚拟机或者容器都可以）之间，可以像在同一个局域网（LAN）里那样自由通信。当然，实际上，这些“主机”可能分布在不同的宿主机上，甚至是分布在不同的物理机房里。</p><p>而为了能够在二层网络上打通“隧道”，VXLAN 会在宿主机上设置一个特殊的网络设备作为“隧道”的两端。这个设备就叫作 VTEP，即：VXLAN Tunnel End Point（虚拟隧道端点）。</p><p>而 VTEP 设备的作用，其实跟前面的 flanneld 进程非常相似。只不过，它进行封装和解封装的对象，是二层数据帧（Ethernet frame）；而且这个工作的执行流程，全部是在内核里完成的（因为 VXLAN 本身就是 Linux 内核中的一个模块）。</p><p>上述基于 VTEP 设备进行“隧道”通信的流程，如下所示：</p><img src="https://static001.geekbang.org/resource/image/03/f5/03185fab251a833fef7ed6665d5049f5.jpg" alt="img" style="zoom:67%;" /><p>可以看到，图中每台宿主机上名叫 flannel.1 的设备，就是 VXLAN 所需的 VTEP 设备，它既有 IP 地址，也有 MAC 地址。现在，我们的 container-1 的 IP 地址是 10.1.15.2，要访问的 container-2 的 IP 地址是 10.1.16.3。那么，与前面 UDP 模式的流程类似，当 container-1 发出请求之后，这个目的地址是 10.1.16.3 的 IP 包，会先出现在 docker0 网桥，然后被路由到本机 flannel.1 设备进行处理。也就是说，来到了“隧道”的入口。为了方便叙述，我接下来会把这个 IP 包称为“原始 IP 包”。</p><p>为了能够将“原始 IP 包”封装并且发送到正确的宿主机，VXLAN 就需要找到这条“隧道”的出口，即：目的宿主机的 VTEP 设备。而这个设备的信息，正是每台宿主机上的 flanneld 进程负责维护的。比如，当 Node 2 启动并加入 Flannel 网络之后，在 Node 1（以及所有其他节点）上，flanneld 就会添加一条如下所示的路由规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> route -n</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">...</span><br><span class="line">10.1.16.0       10.1.16.0       255.255.255.0   UG    0      0        0 flannel.1</span><br></pre></td></tr></table></figure><p>这条规则的意思是：凡是发往 10.1.16.0/24 网段的 IP 包，都需要经过 flannel.1 设备发出，并且，它最后被发往的网关地址是：10.1.16.0。从图 3 的 Flannel VXLAN 模式的流程图中我们可以看到，10.1.16.0 正是 Node 2 上的 VTEP 设备（也就是 flannel.1 设备）的 IP 地址。为了方便叙述，接下来我会把 Node 1 和 Node 2 上的 flannel.1 设备分别称为“源 VTEP 设备”和“目的 VTEP 设备”。而这些 VTEP 设备之间，就需要想办法组成一个虚拟的二层网络，即：通过二层数据帧进行通信。</p><p>“源 VTEP 设备”收到“原始 IP 包”后，就要想办法把“原始 IP 包”加上一个目的 MAC 地址，封装成一个二层数据帧，然后发送给“目的 VTEP 设备”（当然，这么做还是因为这个 IP 包的目的地址不是本机）。</p><p><strong>目的 VTEP 设备 的 MAC 地址是什么？</strong></p><p>此时，根据前面的路由记录，我们已经知道了“目的 VTEP 设备”的 IP 地址。而要根据三层 IP 地址查询对应的二层 MAC 地址，这正是 ARP（Address Resolution Protocol ）表的功能。而这里要用到的 ARP 记录，也是 flanneld 进程在 Node 2 节点启动时，自动添加在 Node 1 上的。我们可以通过 ip 命令看到它，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在Node 1上</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ip neigh show dev flannel.1</span></span><br><span class="line">10.1.16.0 lladdr 5e:f8:4f:00:e3:37 PERMANENT</span><br></pre></td></tr></table></figure><p>这条记录的意思非常明确，即：IP 地址 10.1.16.0，对应的 MAC 地址是 5e:f8:4f:00:e3:37。</p><blockquote><p>可以看到，最新版本的 Flannel 并不依赖 L3 MISS 事件和 ARP 学习，而会在每台节点启动时把它的 VTEP 设备对应的 ARP 记录，直接下放到其他每台宿主机上</p></blockquote><p>有了这个“目的 VTEP 设备”的 MAC 地址，Linux 内核就可以开始二层封包工作了。这个二层帧的格式，如下所示：</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20211113001610.jpg" alt="img" /></p><p>可以看到，Linux 内核会把“目的 VTEP 设备”的 MAC 地址，填写在图中的 Inner Ethernet Header 字段，得到一个二层数据帧。需要注意的是，上述封包过程只是加一个二层头，不会改变“原始 IP 包”的内容。所以图中的 Inner IP Header 字段，依然是 container-2 的 IP 地址，即 10.1.16.3。</p><p>但是，上面提到的这些 VTEP 设备的 MAC 地址，对于宿主机网络来说并没有什么实际意义。所以上面封装出来的这个数据帧，并不能在我们的宿主机二层网络里传输。为了方便叙述，我们把它称为“内部数据帧”（Inner Ethernet Frame）。Linux 内核还需要再把“内部数据帧”进一步封装成为宿主机网络里的一个普通的数据帧，好让它“载着”“内部数据帧”，通过宿主机的 eth0 网卡进行传输。我们把这次要封装出来的、宿主机对应的数据帧称为“外部数据帧”（Outer Ethernet Frame）。</p><p>为了实现这个“搭便车”的机制，Linux 内核会在“内部数据帧”前面，加上一个特殊的 VXLAN 头，用来表示这个“乘客”实际上是一个 VXLAN 要使用的数据帧。而这个 VXLAN 头里有一个重要的标志叫作 VNI，它是 VTEP 设备识别某个数据帧是不是应该归自己处理的重要标识。而在 Flannel 中，VNI 的默认值是 1，这也是为何，宿主机上的 VTEP 设备都叫作 flannel.1 的原因，这里的“1”，其实就是 VNI 的值。</p><p>然后，Linux 内核会把这个数据帧封装进一个 UDP 包里发出去。</p><p>所以，跟 UDP 模式类似，在宿主机看来，它会以为自己的 flannel.1 设备只是在向另外一台宿主机的 flannel.1 设备，发起了一次普通的 UDP 链接。它哪里会知道，这个 UDP 包里面，其实是一个完整的二层数据帧。这是不是跟特洛伊木马的故事非常像呢？不过，不要忘了，一个 flannel.1 设备只知道另一端的 flannel.1 设备的 MAC 地址，却不知道对应的宿主机地址是什么。也就是说，这个 UDP 包该发给哪台宿主机呢？在这种场景下，flannel.1 设备实际上要扮演一个“网桥”的角色，在二层网络进行 UDP 包的转发。而在 Linux 内核里面，“网桥”设备进行转发的依据，来自于一个叫作 FDB（Forwarding Database）的转发数据库。</p><p>不难想到，这个 flannel.1“网桥”对应的 FDB 信息，也是 flanneld 进程负责维护的。它的内容可以通过 bridge fdb 命令查看到，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在Node 1上，使用“目的VTEP设备”的MAC地址进行查询</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bridge fdb show flannel.1 | grep 5e:f8:4f:00:e3:37</span></span><br><span class="line">5e:f8:4f:00:e3:37 dev flannel.1 dst 10.168.0.3 self permanent</span><br></pre></td></tr></table></figure><p>可以看到，在上面这条 FDB 记录里，指定了这样一条规则，即：发往我们前面提到的“目的 VTEP 设备”（MAC 地址是 5e:f8:4f:00:e3:37）的二层数据帧，应该通过 flannel.1 设备，发往 IP 地址为 10.168.0.3 的主机。显然，这台主机正是 Node 2，UDP 包要发往的目的地就找到了。</p><p>所以接下来的流程，就是一个正常的、宿主机网络上的封包工作。</p><p>我们知道，UDP 包是一个四层数据包，所以 Linux 内核会在它前面加上一个 IP 头，即原理图中的 Outer IP Header，组成一个 IP 包。并且，在这个 IP 头里，会填上前面通过 FDB 查询出来的目的主机的 IP 地址，即 Node 2 的 IP 地址 10.168.0.3。然后，Linux 内核再在这个 IP 包前面加上二层数据帧头，即原理图中的 Outer Ethernet Header，并把 Node 2 的 MAC 地址填进去。这个 MAC 地址本身，是 Node 1 的 ARP 表要学习的内容，无需 Flannel 维护。这时候，我们封装出来的“外部数据帧”的格式，如下所示：</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20211113001850.jpg" alt="img" /></p><p>这样，封包工作就宣告完成了。接下来，Node 1 上的 flannel.1 设备就可以把这个数据帧从 Node 1 的 eth0 网卡发出去。显然，这个帧会经过宿主机网络来到 Node 2 的 eth0 网卡。这时候，Node 2 的内核网络栈会发现这个数据帧里有 VXLAN Header，并且 VNI=1。所以 Linux 内核会对它进行拆包，拿到里面的内部数据帧，然后根据 VNI 的值，把它交给 Node 2 上的 flannel.1 设备。而 flannel.1 设备则会进一步拆包，取出“原始 IP 包”。接下来就回到了我在上一篇文章中分享的单机容器网络的处理流程。最终，IP 包就进入到了 container-2 容器的 Network Namespace 里。以上，就是 Flannel VXLAN 模式的具体工作原理了。</p><blockquote><p>Flannel 能负责保证二层网络（MAC 地址）的连通性吗？</p></blockquote><h3 id="cni网络插件"><a class="markdownIt-Anchor" href="#cni网络插件"></a> CNI网络插件</h3><p>UDP与VXLAN都需要容器连接在 docker0 网桥上。而网络插件则在宿主机上创建了一个特殊的设备（UDP 模式创建的是 TUN 设备，VXLAN 模式创建的则是 VTEP 设备），docker0 与这个设备之间，通过 IP 转发（路由表）进行协作</p><p>网络插件是通过某种方法，把不同宿主机上的特殊设备连通，从而达到容器跨主机通信的目的。</p><p>Kubernetes 是通过一个叫作 CNI 的接口，维护了一个单独的网桥来代替 docker0。这个网桥的名字就叫作：CNI 网桥，它在宿主机上的设备名称默认是：cni0</p><p>以 Flannel 的 VXLAN 模式为例，在 Kubernetes 环境里，它的工作方式跟我们在上一篇文章中讲解的没有任何不同。只不过，docker0 网桥被替换成了 CNI 网桥而已</p><img src="https://static001.geekbang.org/resource/image/9f/8c/9f11d8716f6d895ff6d1c813d460488c.jpg" alt="img" style="zoom:67%;" /><p>Kubernetes 为 Flannel 分配的子网范围是 10.244.0.0/16。这个参数可以在部署的时候指定</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubeadm init --pod-network-cidr=10.244.0.0/16</span></span><br></pre></td></tr></table></figure><p>也可以在部署完成后，通过修改 kube-controller-manager 的配置文件来指定。这时候，假设 Infra-container-1 要访问 Infra-container-2（也就是 Pod-1 要访问 Pod-2），这个 IP 包的源地址就是 10.244.0.2，目的 IP 地址是 10.244.1.3。而此时，Infra-container-1 里的 eth0 设备，同样是以 Veth Pair 的方式连接在 Node 1 的 cni0 网桥上。所以这个 IP 包就会经过 cni0 网桥出现在宿主机上</p><p>此时，Node 1 上的路由表，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在Node 1上</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> route -n</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">...</span><br><span class="line">10.244.0.0      0.0.0.0         255.255.255.0   U     0      0        0 cni0</span><br><span class="line">10.244.1.0      10.244.1.0      255.255.255.0   UG    0      0        0 flannel.1</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br></pre></td></tr></table></figure><p>因为我们的 IP 包的目的 IP 地址是 10.244.1.3，所以它只能匹配到第二条规则，也就是 10.244.1.0 对应的这条路由规则。可以看到，这条规则指定了本机的 flannel.1 设备进行处理。并且，flannel.1 在处理完后，要将 IP 包转发到的网关（Gateway），正是“隧道”另一端的 VTEP 设备，也就是 Node 2 的 flannel.1 设备。所以，接下来的流程，就跟上一篇文章中介绍过的 Flannel VXLAN 模式完全一样了</p><p>需要注意的是，<strong>CNI 网桥只是接管所有 CNI 插件负责的、即 Kubernetes 创建的容器（Pod）</strong>。而此时，如果你用 docker run 单独启动一个容器，那么 Docker 项目还是会把这个容器连接到 docker0 网桥上。所以这个容器的 IP 地址，一定是属于 docker0 网桥的 172.17.0.0/16 网段。</p><p>Kubernetes 之所以要设置这样一个与 docker0 网桥功能几乎一样的 CNI 网桥，主要原因包括两个方面：</p><ul><li>一方面，Kubernetes 项目并没有使用 Docker 的网络模型（CNM），所以它并不希望、也不具备配置 docker0 网桥的能力；</li><li>另一方面，这还与 Kubernetes 如何配置 Pod，也就是 Infra 容器的 Network Namespace 密切相关。</li></ul><p>Kubernetes 创建一个 Pod 的第一步，就是创建并启动一个 Infra 容器，用来“hold”住这个 Pod 的 Network Namespace。所以，CNI 的设计思想，就是：Kubernetes 在启动 Infra 容器之后，就可以直接调用 CNI 网络插件，为这个 Infra 容器的 Network Namespace，配置符合预期的网络栈。</p><p>那么它是怎么完成这个网络栈的配置的呢？</p><p>在部署 Kubernetes 的时候，有一个步骤是安装 kubernetes-cni 包，它的目的就是在宿主机上安装 CNI 插件所需的基础可执行文件，在安装完成后，你可以在宿主机的 /opt/cni/bin 目录下看到它们，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -al /opt/cni/bin/</span></span><br><span class="line">total 73088</span><br><span class="line">-rwxr-xr-x 1 root root  3890407 Aug 17  2017 bridge</span><br><span class="line">-rwxr-xr-x 1 root root  9921982 Aug 17  2017 dhcp</span><br><span class="line">-rwxr-xr-x 1 root root  2814104 Aug 17  2017 flannel</span><br><span class="line">-rwxr-xr-x 1 root root  2991965 Aug 17  2017 host-local</span><br><span class="line">-rwxr-xr-x 1 root root  3475802 Aug 17  2017 ipvlan</span><br><span class="line">-rwxr-xr-x 1 root root  3026388 Aug 17  2017 loopback</span><br><span class="line">-rwxr-xr-x 1 root root  3520724 Aug 17  2017 macvlan</span><br><span class="line">-rwxr-xr-x 1 root root  3470464 Aug 17  2017 portmap</span><br><span class="line">-rwxr-xr-x 1 root root  3877986 Aug 17  2017 ptp</span><br><span class="line">-rwxr-xr-x 1 root root  2605279 Aug 17  2017 sample</span><br><span class="line">-rwxr-xr-x 1 root root  2808402 Aug 17  2017 tuning</span><br><span class="line">-rwxr-xr-x 1 root root  3475750 Aug 17  2017 vlan</span><br></pre></td></tr></table></figure><p>这些 CNI 的基础可执行文件，按照功能可以分为三类：</p><ul><li>第一类，叫作 Main 插件，它是用来创建具体网络设备的二进制文件。比如，bridge（网桥设备）、ipvlan、loopback（lo 设备）、macvlan、ptp（Veth Pair 设备），以及 vlan。我在前面提到过的 Flannel、Weave 等项目，都属于“网桥”类型的 CNI 插件。所以在具体的实现中，它们往往会调用 bridge 这个二进制文件。</li><li>第二类，叫作 IPAM（IP Address Management）插件，它是负责分配 IP 地址的二进制文件。比如，dhcp，这个文件会向 DHCP 服务器发起请求；host-local，则会使用预先配置的 IP 地址段来进行分配。</li><li>第三类，是由 CNI 社区维护的内置 CNI 插件。比如：<ul><li>flannel，就是专门为 Flannel 项目提供的 CNI 插件；</li><li>tuning，是一个通过 sysctl 调整网络设备参数的二进制文件；</li><li>portmap，是一个通过 iptables 配置端口映射的二进制文件；</li><li>bandwidth，是一个使用 Token Bucket Filter (TBF) 来进行限流的二进制文件。</li></ul></li></ul><p>从这些二进制文件中，我们可以看到，如果要实现一个给 Kubernetes 用的容器网络方案，其实需要做两部分工作，以 Flannel 项目为例：</p><p>首先，实现这个网络方案本身。这一部分需要编写的，其实就是 flanneld 进程里的主要逻辑。比如，创建和配置 flannel.1 设备、配置宿主机路由、配置 ARP 和 FDB 表里的信息等等。然后，实现该网络方案对应的 CNI 插件。这一部分主要需要做的，就是配置 Infra 容器里面的网络栈，并把它连接在 CNI 网桥上。</p><p>由于 Flannel 项目对应的 CNI 插件已经被内置了，所以它无需再单独安装。而对于 Weave、Calico 等其他项目来说，我们就必须在安装插件的时候，把对应的 CNI 插件的可执行文件放在 /opt/cni/bin/ 目录下。</p><blockquote><p>实际上，对于 Weave、Calico 这样的网络方案来说，它们的 DaemonSet 只需要挂载宿主机的 /opt/cni/bin/，就可以实现插件可执行文件的安装了。你可以想一下具体应该怎么做，就当作一个课后小问题留给你去实践了。</p></blockquote><p>接下来，你就需要在宿主机上安装 flanneld（网络方案本身）。而在这个过程中，flanneld 启动后会在每台宿主机上生成它对应的 CNI 配置文件（它其实是一个 ConfigMap），从而告诉 Kubernetes，这个集群要使用 Flannel 作为容器网络方案。</p><p>这个 CNI 配置文件的内容如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">cat</span> <span class="string">/etc/cni/net.d/10-flannel.conflist</span> </span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line">  <span class="attr">"name":</span> <span class="string">"cbr0"</span><span class="string">,</span></span><br><span class="line">  <span class="attr">"plugins":</span> <span class="string">[</span></span><br><span class="line">    <span class="string">&#123;</span></span><br><span class="line">      <span class="attr">"type":</span> <span class="string">"flannel"</span><span class="string">,</span></span><br><span class="line">      <span class="attr">"delegate":</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">"hairpinMode":</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">        <span class="attr">"isDefaultGateway":</span> <span class="literal">true</span></span><br><span class="line">      <span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;,</span></span><br><span class="line">    <span class="string">&#123;</span></span><br><span class="line">      <span class="attr">"type":</span> <span class="string">"portmap"</span><span class="string">,</span></span><br><span class="line">      <span class="attr">"capabilities":</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">"portMappings":</span> <span class="literal">true</span></span><br><span class="line">      <span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="soft-multi-tenancy"><a class="markdownIt-Anchor" href="#soft-multi-tenancy"></a> Soft multi-tenancy</h3><p>为什么说 Kubernetes 只有 soft multi-tenancy？</p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li>《极客时间-深入剖析 Kubernetes》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;容器网络&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#容器网络&quot;&gt;&lt;/a&gt; 容器网络&lt;/h3&gt;
&lt;p&gt;一个 Linux 容器能看见的“网络栈”，实际上是被隔离在它自己的 Network Namespace 当中的&lt;/p&gt;
&lt;p&gt;&lt;st
      
    
    </summary>
    
    
      <category term="k8s" scheme="http://xboom.github.io/categories/k8s/"/>
    
    
      <category term="k8s" scheme="http://xboom.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>k8s入门13-容器网络之Service和Ingress</title>
    <link href="http://xboom.github.io/2022/02/21/K8S/k8s%E5%85%A5%E9%97%A813-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%B9%8BService%E5%92%8CIngress/"/>
    <id>http://xboom.github.io/2022/02/21/K8S/k8s%E5%85%A5%E9%97%A813-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%B9%8BService%E5%92%8CIngress/</id>
    <published>2022-02-20T16:35:06.000Z</published>
    <updated>2022-02-20T16:36:12.237Z</updated>
    
    <content type="html"><![CDATA[<p>Service 暴露给外界的三种方法中有一个叫作 LoadBalancer 类型的 Service，它会为你在 Cloud Provider（比如：Google Cloud 或者 OpenStack）里创建一个与该 Service 对应的负载均衡服务</p><p>由于每个 Service 都要有一个负载均衡服务，为什么没有一个内置一个全局的负载均衡器。通过访问的 URL，把请求转发给不同的后端 Service。</p><p>这种全局的、为了代理不同后端 Service 而设置的负载均衡服务，就是 Kubernetes 里的 Ingress 服务。可以说是 Service 的“Service”。</p><p>举个例子，假如我现在有这样一个站点：<a href="https://cafe.example.com" target="_blank" rel="noopener">https://cafe.example.com</a>。其中，</p><p><a href="https://cafe.example.com/coffee%EF%BC%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E6%98%AF%E2%80%9C%E5%92%96%E5%95%A1%E7%82%B9%E9%A4%90%E7%B3%BB%E7%BB%9F%E2%80%9D%E3%80%82" target="_blank" rel="noopener">https://cafe.example.com/coffee，对应的是“咖啡点餐系统”。</a></p><p><a href="https://cafe.example.com/tea%EF%BC%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E5%88%99%E6%98%AF%E2%80%9C%E8%8C%B6%E6%B0%B4%E7%82%B9%E9%A4%90%E7%B3%BB%E7%BB%9F%E2%80%9D%E3%80%82" target="_blank" rel="noopener">https://cafe.example.com/tea，对应的则是“茶水点餐系统”。</a></p><p>这两个系统，分别由名叫 coffee 和 tea 这样两个 Deployment 来提供服务</p><p>如何能使用 Kubernetes 的 Ingress 来创建一个统一的负载均衡器，从而实现当用户访问不同的域名时，能够访问到不同的 Deployment 呢？</p><p>在 Kubernetes 里就需要通过 Ingress 对象来描述，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cafe-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cafe.example.com</span></span><br><span class="line">    <span class="attr">secretName:</span> <span class="string">cafe-secret</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">cafe.example.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/tea</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">tea-svc</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/coffee</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">coffee-svc</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>在 Kubernetes 里，文件的 <code>rules</code> 字段叫作：IngressRule</p><p>IngressRule 的 Key 就叫做：host。它<strong>必须</strong>是一个标准的域名格式（Fully Qualified Domain Name）的字符串，而不能是 IP 地址。</p><p>而 <code>host</code> 字段定义的值就是这个 Ingress 的入口。当用户访问 <code>cafe.example.com</code> 的时候，实际上访问到的是这个 Ingress 对象。这样，Kubernetes 就能使用 IngressRule 来对你的请求进行下一步转发。</p><p>接下来 IngressRule 规则的定义，则依赖于 <code>path</code> 字段。你可以简单地理解为，这里的每一个 path 都对应一个后端 Service。所以在我们的例子里，我定义了两个 path，它们分别对应 coffee 和 tea 这两个 Deployment 的 Service（即：coffee-svc 和 tea-svc）</p><p>所以所谓 Ingress 对象，其实就是 Kubernetes 项目对“反向代理”的一种抽象。而这个代理服务对应的转发规则，就是 IngressRule。跟 Nginx、HAproxy 等项目的配置文件的写法是一致的。Kubernetes 的用户就无需关心 Ingress 的具体细节了。选择一个具体的 Ingress Controller，把它部署在 Kubernetes 集群里即可</p><p>这个 Ingress Controller 会根据你定义的 Ingress 对象，提供对应的代理能力。目前，业界常用的各种反向代理项目，比如 Nginx、HAProxy、Envoy、Traefik 等，都已经为 Kubernetes 专门维护了对应的 Ingress Controller。</p><p>以最常用的 Nginx Ingress Controller 为例，在用 kubeadm 部署的 Bare-metal 环境中，实践 Ingress 机制的使用过程。</p><p>部署 Nginx Ingress Controller 的方法非常简单，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/mandatory.yaml</span></span><br></pre></td></tr></table></figure><p>在mandatory.yaml这个文件里，正是 Nginx 官方为你维护的 Ingress Controller 的定义。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-configuration</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-ingress-controller</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">      <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">        <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line">      <span class="attr">annotations:</span></span><br><span class="line">        <span class="string">...</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">nginx-ingress-serviceaccount</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-ingress-controller</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.20.0</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/nginx-ingress-controller</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--configmap=$(POD_NAMESPACE)/nginx-configuration</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--publish-service=$(POD_NAMESPACE)/ingress-nginx</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--annotations-prefix=nginx.ingress.kubernetes.io</span></span><br><span class="line">          <span class="attr">securityContext:</span></span><br><span class="line">            <span class="attr">capabilities:</span></span><br><span class="line">              <span class="attr">drop:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">ALL</span></span><br><span class="line">              <span class="attr">add:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">NET_BIND_SERVICE</span></span><br><span class="line">            <span class="comment"># www-data -&gt; 33</span></span><br><span class="line">            <span class="attr">runAsUser:</span> <span class="number">33</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POD_NAME</span></span><br><span class="line">              <span class="attr">valueFrom:</span></span><br><span class="line">                <span class="attr">fieldRef:</span></span><br><span class="line">                  <span class="attr">fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POD_NAMESPACE</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">              <span class="attr">valueFrom:</span></span><br><span class="line">                <span class="attr">fieldRef:</span></span><br><span class="line">                  <span class="attr">fieldPath:</span> <span class="string">metadata.namespace</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">              <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">              <span class="attr">containerPort:</span> <span class="number">443</span></span><br></pre></td></tr></table></figure><p>上述是使用 nginx-ingress-controller 镜像的 Pod。</p><blockquote><p>注意: 这个 Pod 的启动命令需要使用该 Pod 所在的 Namespace 作为参数{POD_NAMESPACE}。而这个信息，当然是通过 Downward API 拿到的，即：Pod 的 env 字段里的定义（env.valueFrom.fieldRef.fieldPath）</p></blockquote><p>而这个 Pod 本身，就是一个监听 Ingress 对象以及它所代理的后端 Service 变化的控制器。</p><p>当一个新的 Ingress 对象由用户创建后，nginx-ingress-controller 就会根据 Ingress 对象里定义的内容，生成一份对应的 Nginx 配置文件（/etc/nginx/nginx.conf），并使用这个配置文件启动一个 Nginx 服务。</p><p>而一旦 Ingress 对象被更新，nginx-ingress-controller 就会更新这个配置文件。需要注意的是，如果这里只是被代理的 Service 对象被更新，nginx-ingress-controller 所管理的 Nginx 服务是不<strong>需要重新加载</strong>（reload）的。这当然是因为 nginx-ingress-controller 通过Nginx Lua方案实现了 Nginx Upstream 的动态配置</p><p>此外，nginx-ingress-controller 还允许你通过 Kubernetes 的 ConfigMap 对象来对上述 Nginx 配置文件进行定制。这个 ConfigMap 的名字，需要以参数的方式传递给 nginx-ingress-controller。而你在这个 ConfigMap 里添加的字段，将会被合并到最后生成的 Nginx 配置文件当中。可以看到，一个 Nginx Ingress Controller 为你提供的服务，其实是一个可以根据 Ingress 对象和被代理后端 Service 的变化，来自动进行更新的 Nginx 负载均衡器。</p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li>《极客时间-深入剖析Kubernetes》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Service 暴露给外界的三种方法中有一个叫作 LoadBalancer 类型的 Service，它会为你在 Cloud Provider（比如：Google Cloud 或者 OpenStack）里创建一个与该 Service 对应的负载均衡服务&lt;/p&gt;
&lt;p&gt;由于每个
      
    
    </summary>
    
    
      <category term="k8s" scheme="http://xboom.github.io/categories/k8s/"/>
    
    
      <category term="k8s" scheme="http://xboom.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>k8s入门12-容器网络之Service调试访问</title>
    <link href="http://xboom.github.io/2022/02/21/K8S/k8s%E5%85%A5%E9%97%A812-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%B9%8BService%E8%B0%83%E8%AF%95%E8%AE%BF%E9%97%AE/"/>
    <id>http://xboom.github.io/2022/02/21/K8S/k8s%E5%85%A5%E9%97%A812-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%B9%8BService%E8%B0%83%E8%AF%95%E8%AE%BF%E9%97%AE/</id>
    <published>2022-02-20T16:34:52.000Z</published>
    <updated>2022-02-20T16:36:17.744Z</updated>
    
    <content type="html"><![CDATA[<p>Service 的访问入口，其实就是每台宿主机上由 kube-proxy 生成的 iptables 规则，以及 kube-dns 生成的 DNS 记录。Service 的访问信息在 Kubernetes 集群之外是无效的</p><p>如何从外部(Kubernetes 集群之外)，访问到 Kubernetes 里创建的 Service</p><h3 id="外部访问service"><a class="markdownIt-Anchor" href="#外部访问service"></a> 外部访问Service</h3><p>最常用的办法：NodePort</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">my-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">nodePort:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">nodePort:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">my-nginx</span></span><br></pre></td></tr></table></figure><p>在 Service 定义中声明它的类型是，type=NodePort。然后，在 ports 字段里声明了 Service 的 8080 端口代理 Pod 的 80 端口，Service 的 443 端口代理 Pod 的 443 端口</p><blockquote><p>如果不显式地声明 nodePort 字段，Kubernetes 就会为你分配随机的可用端口来设置代理。这个端口的范围默认是 30000-32767，可通过 kube-apiserver 的–service-node-port-range 参数来修改它</p></blockquote><p>这时候，要访问这个 Service，你只需要访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;任何一台宿主机的IP地址&gt;:8080</span><br></pre></td></tr></table></figure><p>就可以访问到某一个被代理的 Pod 的 80 端口了。NodePort 模式下，kube-proxy 要做的就是在每台宿主机上生成这样一条 iptables 规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A KUBE-NODEPORTS -p tcp -m comment --comment "default/my-nginx: nodePort" -m tcp --dport 8080 -j KUBE-SVC-67RL4FN6JRUPOJYM</span><br></pre></td></tr></table></figure><p>KUBE-SVC-67RL4FN6JRUPOJYM 其实就是一组随机模式的 iptables 规则。所以接下来的流程，就跟 ClusterIP 模式完全一样了。需要注意的是，在 NodePort 方式下，Kubernetes 会在 IP 包离开宿主机发往目的 Pod 时，对这个 IP 包做一次 SNAT 操作，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A KUBE-POSTROUTING -m comment --comment "kubernetes service traffic requiring SNAT" -m mark --mark 0x4000/0x4000 -j MASQUERADE</span><br></pre></td></tr></table></figure><p>可以看到，这条规则设置在 POSTROUTING 检查点，也就是说，它给即将离开这台主机的 IP 包，进行了一次 SNAT 操作，将这个 IP 包的源地址替换成了这台宿主机上的 CNI 网桥地址，或者宿主机本身的 IP 地址（如果 CNI 网桥不存在的话）。</p><p>当然，这个 SNAT 操作只需要对 Service 转发出来的 IP 包进行（否则普通的 IP 包就被影响了）。而 iptables 做这个判断的依据，就是查看该 IP 包是否有一个“0x4000”的“标志”。你应该还记得，这个标志正是在 IP 包被执行 DNAT 操作之前被打上去的。</p><p>可是，为什么一定要对流出的包做 SNAT操作呢？</p><p>这里的原理其实很简单，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          client</span><br><span class="line">            \ ^</span><br><span class="line">             \ \</span><br><span class="line">              v \</span><br><span class="line">  node 1 &lt;--- node 2</span><br><span class="line">   | ^   SNAT</span><br><span class="line">   | |   ---&gt;</span><br><span class="line">   v |</span><br><span class="line">endpoint</span><br></pre></td></tr></table></figure><p>当一个外部的 client 通过 node 2 的地址访问一个 Service 的时候，node 2 上的负载均衡规则，就可能把这个 IP 包转发给一个在 node 1 上的 Pod。这里没有任何问题。</p><p>而当 node 1 上的这个 Pod 处理完请求之后，它就会按照这个 IP 包的源地址发出回复。</p><p>可是，如果没有做 SNAT 操作的话，这时候，被转发来的 IP 包的源地址就是 client 的 IP 地址。所以此时，Pod 就会直接将回复发给client。对于 client 来说，它的请求明明发给了 node 2，收到的回复却来自 node 1，这个 client 很可能会报错。</p><p>所以，在上图中，当 IP 包离开 node 2 之后，它的源 IP 地址就会被 SNAT 改成 node 2 的 CNI 网桥地址或者 node 2 自己的地址。这样，Pod 在处理完成之后就会先回复给 node 2（而不是 client），然后再由 node 2 发送给 client。</p><p>当然，这也就意味着这个 Pod 只知道该 IP 包来自于 node 2，而不是外部的 client。对于 Pod 需要明确知道所有请求来源的场景来说，这是不可以的。</p><p>所以这时候，你就可以将 Service 的 spec.externalTrafficPolicy 字段设置为 local，这就保证了所有 Pod 通过 Service 收到请求之后，一定可以看到真正的、外部 client 的源地址。</p><p>而这个机制的实现原理也非常简单：这时候，一台宿主机上的 iptables 规则，会设置为只将 IP 包转发给运行在这台宿主机上的 Pod。所以这时候，Pod 就可以直接使用源地址将回复包发出，不需要事先进行 SNAT 了。这个流程，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      client</span><br><span class="line">      ^ /   \</span><br><span class="line">     / /     \</span><br><span class="line">    / v       X</span><br><span class="line">  node 1     node 2</span><br><span class="line">   ^ |</span><br><span class="line">   | |</span><br><span class="line">   | v</span><br><span class="line">endpoint</span><br></pre></td></tr></table></figure><p>当然，这也就意味着如果在一台宿主机上，没有任何一个被代理的 Pod 存在，比如上图中的 node 2，那么你使用 node 2 的 IP 地址访问这个 Service，就是无效的。此时，你的请求会直接被 DROP 掉。</p><p>从外部访问 Service 的第二种方式，适用于公有云上的 Kubernetes 服务。这时候，你可以指定一个 LoadBalancer 类型的 Service，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: example-service</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 8765</span><br><span class="line">    targetPort: 9376</span><br><span class="line">  selector:</span><br><span class="line">    app: example</span><br><span class="line">  type: LoadBalancer</span><br></pre></td></tr></table></figure><p>在公有云提供的 Kubernetes 服务里，都使用了一个叫作 CloudProvider 的转接层，来跟公有云本身的 API 进行对接。所以，在上述 LoadBalancer 类型的 Service 被提交后，Kubernetes 就会调用 CloudProvider 在公有云上为你创建一个负载均衡服务，并且把被代理的 Pod 的 IP 地址配置给负载均衡服务做后端。</p><p>而第三种方式，是 Kubernetes 在 1.7 之后支持的一个新特性，叫作 ExternalName。举个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: my-service</span><br><span class="line">spec:</span><br><span class="line">  type: ExternalName</span><br><span class="line">  externalName: my.database.example.com</span><br></pre></td></tr></table></figure><p>在上述 Service 的 YAML 文件中，我指定了一个 <a href="http://externalName=my.database.example.com" target="_blank" rel="noopener">externalName=my.database.example.com</a> 的字段。而且你应该会注意到，这个 YAML 文件里不需要指定 selector。</p><p>这时候，当你通过 Service 的 DNS 名字访问它的时候，比如访问：my-service.default.svc.cluster.local。那么，Kubernetes <a href="http://xn--my-tz2c68b97ux4hv9rvz4aiv1c.database.example.com" target="_blank" rel="noopener">为你返回的就是my.database.example.com</a>。所以说，ExternalName 类型的 Service，其实是在 kube-dns 里为你添加了一条 CNAME 记录。这时，访问 my-service.default.svc.cluster.local 就和访问 <a href="http://my.database.example.com" target="_blank" rel="noopener">my.database.example.com</a> 这个域名是一个效果了。</p><p>此外，Kubernetes 的 Service 还允许你为 Service 分配公有 IP 地址，比如下面这个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">MyApp</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">9376</span></span><br><span class="line">  <span class="attr">externalIPs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">80.11</span><span class="number">.12</span><span class="number">.10</span></span><br></pre></td></tr></table></figure><p>在上述 Service 中，我为它指定的 externalIPs=80.11.12.10，那么此时，你就可以通过访问 80.11.12.10:80 访问到被代理的 Pod 了。不过，在这里 Kubernetes 要求 externalIPs 必须是至少能够路由到一个 Kubernetes 的节点。你可以想一想这是为什么。</p><p>实际上，在理解了 Kubernetes Service 机制的工作原理之后，很多与 Service 相关的问题，其实都可以通过分析 Service 在宿主机上对应的 iptables 规则（或者 IPVS 配置）得到解决。</p><p>比如，当你的 Service 没办法通过 DNS 访问到的时候。你就需要区分到底是 Service 本身的配置问题，还是集群的 DNS 出了问题。一个行之有效的方法，就是检查 Kubernetes 自己的 Master 节点的 Service DNS 是否正常：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在一个Pod里执行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nslookup kubernetes.default</span></span><br><span class="line">Server:    10.0.0.10</span><br><span class="line">Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local</span><br><span class="line"></span><br><span class="line">Name:      kubernetes.default</span><br><span class="line">Address 1: 10.0.0.1 kubernetes.default.svc.cluster.local</span><br></pre></td></tr></table></figure><p>如果上面访问 kubernetes.default 返回的值都有问题，那你就需要检查 kube-dns 的运行状态和日志了。否则的话，你应该去检查自己的 Service 定义是不是有问题。</p><p>而如果你的 Service 没办法通过 ClusterIP 访问到的时候，你首先应该检查的是这个 Service 是否有 Endpoints：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get endpoints hostnames</span></span><br><span class="line">NAME        ENDPOINTS</span><br><span class="line">hostnames   10.244.0.5:9376,10.244.0.6:9376,10.244.0.7:9376</span><br></pre></td></tr></table></figure><p>需要注意的是，如果你的 Pod 的 readniessProbe 没通过，它也不会出现在 Endpoints 列表里。</p><p>而如果 Endpoints 正常，那么你就需要确认 kube-proxy 是否在正确运行。在我们通过 kubeadm 部署的集群里，你应该看到 kube-proxy 输出的日志如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I1027 22:14:53.995134    5063 server.go:200] Running in resource-only container "/kube-proxy"</span><br><span class="line">I1027 22:14:53.998163    5063 server.go:247] Using iptables Proxier.</span><br><span class="line">I1027 22:14:53.999055    5063 server.go:255] Tearing down userspace rules. Errors here are acceptable.</span><br><span class="line">I1027 22:14:54.038140    5063 proxier.go:352] Setting endpoints for "kube-system/kube-dns:dns-tcp" to [10.244.1.3:53]</span><br><span class="line">I1027 22:14:54.038164    5063 proxier.go:352] Setting endpoints for "kube-system/kube-dns:dns" to [10.244.1.3:53]</span><br><span class="line">I1027 22:14:54.038209    5063 proxier.go:352] Setting endpoints for "default/kubernetes:https" to [10.240.0.2:443]</span><br><span class="line">I1027 22:14:54.038238    5063 proxier.go:429] Not syncing iptables until Services and Endpoints have been received from master</span><br><span class="line">I1027 22:14:54.040048    5063 proxier.go:294] Adding new service "default/kubernetes:https" at 10.0.0.1:443/TCP</span><br><span class="line">I1027 22:14:54.040154    5063 proxier.go:294] Adding new service "kube-system/kube-dns:dns" at 10.0.0.10:53/UDP</span><br><span class="line">I1027 22:14:54.040223    5063 proxier.go:294] Adding new service "kube-system/kube-dns:dns-tcp" at 10.0.0.10:53/TCP</span><br></pre></td></tr></table></figure><p>如果 kube-proxy 一切正常，你就应该仔细查看宿主机上的 iptables 了。而一个 iptables 模式的 Service 对应的规则，我在上一篇以及这一篇文章里已经全部介绍到了，它们包括：</p><ol><li>KUBE-SERVICES 或者 KUBE-NODEPORTS 规则对应的 Service 的入口链，这个规则应该与 VIP 和 Service 端口一一对应；</li><li>KUBE-SEP-(hash) 规则对应的 DNAT 链，这些规则应该与 Endpoints 一一对应；</li><li>KUBE-SVC-(hash) 规则对应的负载均衡链，这些规则的数目应该与 Endpoints 数目一致；</li><li>如果是 NodePort 模式的话，还有 POSTROUTING 处的 SNAT 链。</li></ol><p>通过查看这些链的数量、转发目的地址、端口、过滤条件等信息，你就能很容易发现一些异常的蛛丝马迹。</p><p>当然，还有一种典型问题，就是 Pod 没办法通过 Service 访问到自己。这往往就是因为 kubelet 的 hairpin-mode 没有被正确设置。关于 Hairpin 的原理我在前面已经介绍过，这里就不再赘述了。你只需要确保将 kubelet 的 hairpin-mode 设置为 hairpin-veth 或者 promiscuous-bridge 即可。</p><p>其中，在 hairpin-veth 模式下，你应该能看到 CNI 网桥对应的各个 VETH 设备，都将 Hairpin 模式设置为了 1，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ for d in &#x2F;sys&#x2F;devices&#x2F;virtual&#x2F;net&#x2F;cni0&#x2F;brif&#x2F;veth*&#x2F;hairpin_mode; do echo &quot;$d &#x3D; $(cat $d)&quot;; done</span><br><span class="line">&#x2F;sys&#x2F;devices&#x2F;virtual&#x2F;net&#x2F;cni0&#x2F;brif&#x2F;veth4bfbfe74&#x2F;hairpin_mode &#x3D; 1</span><br><span class="line">&#x2F;sys&#x2F;devices&#x2F;virtual&#x2F;net&#x2F;cni0&#x2F;brif&#x2F;vethfc2a18c5&#x2F;hairpin_mode &#x3D; 1</span><br></pre></td></tr></table></figure><p>而如果是 promiscuous-bridge 模式的话，你应该看到 CNI 网桥的混杂模式（PROMISC）被开启，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ifconfig cni0 |grep PROMISC</span></span><br><span class="line">UP BROADCAST RUNNING PROMISC MULTICAST  MTU:1460  Metric:1</span><br></pre></td></tr></table></figure><p>总结：</p><p>从外部访问Service的三种方式</p><ol><li>NodePort</li><li>LoadBalancer</li><li>External Name</li></ol><p>所谓 Service，其实就是 Kubernetes 为 Pod 分配的、固定的、基于 iptables（或者 IPVS）的访问入口。而这些访问入口代理的 Pod 信息，则来自于 Etcd，由 kube-proxy 通过控制循环来维护</p><p>Kubernetes 里面的 Service 和 DNS 机制，也都不具备强多租户能力。比如，在多租户情况下，每个租户应该拥有一套独立的 Service 规则（Service 只应该看到和代理同一个租户下的 Pod）。再比如 DNS，在多租户情况下，每个租户应该拥有自己的 kube-dns（kube-dns 只应该为同一个租户下的 Service 和 Pod 创建 DNS Entry）</p><p>为什么Kubernetes 要求 externalIPs 必须是至少能够路由到一个 Kubernetes 的节点？</p><p>因为k8s只是在集群中的每个节点上创建了一个 externalIPs 与kube-ipvs0网卡的绑定关系.<br />若流量都无法路由到任意的一个k8s节点,那自然无法将流量转给具体的service</p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li>《极客时间-深入剖析Kubernetes》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Service 的访问入口，其实就是每台宿主机上由 kube-proxy 生成的 iptables 规则，以及 kube-dns 生成的 DNS 记录。Service 的访问信息在 Kubernetes 集群之外是无效的&lt;/p&gt;
&lt;p&gt;如何从外部(Kubernetes 集群
      
    
    </summary>
    
    
      <category term="k8s" scheme="http://xboom.github.io/categories/k8s/"/>
    
    
      <category term="k8s" scheme="http://xboom.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>k8s入门11-容器网络之服务发现</title>
    <link href="http://xboom.github.io/2022/02/21/K8S/k8s%E5%85%A5%E9%97%A811-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    <id>http://xboom.github.io/2022/02/21/K8S/k8s%E5%85%A5%E9%97%A811-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</id>
    <published>2022-02-20T16:34:37.000Z</published>
    <updated>2022-02-20T16:36:23.455Z</updated>
    
    <content type="html"><![CDATA[<p>Kubernetes 之所以需要 Service，一方面是因为 Pod 的 IP 不是固定的，另一方面则是因为一组 Pod 实例之间总会有负载均衡的需求。</p><p>一个Service例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hostnames</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">hostnames</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">9376</span></span><br></pre></td></tr></table></figure><p>使用 selector 字段来声明这个 Service 只代理携带了 app=hostnames 标签的 Pod。Service 的 80 端口，代理的是 Pod 的 9376 端口</p><p>然后应用的Deployment为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hostnames</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">hostnames</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">hostnames</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hostnames</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">k8s.gcr.io/serve_hostname</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9376</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><p>这个应用的作用就是每次访问 9376 端口时，返回它自己的 hostname。</p><p><strong>被 selector 选中的 Pod，称为 Service 的 Endpoints</strong>，可使用 kubectl get ep 命令看到它们，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get endpoints hostnames</span></span><br><span class="line">NAME        ENDPOINTS</span><br><span class="line">hostnames   10.244.0.5:9376,10.244.0.6:9376,10.244.0.7:9376</span><br></pre></td></tr></table></figure><blockquote><p><strong>只有处于 Running 状态，且 readinessProbe 检查通过的 Pod，才会出现在 Service 的 Endpoints 列表里。并且，当某一个 Pod 出现问题时，Kubernetes 会自动把它从 Service 里摘除掉</strong></p></blockquote><p>通过该 Service 的 VIP 地址 10.0.1.175，你就可以访问到它所代理的 Pod ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc hostnames</span></span><br><span class="line">NAME        TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">hostnames   ClusterIP   10.0.1.175   &lt;none&gt;        80/TCP    5s</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl 10.0.1.175:80</span></span><br><span class="line">hostnames-0uton</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl 10.0.1.175:80</span></span><br><span class="line">hostnames-yp2kp</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl 10.0.1.175:80</span></span><br><span class="line">hostnames-bvc05</span><br></pre></td></tr></table></figure><p>这个 VIP 地址是 Kubernetes 自动为 Service 分配的。</p><p>通过三次连续不断地访问 Service 的 VIP 地址和代理端口 80，它就为我们依次返回了三个 Pod 的 hostname。这也正印证了 Service 提供的是 Round Robin 方式的负载均衡。这种方式称为：<strong>ClusterIP 模式的 Service</strong></p><p>Service 是由 kube-proxy 组件，加上 iptables 来共同实现的</p><p>举个例子，对于我们前面创建的名叫 hostnames 的 Service 来说，一旦它被提交给 Kubernetes，那么 kube-proxy 就可以通过 Service 的 Informer 感知到这样一个 Service 对象的添加。而作为对这个事件的响应，它就会在宿主机上创建这样一条 iptables 规则（你可以通过 iptables-save 看到它），如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A KUBE-SERVICES -d 10.0.1.175/32 -p tcp -m comment --comment "default/hostnames: cluster IP" -m tcp --dport 80 -j KUBE-SVC-NWV5X2332I4OT4T3</span><br></pre></td></tr></table></figure><p>iptables 规则的含义是：凡是目的地址是 10.0.1.175、目的端口是 80 的 IP 包，都应该跳转到另外一条名叫 KUBE-SVC-NWV5X2332I4OT4T3 的 iptables 链进行处理。</p><p>10.0.1.175 正是这个 Service 的 VIP。所以这一条规则，就为这个 Service 设置了一个固定的入口地址。并且，由于 10.0.1.175 只是一条 iptables 规则上的配置，并没有真正的网络设备，所以你 ping 这个地址，是不会有任何响应的。</p><p>KUBE-SVC-NWV5X2332I4OT4T3 规则，实际上是一组规则的集合，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment "default/hostnames:" -m statistic --mode random --probability 0.33332999982 -j KUBE-SEP-WNBA2IHDGP2BOBGZ</span><br><span class="line">-A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment "default/hostnames:" -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-X3P2623AGDH6CDF3</span><br><span class="line">-A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment "default/hostnames:" -j KUBE-SEP-57KPRZ3JQVENLNBR</span><br></pre></td></tr></table></figure><p>这一组规则，实际上是一组随机模式（–mode random）的 iptables 链。随机转发的目的地，分别是 KUBE-SEP-WNBA2IHDGP2BOBGZ、KUBE-SEP-X3P2623AGDH6CDF3 和 KUBE-SEP-57KPRZ3JQVENLNBR。</p><p>而这三条链指向的最终目的地，其实就是这个 Service 代理的三个 Pod。所以这一组规则，就是 Service 实现负载均衡的位置。需要注意的是，iptables 规则的匹配是从上到下逐条进行的，所以为了保证上述三条规则每条被选中的概率都相同，我们应该将它们的 probability 字段的值分别设置为 1/3（0.333…）、1/2 和 1。</p><p>这么设置的原理很简单：第一条规则被选中的概率就是 1/3；而如果第一条规则没有被选中，那么这时候就只剩下两条规则了，所以第二条规则的 probability 就必须设置为 1/2；类似地，最后一条就必须设置为 1。</p><p>通过查看上述三条链的明细，我们就很容易理解 Service 进行转发的具体原理了，如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-A KUBE-SEP-57KPRZ3JQVENLNBR -s 10.244.3.6/32 -m comment --comment "default/hostnames:" -j MARK --set-xmark 0x00004000/0x00004000</span><br><span class="line">-A KUBE-SEP-57KPRZ3JQVENLNBR -p tcp -m comment --comment "default/hostnames:" -m tcp -j DNAT --to-destination 10.244.3.6:9376</span><br><span class="line"></span><br><span class="line">-A KUBE-SEP-WNBA2IHDGP2BOBGZ -s 10.244.1.7/32 -m comment --comment "default/hostnames:" -j MARK --set-xmark 0x00004000/0x00004000</span><br><span class="line">-A KUBE-SEP-WNBA2IHDGP2BOBGZ -p tcp -m comment --comment "default/hostnames:" -m tcp -j DNAT --to-destination 10.244.1.7:9376</span><br><span class="line"></span><br><span class="line">-A KUBE-SEP-X3P2623AGDH6CDF3 -s 10.244.2.3/32 -m comment --comment "default/hostnames:" -j MARK --set-xmark 0x00004000/0x00004000</span><br><span class="line">-A KUBE-SEP-X3P2623AGDH6CDF3 -p tcp -m comment --comment "default/hostnames:" -m tcp -j DNAT --to-destination 10.244.2.3:9376</span><br></pre></td></tr></table></figure><p>可以看到，这三条链，其实是三条 DNAT 规则。但在 DNAT 规则之前，iptables 对流入的 IP 包还设置了一个“标志”（–set-xmark）。而 DNAT 规则的作用，就是在 PREROUTING 检查点之前，也就是在路由之前，将流入 IP 包的目的地址和端口，改成–to-destination 所指定的新的目的地址和端口。可以看到，这个目的地址和端口，正是被代理 Pod 的 IP 地址和端口。</p><p>这样，访问 Service VIP 的 IP 包经过上述 iptables 处理之后，就已经变成了访问具体某一个后端 Pod 的 IP 包了。不难理解，这些 Endpoints 对应的 iptables 规则，正是 kube-proxy 通过监听 Pod 的变化事件，在宿主机上生成并维护的</p><h3 id="kube-proxy-ipvs模式"><a class="markdownIt-Anchor" href="#kube-proxy-ipvs模式"></a> kube-proxy - IPVS模式</h3><p>kube-proxy 通过 iptables 处理 Service 的过程，需要在宿主机上设置相当多的 iptables 规则，并在控制循环里不断地刷新这些规则来确保它们始终是正确的</p><p>当你的宿主机上有大量 Pod 的时候，成百上千条 iptables 规则不断地被刷新，会大量占用该宿主机的 CPU 资源，甚至会让宿主机“卡”在这个过程中。所以，基于 iptables 的 Service 实现，都是制约 Kubernetes 项目承载更多量级的 Pod 的主要障碍。</p><p>解决办法：IPVS模式的Service</p><p>IPVS 模式的工作原理：当创建了前面的 Service 之后，kube-proxy 首先会在宿主机上创建一个虚拟网卡（叫作：kube-ipvs0），并为它分配 Service VIP 作为 IP 地址，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ip addr</span></span><br><span class="line">  ...</span><br><span class="line">  73：kube-ipvs0：&lt;BROADCAST,NOARP&gt;  mtu 1500 qdisc noop state DOWN qlen 1000</span><br><span class="line">  link/ether  1a:ce:f5:5f:c1:4d brd ff:ff:ff:ff:ff:ff</span><br><span class="line">  inet 10.0.1.175/32  scope global kube-ipvs0</span><br><span class="line">  valid_lft forever  preferred_lft forever</span><br></pre></td></tr></table></figure><p>kube-proxy 就会通过 Linux 的 IPVS 模块，为这个 IP 地址设置三个 IPVS 虚拟主机，并设置这三个虚拟主机之间使用轮询模式 (rr) 来作为负载均衡策略。我们可以通过 ipvsadm 查看到这个设置，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ipvsadm -ln</span></span><br><span class="line"> IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">  Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">    -&gt;  RemoteAddress:Port           Forward  Weight ActiveConn InActConn     </span><br><span class="line">  TCP  10.102.128.4:80 rr</span><br><span class="line">    -&gt;  10.244.3.6:9376    Masq    1       0          0         </span><br><span class="line">    -&gt;  10.244.1.7:9376    Masq    1       0          0</span><br><span class="line">    -&gt;  10.244.2.3:9376    Masq    1       0          0</span><br></pre></td></tr></table></figure><p>三个 IPVS 虚拟主机的 IP 地址和端口，对应的正是三个被代理的 Pod。任何发往 10.102.128.4:80 的请求，就都会被 IPVS 模块转发到某一个后端 Pod 上了。</p><p>相比于 iptables，IPVS 在内核中的实现其实也是基于 Netfilter 的 NAT 模式，所以在转发这一层上，理论上 IPVS 并没有显著的性能提升。但是，IPVS 并不需要在宿主机上为每个 Pod 设置 iptables 规则，而是把对这些“规则”的处理放到了内核态，从而极大地降低了维护这些规则的代价。</p><p>不过需要注意的是，<strong>IPVS 模块只负责上述的负载均衡和代理功能。而一个完整的 Service 流程正常工作所需要的包过滤、SNAT 等操作，还是要靠 iptables 来实现</strong>。只不过，这些辅助性的 iptables 规则数量有限，也不会随着 Pod 数量的增加而增加。所以，在大规模集群里，建议为 kube-proxy 设置–proxy-mode=ipvs 来开启这个功能。它为 Kubernetes 集群规模带来的提升，还是非常巨大的。</p><h3 id="service-与-dns"><a class="markdownIt-Anchor" href="#service-与-dns"></a> service 与 DNS</h3><p>在 Kubernetes 中，Service 和 Pod 都会被分配对应的 DNS A 记录（从域名解析 IP 的记录）。</p><p>对于 ClusterIP 模式的 Service 来说（比如我们上面的例子），它的 A 记录的格式是：…svc.cluster.local。当你访问这条 A 记录的时候，它解析到的就是该 Service 的 VIP 地址。</p><p>而对于指定了 clusterIP=None 的 Headless Service 来说，它的 A 记录的格式也是：…svc.cluster.local。但是，当你访问这条 A 记录的时候，它返回的是所有被代理的 Pod 的 IP 地址的集合。当然，如果你的客户端没办法解析这个集合的话，它可能会只会拿到第一个 Pod 的 IP 地址。</p><p>此外，对于 ClusterIP 模式的 Service 来说，它代理的 Pod 被自动分配的 A 记录的格式是：…pod.cluster.local。这条记录指向 Pod 的 IP 地址。而对 Headless Service 来说，它代理的 Pod 被自动分配的 A 记录的格式是：…svc.cluster.local。这条记录也指向 Pod 的 IP 地址。</p><p>但如果你为 Pod 指定了 Headless Service，并且 Pod 本身声明了 hostname 和 subdomain 字段，那么这时候 Pod 的 A 记录就会变成：…svc.cluster.local，比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default-subdomain</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">1234</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">1234</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">busybox1</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hostname:</span> <span class="string">busybox-1</span></span><br><span class="line">  <span class="attr">subdomain:</span> <span class="string">default-subdomain</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sleep</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"3600"</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">busybox</span></span><br></pre></td></tr></table></figure><p>在上面这个 Service 和 Pod 被创建之后，你就可以通过 busybox-1.default-subdomain.default.svc.cluster.local 解析到这个 Pod 的 IP 地址了。</p><p>在 Kubernetes 里，/etc/hosts 文件是单独挂载的，这也是为什么 kubelet 能够对 hostname 进行修改并且 Pod 重建后依然有效的原因。这跟 Docker 的 Init 层是一个原理。</p><p>总结：</p><p>当服务（Pod）的 IP 地址是不固定的且没办法提前获知时，该如何通过一个固定的方式访问到这个 Pod 呢？</p><ul><li>ClusterIP 模式的 Service 为你提供的，就是一个 Pod 的稳定的 IP 地址，即 VIP。并且，这里 Pod 和 Service 的关系是可以通过 Label 确定的。</li><li>Headless Service 提供的是一个 Pod 的稳定的 DNS 名字，并且名字是可以通过 Pod 名字和 Service 名字拼接出来的。</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li>《极客时间-深入剖析Kubernetes》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Kubernetes 之所以需要 Service，一方面是因为 Pod 的 IP 不是固定的，另一方面则是因为一组 Pod 实例之间总会有负载均衡的需求。&lt;/p&gt;
&lt;p&gt;一个Service例子：&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;tab
      
    
    </summary>
    
    
      <category term="k8s" scheme="http://xboom.github.io/categories/k8s/"/>
    
    
      <category term="k8s" scheme="http://xboom.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>k8s入门10-容器网络之多租户</title>
    <link href="http://xboom.github.io/2022/02/21/K8S/k8s%E5%85%A5%E9%97%A810-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%B9%8B%E5%A4%9A%E7%A7%9F%E6%88%B7/"/>
    <id>http://xboom.github.io/2022/02/21/K8S/k8s%E5%85%A5%E9%97%A810-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%B9%8B%E5%A4%9A%E7%A7%9F%E6%88%B7/</id>
    <published>2022-02-20T16:34:25.000Z</published>
    <updated>2022-02-20T16:36:30.059Z</updated>
    
    <content type="html"><![CDATA[<p>什么是多租户：一种软件架构规范，运行在服务器上的单一实例，可服务多个客户或组织（租户）,一个满足多租户规范的软件应用需要对数据和配置进行隔离，每一个租户都有自己虚拟的实例</p><p>Kubernetes 的网络模型，以及前面这些网络方案的实现，都只关注网络的“连通”，却不关心“隔离”，那么 Kubernetes 的网络方案对“隔离”是如何考虑的？</p><h3 id="networkpolicy"><a class="markdownIt-Anchor" href="#networkpolicy"></a> NetworkPolicy</h3><p>在 Kubernetes 里，网络隔离能力的定义，是依靠一种专门的 API 对象来描述的，即：<strong>NetworkPolicy</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-network-policy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">role:</span> <span class="string">db</span></span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ingress</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Egress</span></span><br><span class="line">  <span class="attr">ingress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">from:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ipBlock:</span></span><br><span class="line">        <span class="attr">cidr:</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br><span class="line">        <span class="attr">except:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">172.17</span><span class="number">.1</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">namespaceSelector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">project:</span> <span class="string">myproject</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">podSelector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">role:</span> <span class="string">frontend</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">  <span class="attr">egress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">to:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ipBlock:</span></span><br><span class="line">        <span class="attr">cidr:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">5978</span></span><br></pre></td></tr></table></figure><p>Kubernetes 里的 Pod 默认都是“允许所有”（Accept All）的，即：Pod 可以接收来自任何发送方的请求；或者，向任何接收方发送请求。而如果你要对这个情况作出限制，就必须通过 NetworkPolicy 对象来指定</p><p>而在上面这个例子里，你首先会看到 podSelector 字段。它的作用，就是定义这个 NetworkPolicy 的限制范围，比如：当前 Namespace 里携带了 role=db 标签的 Pod</p><p>而如果你把 podSelector 字段留空：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">podSelector:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>那么这个 NetworkPolicy 就会作用于当前 Namespace 下的所有 Pod。而一旦 Pod 被 NetworkPolicy 选中，那么这个 Pod 就会进入“拒绝所有”（Deny All）的状态，即：这个 Pod 既不允许被外界访问，也不允许对外界发起访问。而 NetworkPolicy 定义的规则，其实就是“白名单”。</p><p>例如，在我们上面这个例子里，我在 policyTypes 字段，定义了这个 NetworkPolicy 的类型是 ingress 和 egress，即：它既会影响流入（ingress）请求，也会影响流出（egress）请求。</p><p>然后，在 ingress 字段里，我定义了 from 和 ports，即：允许流入的“白名单”和端口。其中，这个允许流入的“白名单”里，我指定了三种并列的情况，分别是：ipBlock、namespaceSelector 和 podSelector。</p><p>而在 egress 字段里，我则定义了 to 和 ports，即：允许流出的“白名单”和端口。这里允许流出的“白名单”的定义方法与 ingress 类似。只不过，这一次 ipblock 字段指定的，是目的地址的网段。</p><p>综上所述，这个 NetworkPolicy 对象，指定的隔离规则如下所示：</p><ol><li>该隔离规则只对 default Namespace 下的，携带了 role=db 标签的 Pod 有效。限制的请求类型包括 ingress（流入）和 egress（流出）。</li><li>Kubernetes 会拒绝任何访问被隔离 Pod 的请求，除非这个请求来自于以下“白名单”里的对象，并且访问的是被隔离 Pod 的 6379 端口。这些“白名单”对象包括：a. default Namespace 里的，携带了 role=fronted 标签的 Pod；b. 携带了 project=myproject 标签的 Namespace 里的任何 Pod；c. 任何源地址属于 172.17.0.0/16 网段，且不属于 172.17.1.0/24 网段的请求。</li><li>Kubernetes 会拒绝被隔离 Pod 对外发起任何请求，除非请求的目的地址属于 10.0.0.0/24 网段，并且访问的是该网段地址的 5978 端口。</li></ol><p>需要注意的是，定义一个 NetworkPolicy 对象的过程，容易犯错的是“白名单”部分（from 和 to 字段）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"> <span class="attr">ingress:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">from:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">namespaceSelector:</span></span><br><span class="line">       <span class="attr">matchLabels:</span></span><br><span class="line">         <span class="attr">user:</span> <span class="string">alice</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">podSelector:</span></span><br><span class="line">       <span class="attr">matchLabels:</span></span><br><span class="line">         <span class="attr">role:</span> <span class="string">client</span></span><br><span class="line"> <span class="string">...</span></span><br></pre></td></tr></table></figure><p>像上面这样定义的 namespaceSelector 和 podSelector，<strong>是“或”（OR）的关系</strong>。所以说，这个 from 字段定义了两种情况，无论是 Namespace 满足条件，还是 Pod 满足条件，这个 NetworkPolicy 都会生效。</p><p>而下面这个例子，虽然看起来类似，但是它定义的规则却完全不同：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  ingress:</span><br><span class="line">  - from:</span><br><span class="line">    - namespaceSelector:</span><br><span class="line">        matchLabels:</span><br><span class="line">          user: alice</span><br><span class="line">      podSelector:</span><br><span class="line">        matchLabels:</span><br><span class="line">          role: client</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>注意看，这样定义的 namespaceSelector 和 podSelector，<strong>其实是“与”（AND）的关系</strong>。所以说，这个 from 字段只定义了一种情况，只有 Namespace 和 Pod 同时满足条件，这个 NetworkPolicy 才会生效。</p><p>此外，如果要使上面定义的 NetworkPolicy 在 Kubernetes 集群里真正产生作用，你的 CNI 网络插件就必须是支持 Kubernetes 的 NetworkPolicy 的。</p><p>在具体实现上，凡是支持 NetworkPolicy 的 CNI 网络插件，都维护着一个 NetworkPolicy Controller，通过控制循环的方式对 NetworkPolicy 对象的增删改查做出响应，然后在宿主机上完成 iptables 规则的配置工作。</p><p>在 Kubernetes 生态里，目前已经实现了 NetworkPolicy 的网络插件包括 Calico、Weave 和 kube-router 等多个项目，但是并不包括 Flannel 项目。</p><p>所以说，如果想要在使用 Flannel 的同时还使用 NetworkPolicy 的话，你就需要再额外安装一个网络插件，比如 Calico 项目，来负责执行 NetworkPolicy。</p><blockquote><p>安装 Flannel + Calico 的流程非常简单，你直接参考<a href="https://docs.projectcalico.org/getting-started/kubernetes/flannel/flannel" target="_blank" rel="noopener">这个文档</a>一键安装即可</p></blockquote><h3 id="网络隔离"><a class="markdownIt-Anchor" href="#网络隔离"></a> 网络隔离</h3><p>以三层网络插件为例(比如 Calico 和 kube-router)，分析一下这部分的原理。简单的NetworkPolicy 策略</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: test-network-policy</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  podSelector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      role: db</span><br><span class="line">  ingress:</span><br><span class="line">   - from:</span><br><span class="line">     - namespaceSelector:</span><br><span class="line">         matchLabels:</span><br><span class="line">           project: myproject</span><br><span class="line">     - podSelector:</span><br><span class="line">         matchLabels:</span><br><span class="line">           role: frontend</span><br><span class="line">     ports:</span><br><span class="line">       - protocol: tcp</span><br><span class="line">         port: 6379</span><br></pre></td></tr></table></figure><p>可以看到，我们指定的 ingress“白名单”，是任何 Namespace 里，携带 project=myproject 标签的 Namespace 里的 Pod；以及 default Namespace 里，携带了 role=frontend 标签的 Pod。允许被访问的端口是：6379。而被隔离的对象，是所有携带了 role=db 标签的 Pod。</p><p>那么这个时候，Kubernetes 的网络插件就会使用这个 NetworkPolicy 的定义，在宿主机上生成 iptables 规则。这个过程，我可以通过如下所示的一段 Go 语言风格的伪代码来为你描述：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> dstIP := <span class="keyword">range</span> 所有被networkpolicy.spec.podSelector选中的Pod的IP地址</span><br><span class="line">  <span class="keyword">for</span> srcIP := <span class="keyword">range</span> 所有被ingress.from.podSelector选中的Pod的IP地址</span><br><span class="line">    <span class="keyword">for</span> port, protocol := <span class="keyword">range</span> ingress.ports &#123;</span><br><span class="line">      iptables -A KUBE-NWPLCY-CHAIN -s $srcIP -d $dstIP -p $protocol -m $protocol --dport $port -j ACCEPT </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这是一条最基本的、通过匹配条件决定下一步动作的 iptables 规则。</p><p>这条规则的名字是 KUBE-NWPLCY-CHAIN，含义是：当 IP 包的源地址是 srcIP、目的地址是 dstIP、协议是 protocol、目的端口是 port 的时候，就允许它通过（ACCEPT）。</p><p>而正如这段伪代码所示，匹配这条规则所需的这四个参数，都是从 NetworkPolicy 对象里读取出来的</p><p><strong>Kubernetes 网络插件对 Pod 进行隔离，其实是靠在宿主机上生成 NetworkPolicy 对应的 iptable 规则来实现的。</strong></p><p>在设置好上述“隔离”规则之后，网络插件还需要想办法，将所有对被隔离 Pod 的访问请求，都转发到上述 KUBE-NWPLCY-CHAIN 规则上去进行匹配。并且，如果匹配不通过，这个请求应该被“拒绝”。</p><p>在 CNI 网络插件中，上述需求可以通过设置两组 iptables 规则来实现。</p><p>第一组规则，负责“拦截”对被隔离 Pod 的访问请求。生成这一组规则的伪代码，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> pod := <span class="keyword">range</span> 该Node上的所有Pod &#123;</span><br><span class="line">    <span class="keyword">if</span> pod是networkpolicy.spec.podSelector选中的 &#123;</span><br><span class="line">        iptables -A FORWARD -d $podIP -m physdev --physdev-is-bridged -j KUBE-POD-SPECIFIC-FW-CHAIN</span><br><span class="line">        iptables -A FORWARD -d $podIP -j KUBE-POD-SPECIFIC-FW-CHAIN</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iptable"><a class="markdownIt-Anchor" href="#iptable"></a> IPTABLE</h3><p>iptables 规则使用到了内置链：FORWARD。它是什么意思呢？说到这里，我就得为你稍微普及一下 iptables 的知识了。实际上，iptables 只是一个操作 Linux 内核 Netfilter 子系统的“界面”。顾名思义，Netfilter 子系统的作用，就是 Linux 内核里挡在“网卡”和“用户态进程”之间的一道“防火墙”。它们的关系，可以用如下的示意图来表示：</p><img src="https://static001.geekbang.org/resource/image/4a/c2/4a012412dd694cb815ac9ee11ce511c2.png" alt="img" style="zoom:67%;" /><p>可以看到，这幅示意图中，IP 包“一进一出”的两条路径上，有几个关键的“检查点”，它们正是 Netfilter 设置“防火墙”的地方。在 iptables 中，这些“检查点”被称为：链（Chain）。这是因为这些“检查点”对应的 iptables 规则，是按照定义顺序依次进行匹配的。这些“检查点”的具体工作原理，可以用如下所示的示意图进行描述：</p><img src="https://static001.geekbang.org/resource/image/f7/8e/f722f0f8b16338b02aa02904729dbc8e.jpg" alt="img" style="zoom:67%;" /><p>可以看到，当一个 IP 包通过网卡进入主机之后，它就进入了 Netfilter 定义的流入路径（Input Path）里。在这个路径中，IP 包要经过路由表路由来决定下一步的去向。而在这次路由之前，Netfilter 设置了一个名叫 PREROUTING 的“检查点”。在 Linux 内核的实现里，所谓“检查点”实际上就是内核网络协议栈代码里的 Hook（比如，在执行路由判断的代码之前，内核会先调用 PREROUTING 的 Hook）。</p><p>而在经过路由之后，IP 包的去向就分为了两种：</p><ul><li>第一种，继续在本机处理；</li><li>第二种，被转发到其他目的地</li></ul><p>我们先说一下 IP 包的第一种去向。这时候，IP 包将继续向上层协议栈流动。在它进入传输层之前，Netfilter 会设置一个名叫 INPUT 的“检查点”。到这里，IP 包流入路径（Input Path）结束。</p><p>接下来，这个 IP 包通过传输层进入用户空间，交给用户进程处理。而处理完成后，用户进程会通过本机发出返回的 IP 包。这时候，这个 IP 包就进入了流出路径（Output Path）。此时，IP 包首先还是会经过主机的路由表进行路由。</p><p>路由结束后，Netfilter 就会设置一个名叫 OUTPUT 的“检查点”。然后，在 OUTPUT 之后，再设置一个名叫 POSTROUTING“检查点”。你可能会觉得奇怪，为什么在流出路径结束后，Netfilter 会连着设置两个“检查点”呢？</p><p>这就要说到在流入路径里，路由判断后的第二种去向了。在这种情况下，这个 IP 包不会进入传输层，而是会继续在网络层流动，从而进入到转发路径（Forward Path）。在转发路径中，Netfilter 会设置一个名叫 FORWARD 的“检查点”。而在 FORWARD“检查点”完成后，IP 包就会来到流出路径。而转发的 IP 包由于目的地已经确定，它就不会再经过路由，也自然不会经过 OUTPUT，而是会直接来到 POSTROUTING“检查点”。所以说，POSTROUTING 的作用，其实就是上述两条路径，最终汇聚在一起的“最终检查点”。</p><p>需要注意的是，在有网桥参与的情况下，上述 Netfilter 设置“检查点”的流程，实际上也会出现在链路层（二层），并且会跟我在上面讲述的网络层（三层）的流程有交互。</p><p>这些链路层的“检查点”对应的操作界面叫作 ebtables。所以，准确地说，数据包在 Linux Netfilter 子系统里完整的流动过程，其实应该如下所示（这是一幅来自Netfilter 官方的原理图，建议你点击图片以查看大图）：</p><img src="https://static001.geekbang.org/resource/image/e9/32/e96b58808bf16039e9975e947a6c7532.jpg" alt="img" style="zoom:67%;" /><p>可以看到，我前面为你讲述的，正是上图中绿色部分，也就是网络层的 iptables 链的工作流程。</p><p>另外，你应该还能看到，每一个白色的“检查点”上，还有一个绿色的“标签”，比如：raw、nat、filter 等等。</p><p>在 iptables 里，这些标签叫作：表。比如，同样是 OUTPUT 这个“检查点”，filter Output 和 nat Output 在 iptables 里的语法和参数，就完全不一样，实现的功能也完全不同。</p><p>所以说，iptables 表的作用，就是在某个具体的“检查点”（比如 Output）上，按顺序执行几个不同的检查动作（比如，先执行 nat，再执行 filter）。</p><p>在理解了 iptables 的工作原理之后，我们再回到 NetworkPolicy 上来。这时候，前面由网络插件设置的、负责“拦截”进入 Pod 的请求的三条 iptables 规则，就很容易读懂了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -d $podIP -m physdev --physdev-is-bridged -j KUBE-POD-SPECIFIC-FW-CHAIN</span><br><span class="line">iptables -A FORWARD -d $podIP -j KUBE-POD-SPECIFIC-FW-CHAIN</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中，第一条 FORWARD 链“拦截”的是一种特殊情况：它对应的是同一台宿主机上容器之间经过 CNI 网桥进行通信的流入数据包。其中，–physdev-is-bridged 的意思就是，这个 FORWARD 链匹配的是，通过本机上的网桥设备，发往目的地址是 podIP 的 IP 包。</p><blockquote><p>kube-router 其实是一个简化版的 Calico，它也使用 BGP 来维护路由信息，但是使用 CNI bridge 插件负责跟 Kubernetes 进行交互。</p></blockquote><p>而第二条 FORWARD 链“拦截”的则是最普遍的情况，即：容器跨主通信。这时候，流入容器的数据包都是经过路由转发（FORWARD 检查点）来的。</p><p>不难看到，这些规则最后都跳转（即：-j）到了名叫 KUBE-POD-SPECIFIC-FW-CHAIN 的规则上。它正是网络插件为 NetworkPolicy 设置的第二组规则。而这个 KUBE-POD-SPECIFIC-FW-CHAIN 的作用，就是做出“允许”或者“拒绝”的判断。这部分功能的实现，可以简单描述为下面这样的 iptables 规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A KUBE-POD-SPECIFIC-FW-CHAIN -j KUBE-NWPLCY-CHAIN</span><br><span class="line">iptables -A KUBE-POD-SPECIFIC-FW-CHAIN -j REJECT --reject-with icmp-port-unreachable</span><br></pre></td></tr></table></figure><p>可以看到，首先在第一条规则里，我们会把 IP 包转交给前面定义的 KUBE-NWPLCY-CHAIN 规则去进行匹配。按照我们之前的讲述，如果匹配成功，那么 IP 包就会被“允许通过”。</p><p>而如果匹配失败，IP 包就会来到第二条规则上。可以看到，它是一条 REJECT 规则。通过这条规则，不满足 NetworkPolicy 定义的请求就会被拒绝掉，从而实现了对该容器的“隔离”。</p><p>以上，就是 CNI 网络插件实现 NetworkPolicy 的基本方法了。当然，对于不同的插件来说，上述实现过程可能有不同的手段，但根本原理是不变的。</p><p>NetworkPolicy 实际上只是宿主机上的一系列 iptables 规则，Kubernetes 负责在此基础上提供一种“弱多租户”（soft multi-tenancy）的能力</p><p>它使得指定的 Namespace（比如 my-namespace）里的所有 Pod，都不能接收任何 Ingress 请求。</p><p>job，cronjob这类计算型pod不需要也不应该对外提供服务，可以拒绝所有流入流量，提高系统安全。</p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li>《极客时间-深入剖析 Kubernetes》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;什么是多租户：一种软件架构规范，运行在服务器上的单一实例，可服务多个客户或组织（租户）,一个满足多租户规范的软件应用需要对数据和配置进行隔离，每一个租户都有自己虚拟的实例&lt;/p&gt;
&lt;p&gt;Kubernetes 的网络模型，以及前面这些网络方案的实现，都只关注网络的“连通”，却
      
    
    </summary>
    
    
      <category term="k8s" scheme="http://xboom.github.io/categories/k8s/"/>
    
    
      <category term="k8s" scheme="http://xboom.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>协议5-TLS</title>
    <link href="http://xboom.github.io/2022/02/21/Protocol/%E5%8D%8F%E8%AE%AE5-TLS/"/>
    <id>http://xboom.github.io/2022/02/21/Protocol/%E5%8D%8F%E8%AE%AE5-TLS/</id>
    <published>2022-02-20T16:27:19.000Z</published>
    <updated>2022-06-25T07:00:00.113Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h3><p>HTTPS是建立在HTTP的基础上添加SSL加密层，通过TLS/SSL<strong>具有的身份验证</strong>、<strong>信息加密</strong>和<strong>完整性校验</strong>功能保证数据安全。</p><p>HTTP与HTTPS的区别：</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220221002749.jpg" alt="" /></p><ol><li>HTTPS是加密传输协议，HTTP是名文传输协议;</li><li>HTTPS需要用到SSL证书，而HTTP不用;</li><li>HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO</li><li>HTTPS标准端口443，HTTP标准端口80;</li><li>HTTPS基于传输层，HTTP基于应用层;</li><li>HTTPS在浏览器显示绿色安全锁，HTTP没有显示;</li></ol><h3 id="握手与密钥协商过程报文分析"><a class="markdownIt-Anchor" href="#握手与密钥协商过程报文分析"></a> 握手与密钥协商过程(报文分析)</h3><p>基于RSA握手和密钥交换的TLS/SSL握手过程</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220221002749.jpg" alt="" /></p><p>未完待续。。。</p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ul><li><a href="https://blog.csdn.net/hherima/article/details/52469674" target="_blank" rel="noopener">SSL/TLS握手过程</a></li><li><a href="https://blog.csdn.net/mrpre/category_9270159.html" target="_blank" rel="noopener">SSL/TLS详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;引言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt; 引言&lt;/h3&gt;
&lt;p&gt;HTTPS是建立在HTTP的基础上添加SSL加密层，通过TLS/SSL&lt;strong&gt;具有的身份验证&lt;/strong&gt;、&lt;strong&gt;信息加密
      
    
    </summary>
    
    
      <category term="Protocol" scheme="http://xboom.github.io/categories/Protocol/"/>
    
    
      <category term="TLS" scheme="http://xboom.github.io/tags/TLS/"/>
    
  </entry>
  
  <entry>
    <title>算法实践1-令牌桶算法</title>
    <link href="http://xboom.github.io/2022/02/21/Algorithm%20Applied/%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B51-%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/"/>
    <id>http://xboom.github.io/2022/02/21/Algorithm%20Applied/%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B51-%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/</id>
    <published>2022-02-20T16:22:31.000Z</published>
    <updated>2022-06-25T07:00:00.218Z</updated>
    
    <content type="html"><![CDATA[<p>在高并发系统中有三把利器用来保护系统：<strong>缓存、降级和限流</strong></p><p>其中常用的限流算法有 **漏桶算法 **和 <strong>令牌桶算法</strong></p><h3 id="漏桶算法"><a class="markdownIt-Anchor" href="#漏桶算法"></a> 漏桶算法</h3><p>把请求比作是水，水来了都先放进桶里，并以限定的速度出水，当水来得过猛而出水不够快时就会导致水直接溢出，即拒绝服务</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220209210834.png" alt="img" /></p><p>漏斗有一个进水口 和 一个出水口，出水口以一定速率出水，并且有一个最大出水速率：</p><p>在漏斗中没有水的时候，</p><ul><li>如果进水速率小于等于最大出水速率，那么，出水速率等于进水速率，此时，不会积水</li><li>如果进水速率大于最大出水速率，那么，漏斗以最大速率出水，此时，多余的水会积在漏斗中</li></ul><p>在漏斗中有水的时候</p><ul><li>出水口以最大速率出水</li><li>如果漏斗未满，且有进水的话，那么这些水会积在漏斗中</li><li>如果漏斗已满，且有进水的话，那么这些水会溢出到漏斗之外</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ratelimit <span class="comment">// import "go.uber.org/ratelimit"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"sync/atomic"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> state <span class="keyword">struct</span> &#123; </span><br><span class="line">last     time.Time</span><br><span class="line">sleepFor time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> atomicLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">state unsafe.Pointer  <span class="comment">//用于存储上一次执行的时间以及需要sleep的时间</span></span><br><span class="line">padding [<span class="number">56</span>]<span class="keyword">byte</span>      <span class="comment">//是一个无意义的填充数据，为了提高性能，避免 cpu 缓存的 false sharing</span></span><br><span class="line"></span><br><span class="line">perRequest time.Duration<span class="comment">//只单位，默认为秒</span></span><br><span class="line">maxSlack   time.Duration  <span class="comment">//松弛时间，也就是可以允许的突发流量的大小, 默认是 Pre/10</span></span><br><span class="line">clock      Clock<span class="comment">//时钟，用于在测试的时候可以 mock 掉不使用真实的时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newAtomicBased returns a new atomic based limiter.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newAtomicBased</span><span class="params">(rate <span class="keyword">int</span>, opts ...Option)</span> *<span class="title">atomicLimiter</span></span> &#123;</span><br><span class="line"><span class="comment">// TODO consider moving config building to the implementation</span></span><br><span class="line"><span class="comment">// independent code.</span></span><br><span class="line">config := buildConfig(opts)</span><br><span class="line">perRequest := config.per / time.Duration(rate)</span><br><span class="line">l := &amp;atomicLimiter&#123;</span><br><span class="line">perRequest: perRequest,</span><br><span class="line">maxSlack:   <span class="number">-1</span> * time.Duration(config.slack) * perRequest,</span><br><span class="line">clock:      config.clock,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initialState := state&#123;</span><br><span class="line">last:     time.Time&#123;&#125;,</span><br><span class="line">sleepFor: <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line">atomic.StorePointer(&amp;l.state, unsafe.Pointer(&amp;initialState))</span><br><span class="line"><span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Take blocks to ensure that the time spent between multiple</span></span><br><span class="line"><span class="comment">// Take calls is on average time.Second/rate.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *atomicLimiter)</span> <span class="title">Take</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">newState state<span class="comment">// 状态</span></span><br><span class="line">taken    <span class="keyword">bool</span><span class="comment">// 用于表示原子操作是否成功</span></span><br><span class="line">interval time.Duration  <span class="comment">// 需要 sleep 的时间</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> !taken &#123;  <span class="comment">// 如果 CAS 操作不成功就一直尝试</span></span><br><span class="line">now := t.clock.Now()  <span class="comment">//获取当前时间</span></span><br><span class="line"></span><br><span class="line">previousStatePointer := atomic.LoadPointer(&amp;t.state)  <span class="comment">// load 出上一次调用的时间</span></span><br><span class="line">oldState := (*state)(previousStatePointer)</span><br><span class="line"></span><br><span class="line">newState = state&#123;</span><br><span class="line">last:     now,</span><br><span class="line">sleepFor: oldState.sleepFor,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 last 是零值的话，表示之前就没用过，直接保存返回即可</span></span><br><span class="line"><span class="keyword">if</span> oldState.last.IsZero() &#123;</span><br><span class="line">taken = atomic.CompareAndSwapPointer(&amp;t.state, previousStatePointer, unsafe.Pointer(&amp;newState))</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sleepFor 是需要睡眠的时间，由于引入了松弛时间，所以 sleepFor 可能是一个</span></span><br><span class="line">    <span class="comment">// maxSlack ~ 0 之间的一个值，所以这里需要将现在的需要 sleep 的时间和上一次</span></span><br><span class="line">    <span class="comment">// sleepFor 的值相加</span></span><br><span class="line">newState.sleepFor += t.perRequest - now.Sub(oldState.last)</span><br><span class="line"><span class="comment">// 如果距离上一次调用已经很久了，sleepFor 可能会是一个很小的值</span></span><br><span class="line">    <span class="comment">// 最小值只能是 maxSlack 的大小</span></span><br><span class="line"><span class="keyword">if</span> newState.sleepFor &lt; t.maxSlack &#123;</span><br><span class="line">newState.sleepFor = t.maxSlack</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 如果 sleepFor 大于 0  的话，计算出需要 sleep 的时间</span></span><br><span class="line">    <span class="comment">// 然后将 state.sleepFor 置零</span></span><br><span class="line"><span class="keyword">if</span> newState.sleepFor &gt; <span class="number">0</span> &#123;</span><br><span class="line">newState.last = newState.last.Add(newState.sleepFor)</span><br><span class="line">interval, newState.sleepFor = newState.sleepFor, <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 保存状态</span></span><br><span class="line">taken = atomic.CompareAndSwapPointer(&amp;t.state, previousStatePointer, unsafe.Pointer(&amp;newState))</span><br><span class="line">&#125;</span><br><span class="line">t.clock.Sleep(interval)</span><br><span class="line"><span class="keyword">return</span> newState.last</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="令牌桶算法"><a class="markdownIt-Anchor" href="#令牌桶算法"></a> 令牌桶算法</h3><p>令牌桶算法的原理是系统以恒定的速率产生令牌，然后把令牌放到令牌桶中，令牌桶有一个容量，当令牌桶满了的时候，再向其中放令牌，那么多余的令牌会被丢弃；当想要处理一个请求的时候，需要从令牌桶中取出一个令牌，如果此时令牌桶中没有令牌，那么则拒绝该请求</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220209211050.png" alt="img" /></p><p>源码：<a href="https://github.com/beefsack/go-rate/blob/master/rate.go" target="_blank" rel="noopener">https://github.com/beefsack/go-rate/blob/master/rate.go</a></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rate</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"container/list"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// A RateLimiter limits the rate at which an action can be performed.  It</span></span><br><span class="line"><span class="comment">// applies neither smoothing (like one could achieve in a token bucket system)</span></span><br><span class="line"><span class="comment">// nor does it offer any conception of warmup, wherein the rate of actions</span></span><br><span class="line"><span class="comment">// granted are steadily increased until a steady throughput equilibrium is</span></span><br><span class="line"><span class="comment">// reached.</span></span><br><span class="line"><span class="keyword">type</span> RateLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">limit    <span class="keyword">int</span></span><br><span class="line">interval time.Duration</span><br><span class="line">mtx      sync.Mutex</span><br><span class="line">times    list.List<span class="comment">//双向链表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New creates a new rate limiter for the limit and interval.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(limit <span class="keyword">int</span>, interval time.Duration)</span> *<span class="title">RateLimiter</span></span> &#123;</span><br><span class="line">lim := &amp;RateLimiter&#123;</span><br><span class="line">limit:    limit,</span><br><span class="line">interval: interval,</span><br><span class="line">&#125;</span><br><span class="line">lim.times.Init()</span><br><span class="line"><span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait blocks if the rate limit has been reached.  Wait offers no guarantees</span></span><br><span class="line"><span class="comment">// of fairness for multiple actors if the allowed rate has been temporarily</span></span><br><span class="line"><span class="comment">// exhausted.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RateLimiter)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">ok, remaining := r.Try()</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(remaining)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try returns true if under the rate limit, or false if over and the</span></span><br><span class="line"><span class="comment">// remaining time before the rate limit expires.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RateLimiter)</span> <span class="title">Try</span><span class="params">()</span> <span class="params">(ok <span class="keyword">bool</span>, remaining time.Duration)</span></span> &#123;</span><br><span class="line">r.mtx.Lock()</span><br><span class="line"><span class="keyword">defer</span> r.mtx.Unlock()</span><br><span class="line">now := time.Now()</span><br><span class="line"><span class="keyword">if</span> l := r.times.Len(); l &lt; r.limit &#123;</span><br><span class="line">r.times.PushBack(now)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">frnt := r.times.Front()</span><br><span class="line"><span class="keyword">if</span> diff := now.Sub(frnt.Value.(time.Time)); diff &lt; r.interval &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, r.interval - diff</span><br><span class="line">&#125;</span><br><span class="line">frnt.Value = now</span><br><span class="line">r.times.MoveToBack(frnt)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="漏桶vs令牌桶"><a class="markdownIt-Anchor" href="#漏桶vs令牌桶"></a> 漏桶VS令牌桶</h3><p><strong>漏桶算法</strong> 能够强行限制数据的传输速率，</p><p><strong>令牌桶算法</strong> 在能够限制数据的平均传输速率外，只要桶中存在令牌，就允许突发地传输数据直到达到用户配置的门限，所以也适合于具有突发特性的流量</p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://www.cnblogs.com/xuwc/p/9123078.html" target="_blank" rel="noopener">https://www.cnblogs.com/xuwc/p/9123078.html</a></li><li><a href="https://www.jianshu.com/p/d6250493308b" target="_blank" rel="noopener">https://www.jianshu.com/p/d6250493308b</a></li><li><a href="https://segmentfault.com/a/1190000015967922" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015967922</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在高并发系统中有三把利器用来保护系统：&lt;strong&gt;缓存、降级和限流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其中常用的限流算法有 **漏桶算法 **和 &lt;strong&gt;令牌桶算法&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;漏桶算法&quot;&gt;&lt;a class=&quot;markdownIt-A
      
    
    </summary>
    
    
      <category term="Algorithm Applied" scheme="http://xboom.github.io/categories/Algorithm-Applied/"/>
    
    
      <category term="Algorithm" scheme="http://xboom.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Acwing-剑指</title>
    <link href="http://xboom.github.io/2022/02/15/Acwing/Acwing-%E5%89%91%E6%8C%87/"/>
    <id>http://xboom.github.io/2022/02/15/Acwing/Acwing-%E5%89%91%E6%8C%87/</id>
    <published>2022-02-14T16:27:12.000Z</published>
    <updated>2022-06-25T07:00:00.113Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h3><h4 id="链表"><a class="markdownIt-Anchor" href="#链表"></a> 链表</h4><h5 id="从尾到头打印链表"><a class="markdownIt-Anchor" href="#从尾到头打印链表"></a> 从尾到头打印链表</h5><p>题目</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。</span><br><span class="line"></span><br><span class="line">如输入&#123;1,2,3&#125;的链表如下图:</span><br><span class="line"></span><br><span class="line">返回一个数组为[3,2,1]</span><br><span class="line"></span><br><span class="line">0 <span class="xml"><span class="tag">&lt;<span class="name">=</span> 链表长度 &lt;= <span class="string">10000</span></span></span></span><br></pre></td></tr></table></figure><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220214234055.png" alt="img" /></p><p>解答</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  struct ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        struct ListNode *next;</span></span><br><span class="line"><span class="comment">*        ListNode(int x) :</span></span><br><span class="line"><span class="comment">*              val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*  &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">while</span>(head) &#123;</span><br><span class="line">            result.push_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="反转链表"><a class="markdownIt-Anchor" href="#反转链表"></a> <strong>反转链表</strong></h5><p><strong>题目</strong></p><p>给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。</p><p>数据范围： 0\leq n\leq10000≤<em>n</em>≤1000</p><p>要求：空间复杂度 O(1)<em>O</em>(1) ，时间复杂度 O(n)<em>O</em>(<em>n</em>) 。</p><p>如当输入链表{1,2,3}时，</p><p>经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。</p><p>以上转换过程如下图所示：</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220215000908.png" alt="img" style="zoom:50%;" /><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct ListNode *next;</span></span><br><span class="line"><span class="comment">ListNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *cur = pHead;</span><br><span class="line">        ListNode *nex = <span class="literal">nullptr</span>; <span class="comment">// 这里可以指向nullptr，循环里面要重新指向</span></span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            nex = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="合并两个排序的链表"><a class="markdownIt-Anchor" href="#合并两个排序的链表"></a> <strong>合并两个排序的链表</strong></h5><p><strong>题目</strong></p><p>输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p>数据范围： 0 \le n \le 10000≤<em>n</em>≤1000，-1000 \le 节点值 \le 1000−1000≤节点值≤1000<br />要求：空间复杂度 O(1)<em>O</em>(1)，时间复杂度 O(n)<em>O</em>(<em>n</em>)</p><p>如输入{1,3,5},{2,4,6}时，合并后的链表为{1,2,3,4,5,6}，所以对应的输出为{1,2,3,4,5,6}</p><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct ListNode *next;</span></span><br><span class="line"><span class="comment">ListNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        ListNode * pre = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode * cur = pre;</span><br><span class="line">        <span class="keyword">while</span>(pHead1 &amp;&amp; pHead2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pHead1-&gt;val &lt; pHead2-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = pHead1;</span><br><span class="line">                pHead1 = pHead1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = pHead2;</span><br><span class="line">                pHead2 = pHead2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!pHead1) cur-&gt;next = pHead2;</span><br><span class="line">        <span class="keyword">if</span>(!pHead2) cur-&gt;next = pHead1;</span><br><span class="line">        <span class="keyword">return</span> pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="两个链表的第一个公共结点"><a class="markdownIt-Anchor" href="#两个链表的第一个公共结点"></a> <strong>两个链表的第一个公共结点</strong></h5><p><strong>题目</strong></p><p>输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p><p>数据范围： n \le 1000<em>n</em>≤1000<br />要求：空间复杂度 O(1)<em>O</em>(1)，时间复杂度 O(n)<em>O</em>(<em>n</em>)</p><p>例如，输入{1,2,3},{4,5},{6,7}时，两个无环的单向链表的结构如下图所示：</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220215232557.png" alt="img" /></p><p>输入分为是3段，第一段是第一个链表的非公共部分，第二段是第二个链表的非公共部分，第三段是第一个链表和二个链表的公共部分。 后台会将这3个参数组装为两个链表，并将这两个链表对应的头节点传入到函数FindFirstCommonNode里面，用户得到的输入只有pHead1和pHead2</p><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct ListNode *next;</span></span><br><span class="line"><span class="comment">ListNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        ListNode *ta = pHead1;</span><br><span class="line">        ListNode *tb = pHead2;</span><br><span class="line">         <span class="keyword">while</span> (ta != tb) &#123;</span><br><span class="line">            ta = ta ? ta-&gt;next : pHead2;</span><br><span class="line">            tb = tb ? tb-&gt;next : pHead1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ta;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="链表中环的入口结点"><a class="markdownIt-Anchor" href="#链表中环的入口结点"></a> <strong>链表中环的入口结点</strong></h5><p><strong>题目</strong></p><p>给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。</p><p>数据范围： n\le10000<em>n</em>≤10000，1&lt;=结点值&lt;=100001&lt;=结点值&lt;=10000</p><p>要求：空间复杂度 O(1)<em>O</em>(1)，时间复杂度 O(n)<em>O</em>(<em>n</em>)</p><p>例如，输入{1,2},{3,4,5}时，对应的环形链表如下图所示：</p><img src="https://uploadfiles.nowcoder.com/images/20211025/423483716_1635154005498/DA92C945EF643F1143567935F20D6B46" alt="img" style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        ListNode *fast = pHead;</span><br><span class="line">        ListNode *slow = pHead;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!fast || !fast-&gt;next) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span>(fast != slow) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="链表中倒数最后k个结点"><a class="markdownIt-Anchor" href="#链表中倒数最后k个结点"></a> <strong>链表中倒数最后k个结点</strong></h5><p><strong>题目</strong></p><p>输入一个长度为 n 的链表，设链表中的元素的值为 ai ，返回该链表中倒数第k个节点。</p><p>如果该链表长度小于k，请返回一个长度为 0 的链表。</p><p>数据范围：0 \leq n \leq 10^50≤<em>n</em>≤105，0 \leq a_i \leq 10^90≤<em>a**i</em>≤109，0 \leq k \leq 10^90≤<em>k</em>≤109</p><p>要求：空间复杂度 O(n)<em>O</em>(<em>n</em>)，时间复杂度 O(n)<em>O</em>(<em>n</em>)</p><p>进阶：空间复杂度 O(1)<em>O</em>(1)，时间复杂度 O(n)<em>O</em>(<em>n</em>)</p><p>例如输入{1,2,3,4,5},2时，对应的链表结构如下图所示：</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220215235750.png" alt="img" /></p><p>其中蓝色部分为该链表的最后2个结点，所以返回倒数第2个结点（也即结点值为4的结点）即可，系统会打印后面所有的节点来比较。</p><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *int val;</span></span><br><span class="line"><span class="comment"> *struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param pHead ListNode类 </span></span><br><span class="line"><span class="comment">     * @param k int整型 </span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pHead, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* r = pHead;</span><br><span class="line">        <span class="keyword">while</span> (k-- &amp;&amp; r)</span><br><span class="line">            r = r-&gt;next; <span class="comment">// 移动右侧指针造成 k 的距离差</span></span><br><span class="line">        <span class="keyword">if</span> (k &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 此时说明 k 比链表长度长</span></span><br><span class="line">        ListNode* l = pHead;</span><br><span class="line">        <span class="keyword">while</span> (r)</span><br><span class="line">            r = r-&gt;next, l = l-&gt;next; <span class="comment">// 两个指针一起移动找到倒数第 k 个节点</span></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="删除链表中重复的节点"><a class="markdownIt-Anchor" href="#删除链表中重复的节点"></a> 删除链表中重复的节点</h4><h4 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h4><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><p>数据范围：链表长度满足 0 \le n \le 1000 \0≤<em>n</em>≤1000 ，链表中的值满足 1 \le val \le 1000 \1≤<em>v<strong>a</strong>l</em>≤1000</p><p>进阶：空间复杂度 O(n)*O*(<em>n</em>) ，时间复杂度 O(n) *O*(<em>n</em>)</p><p>例如输入{1,2,3,3,4,4,5}时，对应的输出为{1,2,5}，对应的输入输出链表如下图所示：</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220308004104.png" alt="img" /></p><p>例如</p><ol><li>输入：<code>{1,2,3,3,4,4,5}</code>,输出：<code>{1,2,5}</code></li><li>输入：<code>{1,1,1,8}</code>，输出：<code>{8}</code></li></ol><h5 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pHead)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* slow = <span class="keyword">new</span> ListNode(<span class="number">-1</span>), *fast = <span class="keyword">new</span> ListNode(<span class="number">-1</span>), *dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = pHead;</span><br><span class="line">        <span class="comment">// 初始化两个指针</span></span><br><span class="line">        slow = dummy;  <span class="comment">//虚拟指针</span></span><br><span class="line">        fast = dummy-&gt;next; <span class="comment">//头指针</span></span><br><span class="line">        <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">            <span class="comment">// 遇到重复则只更新fast节点</span></span><br><span class="line">            <span class="keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;val == fast-&gt;next-&gt;val) &#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遇到重复</span></span><br><span class="line">            <span class="keyword">if</span> (slow-&gt;next != fast) &#123; <span class="comment">//如果不相等，说明中间slow 与 fast有相同值的节点</span></span><br><span class="line">                slow-&gt;next = fast-&gt;next;</span><br><span class="line">                fast = slow-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有重复</span></span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://www.nowcoder.com/ta/coding-interviews" target="_blank" rel="noopener">https://www.nowcoder.com/ta/coding-interviews</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据结构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数据结构&quot;&gt;&lt;/a&gt; 数据结构&lt;/h3&gt;
&lt;h4 id=&quot;链表&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#链表&quot;&gt;&lt;/a&gt; 链表&lt;/h4&gt;
&lt;h5 
      
    
    </summary>
    
    
      <category term="Acwing" scheme="http://xboom.github.io/categories/Acwing/"/>
    
    
      <category term="Algorithm" scheme="http://xboom.github.io/tags/Algorithm/"/>
    
      <category term="Acwing" scheme="http://xboom.github.io/tags/Acwing/"/>
    
  </entry>
  
  <entry>
    <title>Acwing-剑指</title>
    <link href="http://xboom.github.io/2022/02/15/Acwing/Test/"/>
    <id>http://xboom.github.io/2022/02/15/Acwing/Test/</id>
    <published>2022-02-14T16:27:12.000Z</published>
    <updated>2022-06-28T14:44:37.504Z</updated>
    
    <content type="html"><![CDATA[<p>本人学历和眼界有限，以下内容仅供参考：</p><ol><li><p>不建议进入该专业的原因：</p><ul><li>内卷严重：大量人员涌入，比较内卷</li><li>频繁裁员：当前互联网公司也在频繁裁员(可能和当前经济环境有关，这样的环境会持续好久</li><li>性别因素：公司在招聘研发岗位可能会更多的考虑男孩子(研究岗位不清楚，不评论)</li><li>技术更新快：需要不断学习，技术更新迭代很快</li></ul></li><li><p>进入该专业的原因：</p><ul><li>社会需求大：社会各单位都需要计算机人才</li><li>前景巨大：计算机需求的趋势不变，不管是新基建、数字乡村的国家政策还是万物互联、数字化等社会需求</li><li>找工作容易：对于考公务员、进入大厂或从事计算机相关工作，有计算机背景会有更多的选择</li></ul></li><li><p>是怎么选自己的专业</p><ul><li>社会需求</li></ul></li></ol><ul><li><ul><li>当前需求</li></ul></li><li><ul><li>未来需求</li></ul></li><li><p>发展前景</p></li><li></li><li><p>薪资</p></li><li><ul><li></li></ul></li><li><p>工作强度</p></li><li><p>工作强度主要跟工作类型区分</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本人学历和眼界有限，以下内容仅供参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不建议进入该专业的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内卷严重：大量人员涌入，比较内卷&lt;/li&gt;
&lt;li&gt;频繁裁员：当前互联网公司也在频繁裁员(可能和当前经济环境有关，这样的环境会持续好久&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Acwing" scheme="http://xboom.github.io/categories/Acwing/"/>
    
    
      <category term="Algorithm" scheme="http://xboom.github.io/tags/Algorithm/"/>
    
      <category term="Acwing" scheme="http://xboom.github.io/tags/Acwing/"/>
    
  </entry>
  
  <entry>
    <title>MySql入门9-温故而知新</title>
    <link href="http://xboom.github.io/2022/02/11/MySql/MySql%E5%85%A5%E9%97%A89-%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0/"/>
    <id>http://xboom.github.io/2022/02/11/MySql/MySql%E5%85%A5%E9%97%A89-%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0/</id>
    <published>2022-02-11T07:51:12.000Z</published>
    <updated>2022-02-11T08:17:48.565Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库基础知识"><a class="markdownIt-Anchor" href="#数据库基础知识"></a> 数据库基础知识</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据库基础知识&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数据库基础知识&quot;&gt;&lt;/a&gt; 数据库基础知识&lt;/h3&gt;

      
    
    </summary>
    
    
      <category term="MySql" scheme="http://xboom.github.io/categories/MySql/"/>
    
    
      <category term="MySql" scheme="http://xboom.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>MySql入门7-表</title>
    <link href="http://xboom.github.io/2022/02/11/MySql/MySql%E5%85%A5%E9%97%A87-%E8%A1%A8/"/>
    <id>http://xboom.github.io/2022/02/11/MySql/MySql%E5%85%A5%E9%97%A87-%E8%A1%A8/</id>
    <published>2022-02-11T07:49:55.000Z</published>
    <updated>2022-02-11T07:50:14.306Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="MySql" scheme="http://xboom.github.io/categories/MySql/"/>
    
    
      <category term="MySql" scheme="http://xboom.github.io/tags/MySql/"/>
    
  </entry>
  
</feed>
