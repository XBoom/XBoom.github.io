<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XBoom Dove</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xboom.github.io/"/>
  <updated>2023-05-26T14:20:58.534Z</updated>
  <id>http://xboom.github.io/</id>
  
  <author>
    <name>XBoom Dove</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式-17-策略模式</title>
    <link href="http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-17-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-17-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-05-26T14:20:58.534Z</published>
    <updated>2023-05-26T14:20:58.534Z</updated>
    
    <content type="html"><![CDATA[<p><strong>策略模式</strong>是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><ol><li><p>定义一个策略接口，其中包含一个方法 <code>Do()</code>，代表具体的算法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Strategy <span class="keyword">interface</span> &#123;</span><br><span class="line">    Do()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建多个实现了策略接口的具体策略类，分别实现不同的算法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StrategyA <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StrategyA)</span> <span class="title">Do</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"StrategyA"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StrategyB <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StrategyB)</span> <span class="title">Do</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"StrategyB"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建一个上下文结构体，用于调用具体的算法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">    strategy Strategy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">SetStrategy</span><span class="params">(s Strategy)</span></span> &#123;</span><br><span class="line">    c.strategy = s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.strategy.Do()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在客户端程序中，创建一个具体的上下文对象，并设置具体的策略对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    context := &amp;Context&#123;&#125;</span><br><span class="line"></span><br><span class="line">    strategyA := &amp;StrategyA&#123;&#125;</span><br><span class="line">    context.SetStrategy(strategyA)</span><br><span class="line">    context.Execute()</span><br><span class="line"></span><br><span class="line">    strategyB := &amp;StrategyB&#123;&#125;</span><br><span class="line">    context.SetStrategy(strategyB)</span><br><span class="line">    context.Execute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>Strategy</code> 是一个接口，包含了一个 <code>Do()</code> 方法，代表具体的算法。<code>StrategyA</code> 和 <code>StrategyB</code> 是两个具体的策略类，分别实现了不同的算法。<code>Context</code> 是一个上下文结构体，用于调用具体的算法。客户端程序可以通过创建具体的上下文对象，并设置具体的策略对象来使用不同的算法</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li>当想使用对象中各种不同的算法变体，并希望能在运行时切换算法时</li><li>可以将算法的实现和使用算法的代码隔离开来</li><li><em>开闭原则</em>。 无需对上下文进行修改就能够引入新的策略</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/strategy" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/strategy</a></li><li><a href="https://lailin.xyz/post/strategy.html" target="_blank" rel="noopener">https://lailin.xyz/post/strategy.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;策略模式&lt;/strong&gt;是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#代码实现&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-16-模板方法模式</title>
    <link href="http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-16-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-16-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-05-26T14:20:58.534Z</published>
    <updated>2023-05-26T14:20:58.534Z</updated>
    
    <content type="html"><![CDATA[<p><strong>模板方法模式</strong>是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤</p><p>举个 例子，假设现在要做一个短信推送的系统，那么需要</p><ol><li>检查短信字数是否超过限制</li><li>检查手机号是否正确</li><li>发送短信</li><li>返回状态</li></ol><p>可以发现，在发送短信的时候由于不同的供应商调用的接口不同，所以会有一些实现上的差异，但短信推送的算法（业务逻辑）是固定的</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><ol><li><p>定义一个模板方法，其中包含算法的骨架，以及一些需要延迟到子类实现的抽象方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Template <span class="keyword">interface</span> &#123;</span><br><span class="line">    step1()</span><br><span class="line">    step2()</span><br><span class="line">    step3()</span><br><span class="line">    TemplateMethod()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConcreteTemplate <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *ConcreteTemplate)</span> <span class="title">step1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"ConcreteTemplate:step1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *ConcreteTemplate)</span> <span class="title">step2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"ConcreteTemplate:step2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *ConcreteTemplate)</span> <span class="title">step3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"ConcreteTemplate:step3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *ConcreteTemplate)</span> <span class="title">TemplateMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t.step1()</span><br><span class="line">    t.step2()</span><br><span class="line">    t.step3()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建一个具体的子类，实现需要延迟到子类中实现的抽象方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ConcreteTemplateA <span class="keyword">struct</span> &#123;</span><br><span class="line">    *ConcreteTemplate</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *ConcreteTemplateA)</span> <span class="title">step1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"ConcreteTemplateA:step1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConcreteTemplateB <span class="keyword">struct</span> &#123;</span><br><span class="line">    *ConcreteTemplate</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *ConcreteTemplateB)</span> <span class="title">step3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"ConcreteTemplateB:step3"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在客户端程序中，创建一个具体子类的实例，并调用模板方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    templateA := &amp;ConcreteTemplateA&#123;&amp;ConcreteTemplate&#123;&#125;&#125;</span><br><span class="line">    templateA.TemplateMethod()</span><br><span class="line"></span><br><span class="line">    templateB := &amp;ConcreteTemplateB&#123;&amp;ConcreteTemplate&#123;&#125;&#125;</span><br><span class="line">    templateB.TemplateMethod()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>类似于重写林父类方法</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>模板方法模式只适用于具有相似算法结构的场景，如果算法结构非常不同，则不太适合使用该模式</li><li>可将重复代码提取到一个超类中</li><li>当一个算法的具体实现需要发生改变时，可以通过在子类中重写抽象方法来灵活地扩展算法</li><li>当一个算法需要在多个子类中共享时，可以将其骨架放在父类中实现</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;模板方法模式&lt;/strong&gt;是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤&lt;/p&gt;
&lt;p&gt;举个 例子，假设现在要做一个短信推送的系统，那么需要&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检查短信字数是否超过限制&lt;/l
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-14-享元模式</title>
    <link href="http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-14-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-14-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-05-26T14:20:58.533Z</published>
    <updated>2023-05-26T14:20:58.533Z</updated>
    
    <content type="html"><![CDATA[<p><strong>享元模式</strong>是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 能在有限的内存容量中载入更多对象</p><p>在享元模式中，有四个角色：</p><ul><li>Flyweight（抽象享元）：声明公共方法，这些方法可以向外界提供对象的内部状态。</li><li>ConcreteFlyweight（具体享元）：实现抽象享元接口，保存对象内部状态，并且可以被共享。</li><li>UnsharedConcreteFlyweight（非共享具体享元）：不能被共享的具体享元类。</li><li>FlyweightFactory（享元工厂）：维护一个享元池（Flyweight Pool），用于存储已经创建的共享对象。客户端可以向工厂请求一个享元，如果工厂中不存在该享元，则创建新的享元并将其加入到享元池中；否则直接从享元池中返回已有的享元</li></ul><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象享元</span></span><br><span class="line"><span class="keyword">type</span> Flyweight <span class="keyword">interface</span> &#123;</span><br><span class="line">    Operation(x <span class="keyword">int</span>, y <span class="keyword">int</span>) <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体享元</span></span><br><span class="line"><span class="keyword">type</span> ConcreteFlyweight <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConcreteFlyweight)</span> <span class="title">Operation</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 享元工厂</span></span><br><span class="line"><span class="keyword">type</span> FlyweightFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">    flyweights <span class="keyword">map</span>[<span class="keyword">string</span>]Flyweight</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFlyweightFactory</span><span class="params">()</span> *<span class="title">FlyweightFactory</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;FlyweightFactory&#123;<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Flyweight)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FlyweightFactory)</span> <span class="title">GetFlyweight</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">Flyweight</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> flyweight, ok := f.flyweights[key]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> flyweight</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        flyweight = &amp;ConcreteFlyweight&#123;&#125;</span><br><span class="line">        f.flyweights[key] = flyweight</span><br><span class="line">        <span class="keyword">return</span> flyweight</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了抽象享元 <code>Flyweight</code> 和具体享元 <code>ConcreteFlyweight</code>。其中，<code>ConcreteFlyweight</code> 实现了 <code>Operation</code> 方法，并且可以被共享。然后定义了一个享元工厂 <code>FlyweightFactory</code>，它维护了一个享元池（<code>flyweights</code>），用于存储已经创建的共享对象。客户端可以通过 <code>GetFlyweight</code> 方法向工厂请求一个享元，如果工厂中不存在该享元，则创建新的享元并将其加入到享元池中；否则直接从享元池中返回已有的享元</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">factory := NewFlyweightFactory()</span><br><span class="line"></span><br><span class="line">fw1 := factory.GetFlyweight(<span class="string">"key1"</span>)</span><br><span class="line">result1 := fw1.Operation(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">fmt.Println(result1) <span class="comment">// 输出：3</span></span><br><span class="line"></span><br><span class="line">fw2 := factory.GetFlyweight(<span class="string">"key1"</span>)</span><br><span class="line">result2 := fw2.Operation(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">fmt.Println(result2) <span class="comment">// 输出：7</span></span><br><span class="line"></span><br><span class="line">fw3 := factory.GetFlyweight(<span class="string">"key2"</span>)</span><br><span class="line">result3 := fw3.Operation(<span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">fmt.Println(result3) <span class="comment">// 输出：11</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式(类似与内存池，但是这个重复利用的不是分配的内存而是对象)</li><li>享元中共享的是对象，如果对象多处使用修改对象内容需要注意(类似指针)，其次需要考虑并发处理</li><li>好处就是减少了内存使用，但这种适用的是常驻对象，临时对象需要考虑内存上限与过期删除问题</li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/flyweight" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/flyweight</a></li><li><a href="https://lailin.xyz/post/flyweight.html" target="_blank" rel="noopener">https://lailin.xyz/post/flyweight.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;享元模式&lt;/strong&gt;是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 能在有限的内存容量中载入更多对象&lt;/p&gt;
&lt;p&gt;在享元模式中，有四个角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Flyweight（抽象享元
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-13-组合模式</title>
    <link href="http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-13-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-13-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-05-26T14:20:58.533Z</published>
    <updated>2023-05-26T14:20:58.533Z</updated>
    
    <content type="html"><![CDATA[<p><strong>组合模式</strong>是一种结构型设计模式， 使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们</p><p>在组合模式中，有三个角色：</p><ul><li>Component（抽象构件）: 定义了叶子节点和组合节点的公共接口。</li><li>Leaf（叶子节点）: 表示树形结构中的叶子节点对象，它没有子节点。</li><li>Composite（组合节点）: 表示树形结构中的组合节点对象，它可以包含子节点</li></ul><h3 id="实现代码"><a class="markdownIt-Anchor" href="#实现代码"></a> 实现代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象构件</span></span><br><span class="line"><span class="keyword">type</span> Component <span class="keyword">interface</span> &#123;</span><br><span class="line">    Add(component Component)</span><br><span class="line">    Remove(component Component)</span><br><span class="line">    Display(depth <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叶子节点</span></span><br><span class="line"><span class="keyword">type</span> Leaf <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Leaf)</span> <span class="title">Add</span><span class="params">(component Component)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Leaf)</span> <span class="title">Remove</span><span class="params">(component Component)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Leaf)</span> <span class="title">Display</span><span class="params">(depth <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(strings.Repeat(<span class="string">"-"</span>, depth) + l.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合节点</span></span><br><span class="line"><span class="keyword">type</span> Composite <span class="keyword">struct</span> &#123;</span><br><span class="line">    name       <span class="keyword">string</span></span><br><span class="line">    components []Component</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewComposite</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">Composite</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Composite&#123;name, <span class="built_in">make</span>([]Component, <span class="number">0</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Composite)</span> <span class="title">Add</span><span class="params">(component Component)</span></span> &#123;</span><br><span class="line">    c.components = <span class="built_in">append</span>(c.components, component)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Composite)</span> <span class="title">Remove</span><span class="params">(component Component)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> c.components &#123;</span><br><span class="line">        <span class="keyword">if</span> v == component &#123;</span><br><span class="line">            c.components = <span class="built_in">append</span>(c.components[:i], c.components[i+<span class="number">1</span>:]...)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Composite)</span> <span class="title">Display</span><span class="params">(depth <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(strings.Repeat(<span class="string">"-"</span>, depth) + c.name)</span><br><span class="line">    <span class="keyword">for</span> _, component := <span class="keyword">range</span> c.components &#123;</span><br><span class="line">        component.Display(depth + <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了抽象构件 <code>Component</code> 和叶子节点 <code>Leaf</code>。然后定义了组合节点 <code>Composite</code>，它持有一个 <code>Component</code> 的切片，并实现了 <code>Add</code>、<code>Remove</code> 和 <code>Display</code> 方法。其中，<code>Add</code> 和 <code>Remove</code> 方法用来添加和删除子节点，<code>Display</code> 方法用来输出树形结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root := NewComposite(<span class="string">"root"</span>)</span><br><span class="line">root.Add(&amp;Leaf&#123;<span class="string">"Leaf A"</span>&#125;)</span><br><span class="line">root.Add(&amp;Leaf&#123;<span class="string">"Leaf B"</span>&#125;)</span><br><span class="line"></span><br><span class="line">comp := NewComposite(<span class="string">"Composite X"</span>)</span><br><span class="line">comp.Add(&amp;Leaf&#123;<span class="string">"Leaf XA"</span>&#125;)</span><br><span class="line">comp.Add(&amp;Leaf&#123;<span class="string">"Leaf XB"</span>&#125;)</span><br><span class="line"></span><br><span class="line">root.Add(comp)</span><br><span class="line"></span><br><span class="line">root.Display(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>创建了一个根节点 <code>root</code>，并添加了两个叶子节点 <code>Leaf A</code> 和 <code>Leaf B</code>，以及一个组合节点 <code>Composite X</code>，并在 <code>Composite X</code> 中添加了两个叶子节点 <code>Leaf XA</code> 和 <code>Leaf XB</code>。最后调用根节点的 <code>Display</code> 方法，输出整个树形结构</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li>可以利用多态和递归机制更方便地使用复杂树结构。</li><li><em>开闭原则</em>，无需更改现有代码， 就可以在应用中添加新元素， 使其成为对象树的一部分</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/composite" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/composite</a></li><li><a href="https://lailin.xyz/post/composite.html" target="_blank" rel="noopener">https://lailin.xyz/post/composite.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;组合模式&lt;/strong&gt;是一种结构型设计模式， 使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们&lt;/p&gt;
&lt;p&gt;在组合模式中，有三个角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Component（抽象构件）: 定义了叶子节点和组合节点的公共接口。&lt;/l
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-15-观察者模式</title>
    <link href="http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-15-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-15-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-05-26T14:20:58.533Z</published>
    <updated>2023-05-26T14:20:58.533Z</updated>
    
    <content type="html"><![CDATA[<p><strong>观察者模式</strong>是一种行为设计模式，允许你定义一种订阅机制，可在对象事件发生时通知多个“观察” 该对象的其他对象，在观察者模式中，有两个角色：</p><ul><li>Subject（目标）：定义了对象之间的一对多依赖关系。当其状态发生改变时，通知所有注册的观察者对象。</li><li>Observer（观察者）：定义了接收到目标通知时所执行的操作</li></ul><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标接口</span></span><br><span class="line"><span class="keyword">type</span> Subject <span class="keyword">interface</span> &#123;</span><br><span class="line">    Attach(observer Observer)<span class="comment">//增加观察者</span></span><br><span class="line">    Detach(observer Observer)<span class="comment">//删除观察者</span></span><br><span class="line">    Notify()<span class="comment">//通知</span></span><br><span class="line">    SetState(state <span class="keyword">string</span>)<span class="comment">//设置状态</span></span><br><span class="line">    GetState() <span class="keyword">string</span><span class="comment">//获取状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体目标</span></span><br><span class="line"><span class="keyword">type</span> ConcreteSubject <span class="keyword">struct</span> &#123;</span><br><span class="line">    observers []Observer</span><br><span class="line">    state     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加观察者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ConcreteSubject)</span> <span class="title">Attach</span><span class="params">(observer Observer)</span></span> &#123;</span><br><span class="line">    s.observers = <span class="built_in">append</span>(s.observers, observer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除观察者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ConcreteSubject)</span> <span class="title">Detach</span><span class="params">(observer Observer)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> s.observers &#123;</span><br><span class="line">        <span class="keyword">if</span> v == observer &#123;</span><br><span class="line">            s.observers = <span class="built_in">append</span>(s.observers[:i], s.observers[i+<span class="number">1</span>:]...)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ConcreteSubject)</span> <span class="title">Notify</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, observer := <span class="keyword">range</span> s.observers &#123;<span class="comment">//观察者更新操作</span></span><br><span class="line">        observer.Update()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ConcreteSubject)</span> <span class="title">SetState</span><span class="params">(state <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    s.state = state</span><br><span class="line">    s.Notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ConcreteSubject)</span> <span class="title">GetState</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者接口</span></span><br><span class="line"><span class="keyword">type</span> Observer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Update()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体观察者1</span></span><br><span class="line"><span class="keyword">type</span> ConcreteObserver1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    subject Subject</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *ConcreteObserver1)</span> <span class="title">Update</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"ConcreteObserver1 updated with state:"</span>, o.subject.GetState())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体观察者2</span></span><br><span class="line"><span class="keyword">type</span> ConcreteObserver2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    subject Subject</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *ConcreteObserver2)</span> <span class="title">Update</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"ConcreteObserver2 updated with state:"</span>, o.subject.GetState())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了目标接口 <code>Subject</code> 和具体目标 <code>ConcreteSubject</code>。其中，<code>ConcreteSubject</code> 实现了 <code>Attach</code>、<code>Detach</code>、<code>Notify</code>、<code>SetState</code> 和 <code>GetState</code> 方法。</p><p>定义了观察者接口 <code>Observer</code> 和两个具体观察者 <code>ConcreteObserver1</code> 和 <code>ConcreteObserver2</code>。其中，<code>ConcreteObserver1</code> 和 <code>ConcreteObserver2</code> 实现了 <code>Update</code> 方法，并通过构造函数接收一个具体目标对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">subject := &amp;ConcreteSubject&#123;observers: <span class="built_in">make</span>([]Observer, <span class="number">0</span>)&#125;</span><br><span class="line"></span><br><span class="line">observer1 := &amp;ConcreteObserver1&#123;subject&#125;</span><br><span class="line">observer2 := &amp;ConcreteObserver2&#123;subject&#125;</span><br><span class="line"></span><br><span class="line">subject.Attach(observer1)</span><br><span class="line">subject</span><br></pre></td></tr></table></figure><p>这种情况下，由于是循环执行，可能导致单个服务的 <code>update</code> 操作影响后续，可以通过管道通知到各个服务并使用协程执行<code>update</code>操作，依据实际需要执行</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li>当一个对象状态的改变需要改变其他对象，或实际对象是事先未知的或动态变化的时</li><li>当应用中的一些对象必须观察其他对象时，但仅能在有限时间内或特定情况下使用</li><li><em>开闭原则</em>。 <strong>无需修改发布者代码就能引入新的订阅者类</strong> (如果是发布者接口则可轻松引入发布者类)，<code>channel</code> 也存在类似功能。</li><li>由于主题和观察者之间的关系是通过接口而不是具体实现建立的，因此它们可以在不同的上下文中重复使用</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/observer" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/observer</a></li><li><a href="https://lailin.xyz/post/observer.html" target="_blank" rel="noopener">https://lailin.xyz/post/observer.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;观察者模式&lt;/strong&gt;是一种行为设计模式，允许你定义一种订阅机制，可在对象事件发生时通知多个“观察” 该对象的其他对象，在观察者模式中，有两个角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Subject（目标）：定义了对象之间的一对多依赖关系。当其状态发生改变时，
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-10-装饰模式</title>
    <link href="http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-10-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-10-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-05-26T14:20:58.532Z</published>
    <updated>2023-05-26T14:20:58.532Z</updated>
    
    <content type="html"><![CDATA[<p><strong>装饰模式</strong>是一种结构型设计模式， 允许在运行时动态地给对象添加新的行为。</p><h3 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h3><p>更改一个对象的行为时，不能忽视继承可能引发的几个严重问题</p><ul><li>继承是静态的，无法在运行时更改已有对象的行为， 只能使用由不同子类创建的对象替代当前的整个对象。</li><li>子类只能有一个父类。 大部分编程语言不允许一个类同时继承多个类的行为</li></ul><p>装饰模式通过将对象放入包装器中来实现这一点，每个包装器都提供了额外的功能。在装饰模式中，有四个角色：</p><ul><li>Component（抽象构件）：定义了一个对象接口，可以给这些对象动态地添加职责。</li><li>ConcreteComponent（具体构件）：定义了一个具体的对象，也可以给这个对象添加一些职责。</li><li>Decorator（装饰者）：持有一个抽象构件的引用，并定义了一个与抽象构件接口一致的接口。</li><li>ConcreteDecorator（具体装饰者）：负责给具体构件添加额外的职责。</li></ul><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象构件</span></span><br><span class="line"><span class="keyword">type</span> Component <span class="keyword">interface</span> &#123;</span><br><span class="line">    Operation() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体构件</span></span><br><span class="line"><span class="keyword">type</span> ConcreteComponent <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConcreteComponent)</span> <span class="title">Operation</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ConcreteComponent"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰者</span></span><br><span class="line"><span class="keyword">type</span> Decorator <span class="keyword">interface</span> &#123;</span><br><span class="line">    Component</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰者 A</span></span><br><span class="line"><span class="keyword">type</span> ConcreteDecoratorA <span class="keyword">struct</span> &#123;</span><br><span class="line">    component Component</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *ConcreteDecoratorA)</span> <span class="title">Operation</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ConcreteDecoratorA("</span> + d.component.Operation() + <span class="string">")"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰者 B</span></span><br><span class="line"><span class="keyword">type</span> ConcreteDecoratorB <span class="keyword">struct</span> &#123;</span><br><span class="line">    component Component</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *ConcreteDecoratorB)</span> <span class="title">Operation</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ConcreteDecoratorB("</span> + d.component.Operation() + <span class="string">")"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义了抽象构件 <code>Component</code> 和具体构件 <code>ConcreteComponent</code>。然后定义了装饰者 <code>Decorator</code> 和具体装饰者 <code>ConcreteDecoratorA</code> 和 <code>ConcreteDecoratorB</code>。其中，具体装饰者持有一个抽象构件的引用，并且实现了与抽象构件接口一致的接口。这样就可以在具体构件上动态地添加额外的职责</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">component := &amp;ConcreteComponent&#123;&#125;</span><br><span class="line">decoratorA := &amp;ConcreteDecoratorA&#123;component&#125;</span><br><span class="line">decoratorB := &amp;ConcreteDecoratorB&#123;decoratorA&#125;</span><br><span class="line"></span><br><span class="line">result := decoratorB.Operation()</span><br><span class="line">fmt.Println(result) <span class="comment">// 输出：ConcreteDecoratorB(ConcreteDecoratorA(ConcreteComponent))</span></span><br></pre></td></tr></table></figure><p>首先创建了一个具体构件 <code>ConcreteComponent</code>，并将其传递给具体装饰者 <code>ConcreteDecoratorA</code> 和 <code>ConcreteDecoratorB</code> 进行装饰。然后调用 <code>ConcreteDecoratorB</code> 的 <code>Operation</code> 方法，最终输出结果为 “ConcreteDecoratorB(ConcreteDecoratorA(ConcreteComponent))”。</p><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><ol><li>如果希望在无需修改代码的情况下即可使用对象，且希望在运行时为对象新增额外的行为，可以使用装饰模式。</li><li>如果用继承来扩展对象行为的方案难以实现或者根本不可行，你可以使用该模式</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li>无需创建新子类即可扩展对象的行为。</li><li>可以在运行时添加或删除对象的功能。</li><li>可以用多个装饰封装对象来组合几种行为。</li><li><em>单一职责原则</em>。 可以将实现了许多不同行为的一个大类拆分为多个较小的类</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/decorator" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/decorator</a></li><li><a href="https://lailin.xyz/post/decorator.html" target="_blank" rel="noopener">https://lailin.xyz/post/decorator.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;装饰模式&lt;/strong&gt;是一种结构型设计模式， 允许在运行时动态地给对象添加新的行为。&lt;/p&gt;
&lt;h3 id=&quot;问题描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题描述&quot;&gt;&lt;/a&gt; 问题描述&lt;/h3&gt;
&lt;p&gt;更改一个对象
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-11-适配器模式</title>
    <link href="http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-11-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-11-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-05-26T14:20:58.532Z</published>
    <updated>2023-05-26T14:20:58.532Z</updated>
    
    <content type="html"><![CDATA[<p><strong>适配器模式</strong>是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。</p><p>适配器模式通过封装对象将复杂的转换过程隐藏于幕后， 被封装的对象甚至察觉不到适配器的存在。 其还有助于采用不同接口的对象之间的合作。</p><p>在适配器模式中，有三个角色：</p><ul><li>Target(目标接口): 定义客户端使用的与特定领域相关的接口。</li><li>Adapter(适配器): 把源接口转换成目标接口。它通常是一个包装器，它会封装一个已有的类，并将这个类的接口转换为目标接口。</li><li>Adaptee(源接口): 定义了需要被适配的接口</li></ul><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标接口</span></span><br><span class="line"><span class="keyword">type</span> Target <span class="keyword">interface</span> &#123;</span><br><span class="line">    Request() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源接口</span></span><br><span class="line"><span class="keyword">type</span> Adaptee <span class="keyword">interface</span> &#123;</span><br><span class="line">    SpecificRequest() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源接口的具体实现</span></span><br><span class="line"><span class="keyword">type</span> ConcreteAdaptee <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *ConcreteAdaptee)</span> <span class="title">SpecificRequest</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Specific request."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器</span></span><br><span class="line"><span class="keyword">type</span> Adapter <span class="keyword">struct</span> &#123;</span><br><span class="line">    adaptee Adaptee<span class="comment">//包含源接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现目标接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Adapter)</span> <span class="title">Request</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Adapter: "</span> + a.adaptee.SpecificRequest()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了目标接口 <code>Target</code> 和源接口 <code>Adaptee</code>。其中， <code>Adaptee</code> 的具体实现为 <code>ConcreteAdaptee</code>。然后定义了适配器 <code>Adapter</code>，它持有一个 <code>Adaptee</code> 的引用，并实现了 <code>Target</code> 接口。这样就将 <code>Adaptee</code> 转换为了 <code>Target</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adaptee := &amp;ConcreteAdaptee&#123;&#125;</span><br><span class="line">adapter := &amp;Adapter&#123;adaptee&#125;</span><br><span class="line"></span><br><span class="line">result := adapter.Request()</span><br><span class="line">fmt.Println(result) <span class="comment">// 输出：Adapter: Specific request.</span></span><br></pre></td></tr></table></figure><p>其实就是适配器包含原接口，实现目标接口，在实现中调用原接口逻辑</p><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><ol><li>当你希望使用某个类，但是其接口与其他代码不兼容时，可以使用适配器类</li><li>如果您需要复用这样一些类，他们处于同一个继承体系，并且他们又有了额外的一些共同的方法，但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li><em>单一职责原则</em>你可以将接口或数据转换代码从程序主要业务逻辑中分离。</li><li><em>开闭原则</em>。 只要客户端代码通过客户端接口与适配器进行交互， 你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://lailin.xyz/post/adapter.html" target="_blank" rel="noopener">https://lailin.xyz/post/adapter.html</a></li><li><a href="https://refactoringguru.cn/design-patterns/adapter" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/adapter</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;适配器模式&lt;/strong&gt;是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。&lt;/p&gt;
&lt;p&gt;适配器模式通过封装对象将复杂的转换过程隐藏于幕后， 被封装的对象甚至察觉不到适配器的存在。 其还有助于采用不同接口的对象之间的合作。&lt;/p&gt;
&lt;p&gt;在适配
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-12-门面模式</title>
    <link href="http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-12-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-12-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-05-26T14:20:58.532Z</published>
    <updated>2023-05-26T14:20:58.533Z</updated>
    
    <content type="html"><![CDATA[<p>**门面模式(外观模式)**是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。</p><p>问题描述：假设必须在代码中使用某个复杂的库或框架中的众多对象。 正常情况下，需要负责所有对象的初始化工作、 管理其依赖关系并按正确的顺序执行方法等。最终， 程序中类的业务逻辑将与第三方类的实现细节紧密耦合， 使得理解和维护代码的工作很难进行。</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子系统 A</span></span><br><span class="line"><span class="keyword">type</span> SubsystemA <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SubsystemA)</span> <span class="title">OperationA</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Subsystem A"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统 B</span></span><br><span class="line"><span class="keyword">type</span> SubsystemB <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SubsystemB)</span> <span class="title">OperationB</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Subsystem B"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 门面</span></span><br><span class="line"><span class="keyword">type</span> Facade <span class="keyword">struct</span> &#123;</span><br><span class="line">    subsystemA *SubsystemA</span><br><span class="line">    subsystemB *SubsystemB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFacade</span><span class="params">()</span> *<span class="title">Facade</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Facade&#123;&amp;SubsystemA&#123;&#125;, &amp;SubsystemB&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Facade)</span> <span class="title">Operation</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    result := <span class="string">"Facade initializes subsystems:\n"</span></span><br><span class="line">    result += f.subsystemA.OperationA() + <span class="string">"\n"</span></span><br><span class="line">    result += f.subsystemB.OperationB() + <span class="string">"\n"</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了两个子系统 <code>SubsystemA</code> 和 <code>SubsystemB</code>。然后定义了门面 <code>Facade</code>，它持有一个 <code>SubsystemA</code> 和一个 <code>SubsystemB</code> 的引用。在门面中，我们实现了 <code>Operation</code> 方法，它会调用子系统的相应方法，并返回一个字符串结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">facade := NewFacade()</span><br><span class="line">result := facade.Operation()</span><br><span class="line">fmt.Println(result)</span><br></pre></td></tr></table></figure><p>最终输出结果是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Facade initializes subsystems:</span><br><span class="line">Subsystem A</span><br><span class="line">Subsystem B</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><ol><li>如果需要一个指向复杂子系统的直接接口，且该接口的功能有限，则可以使用门面模式</li><li>如果需要将子系统组织为多层结构，可以使用外观</li><li>门面模式适用于一个系统的外部和内部之间有着很复杂的交互关系，并且希望通过一个简单的接口对其进行封装的场景，如果门面设计不当，可能会导致门面过于庞大和复杂</li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/facade" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/facade</a></li><li><a href="https://lailin.xyz/post/facade.html" target="_blank" rel="noopener">https://lailin.xyz/post/facade.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;**门面模式(外观模式)**是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。&lt;/p&gt;
&lt;p&gt;问题描述：假设必须在代码中使用某个复杂的库或框架中的众多对象。 正常情况下，需要负责所有对象的初始化工作、 管理其依赖关系并按正确的顺序执行方法等。最终， 
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-08-代理模式</title>
    <link href="http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-08-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-08-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-05-26T14:20:58.531Z</published>
    <updated>2023-05-26T14:24:42.935Z</updated>
    
    <content type="html"><![CDATA[<p><strong>代理模式</strong> 建议新建一个与原服务对象接口相同的代理类， 然后更新应用以将代理对象传递给所有原始对象客户端。 代理类接收到客户端请求后会创建实际的服务对象， 并将所有工作委派给它。使用代理对象来控制对真实对象的访问，并在必要时进行一些额外的操作。代理模式可以提高系统的安全性和可靠性，并且减少了客户端与真实主题对象之间的耦合</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Subject 是主题接口</span></span><br><span class="line"><span class="keyword">type</span> Subject <span class="keyword">interface</span> &#123;</span><br><span class="line">    Request()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RealSubject 是真实主题结构体</span></span><br><span class="line"><span class="keyword">type</span> RealSubject <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*RealSubject)</span> <span class="title">Request</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"RealSubject.Request"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Proxy 是代理结构体</span></span><br><span class="line"><span class="keyword">type</span> Proxy <span class="keyword">struct</span> &#123;</span><br><span class="line">    realSubject *RealSubject</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Proxy)</span> <span class="title">Request</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p.realSubject == <span class="literal">nil</span> &#123;</span><br><span class="line">        p.realSubject = &amp;RealSubject&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p.realSubject.Request()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> subject Subject = &amp;Proxy&#123;&#125;</span><br><span class="line">    subject.Request()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了一个 <code>Subject</code> 接口，其中包含一个 <code>Request()</code> 方法用于执行具体请求操作。</p><p>然后创建一个 <code>RealSubject</code> 结构体，实现了 <code>Request()</code> 方法，并用于执行真实的业务逻辑操作。</p><p>最后创建一个 <code>Proxy</code> 结构体，它也实现了 <code>Request()</code> 方法，并在其中创建了一个 <code>RealSubject</code> 对象用于代理真实主题对象。</p><p>当调用 <code>Proxy</code> 对象的 <code>Request()</code> 方法时，首先会检查其内部的 <code>realSubject</code> 指针是否为空。如果为空，则会创建一个新的 <code>RealSubject</code> 对象。然后，将请求转发给 <code>RealSubject</code> 对象进行处理。这样就成功地使用代理模式来实现了对真实主题对象的代理操作。输出结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RealSubject.Request</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li><strong>延迟初始化</strong>， 如果有一个偶尔使用的重量级服务对象，一直保持该对象运行会消耗系统资源时使用代理模式(类似单例模式，但单例模式强调的是单实例)</li><li><strong>访问控制(保护代理)</strong>，如果你只希望特定客户端使用服务对象，这里的对象可以是操作系统中非常重要的部分，而客户端则是各种已启动的程序(包括恶意程序)，此时可使用代理模式</li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://lailin.xyz/post/factory.html" target="_blank" rel="noopener">https://lailin.xyz/post/factory.html</a></li><li><a href="https://refactoringguru.cn/design-patterns/proxy" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/proxy</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;代理模式&lt;/strong&gt; 建议新建一个与原服务对象接口相同的代理类， 然后更新应用以将代理对象传递给所有原始对象客户端。 代理类接收到客户端请求后会创建实际的服务对象， 并将所有工作委派给它。使用代理对象来控制对真实对象的访问，并在必要时进行一些额外的操作
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-07-原型模式</title>
    <link href="http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-07-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-07-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-05-26T14:20:58.531Z</published>
    <updated>2023-05-26T14:20:58.531Z</updated>
    
    <content type="html"><![CDATA[<p><strong>原型模式</strong>是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类(<strong>亦称：</strong> 克隆、Clone、Prototype)</p><p>如果你有一个对象， 并希望生成与其完全相同的一个复制品， 你该如何实现呢？ 首先， 你必须新建一个属于相同类的对象。 然后， 你必须遍历原始对象的所有成员变量， 并将成员变量值复制到新对象中。</p><p>可能存在的问题</p><ol><li>并非所有对象都能通过这种方式进行复制， 因为有些<strong>对象可能拥有私有成员变量</strong>， 它们在对象本身以外是不可见的</li><li><strong>有时只知道对象所实现的接口， 而不知道其所属的具体类</strong>， 比如可向方法的某个参数传入实现了某个接口的任何对象</li></ol><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Prototype 是原型接口</span></span><br><span class="line"><span class="keyword">type</span> Prototype <span class="keyword">interface</span> &#123;</span><br><span class="line">Clone() Prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcretePrototype 是具体原型结构体</span></span><br><span class="line"><span class="keyword">type</span> ConcretePrototype <span class="keyword">struct</span> &#123;</span><br><span class="line">part1 <span class="keyword">string</span></span><br><span class="line">part2 <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clone 是克隆方法(深拷贝)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ConcretePrototype)</span> <span class="title">Clone</span><span class="params">()</span> <span class="title">Prototype</span></span> &#123;</span><br><span class="line">clone := *p<span class="comment">//值拷贝</span></span><br><span class="line"><span class="keyword">return</span> &amp;clone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">prototype := ConcretePrototype&#123;</span><br><span class="line">part1: <span class="string">"part1"</span>,</span><br><span class="line">part2: <span class="number">123</span>,</span><br><span class="line">&#125;</span><br><span class="line">clone1 := prototype.Clone().(*ConcretePrototype)</span><br><span class="line">clone2 := prototype.Clone().(*ConcretePrototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 clone1 的 part1 和 part2 字段</span></span><br><span class="line">clone1.part1 = <span class="string">"part1_clone1"</span></span><br><span class="line">clone1.part2 = <span class="number">456</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出所有对象的字段值</span></span><br><span class="line">fmt.Printf(<span class="string">"prototype: %+v %p\n"</span>, prototype, &amp;prototype)</span><br><span class="line">fmt.Printf(<span class="string">"clone1: %+v %p\n"</span>, clone1, &amp;clone1)</span><br><span class="line">fmt.Printf(<span class="string">"clone2: %+v %p\n"</span>, clone2, &amp;clone2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在克隆逻辑中它的输出是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prototype: &#123;part1:part1 part2:<span class="number">123</span>&#125; <span class="number">0xc000098420</span></span><br><span class="line">clone1: &amp;&#123;part1:part1_clone1 part2:<span class="number">456</span>&#125; <span class="number">0xc0000cc018</span></span><br><span class="line">clone2: &amp;&#123;part1:part1 part2:<span class="number">789</span>&#125; <span class="number">0xc0000cc020</span></span><br></pre></td></tr></table></figure><p>这是因为  <code>clone := *p</code>是值拷贝，这个地方容易忽略！！！，想到值拷贝，那么改成下面这样是不是也可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (p ConcretePrototype) Clone() Prototype &#123;</span><br><span class="line">return &amp;p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是 可以，输出的内容是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prototype: &#123;part1:part1 part2:<span class="number">123</span>&#125; <span class="number">0xc000004480</span></span><br><span class="line">clone1: &amp;&#123;part1:part1_clone1 part2:<span class="number">456</span>&#125; <span class="number">0xc000006028</span></span><br><span class="line">clone2: &amp;&#123;part1:part1 part2:<span class="number">789</span>&#125; <span class="number">0xc000006030</span></span><br></pre></td></tr></table></figure><p>原因是 <code>func (p ConcretePrototype) Clone() Prototype{...}</code> 其实是通过值复制一份给 <code>p</code></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>另外还可以通过序列号与反序列化实现深拷贝，不过需要考虑到序列化性能</li><li>考虑使用内存池进行对象创建</li><li>适用场景<ul><li>创建对象的过程比较复杂，需要进行多项初始化配置才能完成。</li><li>需要创建大量相似或相同的对象，并且每个对象都有不同的状态和属性。</li><li>由于某些原因，无法或不方便使用其他创建模式（如工厂方法模式、建造者模式等）来创建对象。</li><li>希望在运行时动态地生成新对象，并且能够通过克隆来获得更好的性能</li></ul></li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://lailin.xyz/post/factory.html" target="_blank" rel="noopener">https://lailin.xyz/post/factory.html</a></li><li><a href="https://github.com/senghoo/golang-design-pattern" target="_blank" rel="noopener">https://github.com/senghoo/golang-design-pattern</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;原型模式&lt;/strong&gt;是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类(&lt;strong&gt;亦称：&lt;/strong&gt; 克隆、Clone、Prototype)&lt;/p&gt;
&lt;p&gt;如果你有一个对象， 并希望生成与其完全相同的一个复制品，
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-09-桥接模式</title>
    <link href="http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-09-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-09-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-05-26T14:20:58.531Z</published>
    <updated>2023-05-26T14:24:51.382Z</updated>
    
    <content type="html"><![CDATA[<p><strong>桥接模式</strong>是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用。桥接模式类似于策略模式，区别在于策略模式封装一系列算法使得算法可以互相替换。</p><p>策略模式使抽象部分和实现部分分离，可以独立变化。</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><ol><li><p>定义实现类的接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Implementor <span class="keyword">interface</span> &#123;</span><br><span class="line">    operationImpl() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现具体的实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type ConcreteImplementorA struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (c *ConcreteImplementorA) operationImpl() string &#123;</span><br><span class="line">    return &quot;ConcreteImplementorA&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ConcreteImplementorB struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (c *ConcreteImplementorB) operationImpl() string &#123;</span><br><span class="line">    return &quot;ConcreteImplementorB&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义抽象类及其方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Abstraction <span class="keyword">struct</span> &#123;</span><br><span class="line">    implementor Implementor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Abstraction)</span> <span class="title">Operation</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.implementor.operationImpl()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现具体的抽象类</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RefinedAbstraction <span class="keyword">struct</span> &#123;</span><br><span class="line">    Abstraction</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRefinedAbstraction</span><span class="params">(implementor Implementor)</span> *<span class="title">RefinedAbstraction</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;RefinedAbstraction&#123;Abstraction&#123;implementor&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>通过以上步骤，就可以使用桥接模式了。例如使用 <code>ConcreteImplementorA</code> 类来完成某个操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">implementorA := &amp;ConcreteImplementorA&#123;&#125;</span><br><span class="line">abstractionA := NewRefinedAbstraction(implementorA)</span><br><span class="line">resultA := abstractionA.Operation() <span class="comment">// result = "ConcreteImplementorA"</span></span><br><span class="line"></span><br><span class="line">implementorB := &amp;ConcreteImplementorB&#123;&#125;</span><br><span class="line">abstractionB := NewRefinedAbstraction(implementorB)</span><br><span class="line">resultB := abstractionB.Operation() <span class="comment">// result = "ConcreteImplementorB"</span></span><br></pre></td></tr></table></figure><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><ol><li>想要拆分或重组一个具有多重功能的庞杂类(例如能与多个数据库服务器进行交互的类)，可以使用桥接模式</li><li>希望在几个独立维度上扩展一个类</li><li>需要在运行时切换不同实现方法</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li><em>开闭原则</em>。 你可以新增抽象部分和实现部分， 且它们之间不会相互影响。</li><li><em>单一职责原则</em>。 抽象部分专注于处理高层逻辑， 实现部分处理平台细节</li><li>桥接模式需要额外的工作量来设计抽象和实现部分的接口，并且增加了系统的理解难度。</li><li>如果某个类在多个维度上都有变化，那么桥接模式可能会导致类的数量急剧增加，从而增加系统的复杂度</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/bridge" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/bridge</a></li><li><a href="https://lailin.xyz/post/bridge.html" target="_blank" rel="noopener">https://lailin.xyz/post/bridge.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;桥接模式&lt;/strong&gt;是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用。桥接模式类似于策略模式，区别在于策略模式封装一系列算法使得算法可以互相替换。&lt;/p&gt;
&lt;p&gt;策略模式使抽象部分和实现
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-01-概述</title>
    <link href="http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-01-%E6%A6%82%E8%BF%B0/"/>
    <id>http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-01-%E6%A6%82%E8%BF%B0/</id>
    <published>2023-05-26T14:20:58.530Z</published>
    <updated>2023-05-26T15:05:24.049Z</updated>
    
    <content type="html"><![CDATA[<p><strong>设计模式</strong>是软件设计中常见问题的典型解决方，尝试着学习一下它到底是怎样的</p><h3 id="6大设计原则"><a class="markdownIt-Anchor" href="#6大设计原则"></a> 6大设计原则</h3><h4 id="solid-原则"><a class="markdownIt-Anchor" href="#solid-原则"></a> SOLID 原则</h4><ol><li><p>单一职责原则 (Single responsibility principle, SRP)，每个实体功能都应该专注于一件事上。同时做两件以上的事情，不但阅读性降低，出错时也更难找到问题点。另外多个职责耦合在一起，会影响复用性</p></li><li><p>开放封闭原则 (Open-Close principle, OCP)，通过<strong>增加新代码</strong>来扩展系统的功能，而不是通过<strong>修改原本已经存在的代码</strong>来扩展系统的功能。当未来需求有异动时，如果为了新需求而改动原有代码，可能会造成其他调用原本代码时发生非预期错误</p></li><li><p>里氏替换原则 (Liskov substitution principle, LSP)，任何基类可以出现的地方，子类一定可以出现(替换)。子类可以扩展父类的功能，但不能改变父类原有的功能。只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</p><blockquote><p>实现 OCP 原则的关键步骤就是抽象化，而基类与子类的继承关系是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p></blockquote></li><li><p>接口隔离原则 (Interface segregation principle, ISP)，使用多个隔离的小接口，比使用单个整合在一起的大接口要好。为了方便维护和升级已有的代码，需要尽量降低类之间的耦合度，降低依赖，降低耦合</p></li><li><p>依赖反转原则 (Dependency inversion principle, DIP)，要依赖于抽象，而不依赖于具体。即高低阶层代码都依赖一个抽象类，在抽象类中定义所依赖的方法，并由子类去实现</p></li><li><p>最少知识原则(Least knowledge principle, LKP)，实体之间的联系(通信/交流)应当尽量少。即一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。这样当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易（主要还是解耦思想)。</p></li></ol><h4 id="dry-原则"><a class="markdownIt-Anchor" href="#dry-原则"></a> DRY 原则</h4><p>Do not repeat yourself</p><h3 id="设计模式分类"><a class="markdownIt-Anchor" href="#设计模式分类"></a> 设计模式分类</h3><p>设计模式根据其目的来分类：</p><ul><li><strong>创建型模式</strong>提供创建对象的机制， 增加已有代码的灵活性和可复用性，注重如何初始化一个或一群实体</li><li><strong>结构型模式</strong>介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效，注重实体之间互相<strong>组合</strong>取代<strong>继承</strong></li><li><strong>行为模式</strong>负责对象间的高效沟通和职责委派，注重分配每个实体的功能，建立联系沟通。</li></ul><h4 id="创建型模式"><a class="markdownIt-Anchor" href="#创建型模式"></a> 创建型模式</h4><ol><li><a href="https://www.yuankang.top/2022/07/19/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">单例模式(Singleton Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/07/19/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/" target="_blank" rel="noopener">简单工厂模式(Simple Factory Pattern)</a></li><li><a href="https://www.yuankang.top/2022/07/19/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">工厂方法模式(Factory Method Pattern)</a></li><li><a href="https://www.yuankang.top/2022/07/19/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/" target="_blank" rel="noopener">抽象工厂模式(Abstract Factory)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">建造者模式(Builder Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">原型模式(Prototype Design Pattern)</a></li></ol><h4 id="结构性模式"><a class="markdownIt-Anchor" href="#结构性模式"></a> 结构性模式</h4><ol><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">代理模式(Proxy Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">桥接模式(Bridge Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">装饰器模式(Decorator Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">适配器模式(Adapter Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">门面模式(Facade Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">组合模式(Composite Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">享元模式(Flyweight Design Pattern)</a></li></ol><h4 id="行为模式"><a class="markdownIt-Anchor" href="#行为模式"></a> 行为模式</h4><ol><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">观察者模式(Observer Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">模板模式(Template Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">策略模式(Strategy Method Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">职责链模式(Chain Of Responsibility Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">状态模式(State  Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">迭代器模式(Iterator Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">访问者模式(Visitor Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">备忘录模式(Memento Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">命令模式(Command Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">解释器模式(Interpreter Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">中介模式(Mediator Design Pattern)</a></li></ol><p>其中个人觉得以下模式常见且实用，可以好好把握</p><ul><li>模板方法模式</li><li>组合模式</li><li>桥接模式</li><li>原型模式</li><li>单例模式</li><li>策略模式</li><li>职责链模式</li><li>状态模式</li><li>迭代器模式</li></ul><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://lailin.xyz/post/go-design-pattern.html" target="_blank" rel="noopener">https://lailin.xyz/post/go-design-pattern.html</a></li><li><a href="https://docs.microsoft.com/zh-cn/azure/architecture/patterns/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/azure/architecture/patterns/</a></li><li><a href="https://github.com/senghoo/golang-design-pattern" target="_blank" rel="noopener">https://github.com/senghoo/golang-design-pattern</a></li><li><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a></li><li><a href="https://github.com/idootop/Design-Patterns-Dart" target="_blank" rel="noopener">https://github.com/idootop/Design-Patterns-Dart</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;设计模式&lt;/strong&gt;是软件设计中常见问题的典型解决方，尝试着学习一下它到底是怎样的&lt;/p&gt;
&lt;h3 id=&quot;6大设计原则&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#6大设计原则&quot;&gt;&lt;/a&gt; 6大设计原则&lt;/h3&gt;
&lt;h4
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-06-建造者模式</title>
    <link href="http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-06-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2023/05/26/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-06-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-05-26T14:20:58.530Z</published>
    <updated>2023-05-26T14:20:58.530Z</updated>
    
    <content type="html"><![CDATA[<p>假设有这样一个复杂对象， 在对其进行构造时需要对诸多成员变量和嵌套对象进行繁复的初始化工作。 这些初始化代码通常深藏于一个包含众多参数且让人基本看不懂的构造函数中；甚至还有更糟糕的情况， 那就是这些代码散落在客户端代码的多个位置</p><p><strong>建造者模式</strong> 该模式允许你使用相同的创建代码生成不同类型和形式的对象</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><ol><li><p>创建一个产品类，并定义其中所需的属性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line">    part1 <span class="keyword">string</span></span><br><span class="line">    part2 <span class="keyword">string</span></span><br><span class="line">    part3 <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建一个抽象建造者接口，并定义其中需要实现的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Builder <span class="keyword">interface</span> &#123;</span><br><span class="line">    BuildPart1()</span><br><span class="line">    BuildPart2()</span><br><span class="line">    BuildPart3()</span><br><span class="line">    GetResult() *Product</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建具体的建造者结构体，并实现抽象建造者接口中的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ConcreteBuilder <span class="keyword">struct</span> &#123;</span><br><span class="line">    product *Product</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ConcreteBuilder)</span> <span class="title">BuildPart1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b.product.part1 = <span class="string">"part1"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ConcreteBuilder)</span> <span class="title">BuildPart2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b.product.part2 = <span class="string">"part2"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ConcreteBuilder)</span> <span class="title">BuildPart3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b.product.part3 = <span class="string">"part3"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ConcreteBuilder)</span> <span class="title">GetResult</span><span class="params">()</span> *<span class="title">Product</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b.product</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建指挥者结构体，并定义其中需要使用的建造者对象和建造过程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Director <span class="keyword">struct</span> &#123;</span><br><span class="line">    builder Builder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDirector</span><span class="params">(builder Builder)</span> *<span class="title">Director</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Director&#123;builder: builder&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Director)</span> <span class="title">Construct</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d.builder.BuildPart1()</span><br><span class="line">    d.builder.BuildPart2()</span><br><span class="line">    d.builder.BuildPart3()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="实际使用"><a class="markdownIt-Anchor" href="#实际使用"></a> 实际使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">product1 := NewProduct(Part1Option(<span class="string">"part1"</span>))</span><br><span class="line">product2 := NewProduct(Part2Option(<span class="string">"part2"</span>), Part3Option(<span class="string">"part3"</span>))</span><br></pre></td></tr></table></figure><h3 id="可选参数"><a class="markdownIt-Anchor" href="#可选参数"></a> 可选参数</h3><p>类似于可选参数的应用，可能更好理解，Option 是一种函数式编程技巧，这里也需要构建一个产品，并定义其中的属性</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Product 是要创建的产品结构体</span></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line">    part1 <span class="keyword">string</span></span><br><span class="line">    part2 <span class="keyword">string</span></span><br><span class="line">    part3 <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 是可选参数的类型</span></span><br><span class="line"><span class="keyword">type</span> Option <span class="function"><span class="keyword">func</span><span class="params">(*Product)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Part1Option 是 part1 字段的设置函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Part1Option</span><span class="params">(value <span class="keyword">string</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(p *Product)</span></span> &#123;</span><br><span class="line">        p.part1 = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Part2Option 是 part2 字段的设置函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Part2Option</span><span class="params">(value <span class="keyword">string</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(p *Product)</span></span> &#123;</span><br><span class="line">        p.part2 = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Part3Option 是 part3 字段的设置函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Part3Option</span><span class="params">(value <span class="keyword">string</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(p *Product)</span></span> &#123;</span><br><span class="line">        p.part3 = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewProduct 是创建 Product 的函数，通过传入可选参数并返回 Product 的指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProduct</span><span class="params">(opts ...Option)</span> *<span class="title">Product</span></span> &#123;</span><br><span class="line">    product := &amp;Product&#123;&#125;</span><br><span class="line">    <span class="comment">// 遍历所有可选参数，并逐一将其设置给 Product 结构体的字段</span></span><br><span class="line">    <span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">        opt(product)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> product</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用的时候传入需要的可选参数即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">product1 := NewProduct(Part1Option(<span class="string">"part1"</span>))</span><br><span class="line">product2 := NewProduct(Part2Option(<span class="string">"part2"</span>), Part3Option(<span class="string">"part3"</span>))</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>建造者模式适用于对象创建成本比较大需要经过复杂计算的情况</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://lailin.xyz/post/builder.html" target="_blank" rel="noopener">https://lailin.xyz/post/builder.html</a></li><li><a href="https://refactoringguru.cn/design-patterns/catalog" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/catalog</a></li><li><a href="https://github.com/senghoo/golang-design-pattern" target="_blank" rel="noopener">https://github.com/senghoo/golang-design-pattern</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假设有这样一个复杂对象， 在对其进行构造时需要对诸多成员变量和嵌套对象进行繁复的初始化工作。 这些初始化代码通常深藏于一个包含众多参数且让人基本看不懂的构造函数中；甚至还有更糟糕的情况， 那就是这些代码散落在客户端代码的多个位置&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;建造者模式&lt;/
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-04-工厂方法模式</title>
    <link href="http://xboom.github.io/2023/05/17/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-04-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2023/05/17/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-04-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-05-17T14:29:12.472Z</published>
    <updated>2023-05-17T14:29:12.472Z</updated>
    
    <content type="html"><![CDATA[<p>简单工厂模式违背的开闭原则，拓展新的产品的时候都需要修改旧的代码</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Product <span class="keyword">interface</span> &#123;</span><br><span class="line">    GetName() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产品实现</span></span><br><span class="line"><span class="keyword">type</span> ProductA <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProductA)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ProductA"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ProductB <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProductB)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ProductB"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂</span></span><br><span class="line"><span class="keyword">type</span> Factory <span class="keyword">interface</span> &#123;</span><br><span class="line">    CreateProduct() Product</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ProductAFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *ProductAFactory)</span> <span class="title">CreateProduct</span><span class="params">()</span> <span class="title">Product</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;ProductA&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ProductBFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *ProductBFactory)</span> <span class="title">CreateProduct</span><span class="params">()</span> <span class="title">Product</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;ProductB&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个用于创建对象的接口<code>Factory</code>，让子类 <code>ProductAFactory</code> 、<code>ProductBFactory</code>决定将哪一个类实例化。将实例化过程封装到子类中，符合开闭原则，有利于拓展</p><blockquote><p>工厂方法：工厂中实现的是生产(实例化)不同产品的方法</p></blockquote><h3 id="实际使用"><a class="markdownIt-Anchor" href="#实际使用"></a> 实际使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">factory1 := &amp;ProductAFactory&#123;&#125;</span><br><span class="line">product1 := factory1.CreateProduct()</span><br><span class="line">fmt.Println(product1.GetName()) <span class="comment">// Output: ProductA</span></span><br><span class="line"></span><br><span class="line">factory2 := &amp;ProductBFactory&#123;&#125;</span><br><span class="line">product2 := factory2.CreateProduct()</span><br><span class="line">fmt.Println(product2.GetName()) <span class="comment">// Output: ProductB</span></span><br></pre></td></tr></table></figure><p>跟简单工厂模式相比，完全符合开闭原则。当需要增加新的产品的时候，完全不会影响旧的逻辑</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>工厂方法相当于简单工厂模式，实际是通过将对象的创建延迟到具体的工厂类中来解决简单工厂模式的缺点</li><li>工厂方法模式完全符合开闭原则</li><li>工厂方法模式适用于类型创建比较复杂不是简单的New，将复杂的创建逻辑拆分到多个工厂类中</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://lailin.xyz/post/factory.html" target="_blank" rel="noopener">https://lailin.xyz/post/factory.html</a></li><li><a href="https://github.com/senghoo/golang-design-pattern" target="_blank" rel="noopener">https://github.com/senghoo/golang-design-pattern</a></li><li><a href="https://chat.openai.com/c/574c8562-2f17-4d1c-8a02-9d1c65f1f6c3" target="_blank" rel="noopener">https://chat.openai.com/c/574c8562-2f17-4d1c-8a02-9d1c65f1f6c3</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单工厂模式违背的开闭原则，拓展新的产品的时候都需要修改旧的代码&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#代码实现&quot;&gt;&lt;/a&gt; 代码实现&lt;/h3&gt;
&lt;figure class=&quot;highlight go&quot;&gt;
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-05-抽象工厂模式</title>
    <link href="http://xboom.github.io/2023/05/17/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-05-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2023/05/17/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-05-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-05-17T14:29:12.472Z</published>
    <updated>2023-05-17T14:29:12.472Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式分为三种更加细分的类型</p><ol><li>简单工厂(Simple Factory)</li><li>工厂方法(Factory Method)</li><li>抽象工厂(Abstract Factory)</li></ol><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品接口</span></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">interface</span> &#123;</span><br><span class="line">    Use()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A</span></span><br><span class="line"><span class="keyword">type</span> ProductA <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProductA)</span> <span class="title">Use</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Using ProductA"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B</span></span><br><span class="line"><span class="keyword">type</span> ProductB <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProductB)</span> <span class="title">Use</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Using ProductB"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂接口</span></span><br><span class="line"><span class="keyword">type</span> Factory <span class="keyword">interface</span> &#123;</span><br><span class="line">    CreateProductA() Product</span><br><span class="line">    CreateProductB() Product</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂1</span></span><br><span class="line"><span class="keyword">type</span> Factory1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Factory1)</span> <span class="title">CreateProductA</span><span class="params">()</span> <span class="title">Product</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;ProductA&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Factory1)</span> <span class="title">CreateProductB</span><span class="params">()</span> <span class="title">Product</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;ProductB&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂2</span></span><br><span class="line"><span class="keyword">type</span> Factory2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Factory2)</span> <span class="title">CreateProductA</span><span class="params">()</span> <span class="title">Product</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;ProductA&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Factory2)</span> <span class="title">CreateProductB</span><span class="params">()</span> <span class="title">Product</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;ProductB&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供一个创建一系列相关或相互依赖对象的接口 <code>Factory</code>，而无需指定它们具体的类。即通过一个工厂接口来创建一组相关联的对象，由具体的工厂 <code>Factory1</code> 、<code>Factory2</code> 实现这个接口并创建一系列相关的对象。这样做的好处是能够保证一系列对象被一起创建，并且这些对象之间相互协调</p><blockquote><p>抽象工厂：每个工厂都能产生全系列产品，这个全系列在抽象工厂接口中定义</p></blockquote><h3 id="实际使用"><a class="markdownIt-Anchor" href="#实际使用"></a> 实际使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工厂A生产</span></span><br><span class="line">factory1 := &amp;Factory1&#123;&#125;</span><br><span class="line">productA1 := factory1.CreateProductA()</span><br><span class="line">productB1 := factory1.CreateProductB()</span><br><span class="line">productA1.Use()</span><br><span class="line">productB1.Use()</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂2生产</span></span><br><span class="line">factory2 := &amp;Factory2&#123;&#125;</span><br><span class="line">productA2 := factory2.CreateProductA()</span><br><span class="line">productB2 := factory2.CreateProductB()</span><br><span class="line">productA2.Use()</span><br><span class="line">productB2.Use()</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>工厂方法与抽象工厂的区别：</p><ul><li><p>工厂方法模式（Factory Method Pattern）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。即通过一个公共的接口来创建具体的对象，由子类来实现这个接口并创建具体的对象。这样做的好处是将具体类的实例化过程封装到子类中，符合开闭原则，有利于系统的扩展。</p></li><li><p>抽象工厂模式（Abstract Factory Pattern）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。即通过一个工厂接口来创建一组相关联的对象，由具体的工厂实现这个接口并创建一系列相关的对象。这样做的好处是能够保证一系列对象被一起创建，并且这些对象之间相互协调</p></li></ul><p><strong>抽象工厂模式并没有违背开闭原则</strong>，当需要新增一族产品时，只需要<strong>扩展</strong>抽象工厂接口，并创建对应的具体工厂类来实现该接口。保证在不影响现有功能的情况下，增加新的功能(在抽象接口中新增类型不算修改…)</p><p>在实际应用中，如果需要创建一系列相关或依赖的对象，可以选择抽象工厂模式；如果需要创建单个对象，并且需要扩展性和灵活性，可以选择工厂方法模式。所以抽象工厂并不是工厂方式的优化，两者应用场景不一样</p><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://lailin.xyz/post/factory.html" target="_blank" rel="noopener">https://lailin.xyz/post/factory.html</a></li><li><a href="https://github.com/senghoo/golang-design-pattern" target="_blank" rel="noopener">https://github.com/senghoo/golang-design-pattern</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工厂模式分为三种更加细分的类型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简单工厂(Simple Factory)&lt;/li&gt;
&lt;li&gt;工厂方法(Factory Method)&lt;/li&gt;
&lt;li&gt;抽象工厂(Abstract Factory)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-03-简单工厂模式</title>
    <link href="http://xboom.github.io/2023/05/17/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-03-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2023/05/17/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-03-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-05-17T14:29:12.471Z</published>
    <updated>2023-05-17T14:29:12.471Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式分为三种更加细分的类型</p><ol><li>简单工厂(Simple Factory)</li><li>工厂方法(Factory Method)</li><li>抽象工厂(Abstract Factory)</li></ol><p>由于 Go 本身是没有构造函数的，一般采用 <code>NewName</code> 的方式创建对象/接口，当它返回的是接口的时候，其实就是简单工厂模式</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Product <span class="keyword">interface</span> &#123;</span><br><span class="line">    GetName() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ProductA <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProductA)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ProductA"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ProductB <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProductB)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ProductB"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Factory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Factory)</span> <span class="title">CreateProduct</span><span class="params">(productType <span class="keyword">string</span>)</span> <span class="title">Product</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> productType &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"ProductA"</span>:</span><br><span class="line">        <span class="keyword">return</span> &amp;ProductA&#123;&#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"ProductB"</span>:</span><br><span class="line">        <span class="keyword">return</span> &amp;ProductB&#123;&#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实际使用"><a class="markdownIt-Anchor" href="#实际使用"></a> 实际使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">factory := &amp;Factory&#123;&#125;</span><br><span class="line"></span><br><span class="line">productA := factory.CreateProduct(<span class="string">"ProductA"</span>)</span><br><span class="line">fmt.Println(productA.GetName()) <span class="comment">// Output: ProductA</span></span><br><span class="line"></span><br><span class="line">productB := factory.CreateProduct(<span class="string">"ProductB"</span>)</span><br><span class="line">fmt.Println(productB.GetName()) <span class="comment">// Output: ProductB</span></span><br></pre></td></tr></table></figure><p>根据参数的参数不同构建不同的产品对象，当增加一种产品的时候，这里就需要修改 <code>CreateProduct</code> 方法，并在使用的时候追加CreateProduct 新的类型与业务，违反了开闭原则</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>增加新的产品类型时需要修改工厂类的代码，违反了开闭原则</li><li>简单工厂模式适用于对象较少、对象类型固定的场景，可以提高对象的创建效率和统一管理对象的创建过程</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://lailin.xyz/post/factory.html" target="_blank" rel="noopener">https://lailin.xyz/post/factory.html</a></li><li><a href="https://github.com/senghoo/golang-design-pattern" target="_blank" rel="noopener">https://github.com/senghoo/golang-design-pattern</a></li><li><a href="https://chat.openai.com/c/574c8562-2f17-4d1c-8a02-9d1c65f1f6c3" target="_blank" rel="noopener">https://chat.openai.com/c/574c8562-2f17-4d1c-8a02-9d1c65f1f6c3</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工厂模式分为三种更加细分的类型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简单工厂(Simple Factory)&lt;/li&gt;
&lt;li&gt;工厂方法(Factory Method)&lt;/li&gt;
&lt;li&gt;抽象工厂(Abstract Factory)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于 Go 本身是没有
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>Go入门15-SyncMap</title>
    <link href="http://xboom.github.io/2023/04/04/Go/Go%E5%85%A5%E9%97%A815-SyncMap/"/>
    <id>http://xboom.github.io/2023/04/04/Go/Go%E5%85%A5%E9%97%A815-SyncMap/</id>
    <published>2023-04-04T13:01:05.349Z</published>
    <updated>2023-04-05T03:33:14.176Z</updated>
    
    <content type="html"><![CDATA[<p>一开始以为 <code>Sync.Map</code> 仅仅是封装的了一层，后来在与同事的讨论中发现并不是这样，这里重新学习一下源码</p><h3 id="线程安全"><a class="markdownIt-Anchor" href="#线程安全"></a> 线程安全</h3><p>首先搞清楚一个问题，什么是并发安全。由于没有完整的解释，我找了一段Java中的表达</p><blockquote><p>当多个线程访问某个类时，不管运行环境采用何种调度方式或者这些进程将如何交替执行，并且在主调代码中不需要任何额外的协同或者同步，这个类都能表现出正确的行为，那么这个类是线程安全的</p></blockquote><p>大致抓住两点 <strong>无论如何交替执行</strong> <strong>表现出正确的行为</strong>，有点抽象，反过来问 <strong>什么情况会导致线程不安全</strong>？<strong>怎样才能保证线程安全？</strong></p><p><u>当前的一个操作可能不是原子的，执行过程中会被打断，其他线程有能力修改共享变量的值，同时存在线程修改的值不是立即对其他线程可见的，因为线程有自己的执行空间，另外一点就是存在程序可能存在乱序执行的情况，单线程没问题，但是多个线程同时执行，线程共享的数据会出现错乱</u>。那么保证线程安全的三个特征：</p><ul><li><strong>原子性</strong>：提供互斥访问、同一时刻只能有一个线程在操作</li><li><strong>可见性</strong>：一个线程对主内容的修改可以及时被其他线程看到</li><li><strong>有序性</strong>：程序在执行的时候，程序的代码执行顺序和语句的顺序是一致的有序性<ul><li>多个协程并发执行，那么<strong>几个协程之间是没有有序性的</strong>，但是协程里面的代码是有序的</li><li>什么情况下代码的执行顺序与语句顺序不一致？比如指令重排序，将多次访问主存合并到一起执行</li></ul></li></ul><p>这样就好理解为啥普通的map会存在并发安全问题了，因为一个协程的修改对于另外一个协程可能是不可见的。另外当map并发读写时候触发的panic是map内部实现的，结构体的并发读写只会报错不会panic。</p><h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3><p>普通的map并发处理实践</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="keyword">struct</span>&#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)&#125;</span><br></pre></td></tr></table></figure><p>使用 sync.Map 则可以</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter sync.Map</span><br></pre></td></tr></table></figure><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>源码：<code>src/sync/map.go</code></p><p>为了实现并发安全的Map，<code>Sync.Map</code>实现了一种读写分离的方式</p><ol><li>空间换时间。 通过冗余的两个数据结构(read、dirty),实现加锁对性能的影响。</li><li>动态调整，miss次数多了之后，将dirty数据提升为read。</li><li>double-checking，因为是判断与获取并不是原子操作，所以会出现 double-checking</li><li>延迟删除。 删除一个键值只是打标记，只有在提升dirty的时候才清理删除的数据。</li><li>优先从read读取、更新、删除，因为对read的读取不需要锁。</li></ol><p><strong>问题1</strong>：如何在并发情况下修改或删除已经存在的Key？</p><p>答：通过将 key 映射到 val 的地址，然后 val 指针指向真正的值，那么只需要保证 <code>address</code> 指针的原子操作，就能解决并发安全问题</p><blockquote><p>key -&gt; &amp;地址 --&gt; 真正的值</p></blockquote><p><strong>问题2</strong>：如何在写的同时保证读的准确性</p><p>答：读写指向的是同一个指针，首先在写时会通过互斥锁防止并发操作 <code>dirty</code>，其次就是用到了<code>atomic</code>原子操作<code>value</code>指针</p><p><strong>问题3</strong>：如果读写分离，如何将写入的数据同步到读中</p><p>答： 第一种是当<code>misses == len(dirty)</code>的时候就会升级<code>dirty</code>到<code>read</code>中；第二种就是在遍历的如果<code>dirty</code>有<code>read</code>中没有的数据；</p><p>第三其实也不是读写分离，而是乐观锁，因为如果<code>read</code>中已经有key/val，也会尝试去更新<code>read</code>，发现已经删除，则去dirty中更新</p><p>最后的实现就变成了下面这个样子</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/20200505120255.png" alt="sync.map 整体结构" style="zoom:50%;" /><p><strong>问题4</strong>：指向的是同一个<code>entry</code>，不还是一样需要加锁吗？内部 的<code>mutex</code> 与 <code>atomic.pointer</code>的区别跟作用又是什么？</p><p><code>mutex</code> 与 <code>atomic</code> 的区别是：<code>mutex</code> 通过阻塞其他协程起到了原子操作的功能，是用来保护 dirty 的读写的。而<code>atomic</code>是通过CPU指令，来达到值操作的原子性，所以 <code>atomic</code>与<code>mutex</code>并不是一个层面的东西，<code>atomic</code>也比<code>mutex</code>更快。</p><p>所以才会出现 <code>mutex</code> 保护的是 <code>dirty</code>，而 <code>atomic</code> 保护的是 <code>entry</code> 具体值</p><h4 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h4><p>定义的 <code>Map</code> 中 除普通的map 与 互斥锁，还增加了两个字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">//当涉及到dirty的操作的时候，需要使用这个锁</span></span><br><span class="line">   mu Mutex</span><br><span class="line">  <span class="comment">// 一个只读结构(实际也会更新这个数据的entries，标记为未删除的unexpunger)</span></span><br><span class="line">   read atomic.Pointer[readOnly]</span><br><span class="line">  <span class="comment">// dirty包含最新的entries(包括read中未删除的数据,虽有冗余，但也提升dirty字段为read的时候非常快，不用一个一个的复制，而是直接将这个数据结构作为read字段的一部分),有些数据还可能没有移动到read字段中。</span></span><br><span class="line"><span class="comment">// 对于dirty的操作需要加锁，因为对它的操作可能会有读写竞争。</span></span><br><span class="line"><span class="comment">// 当dirty为空的时候， 比如初始化或者刚提升完，下一次的写操作会复制read字段中未删除的数据到这个数据中。</span></span><br><span class="line">   dirty <span class="keyword">map</span>[any]*entry</span><br><span class="line">  <span class="comment">// 当从Map中读取entry的时候，如果read中不包含这个entry,会尝试从dirty中读取，这个时候会将misses加一，</span></span><br><span class="line"><span class="comment">// 当misses累积到 dirty的长度的时候， 就会将dirty提升为read,避免从dirty中miss太多次。因为操作dirty需要加锁</span></span><br><span class="line">   misses <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中存在两个结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">m       <span class="keyword">map</span>[any]*entry</span><br><span class="line">amended <span class="keyword">bool</span> <span class="comment">// 如果Map.dirty有些数据不在中的时候，这个值为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基本"><a class="markdownIt-Anchor" href="#基本"></a> 基本</h4><ol><li><code>read</code> 与 <code>dirty</code> 的转换</li><li><code>entry</code>的操作</li></ol><h5 id="entry"><a class="markdownIt-Anchor" href="#entry"></a> entry</h5><p><code>entry</code> 代表的是每个 key 在<code>Map</code>中对应的一个 <code>entry</code>，并且还记录了 <strong>其他信息</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">p atomic.Pointer[any]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> expunged = <span class="built_in">new</span>(any) <span class="comment">//</span></span><br></pre></td></tr></table></figure><p><code>p</code> 一共记录林 <code>entry</code> 的三种状态</p><ol><li><code>nil</code>: <code>entry</code>已被删除了，并且<code>m.dirty</code>为<code>nil</code></li><li><code>expunged</code>: <code>entry</code>已被删除了，并且<code>m.dirty</code>不为<code>nil</code>，而且这个<code>entry</code>不存在于<code>m.dirty</code>中</li><li>其它： <code>entry</code>是一个正常的值</li></ol><p>构建一个 <code>entry</code> 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newEntry</span><span class="params">(i any)</span> *<span class="title">entry</span></span> &#123;</span><br><span class="line">   e := &amp;entry&#123;&#125;</span><br><span class="line">   e.p.Store(&amp;i)</span><br><span class="line">   <span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">load</span><span class="params">()</span> <span class="params">(value any, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">p := e.p.Load()</span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;<span class="comment">//表示不存在</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *p, <span class="literal">true</span><span class="comment">//表示存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>entry</code> 使用 <code>atomic.Pointer[n]</code> 的作用在后面才体现出来, <code>atomic.Pointer</code> 原子地读取和存储指针类型的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">trySwap</span><span class="params">(i *any)</span> <span class="params">(*any, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      p := e.p.Load()</span><br><span class="line">      <span class="keyword">if</span> p == expunged &#123;<span class="comment">//如果已经被删除则返回false</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> e.p.CompareAndSwap(p, i) &#123;<span class="comment">//否则不断的CAS更新</span></span><br><span class="line">         <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h4><p>操作与正常的map类似，包含 存储、获取、删除、遍历。除此之外还增加的 交换、比较交换、比较删除</p><h5 id="获取"><a class="markdownIt-Anchor" href="#获取"></a> 获取</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Load</span><span class="params">(key any)</span> <span class="params">(value any, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1.首先从m.read中得到只读readOnly,从它的map中查找，不需要加锁</span></span><br><span class="line">  read := m.loadReadOnly()</span><br><span class="line">e, ok := read.m[key]</span><br><span class="line">  <span class="comment">//2. 如果没找到，并且m.dirty中有新数据，需要从m.dirty查找，这个时候需要加锁</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123; <span class="comment">// a 操作</span></span><br><span class="line">m.mu.Lock()  <span class="comment">//b 操作</span></span><br><span class="line">    <span class="comment">//双检查，避免加锁的时候m.dirty提升为m.read,这个时候m.read可能被替换了。</span></span><br><span class="line">read = m.loadReadOnly()</span><br><span class="line">e, ok = read.m[key]</span><br><span class="line">    <span class="comment">// 如果m.read中还是不存在，并且m.dirty中有新数据</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">      <span class="comment">// 从m.dirty查找</span></span><br><span class="line">e, ok = m.dirty[key]</span><br><span class="line">      <span class="comment">// 不管m.dirty中存不存在，都将misses计数加一</span></span><br><span class="line"><span class="comment">// missLocked()中满足条件后就会提升m.dirty</span></span><br><span class="line">m.missLocked()</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个注意事项</p><ol><li><p>出现double-check，是因为在执行 <code>if !ok &amp;&amp; read.amended</code> 的过程中，dirty可能升级为read，所以还是需要锁操作</p></li><li><p>不管 m.dirty中是否存在，都需要misses+1，表明 read中不存在才到 dirty中获取</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">missLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">m.misses++</span><br><span class="line"><span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">m.read.Store(&amp;readOnly&#123;m: m.dirty&#125;)<span class="comment">//直接将dirty升级到read中，然后</span></span><br><span class="line">m.dirty = <span class="literal">nil</span></span><br><span class="line">m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>什么时候讲dirty提升为 read，当 <code>misses &gt;= len(m.dirty)</code></p><h5 id="存储"><a class="markdownIt-Anchor" href="#存储"></a> 存储</h5><p>从接口实现可以看出，存储 k/v 内部使用的其实 Swap 接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Store</span><span class="params">(key, value any)</span></span> &#123;</span><br><span class="line">   _, _ = m.Swap(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接查看 <code>Swap</code> 的实现原理</p><p>根据描述，<code>Swap</code> 的作用是 将 <code>newValue</code> 更新入 <code>key</code> 所对应的 <code>value</code>中，并将 <code>oldValue</code> 返回。另外一个返回值<code>loaded</code>表示 <code>key</code> 是否存在</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Swap</span><span class="params">(key, value any)</span> <span class="params">(previous any, loaded <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 如果m.read存在这个键，并且这个entry没有被标记删除，尝试直接存储。</span></span><br><span class="line"><span class="comment">// 因为m.dirty也指向这个entry,所以m.dirty也保持最新的entry。</span></span><br><span class="line">   read := m.loadReadOnly()</span><br><span class="line">   <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;<span class="comment">//如果只读存在</span></span><br><span class="line">      <span class="keyword">if</span> v, ok := e.trySwap(&amp;value); ok &#123;<span class="comment">//尝试去更新value，如果未 标记删除</span></span><br><span class="line">         <span class="keyword">if</span> v == <span class="literal">nil</span> &#123;<span class="comment">//value为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> *v, <span class="literal">true</span><span class="comment">//更新成功 返回 true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   m.mu.Lock()<span class="comment">// 加锁，如果`m.read`不存在或者已经被标记删除</span></span><br><span class="line">   read = m.loadReadOnly()</span><br><span class="line">   <span class="keyword">if</span> e, ok := read.m[key]; ok &#123; <span class="comment">//只读存在</span></span><br><span class="line">     <span class="keyword">if</span> e.unexpungeLocked() &#123;<span class="comment">//如果未标记删除则删除read,然后存入dirty(写数据到dirty中)</span></span><br><span class="line">         m.dirty[key] = e<span class="comment">//存入 dirty</span></span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">if</span> v := e.swapLocked(&amp;value); v != <span class="literal">nil</span> &#123;<span class="comment">//未标记删除则直接更新read</span></span><br><span class="line">         loaded = <span class="literal">true</span></span><br><span class="line">         previous = *v</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;<span class="comment">//只读不存在但是dirty存在</span></span><br><span class="line">      <span class="keyword">if</span> v := e.swapLocked(&amp;value); v != <span class="literal">nil</span> &#123;</span><br><span class="line">         loaded = <span class="literal">true</span></span><br><span class="line">         previous = *v</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;<span class="comment">//都不存在</span></span><br><span class="line">      <span class="keyword">if</span> !read.amended &#123;<span class="comment">//dirty中没有新值</span></span><br><span class="line">         m.dirtyLocked()<span class="comment">//如果dirty为空，从 m.read中复制未删除的数据</span></span><br><span class="line">         m.read.Store(&amp;readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;) <span class="comment">//read中存储</span></span><br><span class="line">      &#125;</span><br><span class="line">      m.dirty[key] = newEntry(value)<span class="comment">//dirty 存储一个新的 value地址</span></span><br><span class="line">   &#125;</span><br><span class="line">   m.mu.Unlock()</span><br><span class="line">   <span class="keyword">return</span> previous, loaded</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>dirtyLocked的</code>作用是将未删除的复制到<code>dirty</code>中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">dirtyLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;<span class="comment">//如果不为空直接返回</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   read := m.loadReadOnly()</span><br><span class="line">   m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[any]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line">   <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">      <span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">         m.dirty[k] = e</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">tryExpungeLocked</span><span class="params">()</span> <span class="params">(isExpunged <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   p := e.p.Load()<span class="comment">//加载entry中的地址</span></span><br><span class="line">   <span class="keyword">for</span> p == <span class="literal">nil</span> &#123;<span class="comment">//如果为空</span></span><br><span class="line">      <span class="keyword">if</span> e.p.CompareAndSwap(<span class="literal">nil</span>, expunged) &#123;<span class="comment">//尝试使用 expunged更新状态</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      p = e.p.Load()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> p == expunged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Delete</span><span class="params">(key any)</span></span> &#123;</span><br><span class="line">m.LoadAndDelete(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">LoadAndDelete</span><span class="params">(key any)</span> <span class="params">(value any, loaded <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//先从read中加载</span></span><br><span class="line">read := m.loadReadOnly()</span><br><span class="line">e, ok := read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;<span class="comment">//read没有且dirty中有新数据</span></span><br><span class="line">    <span class="comment">//开启锁</span></span><br><span class="line">m.mu.Lock()</span><br><span class="line">read = m.loadReadOnly()</span><br><span class="line">e, ok = read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;<span class="comment">//如果read没有，则dirty中有新数据</span></span><br><span class="line">e, ok = m.dirty[key]</span><br><span class="line"><span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">      m.missLocked()<span class="comment">//当misses数量达到 len(m.dirty),dirty升级为read</span></span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">return</span> e.<span class="built_in">delete</span>()<span class="comment">//如果read存在则标记删除</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果read中存在，那么仅会标记删除</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">delete</span><span class="params">()</span> <span class="params">(value any, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      p := e.p.Load()</span><br><span class="line">      <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;<span class="comment">//如果为空或者标记删除，返回没有数据</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> e.p.CompareAndSwap(p, <span class="literal">nil</span>) &#123;<span class="comment">//标记为nil，并不会直接删除</span></span><br><span class="line">         <span class="keyword">return</span> *p, <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遍历"><a class="markdownIt-Anchor" href="#遍历"></a> 遍历</h5><p>因为是读写分离，所以在遍历的过程中</p><ol><li>如果dirty中没有新数据，那么就使用read遍历</li><li>如果dirty中有新数据，那么就将dirty升级为read，然后遍历read</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Range</span><span class="params">(f <span class="keyword">func</span>(key, value any)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">   <span class="comment">//判断dirty是否有新值</span></span><br><span class="line">   read := m.loadReadOnly()</span><br><span class="line">   <span class="keyword">if</span> read.amended &#123;</span><br><span class="line">      m.mu.Lock()<span class="comment">//开锁</span></span><br><span class="line">      read = m.loadReadOnly()</span><br><span class="line">      <span class="keyword">if</span> read.amended &#123;<span class="comment">//dirty是否有新值</span></span><br><span class="line">         read = readOnly&#123;m: m.dirty&#125;</span><br><span class="line">         m.read.Store(&amp;read)<span class="comment">//升级dirty为read</span></span><br><span class="line">         m.dirty = <span class="literal">nil</span></span><br><span class="line">         m.misses = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">      m.mu.Unlock()</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//遍历read</span></span><br><span class="line">   <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">      v, ok := e.load()</span><br><span class="line">      <span class="keyword">if</span> !ok &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> !f(k, v) &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3><ol><li><p>该map仅针对特定的场景</p><ul><li>Key 读多写少的情况，例如只增长的缓存</li><li>多个协程针对不同的key合集进行读写更新时候可以用</li><li>sync.Map 不能在第一次使用后复制</li></ul></li><li><p>由于dirty达到一定条件就需要升级为read，所以适用读多写少的场景</p></li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://www.cnblogs.com/qcrao-2018/p/12833787.html" target="_blank" rel="noopener">https://www.cnblogs.com/qcrao-2018/p/12833787.html</a></li><li><a href="https://colobu.com/2017/07/11/dive-into-sync-Map/#sync-Map%E7%9A%84%E6%80%A7%E8%83%BD" target="_blank" rel="noopener">https://colobu.com/2017/07/11/dive-into-sync-Map/#sync-Map的性能</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一开始以为 &lt;code&gt;Sync.Map&lt;/code&gt; 仅仅是封装的了一层，后来在与同事的讨论中发现并不是这样，这里重新学习一下源码&lt;/p&gt;
&lt;h3 id=&quot;线程安全&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线程安全&quot;&gt;&lt;/a&gt; 线程安全&lt;
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go入门24-协程池问题</title>
    <link href="http://xboom.github.io/2023/03/05/Go/Go%E5%85%A5%E9%97%A824-%E5%8D%8F%E7%A8%8B%E6%B1%A0%E9%97%AE%E9%A2%98/"/>
    <id>http://xboom.github.io/2023/03/05/Go/Go%E5%85%A5%E9%97%A824-%E5%8D%8F%E7%A8%8B%E6%B1%A0%E9%97%AE%E9%A2%98/</id>
    <published>2023-03-05T06:46:45.000Z</published>
    <updated>2023-04-05T04:17:47.389Z</updated>
    
    <content type="html"><![CDATA[<p>之前在整理 <a href="https://www.yuankang.top/2022/07/06/GoZero/GoZero4-%E5%8D%8F%E7%A8%8B%E6%B1%A01/" target="_blank" rel="noopener">GoZero4-协程池</a>的过程中发现 <a href="https://github.com/bytedance/gopkg/tree/develop/util/gopool" target="_blank" rel="noopener">字节跳动开源的协程池</a>在使用中需要注意的地方：</p><p>​<strong>使用双向链表存储任务，表示它理论上支持无限个任务。后面的任务可能存在长时间等待的情况，并不存在任务过期处理逻辑</strong></p><p>没想到在实际应用中真的没注意踩了一遍，这里记录一下这个原因与后续的解决思路，排查过程就不赘述了。</p><p>伪代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Send</span><span class="params">(conn *grpc.ClientConn)</span></span> &#123;</span><br><span class="line">c := pb.NewGreeterClient(conn)</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">3</span>*time.Second)</span><br><span class="line"></span><br><span class="line">gopool.CtxGo(ctx, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="comment">//1. 通信消息自定义处理</span></span><br><span class="line">Handle(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 发送消息</span></span><br><span class="line">_, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: *name&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"could not greet: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="comment">//log.Printf("end success")</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">5</span>):</span><br><span class="line">log.Printf(<span class="string">"time out"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题原因</strong>：负责底层通信的 grpc-go(进行过二次开发) 使用了上述的协程池进行发送接口的超时控制。当突然大量的消息进入，消息接受速率 大于 消息发送-响应速率。导致过量的消息全部堆积到这个双向链表中，而本身消息是有超时时间的，就导致堆积的消息越来越多，消息等到发送的时候已经超时了，所以就出现了服务OOM，消息也无法发送出去。</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/%E5%8D%8F%E7%A8%8B%E6%B1%A0%E9%97%AE%E9%A2%982.png" alt="协程池问题2" style="zoom:50%;" /><p>类似上图所示，模拟客户端通过协程池的发送协程 <strong>work</strong> 实现超时控制消息任务 <strong>t</strong> 的发送</p><ul><li>第一阶段，发送协程 <strong>work</strong> 的消费速率 大于 消息任务 <strong>t</strong> 的生产速率，一切正常</li><li>第二阶段，发送协程 <strong>work</strong> 的消费速率 小于 消息任务 <strong>t</strong> 的生产速率的时候，消息开始在双向链表中堆积，出现内存快速增长</li><li>第三阶段，当 消息任务 <strong>t</strong> 的堆积 超过自定义超时时间的时候，所有消息都发送超时失败</li><li>第四阶段，当 双向链表中的任务堆积导致内存超时服务上限的时候，服务OOM</li></ul><p>这里产生了如下几个思考</p><ol><li>能否在任务双向链表中限制数量大小当发送超过限制的时候直接失败?</li><li>为什么不直接使用管道来代替底层的双向链表？</li><li>能否自动丢弃超时的消息并返回结果，注意这个时候是在协程里面运行的</li><li>如何像linux一样保存 pod因为OOM而产生的core方便后续分析</li></ol><p>第一个问题是可以解决的，协程池对象存在 taskCount 记录当前任务数量，也就是说可以增加协程池容量判断来达到限制目的</p><ul><li>增加协程池任务容量字段 <code>taskCap</code></li><li>增加接口，协程失败返回错误 error</li><li>添加协程池容量判断</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pool)</span> <span class="title">CtxGo2</span><span class="params">(ctx context.Context, f <span class="keyword">func</span>()</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">  cur := atomic.AddInt32(&amp;p.taskCount, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> cur &gt; p.taskCap &#123;<span class="comment">//当前任务容量判断</span></span><br><span class="line"><span class="keyword">return</span> errors.New</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个问题管道的缺点是管道数量是固定的，也就是达不到根据任务数量动态扩容 <code>work</code> 的功效</p><p>第三个问题由于任务放入协程中相当于异步处理，并不能直接将任务待执行超时的情况返回给客户端，可以通过自定义处理函数或者内部的panic处理任务超时的情况；但又能如何发现任务超时，时间轮貌似是个好东西</p><p>第四个问题找到<a href="https://juejin.cn/post/6844903792136159239" target="_blank" rel="noopener">一篇实践</a>，实操之后再单独记录</p><p>总结：</p><ol><li>我在使用过程中忽视了双向队列任务堆积的情况，令牌桶的使用也可能存在这样的情况(正常情况不会配置速率上千万的情况)，注意异常情况下的配置范围</li><li>上述需要改进与实操的部分尝试解决之后再来补充这边文章</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在整理 &lt;a href=&quot;https://www.yuankang.top/2022/07/06/GoZero/GoZero4-%E5%8D%8F%E7%A8%8B%E6%B1%A01/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GoZero4-协
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>算法-E10C-最大公约数</title>
    <link href="http://xboom.github.io/2023/02/02/Algorithms%20To%20Live%20By/%E7%AE%97%E6%B3%95-E10C-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"/>
    <id>http://xboom.github.io/2023/02/02/Algorithms%20To%20Live%20By/%E7%AE%97%E6%B3%95-E10C-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</id>
    <published>2023-02-02T12:25:25.494Z</published>
    <updated>2023-02-15T13:39:32.337Z</updated>
    
    <content type="html"><![CDATA[<p>今天碰到一道有意思的题目，学到了很多东西，所以记录一下</p><p><a href="https://leetcode.cn/problems/check-if-it-is-a-good-array/" target="_blank" rel="noopener">检查好数组</a></p><p>碰到之后完全不知道如何入手，最后通过看解答才弄明白，但是中间有很多知识点可以记录一下</p><p><strong>首先</strong> 需要知道裴蜀定理，又称贝祖定理，是一个最大公约数定理：设 a, b 是不全为零的整数，则存在整数 x , y , 使得</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ax + by = gcd(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span></p><ol><li><p>若任何一个等于0，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">gcd(a, b) == a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span></p></li><li><p>对任何整数a、b和它们的最大公约数d，关于未知数x和y的线性丢番图方程</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">ax + by = m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span></span></p><p>有解当前仅当 m 是 d 的倍数</p></li></ol><blockquote><p>这里有一个奇特的点 0 因为没有因数，所以 0 不与其他数存在最大公约数，等我看了 类欧几里德算法 再补充</p></blockquote><p>所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ax + by = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 有解，那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(a, b) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><p>其次 我们如何求一个两个数的最大公约数，经典的 <strong>辗转相除法</strong>(又称 <strong>欧几里德算法</strong>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以使用现有函数 gcd(a, b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b ? GCD(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>证明 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a, b) = gcd(b, a \% b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 过程如下</p><ol><li><p>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi><mi>k</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a = bk + c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>，所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">c = a \% b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span></span></span></span></p></li><li><p>设 d 是 a , b 的公约数</p></li><li><p>所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>=</mo><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>∗</mo><mi>k</mi><mo>+</mo><mi>c</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">a / d = b / d * k + c / d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span></p></li><li><p>因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">a / d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">b / d * k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 是整数，所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">c / d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span> 也是整数</p></li><li><p>将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">c = a \% b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span></span></span></span> 带入第3步得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>−</mo><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>∗</mo><mi>k</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">a / d - b / d * k = a \% b / d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span>，因为 左边是整数，所有等式右边也是整数</p></li><li><p>那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>+</mo><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">a / d = a \% b / d + b / d * k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，那么 d 也是  b, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">a \% b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span></span></span></span> 的约数，也是 a, b 的约数</p></li><li><p>尽然两式的公约数是相同的，那么最大公约数也会相同</p></li><li><p>所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a, b) = gcd(b, a mod b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p></li></ol><p>最后就是这个题目的解答</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b ? Gcd(b, a % b) : a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isGoodArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//1与任意正整数的最大公约数是1</span></span><br><span class="line">            v = Gcd(nums[i], v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://oi-wiki.org/math/number-theory/gcd/" target="_blank" rel="noopener">https://oi-wiki.org/math/number-theory/gcd/</a></li><li><a href="https://leetcode.cn/problems/check-if-it-is-a-good-array/" target="_blank" rel="noopener">https://leetcode.cn/problems/check-if-it-is-a-good-array/</a></li><li><a href="https://oi-wiki.org/math/number-theory/bezouts/" target="_blank" rel="noopener">https://oi-wiki.org/math/number-theory/bezouts/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天碰到一道有意思的题目，学到了很多东西，所以记录一下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/check-if-it-is-a-good-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;检查好
      
    
    </summary>
    
    
      <category term="Algorithms To Live By" scheme="http://xboom.github.io/categories/Algorithms-To-Live-By/"/>
    
    
      <category term="Algorithms To Live By" scheme="http://xboom.github.io/tags/Algorithms-To-Live-By/"/>
    
  </entry>
  
  <entry>
    <title>Go入门23-arena</title>
    <link href="http://xboom.github.io/2023/01/10/Go/Go%E5%85%A5%E9%97%A823-arena/"/>
    <id>http://xboom.github.io/2023/01/10/Go/Go%E5%85%A5%E9%97%A823-arena/</id>
    <published>2023-01-10T08:00:20.000Z</published>
    <updated>2023-04-05T04:17:42.941Z</updated>
    
    <content type="html"><![CDATA[<p>最近 <code>Go1.20</code> 更新，中间讲到了一个特性 <code>arena</code> ，这里看看加入 <code>arena</code> 的作用</p><blockquote><p>在Go的内存管理中，<code>arena</code> 其实就是所谓的堆区，然后将这个区域分割成 <code>8KB</code> 大小的页，组合起来称为 <code>mspan</code>，<code>mspan</code>就是Go中内存管理的基本单元，是由一片连续的 8KB 的页组成的大块内存。其实 <code>mspan</code> 是一个包含起始地址、规格、页的数量等内容的双端链表</p></blockquote><p>虽然 Go 的垃圾回收机制能够正常的进行内存管理，但是存在以下问题</p><ol><li>垃圾回收机制需要花费大量CPU进行垃圾回收操作</li><li>垃圾回收机制有一定的延迟性，导致花费的内存比实际的内存要大</li></ol><p>而 <code>arena</code> 的优势 <strong>允许从连续的内存空间中分配对象并一次性进行释放</strong></p><p>注意：在 <a href="https://github.com/golang/go/issues/51317" target="_blank" rel="noopener">github arena 的话题</a>中，有一个最新的笔记提醒, 即处在测试阶段的 arena 功能随时可能被去除掉</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Note, 2023-01-17. This proposal is on hold indefinitely due to serious API concerns. The GOEXPERIMENT=arena code may be changed incompatibly or removed at any time, and we do not recommend its use in production.</span><br></pre></td></tr></table></figure><p>带着问题看世界：</p><ol><li>它跟内存池的区别</li><li>由于需要连续的内存空间，那么当需要分配的内存比较多，没有这么大的连续内存空间怎么办？</li><li>如果它分配的对象有一部分存在内存逃逸，那么该如何处理？</li><li>能支持并发吗</li></ol><h3 id="基础功能"><a class="markdownIt-Anchor" href="#基础功能"></a> 基础功能</h3><p>由于是实验功能，所以需要配置环境变量 <code>GOEXPERIMENT=arenas</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"arena"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;</span><br><span class="line">Foo <span class="keyword">string</span></span><br><span class="line">Bar [<span class="number">16</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processRequest</span><span class="params">(req *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// Create an arena in the beginning of the function.</span></span><br><span class="line">mem := arena.NewArena()</span><br><span class="line"><span class="comment">// Free the arena in the end.</span></span><br><span class="line"><span class="keyword">defer</span> mem.Free()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a bunch of objects from the arena.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">obj := arena.New[T](mem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or a slice with length and capacity.</span></span><br><span class="line">slice := arena.MakeSlice[T](mem, <span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想在arena释放时候继续使用它分配的对象，则可以通过 Clone 从堆中浅拷贝一个对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj1 := arena.New[T](mem) <span class="comment">// arena-allocated</span></span><br><span class="line">obj2 := arena.Clone(obj1) <span class="comment">// heap-allocated</span></span><br><span class="line">fmt.Println(obj2 == obj1) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">mem.Free()</span><br></pre></td></tr></table></figure><p>其他接口包括</p><ul><li><code>NewArena</code>：创建一个新的 arena 内存空间。</li><li><code>Free</code>：释放 arena 及其关联对象。</li><li><code>New</code>：基于 arena，创建新对象。</li><li><code>MakeSlice</code>：基于 arena，创建新切片。</li><li><code>Clone</code>：克隆一个 arena 的对象，并移动到内存堆上。<strong>只能是指针、slice或者字符串</strong></li></ul><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>代码路径：</p><ol><li><code>src/runtime/arena.go</code></li><li><code>src/arena/arena.go</code></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arena 表示多个Go一起分配与释放的内存集合，当其中的对象不在被引用那么将会自动释放</span></span><br><span class="line"><span class="keyword">type</span> Arena <span class="keyword">struct</span> &#123;</span><br><span class="line">a unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewArena allocates a new arena.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewArena</span><span class="params">()</span> *<span class="title">Arena</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Arena&#123;a: runtime_arena_newArena()&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据描述这里注意点有两个：</p><ol><li>arena 分配的对象需要及时释放</li><li>既然是自动释放，然后在使用中 <code>defer arena.Free()</code> 可以任务是，不用等到二次垃圾回收，直接将资源释放，并将可重复使用的mspan放入<code>reused</code>中</li></ol><p>查看Arena 内部结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> userArena <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 表示一系列没有足够空心内存的 mspan,当arena被释放他们也会被释放</span></span><br><span class="line">fullList *mspan  <span class="comment">//内存组件 mspan</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 未满的mspan</span></span><br><span class="line">active *mspan   </span><br><span class="line"></span><br><span class="line">  <span class="comment">//arena 对象引用报活</span></span><br><span class="line">refs []unsafe.Pointer</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果arena被释放，那么 defunct=true,避免重复释放</span></span><br><span class="line">defunct atomic.Bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Arena 如果重复释放也没有关系，判断释放过则直接结束</li></ul><p>**第一步：**分配一个 <code>Arena</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newUserArena creates a new userArena ready to be used.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newUserArena</span><span class="params">()</span> *<span class="title">userArena</span></span> &#123;</span><br><span class="line">a := <span class="built_in">new</span>(userArena)</span><br><span class="line">SetFinalizer(a, <span class="function"><span class="keyword">func</span><span class="params">(a *userArena)</span></span> &#123; <span class="comment">//g</span></span><br><span class="line"><span class="comment">// If arena handle is dropped without being freed, then call</span></span><br><span class="line"><span class="comment">// free on the arena, so the arena chunks are never reclaimed</span></span><br><span class="line"><span class="comment">// by the garbage collector.</span></span><br><span class="line">a.free()</span><br><span class="line">&#125;)</span><br><span class="line">a.refill()</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *userArena)</span> <span class="title">refill</span><span class="params">()</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line"><span class="comment">// If there's an active chunk, assume it's full.</span></span><br><span class="line">s := a.active</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the partially-used list.</span></span><br><span class="line">lock(&amp;userArenaState.lock)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(userArenaState.reuse) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">//当前存在可重用的就使用重用的</span></span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;userArenaState.lock)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Allocate a new one. 否则分配一个新的mspan</span></span><br><span class="line">x, s = newUserArenaChunk()</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"out of memory"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a.refs = <span class="built_in">append</span>(a.refs, x)<span class="comment">//记录mspan.base()，报活mspan</span></span><br><span class="line">a.active = s<span class="comment">//记录当前使用的mspan</span></span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>SetFinalizer</code> 函数可参考<a href="https://www.yuankang.top/2023/01/04/Go/Go%E5%85%A5%E9%97%A821-SetFinalizer/" target="_blank" rel="noopener">文章</a>，当gc检测到unreachable对象有关联的SetFinalizer函数时，会执行关联的SetFinalizer函数， 同时取消关联。 这样当下一次gc的时候，对象重新处于unreachable状态并且没有SetFinalizer关联， 就会被回收。</li></ul><p>**第二步：**从 arena 中分配具体类型的对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *userArena)</span> <span class="title">refill</span><span class="params">()</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line"><span class="comment">// If there's an active chunk, assume it's full.</span></span><br><span class="line">s := a.active<span class="comment">//上次分配了mspan</span></span><br><span class="line"><span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> s.userArenaChunkFree.size() &gt; userArenaChunkMaxAllocBytes &#123;</span><br><span class="line"><span class="comment">// It's difficult to tell when we're actually out of memory</span></span><br><span class="line"><span class="comment">// in a chunk because the allocation that failed may still leave</span></span><br><span class="line"><span class="comment">// some free space available. However, that amount of free space</span></span><br><span class="line"><span class="comment">// should never exceed the maximum allocation size.</span></span><br><span class="line">throw(<span class="string">"wasted too much memory in an arena chunk"</span>)</span><br><span class="line">&#125;</span><br><span class="line">s.next = a.fullList <span class="comment">//将这个mspan放到fullList的链表头部</span></span><br><span class="line">a.fullList = s</span><br><span class="line">a.active = <span class="literal">nil</span><span class="comment">//active置为空</span></span><br><span class="line">s = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the partially-used list.</span></span><br><span class="line">lock(&amp;userArenaState.lock)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(userArenaState.reuse) &gt; <span class="number">0</span> &#123;<span class="comment">//</span></span><br><span class="line"><span class="comment">//如果有可以重用的mspan则放到s中</span></span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;userArenaState.lock)</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Allocate a new one.</span></span><br><span class="line">x, s = newUserArenaChunk()<span class="comment">//否则新分配一个新的</span></span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"out of memory"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a.refs = <span class="built_in">append</span>(a.refs, x)</span><br><span class="line">a.active = s</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**第三步：**释放的核心是这块代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s := a.fullList<span class="comment">//获取这个mspan</span></span><br><span class="line">i := <span class="built_in">len</span>(a.refs) - <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> s != <span class="literal">nil</span> &#123;<span class="comment">//不为空</span></span><br><span class="line">  a.fullList = s.next<span class="comment">//指向下一个节点</span></span><br><span class="line">  s.next = <span class="literal">nil</span></span><br><span class="line">  freeUserArenaChunk(s, a.refs[i])<span class="comment">//释放这个mspan</span></span><br><span class="line">  s = a.fullList<span class="comment">//指向下一个节点</span></span><br><span class="line">  i--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>释放的时候仅仅是将fullList中所有的都释放掉了，而active中的则会进去到全局reuse对象中用于下次使用</li></ul><p>这个全局变量就是 <code>userArenaState</code> 用于存放可重复使用的mspan以及回收的mspan</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> userArenaState <span class="keyword">struct</span> &#123;</span><br><span class="line">lock mutex</span><br><span class="line"></span><br><span class="line">  <span class="comment">//可重复使用</span></span><br><span class="line">reuse []liveUserArenaChunk</span><br><span class="line"></span><br><span class="line">  <span class="comment">//回收释放的</span></span><br><span class="line">fault []liveUserArenaChunk</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对比syncpool"><a class="markdownIt-Anchor" href="#对比syncpool"></a> 对比Sync.Pool</h3><p>arena 与 Sync.Pool 同样都是为了解决频繁分配对象和大量对象GC带来的开销</p><p><code>Sync.Pool</code>相同类型的对象，使用完后暂时缓存不GC，下次再有相同的对象分配时直接用之前的缓存的对象，避免频繁创建大量对象。不承诺这些缓存对象的生命周期，GC时会释放之前的缓存，适合解决频繁创建相同对象带来的压力，短时间(两次GC之间)大量创建可能还是会有较大冲击，使用相对简单，但只能用于相同结构创建，不能创建slice等复杂结构</p><p><code>arena</code>手动管理连续内容并统一释放，对象的生命周期完全自己控制，使用相对复杂，支持slice等复杂结构，也不是一个真正意义的连续超大空间，而是通过管理不同的mspan实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"arena"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyObj <span class="keyword">struct</span> &#123;</span><br><span class="line">Index <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkCreateObj</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *MyObj</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++ &#123;</span><br><span class="line">p = <span class="built_in">new</span>(MyObj)</span><br><span class="line">p.Index = j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">objPool = sync.Pool&#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;MyObj&#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkCreateObj_SyncPool</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *MyObj</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++ &#123;</span><br><span class="line">p = objPool.Get().(*MyObj)</span><br><span class="line">p.Index = <span class="number">23</span></span><br><span class="line">objPool.Put(p)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkCreateObj_Arena</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *MyObj</span><br><span class="line"></span><br><span class="line">a := arena.NewArena()</span><br><span class="line"><span class="keyword">defer</span> a.Free()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++ &#123;</span><br><span class="line">p = arena.New[MyObj](a)</span><br><span class="line">p.Index = <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性能对比的结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cpu: Intel(R) Core(TM) i7-8559U CPU @ 2.70GHz</span><br><span class="line">BenchmarkCreateObj-8                      100518             11370 ns/op            8000 B/op       1000 allocs/op</span><br><span class="line">BenchmarkCreateObj_SyncPool-8             110017             11523 ns/op               0 B/op          0 allocs/op</span><br><span class="line">BenchmarkCreateObj_Arena-8                 80409             15340 ns/op            8032 B/op          0 allocs/op</span><br></pre></td></tr></table></figure><p><code>Sync.Pool</code> 不需要重复分配且每次操作时间短，而<code>Arena</code>执行时间会长一点且每次还是需要分配内存的，因为需要引入新的 <code>mspan</code></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li><code>Arena</code> 不支持并发，可以看出操作同一个 arena的时候并不存在锁操作</li><li>Arena 强制 Free()之后的对象无法继续使用</li><li>优点：<ul><li>一旦被释放但仍然被访问则会显示的导致程序错误</li><li>arena 地址空间除非没有指针指向，否则将不能被重用</li><li>arena 永远不会被垃圾回收机制回收(如果GC不可达它会执行 <code>SetFinalizer</code> 自己释放掉，那我们手动free的意义在哪里 --&gt; 也就是构建arena的目的，提前释放内存，降低GC扫描频率)</li></ul></li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://uptrace.dev/blog/golang-memory-arena.html" target="_blank" rel="noopener">https://uptrace.dev/blog/golang-memory-arena.html</a></li><li><a href="https://colobu.com/2022/10/17/a-first-look-at-arena/" target="_blank" rel="noopener">https://colobu.com/2022/10/17/a-first-look-at-arena/</a></li><li><a href="https://zhuanlan.zhihu.com/p/604686258" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/604686258</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近 &lt;code&gt;Go1.20&lt;/code&gt; 更新，中间讲到了一个特性 &lt;code&gt;arena&lt;/code&gt; ，这里看看加入 &lt;code&gt;arena&lt;/code&gt; 的作用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在Go的内存管理中，&lt;code&gt;arena&lt;/code&gt; 其实
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
</feed>
