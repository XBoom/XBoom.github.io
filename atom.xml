<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XBoom Dove</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xboom.github.io/"/>
  <updated>2022-08-13T13:52:53.247Z</updated>
  <id>http://xboom.github.io/</id>
  
  <author>
    <name>XBoom Dove</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式-原型模式</title>
    <link href="http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-09T15:30:38.932Z</published>
    <updated>2022-08-13T13:52:53.247Z</updated>
    
    <content type="html"><![CDATA[<p><strong>原型模式</strong>是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类(<strong>亦称：</strong> 克隆、Clone、Prototype)</p><p>如果你有一个对象， 并希望生成与其完全相同的一个复制品， 你该如何实现呢？ 首先， 你必须新建一个属于相同类的对象。 然后， 你必须遍历原始对象的所有成员变量， 并将成员变量值复制到新对象中。</p><p>可能存在的问题</p><ol><li>并非所有对象都能通过这种方式进行复制， 因为有些对象可能拥有私有成员变量， 它们在对象本身以外是不可见的</li><li>有时只知道对象所实现的接口， 而不知道其所属的具体类， 比如可向方法的某个参数传入实现了某个接口的任何对象</li></ol><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> prototype</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keyword 搜索关键字</span></span><br><span class="line"><span class="keyword">type</span> Keyword <span class="keyword">struct</span> &#123;</span><br><span class="line">word      <span class="keyword">string</span><span class="comment">//私有</span></span><br><span class="line">visit     <span class="keyword">int</span><span class="comment">//私有</span></span><br><span class="line">UpdatedAt *time.Time <span class="comment">//公有</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clone 这里使用序列化与反序列化的方式深拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(k *Keyword)</span> <span class="title">Clone</span><span class="params">()</span> *<span class="title">Keyword</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> newKeyword Keyword</span><br><span class="line">b, _ := json.Marshal(k)</span><br><span class="line">json.Unmarshal(b, &amp;newKeyword)</span><br><span class="line"><span class="keyword">return</span> &amp;newKeyword</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keywords 关键字 map</span></span><br><span class="line"><span class="keyword">type</span> Keywords <span class="keyword">map</span>[<span class="keyword">string</span>]*Keyword</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clone 复制一个新的 keywords</span></span><br><span class="line"><span class="comment">// updatedWords: 需要更新的关键词列表，由于从数据库中获取数据常常是数组的方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(words Keywords)</span> <span class="title">Clone</span><span class="params">(updatedWords []*Keyword)</span> <span class="title">Keywords</span></span> &#123;</span><br><span class="line">newKeywords := Keywords&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> words &#123;</span><br><span class="line"><span class="comment">// 这里是浅拷贝，直接拷贝了地址</span></span><br><span class="line">newKeywords[k] = v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换掉需要更新的字段，这里用的是深拷贝</span></span><br><span class="line"><span class="keyword">for</span> _, word := <span class="keyword">range</span> updatedWords &#123;</span><br><span class="line">newKeywords[word.word] = word.Clone()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newKeywords</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> prototype</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/stretchr/testify/assert"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestKeywords_Clone</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">updateAt, _ := time.Parse(<span class="string">"2006"</span>, <span class="string">"2020"</span>)</span><br><span class="line">words := Keywords&#123;</span><br><span class="line"><span class="string">"testA"</span>: &amp;Keyword&#123;</span><br><span class="line">word:      <span class="string">"testA"</span>,</span><br><span class="line">visit:     <span class="number">1</span>,</span><br><span class="line">UpdatedAt: &amp;updateAt,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"testB"</span>: &amp;Keyword&#123;</span><br><span class="line">word:      <span class="string">"testB"</span>,</span><br><span class="line">visit:     <span class="number">2</span>,</span><br><span class="line">UpdatedAt: &amp;updateAt,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"testC"</span>: &amp;Keyword&#123;</span><br><span class="line">word:      <span class="string">"testC"</span>,</span><br><span class="line">visit:     <span class="number">3</span>,</span><br><span class="line">UpdatedAt: &amp;updateAt,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">now := time.Now()</span><br><span class="line">updatedWords := []*Keyword&#123;</span><br><span class="line">&#123;</span><br><span class="line">word:      <span class="string">"testB"</span>,</span><br><span class="line">visit:     <span class="number">10</span>,</span><br><span class="line">UpdatedAt: &amp;now,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">got := words.Clone(updatedWords)</span><br><span class="line"></span><br><span class="line">assert.Equal(t, words[<span class="string">"testA"</span>], got[<span class="string">"testA"</span>])</span><br><span class="line">assert.NotEqual(t, words[<span class="string">"testB"</span>], got[<span class="string">"testB"</span>])</span><br><span class="line">assert.NotEqual(t, updatedWords[<span class="number">0</span>], got[<span class="string">"testB"</span>])</span><br><span class="line">assert.Equal(t, words[<span class="string">"testC"</span>], got[<span class="string">"testC"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>适用于对象创建成本比较大需要经过复杂计算的情况</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://lailin.xyz/post/factory.html" target="_blank" rel="noopener">https://lailin.xyz/post/factory.html</a></li><li><a href="https://github.com/senghoo/golang-design-pattern" target="_blank" rel="noopener">https://github.com/senghoo/golang-design-pattern</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;原型模式&lt;/strong&gt;是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类(&lt;strong&gt;亦称：&lt;/strong&gt; 克隆、Clone、Prototype)&lt;/p&gt;
&lt;p&gt;如果你有一个对象， 并希望生成与其完全相同的一个复制品，
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-建造者模式</title>
    <link href="http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-09T15:30:38.932Z</published>
    <updated>2022-08-13T14:07:54.043Z</updated>
    
    <content type="html"><![CDATA[<p><strong>建造者模式</strong> 该模式允许你使用相同的创建代码生成不同类型和形式的对象</p><p>假设有这样一个复杂对象， 在对其进行构造时需要对诸多成员变量和嵌套对象进行繁复的初始化工作。 这些初始化代码通常深藏于一个包含众多参数且让人基本看不懂的构造函数中；甚至还有更糟糕的情况， 那就是这些代码散落在客户端代码的多个位置</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><p>普通负载对象构建方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">defaultMaxTotal = <span class="number">10</span></span><br><span class="line">defaultMaxIdle  = <span class="number">9</span></span><br><span class="line">defaultMinIdle  = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ResourcePoolConfig resource pool</span></span><br><span class="line"><span class="keyword">type</span> ResourcePoolConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">name     <span class="keyword">string</span></span><br><span class="line">maxTotal <span class="keyword">int</span></span><br><span class="line">maxIdle  <span class="keyword">int</span></span><br><span class="line">minIdle  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ResourcePoolConfigBuilder 用于构建 ResourcePoolConfig</span></span><br><span class="line"><span class="keyword">type</span> ResourcePoolConfigBuilder <span class="keyword">struct</span> &#123;</span><br><span class="line">name     <span class="keyword">string</span></span><br><span class="line">maxTotal <span class="keyword">int</span></span><br><span class="line">maxIdle  <span class="keyword">int</span></span><br><span class="line">minIdle  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetName SetName</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ResourcePoolConfigBuilder)</span> <span class="title">SetName</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> name == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"name can not be empty"</span>)</span><br><span class="line">&#125;</span><br><span class="line">b.name = name</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetMinIdle SetMinIdle</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ResourcePoolConfigBuilder)</span> <span class="title">SetMinIdle</span><span class="params">(minIdle <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> minIdle &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"max tatal cannot &lt; 0, input: %d"</span>, minIdle)</span><br><span class="line">&#125;</span><br><span class="line">b.minIdle = minIdle</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetMaxIdle SetMaxIdle</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ResourcePoolConfigBuilder)</span> <span class="title">SetMaxIdle</span><span class="params">(maxIdle <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> maxIdle &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"max tatal cannot &lt; 0, input: %d"</span>, maxIdle)</span><br><span class="line">&#125;</span><br><span class="line">b.maxIdle = maxIdle</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetMaxTotal SetMaxTotal</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ResourcePoolConfigBuilder)</span> <span class="title">SetMaxTotal</span><span class="params">(maxTotal <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> maxTotal &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"max tatal cannot &lt;= 0, input: %d"</span>, maxTotal)</span><br><span class="line">&#125;</span><br><span class="line">b.maxTotal = maxTotal</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Build Build</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ResourcePoolConfigBuilder)</span> <span class="title">Build</span><span class="params">()</span> <span class="params">(*ResourcePoolConfig, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> b.name == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"name can not be empty"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line"><span class="keyword">if</span> b.minIdle == <span class="number">0</span> &#123;</span><br><span class="line">b.minIdle = defaultMinIdle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> b.maxIdle == <span class="number">0</span> &#123;</span><br><span class="line">b.maxIdle = defaultMaxIdle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> b.maxTotal == <span class="number">0</span> &#123;</span><br><span class="line">b.maxTotal = defaultMaxTotal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> b.maxTotal &lt; b.maxIdle &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"max total(%d) cannot &lt; max idle(%d)"</span>, b.maxTotal, b.maxIdle)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> b.minIdle &gt; b.maxIdle &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"max idle(%d) cannot &lt; min idle(%d)"</span>, b.maxIdle, b.minIdle)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;ResourcePoolConfig&#123;</span><br><span class="line">name:     b.name,</span><br><span class="line">maxTotal: b.maxTotal,</span><br><span class="line">maxIdle:  b.maxIdle,</span><br><span class="line">minIdle:  b.minIdle,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用可选参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ResourcePoolConfigOption option</span></span><br><span class="line"><span class="keyword">type</span> ResourcePoolConfigOption <span class="keyword">struct</span> &#123;</span><br><span class="line">maxTotal <span class="keyword">int</span></span><br><span class="line">maxIdle  <span class="keyword">int</span></span><br><span class="line">minIdle  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ResourcePoolConfigOptFunc to set option</span></span><br><span class="line"><span class="keyword">type</span> ResourcePoolConfigOptFunc <span class="function"><span class="keyword">func</span><span class="params">(option *ResourcePoolConfigOption)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewResourcePoolConfig NewResourcePoolConfig</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewResourcePoolConfig</span><span class="params">(name <span class="keyword">string</span>, opts ...ResourcePoolConfigOptFunc)</span> <span class="params">(*ResourcePoolConfig, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> name == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"name can not be empty"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">option := &amp;ResourcePoolConfigOption&#123;</span><br><span class="line">maxTotal: <span class="number">10</span>,</span><br><span class="line">maxIdle:  <span class="number">9</span>,</span><br><span class="line">minIdle:  <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">opt(option)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> option.maxTotal &lt; <span class="number">0</span> || option.maxIdle &lt; <span class="number">0</span> || option.minIdle &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"args err, option: %v"</span>, option)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> option.maxTotal &lt; option.maxIdle || option.minIdle &gt; option.maxIdle &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"args err, option: %v"</span>, option)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;ResourcePoolConfig&#123;</span><br><span class="line">name:     name,</span><br><span class="line">maxTotal: option.maxTotal,</span><br><span class="line">maxIdle:  option.maxIdle,</span><br><span class="line">minIdle:  option.minIdle,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/stretchr/testify/assert"</span></span><br><span class="line"><span class="string">"github.com/stretchr/testify/require"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestResourcePoolConfigBuilder_Build</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">name    <span class="keyword">string</span></span><br><span class="line">builder *ResourcePoolConfigBuilder</span><br><span class="line">want    *ResourcePoolConfig</span><br><span class="line">wantErr <span class="keyword">bool</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;</span><br><span class="line">name: <span class="string">"name empty"</span>,</span><br><span class="line">builder: &amp;ResourcePoolConfigBuilder&#123;</span><br><span class="line">name:     <span class="string">""</span>,</span><br><span class="line">maxTotal: <span class="number">0</span>,</span><br><span class="line">&#125;,</span><br><span class="line">want:    <span class="literal">nil</span>,</span><br><span class="line">wantErr: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name: <span class="string">"maxIdle &lt; minIdle"</span>,</span><br><span class="line">builder: &amp;ResourcePoolConfigBuilder&#123;</span><br><span class="line">name:     <span class="string">"test"</span>,</span><br><span class="line">maxTotal: <span class="number">0</span>,</span><br><span class="line">maxIdle:  <span class="number">10</span>,</span><br><span class="line">minIdle:  <span class="number">20</span>,</span><br><span class="line">&#125;,</span><br><span class="line">want:    <span class="literal">nil</span>,</span><br><span class="line">wantErr: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name: <span class="string">"success"</span>,</span><br><span class="line">builder: &amp;ResourcePoolConfigBuilder&#123;</span><br><span class="line">name: <span class="string">"test"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">want: &amp;ResourcePoolConfig&#123;</span><br><span class="line">name:     <span class="string">"test"</span>,</span><br><span class="line">maxTotal: defaultMaxTotal,</span><br><span class="line">maxIdle:  defaultMaxIdle,</span><br><span class="line">minIdle:  defaultMinIdle,</span><br><span class="line">&#125;,</span><br><span class="line">wantErr: <span class="literal">false</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">got, err := tt.builder.Build()</span><br><span class="line">require.Equalf(t, tt.wantErr, err != <span class="literal">nil</span>, <span class="string">"Build() error = %v, wantErr %v"</span>, err, tt.wantErr)</span><br><span class="line">assert.Equal(t, tt.want, got)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可选参数"><a class="markdownIt-Anchor" href="#可选参数"></a> 可选参数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/stretchr/testify/assert"</span></span><br><span class="line"><span class="string">"github.com/stretchr/testify/require"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNewResourcePoolConfig</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> args <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">opts []ResourcePoolConfigOptFunc</span><br><span class="line">&#125;</span><br><span class="line">tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">name    <span class="keyword">string</span></span><br><span class="line">args    args</span><br><span class="line">want    *ResourcePoolConfig</span><br><span class="line">wantErr <span class="keyword">bool</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;</span><br><span class="line">name: <span class="string">"name empty"</span>,</span><br><span class="line">args: args&#123;</span><br><span class="line">name: <span class="string">""</span>,</span><br><span class="line">&#125;,</span><br><span class="line">want:    <span class="literal">nil</span>,</span><br><span class="line">wantErr: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name: <span class="string">"success"</span>,</span><br><span class="line">args: args&#123;</span><br><span class="line">name: <span class="string">"test"</span>,</span><br><span class="line">opts: []ResourcePoolConfigOptFunc&#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(option *ResourcePoolConfigOption)</span></span> &#123;</span><br><span class="line">option.minIdle = <span class="number">2</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">want: &amp;ResourcePoolConfig&#123;</span><br><span class="line">name:     <span class="string">"test"</span>,</span><br><span class="line">maxTotal: <span class="number">10</span>,</span><br><span class="line">maxIdle:  <span class="number">9</span>,</span><br><span class="line">minIdle:  <span class="number">2</span>,</span><br><span class="line">&#125;,</span><br><span class="line">wantErr: <span class="literal">false</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">got, err := NewResourcePoolConfig(tt.args.name, tt.args.opts...)</span><br><span class="line">require.Equalf(t, tt.wantErr, err != <span class="literal">nil</span>, <span class="string">"error = %v, wantErr %v"</span>, err, tt.wantErr)</span><br><span class="line">assert.Equal(t, tt.want, got)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>建造者模式适用于对象创建成本比较大需要经过复杂计算的情况</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://lailin.xyz/post/builder.html" target="_blank" rel="noopener">https://lailin.xyz/post/builder.html</a></li><li><a href="https://refactoringguru.cn/design-patterns/catalog" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/catalog</a></li><li><a href="https://github.com/senghoo/golang-design-pattern" target="_blank" rel="noopener">https://github.com/senghoo/golang-design-pattern</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;建造者模式&lt;/strong&gt; 该模式允许你使用相同的创建代码生成不同类型和形式的对象&lt;/p&gt;
&lt;p&gt;假设有这样一个复杂对象， 在对其进行构造时需要对诸多成员变量和嵌套对象进行繁复的初始化工作。 这些初始化代码通常深藏于一个包含众多参数且让人基本看不懂的构造函
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>微服务-缓存一致性</title>
    <link href="http://xboom.github.io/2022/07/28/Microservices/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>http://xboom.github.io/2022/07/28/Microservices/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</id>
    <published>2022-07-28T00:39:54.767Z</published>
    <updated>2022-07-31T03:01:41.292Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h3><p>一致性有很多种</p><ul><li><strong>强一致性</strong>：保证写入后立即可以读取</li><li><strong>弱一致性</strong>：在系统写入后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态</li><li><strong>最终一致性</strong>：最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态</li></ul><p>缓存可以提升性能、缓解数据库压力，使用缓存也会导致数据<strong>不一致性</strong>的问题</p><p>缓存系统的数据一致性通常包括持久化层和缓存层的一致性、以及多级缓存之间的一致性，这里讨论是前者。持久化层和缓存层的一致性问题也通常被称为双写一致性问题。</p><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>引入 <code>Cache</code> 之后，延迟或程序失败等都会导致缓存和实际存储层数据不一致，下面几种模式减少不一致风险</p><ol><li>Cache-Aside Pattern，即旁路缓存模式</li><li>Read-Through/Write-Through，读写穿透模式</li><li>Write behind，异步缓存写入模式</li></ol><h4 id="cache-aside"><a class="markdownIt-Anchor" href="#cache-aside"></a> Cache-Aside</h4><h5 id="读模式"><a class="markdownIt-Anchor" href="#读模式"></a> 读模式</h5><p>当缓存命中则直接返回，否则从数据库读取数据并更新缓存</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/cache-same-6.png" alt="cache-same-6" style="zoom:67%;" /><h5 id="写模式"><a class="markdownIt-Anchor" href="#写模式"></a> 写模式</h5><p>首先更新数据库，然后删除缓存</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/cache-same-8.png" alt="cache-same-3" style="zoom:67%;" /><p><strong>问题1</strong>：为什么是删除缓存，而不是更新缓存</p><ol><li>如果缓存需要通过大量的计算(联表查询更新)，那么更新缓存会是一笔不小的开销</li><li>另外如果写操作比较多，可能存在刚更新的缓存还没有读取就又要更新的情况(称为<strong>缓存扰动</strong>)，所以此模式适用于读多写少的模式</li><li>等到读请求未命中再去更新，符合懒加载思路</li><li>并发更新可能导致缓存落后与数据库，读请求读到的仍然是旧缓存</li></ol><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/cache-same-8.png" alt="cache-same-8" style="zoom:67%;" /><p><strong>问题2</strong>：为什么是先更新数据库，而不是先删除缓存</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/cahche-same-10.png" alt="cahche-same-10" style="zoom:67%;" /><p>数据库查询请求往往比更新请求更快，可能这种异常更容易出现</p><h4 id="readwrite-through"><a class="markdownIt-Anchor" href="#readwrite-through"></a> Read/Write Through</h4><h5 id="读模式-2"><a class="markdownIt-Anchor" href="#读模式-2"></a> 读模式</h5><p>当缓存命中则直接返回，否则从数据库读取数据并更新缓存</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/cache-same-8.png" alt="cache-same-6" style="zoom: 50%;" /><p><strong>Read/Write Through</strong>模式中，服务端把缓存作为主要数据存储。应用程序跟数据库缓存交互，都是通过<strong>抽象缓存层</strong>完成的</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/cache-same-8.png" alt="cache-same-11" style="zoom: 50%;" /><h5 id="写模式-2"><a class="markdownIt-Anchor" href="#写模式-2"></a> 写模式</h5><p>Write Through模式在发生Cache Miss的时候，只会在读请求中更新缓存。</p><ul><li><p>写请求在发生Cache Miss的时候不会更新缓存，而是直接写入数据库；</p></li><li><p>如果命中缓存则先更新缓存，由缓存自己再将数据写回到数据库中</p></li></ul><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/cache-same-8.png" alt="cache-same-12" style="zoom: 50%;" /><p>注意这个时候如果命中缓存，是先更新缓存的。也就说和 Cache-Aside一样存在并发场景下的一致性问题</p><p>这个策略的核心原则：<strong>用户只与缓存打交道，由缓存组件和DB通信，写入或者读取数据</strong>。在一些本地进程缓存组件可以考虑这种策略</p><p><strong>Write-Through</strong> 存在的缺陷：写数据时缓存和数据库同步，但是我们知道这两块存储介质的速度差几个数量级，对写入性能是有很大影响。那我们是否异步更新数据库</p><h4 id="write-behind"><a class="markdownIt-Anchor" href="#write-behind"></a> Write behind</h4><p><strong>Write behind</strong> 跟有相似的地方，都是由<code>Cache Provider</code>来负责缓存和数据库的读写。它两又有个很大的不同：<strong>Read/Write Through</strong>是同步更新缓存和数据的，<strong>Write Behind</strong>则是只更新缓存，不直接更新数据库，通过<strong>批量异步</strong>的方式来更新数据库</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/cache-same-8.png" alt="cache-same-13" style="zoom:50%;" /><p>缓存和数据库的一致性不强，<strong>对一致性要求高的系统要谨慎使用</strong>。但是它适合频繁写的场景，MySQL的<strong>InnoDB Buffer Pool机制</strong>就使用到这种模式</p><h4 id="延时双删"><a class="markdownIt-Anchor" href="#延时双删"></a> 延时双删</h4><p>延时双删主要用于 Redis主从节点的场景，延时的原因是，mysql 和 redis 主从节点数据不是实时同步的，同步数据需要时间。</p><ol><li>服务节点删除 redis 主库数据</li><li>服务节点修改 mysql 主库数据</li><li>服务节点使得当前业务处理 <code>等待一段时间</code>，等 redis 和 mysql 主从节点数据同步成功。</li><li>服务节点从 redis 主库删除数据。</li><li>当前或其它服务节点读取 redis 从库数据，发现 redis 从库没有数据，从 mysql 从库读取数据，并写入 redis 主库</li></ol><p>注意：</p><ol><li>延时双删，有等待环节，如果系统要求低延时，这种场景就不合适了。</li><li>延时双删，不适合“秒杀”这种频繁修改数据和要求数据强一致的场景。</li><li>延时双删，延时时间是一个预估值，不能确保 mysql 和 redis 数据在这个时间段内都实时同步或持久化成功了</li></ol><h4 id="重试保障"><a class="markdownIt-Anchor" href="#重试保障"></a> 重试保障</h4><h5 id="方案1服务自行订阅删除缓存消息"><a class="markdownIt-Anchor" href="#方案1服务自行订阅删除缓存消息"></a> 方案1：服务自行订阅删除缓存消息</h5><ol><li>更新数据库数据；</li><li>缓存因为种种问题删除失败；</li><li>将需要删除的key发送至消息队列；</li><li>自己消费消息，获得需要删除的key；</li><li>继续重试删除操作，直到成功</li></ol><h5 id="方案2利用第三方服务删除缓存"><a class="markdownIt-Anchor" href="#方案2利用第三方服务删除缓存"></a> 方案2：利用第三方服务删除缓存</h5><ol><li>更新数据库数据；</li><li>数据库会将操作信息写入binlog日志当中；</li><li>订阅程序提取出所需要的数据以及key；</li><li>另起一段非业务代码，获得该信息；</li><li>尝试删除缓存操作，发现删除失败；</li><li>将这些信息发送至消息队列；</li><li>重新从消息队列中获得该数据，重试操作</li></ol><p>注意：</p><ol><li>删除缓存也可能存储缓存击穿的问题<ul><li>在 <a href="https://www.yuankang.top/2022/07/19/GoZero/GoZero8-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98/" target="_blank" rel="noopener">GoZero8-数据库缓存中</a>中使用共享调用的方式(类似自旋锁)进行数据查询</li></ul></li><li>使用<strong>方案1</strong>进行消息订阅的时候可能出现消息队列也失败的情况</li></ol><p>强一致性肯定会有性能影响(比如 <code>raft协议</code>需要等待超过半数节点做出响应)，另外强一致性的异常处理</p><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><p>来看看 <code>rockscache</code> 如何解决缓存一致性的，</p><blockquote><p>地址：<a href="https://github.com/dtm-labs/rockscache" target="_blank" rel="noopener">https://github.com/dtm-labs/rockscache</a></p><p>The First Redis Cache Library To Ensure Eventual Consistency And Strong Consistency With DB.</p></blockquote><h4 id="变量定义"><a class="markdownIt-Anchor" href="#变量定义"></a> 变量定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rockscache client 可选参数</span></span><br><span class="line"><span class="keyword">type</span> Options <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">//标记删除key的延时删除时间 默认10s</span></span><br><span class="line">Delay time.Duration </span><br><span class="line">  <span class="comment">//EmptyExpire 是空结果的过期时间。默认为 60 秒</span></span><br><span class="line">EmptyExpire time.Duration</span><br><span class="line"><span class="comment">// LockExpire 是更新缓存时分配的锁的过期时间。默认为 3s</span></span><br><span class="line">LockExpire time.Duration</span><br><span class="line">  <span class="comment">//锁失败后的重试等待时间 100ms</span></span><br><span class="line">LockSleep time.Duration</span><br><span class="line">  <span class="comment">// 等待副本数量</span></span><br><span class="line">WaitReplicas <span class="keyword">int</span></span><br><span class="line">  <span class="comment">// 副本等待超时时间 默认300ms</span></span><br><span class="line">WaitReplicasTimeout time.Duration</span><br><span class="line">  <span class="comment">//随机过期时间，0.1的偏移(缓存雪崩)</span></span><br><span class="line">RandomExpireAdjustment <span class="keyword">float64</span></span><br><span class="line">  <span class="comment">// 标识缓存禁止读，默认关闭。用于缓存宕机时候的降级</span></span><br><span class="line">DisableCacheRead <span class="keyword">bool</span></span><br><span class="line">  <span class="comment">// 标识缓存删除，默认关闭。用于缓存宕机时候的降级</span></span><br><span class="line">DisableCacheDelete <span class="keyword">bool</span></span><br><span class="line">  <span class="comment">// 强一致性，默认关闭</span></span><br><span class="line">StrongConsistency <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lua脚本"><a class="markdownIt-Anchor" href="#lua脚本"></a> lua脚本</h4><p>使用脚本进行redis操作，lua的好处是一次性执行，执行过程其他脚本或命令无法执行(注意不确定参数)。</p><p>这里使用<code>hash</code>进行数据存储，同时保存 <code>key/value</code> 与 <code>key/lock</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">luaGet</span><span class="params">(key <span class="keyword">string</span>, owner <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">res, err := callLua(c.rdb.Context(), c.rdb, <span class="string">` -- luaGet</span></span><br><span class="line"><span class="string">local v = redis.call('HGET', KEYS[1], 'value')//获取值</span></span><br><span class="line"><span class="string">local lu = redis.call('HGET', KEYS[1], 'lockUtil')//获取过期时间</span></span><br><span class="line"><span class="string">if lu ~= false and tonumber(lu) &lt; tonumber(ARGV[1]) or lu == false and v == false then</span></span><br><span class="line"><span class="string">redis.call('HSET', KEYS[1], 'lockUtil', ARGV[2])//如果锁已经过期或者不存在，则更新锁</span></span><br><span class="line"><span class="string">redis.call('HSET', KEYS[1], 'lockOwner', ARGV[3])</span></span><br><span class="line"><span class="string">return &#123; v, 'LOCKED' &#125;</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">return &#123;v, lu&#125;</span></span><br><span class="line"><span class="string">`</span>, []<span class="keyword">string</span>&#123;key&#125;, []<span class="keyword">interface</span>&#123;&#125;&#123;now(), now() + <span class="keyword">int64</span>(c.Options.LockExpire/time.Second), owner&#125;)</span><br><span class="line">debugf(<span class="string">"luaGet return: %v, %v"</span>, res, err)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res.([]<span class="keyword">interface</span>&#123;&#125;), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">luaSet</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">string</span>, expire <span class="keyword">int</span>, owner <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">_, err := callLua(c.rdb.Context(), c.rdb, <span class="string">`-- luaSet</span></span><br><span class="line"><span class="string">local o = redis.call('HGET', KEYS[1], 'lockOwner')</span></span><br><span class="line"><span class="string">if o ~= ARGV[2] then</span></span><br><span class="line"><span class="string">return</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">redis.call('HSET', KEYS[1], 'value', ARGV[1])</span></span><br><span class="line"><span class="string">redis.call('HDEL', KEYS[1], 'lockUtil')</span></span><br><span class="line"><span class="string">redis.call('HDEL', KEYS[1], 'lockOwner')</span></span><br><span class="line"><span class="string">redis.call('EXPIRE', KEYS[1], ARGV[3])</span></span><br><span class="line"><span class="string">`</span>, []<span class="keyword">string</span>&#123;key&#125;, []<span class="keyword">interface</span>&#123;&#125;&#123;value, owner, expire&#125;)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加锁和解锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">LockForUpdate</span><span class="params">(key <span class="keyword">string</span>, owner <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">lockUtil := math.Pow10(<span class="number">10</span>)</span><br><span class="line">res, err := callLua(c.rdb.Context(), c.rdb, <span class="string">` -- luaLock</span></span><br><span class="line"><span class="string">local lu = redis.call('HGET', KEYS[1], 'lockUtil')</span></span><br><span class="line"><span class="string">local lo = redis.call('HGET', KEYS[1], 'lockOwner')</span></span><br><span class="line"><span class="string">if lu == false or tonumber(lu) &lt; tonumber(ARGV[2]) or lo == ARGV[1] then</span></span><br><span class="line"><span class="string">redis.call('HSET', KEYS[1], 'lockUtil', ARGV[2])</span></span><br><span class="line"><span class="string">redis.call('HSET', KEYS[1], 'lockOwner', ARGV[1])</span></span><br><span class="line"><span class="string">return 'LOCKED'</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">return lo</span></span><br><span class="line"><span class="string">`</span>, []<span class="keyword">string</span>&#123;key&#125;, []<span class="keyword">interface</span>&#123;&#125;&#123;owner, lockUtil&#125;)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; res != <span class="string">"LOCKED"</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"%s has been locked by %s"</span>, key, res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">UnlockForUpdate</span><span class="params">(key <span class="keyword">string</span>, owner <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">_, err := callLua(c.rdb.Context(), c.rdb, <span class="string">` -- luaUnlock</span></span><br><span class="line"><span class="string">local lo = redis.call('HGET', KEYS[1], 'lockOwner')</span></span><br><span class="line"><span class="string">if lo == ARGV[1] then</span></span><br><span class="line"><span class="string">redis.call('HSET', KEYS[1], 'lockUtil', 0)</span></span><br><span class="line"><span class="string">redis.call('HDEL', KEYS[1], 'lockOwner')</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">`</span>, []<span class="keyword">string</span>&#123;key&#125;, []<span class="keyword">interface</span>&#123;&#125;&#123;owner&#125;)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读取缓存"><a class="markdownIt-Anchor" href="#读取缓存"></a> 读取缓存</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new a client for rockscache using the default options</span></span><br><span class="line">rc := rockscache.NewClient(redisClient, NewDefaultOptions())</span><br><span class="line"></span><br><span class="line">v, err := rc.Fetch(<span class="string">"key1"</span>, <span class="number">300</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span><span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// fetch data from database or other sources</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"value1"</span>, <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Fetch</span><span class="params">(key <span class="keyword">string</span>, expire time.Duration, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">string</span>, error)</span>) <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">ex := expire - c.Options.Delay - time.Duration(rand.Float64()*c.Options.RandomExpireAdjustment*<span class="keyword">float64</span>(expire))</span><br><span class="line">v, err, _ := c.group.Do(key, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;<span class="comment">//同样使用共享调用进行操作</span></span><br><span class="line"><span class="keyword">if</span> c.Options.DisableCacheRead &#123;<span class="comment">//缓存崩溃直接读数据库</span></span><br><span class="line"><span class="keyword">return</span> fn()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> c.Options.StrongConsistency &#123; <span class="comment">//强一致性</span></span><br><span class="line"><span class="keyword">return</span> c.strongFetch(key, ex, fn)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c.weakFetch(key, ex, fn)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> v.(<span class="keyword">string</span>), err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也提供了忽略锁的操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">RawGet</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.rdb.HGet(c.rdb.Context(), key, <span class="string">"value"</span>).Result()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">RawSet</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">string</span>, expire time.Duration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">err := c.rdb.HSet(c.rdb.Context(), key, <span class="string">"value"</span>, value).Err()</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">//如果过期操作失败了，那么缓存可能永远不过期(根据AOF策略，默认每秒)</span></span><br><span class="line">    <span class="comment">//操作失败可能是网络或者redis宕机，如果是宕机，那么key可能都还没有落盘。所以这里得考虑网络异常情况</span></span><br><span class="line">err = c.rdb.Expire(c.rdb.Context(), key, expire).Err()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="强一致性获取"><a class="markdownIt-Anchor" href="#强一致性获取"></a> 强一致性获取</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">weakFetch</span><span class="params">(key <span class="keyword">string</span>, expire time.Duration, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">string</span>, error)</span>) <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">debugf(<span class="string">"weakFetch: key=%s"</span>, key)</span><br><span class="line">owner := shortuuid.New()</span><br><span class="line">r, err := c.luaGet(key, owner)</span><br><span class="line"><span class="keyword">for</span> err == <span class="literal">nil</span> &amp;&amp; r[<span class="number">0</span>] == <span class="literal">nil</span> &amp;&amp; r[<span class="number">1</span>].(<span class="keyword">string</span>) != locked &#123;</span><br><span class="line">debugf(<span class="string">"empty result for %s locked by other, so sleep %s"</span>, key, c.Options.LockSleep.String())</span><br><span class="line">time.Sleep(c.Options.LockSleep)</span><br><span class="line">r, err = c.luaGet(key, owner)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> r[<span class="number">1</span>] != locked &#123;</span><br><span class="line"><span class="keyword">return</span> r[<span class="number">0</span>].(<span class="keyword">string</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> r[<span class="number">0</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.fetchNew(key, expire, owner, fn)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> withRecover(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">_, _ = c.fetchNew(key, expire, owner, fn)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> r[<span class="number">0</span>].(<span class="keyword">string</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">strongFetch</span><span class="params">(key <span class="keyword">string</span>, expire time.Duration, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">string</span>, error)</span>) <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">debugf(<span class="string">"strongFetch: key=%s"</span>, key)</span><br><span class="line">owner := shortuuid.New()</span><br><span class="line">r, err := c.luaGet(key, owner)</span><br><span class="line"><span class="keyword">for</span> err == <span class="literal">nil</span> &amp;&amp; r[<span class="number">1</span>] != <span class="literal">nil</span> &amp;&amp; r[<span class="number">1</span>] != locked &#123; <span class="comment">// locked by other</span></span><br><span class="line">debugf(<span class="string">"locked by other, so sleep %s"</span>, c.Options.LockSleep)</span><br><span class="line">time.Sleep(c.Options.LockSleep)</span><br><span class="line">r, err = c.luaGet(key, owner)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> r[<span class="number">1</span>] != locked &#123; <span class="comment">// normal value</span></span><br><span class="line"><span class="keyword">return</span> r[<span class="number">0</span>].(<span class="keyword">string</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c.fetchNew(key, expire, owner, fn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">fetchNew</span><span class="params">(key <span class="keyword">string</span>, expire time.Duration, owner <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">string</span>, error)</span>) <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">result, err := fn()<span class="comment">//自定义读取数据</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;<span class="comment">//成功则删除锁</span></span><br><span class="line">_ = c.UnlockForUpdate(key, owner)</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> result == <span class="string">""</span> &#123;<span class="comment">//如果结果为空</span></span><br><span class="line"><span class="keyword">if</span> c.Options.EmptyExpire == <span class="number">0</span> &#123; <span class="comment">// if empty expire is 0, then delete the key</span></span><br><span class="line">err = c.rdb.Del(c.rdb.Context(), key).Err()</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line">expire = c.Options.EmptyExpire</span><br><span class="line">&#125;</span><br><span class="line">err = c.luaSet(key, result, <span class="keyword">int</span>(expire/time.Second), owner)<span class="comment">//更新缓存</span></span><br><span class="line"><span class="keyword">return</span> result, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>应该根据场景来设计合适的方案解决缓存一致性问题</p><ol><li>读多写少的场景下，可以选择采用 <strong>Cache-Aside 结合消费数据库日志做补偿</strong> 的方案</li><li>写多的场景下，可以选择采用 <strong>Write-Through 结合分布式锁</strong>的方案</li><li>写多的极端场景下，可以选择采用 <strong>Write-Behind</strong> 的方案</li><li>可以通过读取 binlog (阿里云canal)异步删除缓存缓存</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://blog.csdn.net/qq_34827674/article/details/123463175" target="_blank" rel="noopener">https://blog.csdn.net/qq_34827674/article/details/123463175</a></li><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/300%E5%88%86%E9%92%9F%E5%90%83%E9%80%8F%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E5%AE%8C" target="_blank" rel="noopener">https://learn.lianglianglee.com/专栏/300分钟吃透分布式缓存-完</a></li><li><a href="https://www.cnblogs.com/rjzheng/p/9041659.html" target="_blank" rel="noopener">分布式之数据库和缓存双写一致性方式解析</a></li><li><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside" target="_blank" rel="noopener">Cache-Aside Pattern</a></li><li><a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf" target="_blank" rel="noopener">Scaling Memcache at Facebook</a></li><li><a href="https://www.w3cschool.cn/architectroad/architectroad-cache-architecture-design.html" target="_blank" rel="noopener">https://www.w3cschool.cn/architectroad/architectroad-cache-architecture-design.html</a></li><li><a href="https://cloud.tencent.com/developer/article/1932934" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1932934</a></li><li><a href="https://segmentfault.com/a/1190000040976439" target="_blank" rel="noopener">https://segmentfault.com/a/1190000040976439</a></li><li><a href="https://talkgo.org/t/topic/1505" target="_blank" rel="noopener">https://talkgo.org/t/topic/1505</a></li><li><a href="https://github.com/dtm-labs/rockscache/blob/main/helper/README-cn.md" target="_blank" rel="noopener">https://github.com/dtm-labs/rockscache/blob/main/helper/README-cn.md</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题背景&quot;&gt;&lt;/a&gt; 问题背景&lt;/h3&gt;
&lt;p&gt;一致性有很多种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;强一致性&lt;/strong&gt;：保证写入后立即可以读取&lt;/li&gt;
&lt;li&gt;&lt;s
      
    
    </summary>
    
    
      <category term="Microservices" scheme="http://xboom.github.io/categories/Microservices/"/>
    
    
      <category term="Microservices" scheme="http://xboom.github.io/tags/Microservices/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-工厂模式</title>
    <link href="http://xboom.github.io/2022/07/19/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/07/19/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-07-19T14:31:29.930Z</published>
    <updated>2022-08-13T12:20:29.361Z</updated>
    
    <content type="html"><![CDATA[<p>一个类只允许创建一个对象(或实例)，那这个类就是一个单例类，这种设计模式就叫做单例设计模式(Singleton Design Pattern)</p><p>单例模式分为 <code>饿汉式</code> 和 <code>懒汉式</code> 两种实现</p><ol><li><strong>饿汉式</strong>：初始化的时候已经创建好实例</li><li><strong>懒汉式</strong>：只有在调用的时候才会初始化</li></ol><p>构建的时候注意：</p><ol><li>构造函数是私有访问权限(防止被其他地方重新构建)</li><li>构建的时候考虑并发情况</li><li>考虑是否支持延迟加载</li></ol><h3 id="饿汉式"><a class="markdownIt-Anchor" href="#饿汉式"></a> 饿汉式</h3><h4 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="comment">// Singleton 饿汉式单例</span></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> singleton *Singleton</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">singleton = &amp;Singleton&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetInstance 获取实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">Singleton</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> singleton</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetInstance</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">assert.Equal(t, singleton.GetInstance(), singleton.GetInstance()) <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkGetInstanceParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line"><span class="keyword">if</span> singleton.GetInstance() != singleton.GetInstance() &#123;</span><br><span class="line">b.Errorf(<span class="string">"test fail"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性能测试结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkGetInstanceParallel-8   1000000000         0.234 ns/op</span><br></pre></td></tr></table></figure><h3 id="懒汉式"><a class="markdownIt-Anchor" href="#懒汉式"></a> 懒汉式</h3><h4 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Singleton 是单例模式接口，导出的</span></span><br><span class="line"><span class="comment">// 通过该接口可以避免 GetInstance 返回一个包私有类型的指针</span></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">interface</span> &#123;</span><br><span class="line">foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// singleton 是单例模式类，包私有的</span></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s singleton)</span> <span class="title">foo</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">instance *singleton</span><br><span class="line">once     sync.Once</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//GetInstance 用于获取单例模式对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> <span class="title">Singleton</span></span> &#123;</span><br><span class="line">once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">instance = &amp;singleton&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单元测试-2"><a class="markdownIt-Anchor" href="#单元测试-2"></a> 单元测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetLazyInstance</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">assert.Equal(t, singleton.GetLazyInstance(), singleton.GetLazyInstance())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkGetLazyInstanceParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line"><span class="keyword">if</span> singleton.GetLazyInstance() != singleton.GetLazyInstance() &#123;</span><br><span class="line">b.Errorf(<span class="string">"test fail"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性能测试结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkGetLazyInstanceParallel-8   1000000000         0.816 ns/op</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>可拓展性差，如果需要多实例对象可能比较麻烦，适用于单实例对象</li><li>可测试性差，因为是唯一实例，进行多场景修改实例进行测试可能会比较麻烦</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://lailin.xyz/post/singleton.html" target="_blank" rel="noopener">https://lailin.xyz/post/singleton.html</a></li><li><a href="https://github.com/senghoo/golang-design-pattern/blob/master/03_singleton/singleton.go" target="_blank" rel="noopener">https://github.com/senghoo/golang-design-pattern/blob/master/03_singleton/singleton.go</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个类只允许创建一个对象(或实例)，那这个类就是一个单例类，这种设计模式就叫做单例设计模式(Singleton Design Pattern)&lt;/p&gt;
&lt;p&gt;单例模式分为 &lt;code&gt;饿汉式&lt;/code&gt; 和 &lt;code&gt;懒汉式&lt;/code&gt; 两种实现&lt;/p&gt;
&lt;ol&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-工厂方法模式</title>
    <link href="http://xboom.github.io/2022/07/19/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
    <id>http://xboom.github.io/2022/07/19/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/</id>
    <published>2022-07-19T14:31:29.930Z</published>
    <updated>2022-08-13T12:57:55.700Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式分为三种更加细分的类型</p><ol><li>简单工厂(Simple Factory)</li><li>工厂方法(Factory Method)</li><li>抽象工厂(Abstract Factory)</li></ol><p>工厂方法中在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> factory</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置文件解析 接口</span></span><br><span class="line"><span class="keyword">type</span> IRuleConfigParser <span class="keyword">interface</span> &#123;</span><br><span class="line">Parse(data []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// json 文件解析器</span></span><br><span class="line"><span class="keyword">type</span> jsonRuleConfigParser <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jsonRuleConfigParser 实现解析接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(J jsonRuleConfigParser)</span> <span class="title">Parse</span><span class="params">(data []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"implement me"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// yaml 文件解析器</span></span><br><span class="line"><span class="keyword">type</span> yamlRuleConfigParser <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// yamlRuleConfigParser 实现解析接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Y yamlRuleConfigParser)</span> <span class="title">Parse</span><span class="params">(data []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"implement me"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IRuleConfigParserFactory 工厂方法接口</span></span><br><span class="line"><span class="keyword">type</span> IRuleConfigParserFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">CreateParser() IRuleConfigParser</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// yaml 解析工厂</span></span><br><span class="line"><span class="keyword">type</span> yamlRuleConfigParserFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// yamlRuleConfigParserFactory yaml文件解析器构建器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(y yamlRuleConfigParserFactory)</span> <span class="title">CreateParser</span><span class="params">()</span> <span class="title">IRuleConfigParser</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> yamlRuleConfigParser&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// json 解析工厂</span></span><br><span class="line"><span class="keyword">type</span> jsonRuleConfigParserFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jsonRuleConfigParserFactory json文件解析器构建器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(j jsonRuleConfigParserFactory)</span> <span class="title">CreateParser</span><span class="params">()</span> <span class="title">IRuleConfigParser</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> jsonRuleConfigParser&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewIRuleConfigParserFactory 根据类型返回对应的构建工厂</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewIRuleConfigParserFactory</span><span class="params">(t <span class="keyword">string</span>)</span> <span class="title">IRuleConfigParserFactory</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> t &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"json"</span>:</span><br><span class="line"><span class="keyword">return</span> jsonRuleConfigParserFactory&#123;&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"yaml"</span>:</span><br><span class="line"><span class="keyword">return</span> yamlRuleConfigParserFactory&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNewIRuleConfigParserFactory</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> args <span class="keyword">struct</span> &#123;</span><br><span class="line">t <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">args args</span><br><span class="line">want IRuleConfigParserFactory</span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;</span><br><span class="line">name: <span class="string">"json"</span>,</span><br><span class="line">args: args&#123;t: <span class="string">"json"</span>&#125;,</span><br><span class="line">want: jsonRuleConfigParserFactory&#123;&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name: <span class="string">"yaml"</span>,</span><br><span class="line">args: args&#123;t: <span class="string">"yaml"</span>&#125;,</span><br><span class="line">want: yamlRuleConfigParserFactory&#123;&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> got := NewIRuleConfigParserFactory(tt.args.t); !reflect.DeepEqual(got, tt.want) &#123;</span><br><span class="line">t.Errorf(<span class="string">"NewIRuleConfigParserFactory() = %v, want %v"</span>, got, tt.want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>和简单工厂模式一样，在工厂方法构建工厂中包含较多<code>if else</code> ，实用工厂类型不那么多的场景</li><li>工厂方法模式适用于类型创建比较复杂不是简单的New，将复杂的创建逻辑拆分到多个工厂类中</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://lailin.xyz/post/factory.html" target="_blank" rel="noopener">https://lailin.xyz/post/factory.html</a></li><li><a href="https://github.com/senghoo/golang-design-pattern" target="_blank" rel="noopener">https://github.com/senghoo/golang-design-pattern</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工厂模式分为三种更加细分的类型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简单工厂(Simple Factory)&lt;/li&gt;
&lt;li&gt;工厂方法(Factory Method)&lt;/li&gt;
&lt;li&gt;抽象工厂(Abstract Factory)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;工厂方法中在父类中提供
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-简单工厂模式</title>
    <link href="http://xboom.github.io/2022/07/19/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/"/>
    <id>http://xboom.github.io/2022/07/19/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/</id>
    <published>2022-07-19T14:31:29.930Z</published>
    <updated>2022-08-13T12:39:08.125Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式分为三种更加细分的类型</p><ol><li>简单工厂(Simple Factory)</li><li>工厂方法(Factory Method)</li><li>抽象工厂(Abstract Factory)</li></ol><p>由于 Go 本身是没有构造函数的，一般采用 <code>NewName</code> 的方式创建对象/接口，当它返回的是接口的时候，其实就是简单工厂模式</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> factory</span><br><span class="line"></span><br><span class="line"><span class="comment">////配置文件解析接口</span></span><br><span class="line"><span class="keyword">type</span> IRuleConfigParser <span class="keyword">interface</span> &#123;</span><br><span class="line">Parse(data []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//json 文件解析器</span></span><br><span class="line"><span class="keyword">type</span> jsonRuleConfigParser <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//jsonRuleConfigParser 实现接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(J jsonRuleConfigParser)</span> <span class="title">Parse</span><span class="params">(data []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"implement me"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//yaml 文件解析器</span></span><br><span class="line"><span class="keyword">type</span> yamlRuleConfigParser <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// yamlRuleConfigParser 实现解析接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Y yamlRuleConfigParser)</span> <span class="title">Parse</span><span class="params">(data []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"implement me"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据类型返回解析对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewIRuleConfigParser</span><span class="params">(t <span class="keyword">string</span>)</span> <span class="title">IRuleConfigParser</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> t &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"json"</span>:</span><br><span class="line"><span class="keyword">return</span> jsonRuleConfigParser&#123;&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"yaml"</span>:</span><br><span class="line"><span class="keyword">return</span> yamlRuleConfigParser&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNewIRuleConfigParser</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> args <span class="keyword">struct</span> &#123;</span><br><span class="line">t <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">args args</span><br><span class="line">want IRuleConfigParser</span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;</span><br><span class="line">name: <span class="string">"json"</span>,</span><br><span class="line">args: args&#123;t: <span class="string">"json"</span>&#125;,</span><br><span class="line">want: jsonRuleConfigParser&#123;&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name: <span class="string">"yaml"</span>,</span><br><span class="line">args: args&#123;t: <span class="string">"yaml"</span>&#125;,</span><br><span class="line">want: yamlRuleConfigParser&#123;&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> got := NewIRuleConfigParser(tt.args.t); !reflect.DeepEqual(got, tt.want) &#123;</span><br><span class="line">t.Errorf(<span class="string">"NewIRuleConfigParser() = %v, want %v"</span>, got, tt.want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li><code>NewIRuleConfigParser</code> 中包含多个<code>if else</code>，适用于类型不多，不经常修改的情况</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://lailin.xyz/post/factory.html" target="_blank" rel="noopener">https://lailin.xyz/post/factory.html</a></li><li><a href="https://github.com/senghoo/golang-design-pattern" target="_blank" rel="noopener">https://github.com/senghoo/golang-design-pattern</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工厂模式分为三种更加细分的类型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简单工厂(Simple Factory)&lt;/li&gt;
&lt;li&gt;工厂方法(Factory Method)&lt;/li&gt;
&lt;li&gt;抽象工厂(Abstract Factory)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于 Go 本身是没有
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-抽象工厂模式</title>
    <link href="http://xboom.github.io/2022/07/19/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"/>
    <id>http://xboom.github.io/2022/07/19/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/</id>
    <published>2022-07-19T14:31:29.930Z</published>
    <updated>2022-08-13T13:38:52.856Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式分为三种更加细分的类型</p><ol><li>简单工厂(Simple Factory)</li><li>工厂方法(Factory Method)</li><li>抽象工厂(Abstract Factory)</li></ol><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abstractfactory</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置文件解析 接口</span></span><br><span class="line"><span class="keyword">type</span> IRuleConfigParser <span class="keyword">interface</span> &#123;</span><br><span class="line">Parse(data []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// json文件解析器 </span></span><br><span class="line"><span class="keyword">type</span> jsonRuleConfigParser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jsonRuleConfigParser 实现解析接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(j jsonRuleConfigParser)</span> <span class="title">Parse</span><span class="params">(data []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"implement me"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统配置解析器 接口</span></span><br><span class="line"><span class="keyword">type</span> ISystemConfigParser <span class="keyword">interface</span> &#123;</span><br><span class="line">ParseSystem(data []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// json 系统配置解析器</span></span><br><span class="line"><span class="keyword">type</span> jsonSystemConfigParser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jsonSystemConfigParser 实现系统配置解析接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(j jsonSystemConfigParser)</span> <span class="title">ParseSystem</span><span class="params">(data []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"implement me"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IConfigParserFactory 解析抽象工厂</span></span><br><span class="line"><span class="keyword">type</span> IConfigParserFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">CreateRuleParser() IRuleConfigParser</span><br><span class="line">CreateSystemParser() ISystemConfigParser</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析工厂</span></span><br><span class="line"><span class="keyword">type</span> jsonConfigParserFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置文件解析工厂</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(j jsonConfigParserFactory)</span> <span class="title">CreateRuleParser</span><span class="params">()</span> <span class="title">IRuleConfigParser</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> jsonRuleConfigParser&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//系统文件解析工厂</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(j jsonConfigParserFactory)</span> <span class="title">CreateSystemParser</span><span class="params">()</span> <span class="title">ISystemConfigParser</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> jsonSystemConfigParser&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_jsonConfigParserFactory_CreateRuleParser</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">want IRuleConfigParser</span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;</span><br><span class="line">name: <span class="string">"json"</span>,</span><br><span class="line">want: jsonRuleConfigParser&#123;&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">j := jsonConfigParserFactory&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> got := j.CreateRuleParser(); !reflect.DeepEqual(got, tt.want) &#123;</span><br><span class="line">t.Errorf(<span class="string">"CreateRuleParser() = %v, want %v"</span>, got, tt.want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_jsonConfigParserFactory_CreateSystemParser</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">want ISystemConfigParser</span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;</span><br><span class="line">name: <span class="string">"json"</span>,</span><br><span class="line">want: jsonSystemConfigParser&#123;&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">j := jsonConfigParserFactory&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> got := j.CreateSystemParser(); !reflect.DeepEqual(got, tt.want) &#123;</span><br><span class="line">t.Errorf(<span class="string">"CreateSystemParser() = %v, want %v"</span>, got, tt.want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>使用一个工厂常见多个不同类型的对象，而不是只创建一种 <code>parser</code> 解析工厂对象，有效减少工厂数目</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://lailin.xyz/post/factory.html" target="_blank" rel="noopener">https://lailin.xyz/post/factory.html</a></li><li><a href="https://github.com/senghoo/golang-design-pattern" target="_blank" rel="noopener">https://github.com/senghoo/golang-design-pattern</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工厂模式分为三种更加细分的类型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简单工厂(Simple Factory)&lt;/li&gt;
&lt;li&gt;工厂方法(Factory Method)&lt;/li&gt;
&lt;li&gt;抽象工厂(Abstract Factory)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>go-zero9-自适应熔断</title>
    <link href="http://xboom.github.io/2022/07/19/GoZero/GoZero9-%E8%87%AA%E9%80%82%E5%BA%94%E7%86%94%E6%96%AD/"/>
    <id>http://xboom.github.io/2022/07/19/GoZero/GoZero9-%E8%87%AA%E9%80%82%E5%BA%94%E7%86%94%E6%96%AD/</id>
    <published>2022-07-19T14:31:29.926Z</published>
    <updated>2022-08-01T10:07:02.530Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h3><p>使用负载均衡策略是一种避免超负载的处理方式，但服务的容量是有限的。部分服务还是会出现超载的情况，如果优雅的处理过载则对可靠的服务至关重要。</p><p>在高并发场景下，为了应对依赖服务过载，服务不可用等情况，提出了熔断、限流与降级方案。这里主要描述熔断的原理，这里存在几个问题：</p><ol><li>都有哪些熔断的解决方案</li><li>熔断器的实现原理是什么</li></ol><p>使用较多的熔断组件：</p><ol><li>hystrix circuit breaker（不再维护）</li><li>hystrix-go</li><li>resilience4j（推荐）</li><li>sentinel（推荐）</li></ol><h3 id="熔断器原理"><a class="markdownIt-Anchor" href="#熔断器原理"></a> 熔断器原理</h3><p>熔断器一般具有三个状态：</p><ol><li><strong>关闭</strong>: 默认状态，请求能被到达目标服务，同时统计在窗口时间成功和失败次数，如果达到错误率阈值将会进入断开状态。</li><li><strong>断开</strong>: 此状态下将会直接返回错误，如果有 fallback 配置则直接调用 fallback 方法。</li><li><strong>半断开</strong>: 进行断开状态会维护一个超时时间，到达超时时间开始进入 <strong>半断开</strong> 状态，尝试允许一部分请求正常通过并统计成功数量，如果请求正常则认为此时目标服务已恢复进入 <strong>关闭</strong> 状态，否则进入 <strong>断开</strong> 状态</li></ol><p>基于熔断器的原理，通常熔断器主要关注以下参数：</p><ol><li>错误比例阈值: 达到该阈值进入 断开 状态</li><li>断开状态超时时间: 超时后进入 半断开 状态</li><li>半断开状态允许请求数量</li><li>窗口时间大小</li></ol><p>这里有更将详细可参考的参考以及算法说明</p><ol><li><a href="https://resilience4j.readme.io/docs/circuitbreaker" target="_blank" rel="noopener">https://resilience4j.readme.io/docs/circuitbreaker</a></li><li><a href="https://sre.google/sre-book/handling-overload/" target="_blank" rel="noopener">https://sre.google/sre-book/handling-overload/</a></li></ol><p>由于<code>go-zero</code> 的熔断器是基于google文章实现，来看下基本算法</p><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><ol><li>无论什么熔断器都得依靠指标统计来转换状态，而统计指标一般要求是最近的一段时间内的数据，所以通常采用一个 <code>滑动时间窗口</code> 数据结构 来存储统计数据。同时熔断器的状态也需要依靠指标统计来实现可观测性。</li><li>外部服务请求结果各式各样，所以需要提供一个自定义的判断方法，判断请求是否成功。熔断器需要实时收集此数据。</li><li>当外部服务被熔断时使用者往往需要自定义快速失败的逻辑，考虑提供自定义的 <code>fallback()</code> 功能。</li></ol><h4 id="接口定义"><a class="markdownIt-Anchor" href="#接口定义"></a> 接口定义</h4><p>代码路径：<code>core/breaker/breaker.go</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 250ms for bucket duration</span></span><br><span class="line">window     = time.Second * <span class="number">10</span></span><br><span class="line">buckets    = <span class="number">40</span></span><br><span class="line">k          = <span class="number">1.5</span></span><br><span class="line">protection = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断断路器是否通过</span></span><br><span class="line">Acceptable <span class="function"><span class="keyword">func</span><span class="params">(err error)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Breaker 断路器</span></span><br><span class="line">Breaker <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// 熔断器名称</span></span><br><span class="line">Name() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查请求是否允许。调用成功则使用 Promise.Accept()，失败则调用 Promise.Reject()，否则表示不许云</span></span><br><span class="line">Allow() (Promise, error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 Breaker 接受，Do 运行给定的请求。</span></span><br><span class="line"><span class="comment">// 如果 Breaker 拒绝请求，Do 立即返回错误。</span></span><br><span class="line"><span class="comment">// 如果请求发生恐慌，Breaker 将其作为错误处理并再次引起同样的恐慌。</span></span><br><span class="line">Do(req <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span>) <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 Breaker 接受，DoWithAcceptable 运行给定的请求。</span></span><br><span class="line"><span class="comment">// 如果 Breaker 拒绝请求，DoWithAcceptable 会立即返回错误。</span></span><br><span class="line"><span class="comment">// 如果请求发生恐慌，Breaker 将其作为错误处理并再次引起同样的恐慌。</span></span><br><span class="line"><span class="comment">// 可接受的检查它是否是一个成功的调用，即使错误不是零。</span></span><br><span class="line">DoWithAcceptable(req <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span>, <span class="title">acceptable</span> <span class="title">Acceptable</span>) <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 Breaker 接受，DoWithFallback 运行给定的请求。</span></span><br><span class="line"><span class="comment">// 如果 Breaker 拒绝请求，DoWithFallback 运行回退。</span></span><br><span class="line"><span class="comment">// 如果请求发生恐慌，Breaker 将其作为错误处理并再次引起同样的恐慌。</span></span><br><span class="line">DoWithFallback(req <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span>, <span class="title">fallback</span> <span class="title">func</span><span class="params">(err error)</span> <span class="title">error</span>) <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 Breaker 接受，DoWithFallbackAcceptable 运行给定的请求。</span></span><br><span class="line"><span class="comment">// DoWithFallbackAcceptable 如果 Breaker 拒绝请求，则运行回退。</span></span><br><span class="line"><span class="comment">// 如果请求发生恐慌，Breaker 将其作为错误处理并再次引起同样的恐慌。</span></span><br><span class="line"><span class="comment">// 可接受的检查它是否是一个成功的调用，即使错误不是零。</span></span><br><span class="line">DoWithFallbackAcceptable(req <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span>, <span class="title">fallback</span> <span class="title">func</span><span class="params">(err error)</span> <span class="title">error</span>, <span class="title">acceptable</span> <span class="title">Acceptable</span>) <span class="title">error</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="断路器"><a class="markdownIt-Anchor" href="#断路器"></a> 断路器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//断路器</span></span><br><span class="line">circuitBreaker <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">throttle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//断路器内部则通过两个接口实现</span></span><br><span class="line">throttle <span class="keyword">interface</span> &#123;</span><br><span class="line">allow() (Promise, error)</span><br><span class="line">doReq(req <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span>, <span class="title">fallback</span> <span class="title">func</span><span class="params">(err error)</span> <span class="title">error</span>, <span class="title">acceptable</span> <span class="title">Acceptable</span>) <span class="title">error</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义断路器对象</span></span><br><span class="line"><span class="keyword">type</span> googleBreaker <span class="keyword">struct</span> &#123;</span><br><span class="line">k     <span class="keyword">float64</span></span><br><span class="line">stat  *collection.RollingWindow<span class="comment">//使用滑动窗口统计最近一段时间数据</span></span><br><span class="line">proba *mathx.Proba</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newGoogleBreaker</span><span class="params">()</span> *<span class="title">googleBreaker</span></span> &#123;</span><br><span class="line">bucketDuration := time.Duration(<span class="keyword">int64</span>(window) / <span class="keyword">int64</span>(buckets))</span><br><span class="line">st := collection.NewRollingWindow(buckets, bucketDuration)</span><br><span class="line"><span class="keyword">return</span> &amp;googleBreaker&#123;</span><br><span class="line">stat:  st,</span><br><span class="line">k:     k,</span><br><span class="line">proba: mathx.NewProba(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据记录"><a class="markdownIt-Anchor" href="#数据记录"></a> 数据记录</h4><p>其实是将成功或者失败记录到滑动窗口中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *googleBreaker)</span> <span class="title">markSuccess</span><span class="params">()</span></span> &#123;</span><br><span class="line">b.stat.Add(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *googleBreaker)</span> <span class="title">markFailure</span><span class="params">()</span></span> &#123;</span><br><span class="line">b.stat.Add(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="请求操作"><a class="markdownIt-Anchor" href="#请求操作"></a> 请求操作</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计滑动窗口中所代表的最近一段时间的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *googleBreaker)</span> <span class="title">history</span><span class="params">()</span> <span class="params">(accepts, total <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">b.stat.Reduce(<span class="function"><span class="keyword">func</span><span class="params">(b *collection.Bucket)</span></span> &#123;</span><br><span class="line">accepts += <span class="keyword">int64</span>(b.Sum)</span><br><span class="line">total += b.Count</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查是否允许</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *googleBreaker)</span> <span class="title">accept</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">accepts, total := b.history()</span><br><span class="line">weightedAccepts := b.k * <span class="keyword">float64</span>(accepts)</span><br><span class="line"><span class="comment">// https://landing.google.com/sre/sre-book/chapters/handling-overload/#eq2101</span></span><br><span class="line">dropRatio := math.Max(<span class="number">0</span>, (<span class="keyword">float64</span>(total-protection)-weightedAccepts)/<span class="keyword">float64</span>(total+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">if</span> dropRatio &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> b.proba.TrueOnProba(dropRatio) &#123;</span><br><span class="line"><span class="keyword">return</span> ErrServiceUnavailable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回断路器权限</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *googleBreaker)</span> <span class="title">allow</span><span class="params">()</span> <span class="params">(internalPromise, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := b.accept(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> googlePromise&#123;</span><br><span class="line">b: b,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *googleBreaker)</span> <span class="title">doReq</span><span class="params">(req <span class="keyword">func</span>()</span> <span class="title">error</span>, <span class="title">fallback</span> <span class="title">func</span><span class="params">(err error)</span> <span class="title">error</span>, <span class="title">acceptable</span> <span class="title">Acceptable</span>) <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := b.accept(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> fallback != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fallback(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">b.markFailure()</span><br><span class="line"><span class="built_in">panic</span>(e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">err := req()</span><br><span class="line"><span class="keyword">if</span> acceptable(err) &#123;<span class="comment">//结果的处理</span></span><br><span class="line">b.markSuccess()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">b.markFailure()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li><p>通过滑动窗口进行最近一段数据(成功失败次数)的统计</p></li><li><p>是否断路则是通过指定的公式计算</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">失</mi><mi mathvariant="normal">败</mi><mi mathvariant="normal">率</mi><mo>=</mo><mi mathvariant="normal">总</mi><mi mathvariant="normal">数</mi><mo>−</mo><mi mathvariant="normal">可</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">收</mi><mi mathvariant="normal">误</mi><mi mathvariant="normal">差</mi><mo>−</mo><mi>k</mi><mo>∗</mo><mi mathvariant="normal">成</mi><mi mathvariant="normal">功</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">失</mi><mi mathvariant="normal">败</mi></mrow><annotation encoding="application/x-tex">失败率 = 总数 - 可接收误差 - k * 成功 / 失败</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">失</span><span class="mord cjk_fallback">败</span><span class="mord cjk_fallback">率</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">总</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">收</span><span class="mord cjk_fallback">误</span><span class="mord cjk_fallback">差</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">功</span><span class="mord">/</span><span class="mord cjk_fallback">失</span><span class="mord cjk_fallback">败</span></span></span></span></span></p></li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://talkgo.org/t/topic/3035" target="_blank" rel="noopener">https://talkgo.org/t/topic/3035</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题背景&quot;&gt;&lt;/a&gt; 问题背景&lt;/h3&gt;
&lt;p&gt;使用负载均衡策略是一种避免超负载的处理方式，但服务的容量是有限的。部分服务还是会出现超载的情况，如果优雅的处理过载则对可靠的服务至关
      
    
    </summary>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/categories/go-zero/"/>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>go-zero8-数据库缓存</title>
    <link href="http://xboom.github.io/2022/07/19/GoZero/GoZero8-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98/"/>
    <id>http://xboom.github.io/2022/07/19/GoZero/GoZero8-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98/</id>
    <published>2022-07-19T14:31:29.925Z</published>
    <updated>2022-07-22T13:54:57.154Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h3><p>在 <a href="https://xboom.github.io/2022/07/19/GoZero/GoZero7-%E8%BF%9B%E7%A8%8B%E5%86%85%E7%BC%93%E5%AD%98/">进程内缓存</a>中说到的是直接在进程进行缓存的自管理，一般应用于业务生成的自定义数据(多副本情况下可能存在缓存一致性问题)。而随着业务量的增加，利用Redis构建专门的数据缓存，加快数据库访问。</p><p>由于数据库数据的特点，那么这里就有几个实现需要注意的点</p><ol><li>数据一致性</li><li>缓存击穿、穿透、雪崩</li><li>缓存访问量、缓存命中率</li></ol><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>源码注释：<code>core/stores/cache</code></p><h4 id="构建缓存对象"><a class="markdownIt-Anchor" href="#构建缓存对象"></a> 构建缓存对象</h4><p>根据缓存节点配置构建一个缓存对象用于业务层进行缓存处理</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/go-zero-cache10.png" alt="go-zero-cache10" />缓存支持通过多节点构建的缓存集群，也支持单个节点结构</p><ol><li>多节点缓存集群通过一致性Hash进行访问，这里的多节点是指多个无关的缓存节点。而每个缓存节点可能都是一个Redis集群</li><li>共享调用防止缓存击穿</li><li>统计将环中命中，DB查询等情况上报给外部</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓存集群对象</span></span><br><span class="line">cacheCluster <span class="keyword">struct</span> &#123;</span><br><span class="line">dispatcher  *hash.ConsistentHash</span><br><span class="line">errNotFound error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于一致性Hash 在 《go-zero-一致性Hash》有说明</p></blockquote><h4 id="集群缓存操作"><a class="markdownIt-Anchor" href="#集群缓存操作"></a> 集群缓存操作</h4><p>集群的缓存操作都是根据一致性<code>Hash</code>算法得出对应节点，然后演变成单节点的缓存操作</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/go-zero-cache13.png" alt="go-zero-cache13" style="zoom:50%;" /><p>与单点不同的是，缓存集群批量删除<code>Key</code>,而<code>Key</code>有可能存在于多个节点上</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/go-zero-cache14.png" alt="go-zero-cache14" style="zoom:50%;" /><p>当<code>keys</code>数量大于1的时候，首先会 <code>for Hash(Key)</code> 找到所有的缓存节点，然后再通过 <code>for del</code></p><ol><li>单次映射<code>Hash</code>节点或者删除<code>Key</code>并不会影响后续操作，而是通过 <code>BatchError</code>记录每一次错误</li><li>通过 <code>make(map[interface{}][]string)</code>保存<strong>节点</strong>与<strong>Key</strong>的关系</li></ol><h4 id="单点缓存操作"><a class="markdownIt-Anchor" href="#单点缓存操作"></a> 单点缓存操作</h4><h5 id="查询缓存"><a class="markdownIt-Anchor" href="#查询缓存"></a> 查询缓存</h5><p>查询缓存的过程其实就是从Redis中获取数据的过程</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/go-zero-cachedb1.png" alt="go-zero-cachedb1" style="zoom: 33%;" /><p>这里有两点需要注意</p><ol><li>当加载数据完毕，有一个将结果与空占位符比较的过程 <code>value = &quot;*&quot;</code>，是为了防止缓存穿透而故意设置的占位符。那么它是什么时候怎么插入的？</li><li>将结果反序列如果失败，那么会去Redis删除这个 <code>Key</code>，表示存储的缓存异常</li></ol><h5 id="设置缓存"><a class="markdownIt-Anchor" href="#设置缓存"></a> 设置缓存</h5><p>设置缓存是直接按照redis语法设置 <code>k/v</code> 与 <code>expire</code></p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/go-zero-cacheDB2.png" alt="go-zero-cacheDB2" style="zoom:50%;" /><h5 id="删除缓存"><a class="markdownIt-Anchor" href="#删除缓存"></a> 删除缓存</h5><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/go-zero-cachedb3.png" alt="go-zero-cachedb3" style="zoom:33%;" /><ol><li>删除缓存时候，如果本身就是一个缓存集群，当对 <code>keys</code>进行批量删除的时候，需要依次删除每一个Key，而不是直接 <code>del(keys...)</code> 删除。</li><li>删除失败这里添加延时任务进行重试，但只会重试一次，失败后直接退出</li></ol><h5 id="获取缓存"><a class="markdownIt-Anchor" href="#获取缓存"></a> 获取缓存</h5><p>获取缓存当缓存数据库没有的时候，就会直接从数据库加载并将数据保存到缓存数据库</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/go-zero-cachedb5.png" alt="go-zero-cachedb5" style="zoom:33%;" /><ol><li>当缓存中没有且数据库中也没有的时候，那么这个时候就会设置占位符(防止缓存穿透)，占位符的过期时间与普通的<code>Key</code>一致</li><li>关于查询数据库操作，这里仅仅是将结果实体传入，由数据层进行数据加载</li><li>当缓存没有的时候，是先查询数据库，然后更新缓存</li></ol><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><p>代码：<code>core/stores/cache/cachenode.go</code></p><p><code>cacheNode</code> 表示是单个缓存节点的对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cacheNode 表示单个缓存节点</span></span><br><span class="line"><span class="keyword">type</span> cacheNode <span class="keyword">struct</span> &#123;</span><br><span class="line">rds            *redis.Redis<span class="comment">//redis句柄</span></span><br><span class="line">expiry         time.Duration <span class="comment">//缓存过期时间</span></span><br><span class="line">notFoundExpiry time.Duration<span class="comment">//</span></span><br><span class="line">barrier        syncx.SingleFlight<span class="comment">//共享调用</span></span><br><span class="line">r              *rand.Rand</span><br><span class="line">lock           *sync.Mutex<span class="comment">//原子锁</span></span><br><span class="line">unstableExpiry mathx.Unstable</span><br><span class="line">  stat           *Stat<span class="comment">//统计(单个节点的统计)</span></span><br><span class="line">errNotFound    error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">notFoundPlaceholder = <span class="string">"*"</span></span><br><span class="line">  <span class="comment">//避免缓存雪崩，这里加上随机过期时间随机值 [0.95, 1.05] * seconds</span></span><br><span class="line">expiryDeviation = <span class="number">0.05</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li>这里几个过期分别有什么作用<ul><li><code>expiry</code>:</li><li><code>notFoundExpiry</code>:</li><li><code>unstableExpiry</code>:</li></ul></li><li>使用共享调用 <code>barrier</code>减少缓存调用</li><li><code>rand.Rand</code> 的随机数</li></ol><h4 id="新建缓存节点"><a class="markdownIt-Anchor" href="#新建缓存节点"></a> 新建缓存节点</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNode</span><span class="params">(rds *redis.Redis, barrier syncx.SingleFlight, st *Stat,</span></span></span><br><span class="line"><span class="function"><span class="params">errNotFound error, opts ...Option)</span> <span class="title">Cache</span></span> &#123;</span><br><span class="line">o := newOptions(opts...)</span><br><span class="line"><span class="keyword">return</span> cacheNode&#123;</span><br><span class="line">rds:            rds,<span class="comment">//redis句柄</span></span><br><span class="line">expiry:         o.Expiry,<span class="comment">//过期时间</span></span><br><span class="line">notFoundExpiry: o.NotFoundExpiry,<span class="comment">//设置占位符过期时间</span></span><br><span class="line">barrier:        barrier,<span class="comment">//共享调用</span></span><br><span class="line">r:              rand.New(rand.NewSource(time.Now().UnixNano())),</span><br><span class="line">lock:           <span class="built_in">new</span>(sync.Mutex),</span><br><span class="line">unstableExpiry: mathx.NewUnstable(expiryDeviation),<span class="comment">//一定范围内过期时间</span></span><br><span class="line">stat:           st,<span class="comment">//统计逻辑</span></span><br><span class="line">errNotFound:    errNotFound,<span class="comment">//找不到缓存</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询缓存-2"><a class="markdownIt-Anchor" href="#查询缓存-2"></a> 查询缓存</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cacheNode)</span> <span class="title">doGetCache</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">c.stat.IncrementTotal()</span><br><span class="line">data, err := c.rds.GetCtx(ctx, key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.stat.IncrementMiss()</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span> &#123;<span class="comment">//数据为空</span></span><br><span class="line">c.stat.IncrementMiss()</span><br><span class="line"><span class="keyword">return</span> c.errNotFound</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.stat.IncrementHit()</span><br><span class="line"><span class="keyword">if</span> data == notFoundPlaceholder &#123;<span class="comment">//防止缓存穿透</span></span><br><span class="line"><span class="keyword">return</span> errPlaceholder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c.processCache(ctx, key, data, v)<span class="comment">//缓存处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cacheNode)</span> <span class="title">processCache</span><span class="params">(ctx context.Context, key, data <span class="keyword">string</span>, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">err := jsonx.Unmarshal([]<span class="keyword">byte</span>(data), v)<span class="comment">//反序列化</span></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//... 日志记录</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> _, e := c.rds.DelCtx(ctx, key); e != <span class="literal">nil</span> &#123;<span class="comment">//删除缓存 </span></span><br><span class="line">logger.Errorf(<span class="string">"delete invalid cache, node: %s, key: %s, value: %s, error: %v"</span>,</span><br><span class="line">c.rds.Addr, key, data, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// returns errNotFound to reload the value by the given queryFn</span></span><br><span class="line"><span class="keyword">return</span> c.errNotFound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设置缓存-2"><a class="markdownIt-Anchor" href="#设置缓存-2"></a> 设置缓存</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cacheNode)</span> <span class="title">SetWithExpireCtx</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, val <span class="keyword">interface</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">expire time.Duration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">data, err := jsonx.Marshal(val)<span class="comment">//序列化</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c.rds.SetexCtx(ctx, key, <span class="keyword">string</span>(data), <span class="keyword">int</span>(expire.Seconds()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取缓存-2"><a class="markdownIt-Anchor" href="#获取缓存-2"></a> 获取缓存</h4><p>获取缓存直接加载加载redis，并根据加载结果进行不同的处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cacheNode)</span> <span class="title">doTake</span><span class="params">(ctx context.Context, v <span class="keyword">interface</span>&#123;&#125;, key <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">query <span class="keyword">func</span>(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span>, <span class="title">cacheVal</span> <span class="title">func</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">logger := logx.WithContext(ctx)</span><br><span class="line">val, fresh, err := c.barrier.DoEx(key, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;<span class="comment">//共享调用加载key</span></span><br><span class="line"><span class="keyword">if</span> err := c.doGetCache(ctx, key, v); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == errPlaceholder &#123;<span class="comment">//如果是占位符直接返回找不到</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, c.errNotFound</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != c.errNotFound &#123;</span><br><span class="line"><span class="comment">//如果是其他错误，直接返回而不要继续将错误蔓延到dbs</span></span><br><span class="line">        <span class="comment">//如果不这样，可能高并发导致redis奔溃之后，dbs也会跟着崩溃</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//数据库查询</span></span><br><span class="line"><span class="keyword">if</span> err = query(v); err == c.errNotFound &#123; </span><br><span class="line">        <span class="comment">//没有找到就设置占位符</span></span><br><span class="line"><span class="keyword">if</span> err = c.setCacheWithNotFound(ctx, key); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Error(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, c.errNotFound</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.stat.IncrementDbFails()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err = cacheVal(v); err != <span class="literal">nil</span> &#123;<span class="comment">//缓存找到的缓存</span></span><br><span class="line">logger.Error(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> jsonx.Marshal(v)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> fresh &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//放在最后的原因是共享调用，这里共享调用不记录到总数中</span></span><br><span class="line">c.stat.IncrementTotal()</span><br><span class="line">c.stat.IncrementHit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> jsonx.Unmarshal(val.([]<span class="keyword">byte</span>), v)<span class="comment">//反序列化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除缓存-2"><a class="markdownIt-Anchor" href="#删除缓存-2"></a> 删除缓存</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cacheNode)</span> <span class="title">DelCtx</span><span class="params">(ctx context.Context, keys ...<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(keys) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger := logx.WithContext(ctx)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(keys) &gt; <span class="number">1</span> &amp;&amp; c.rds.Type == redis.ClusterType &#123;<span class="comment">//如果是集群则for循环批量删除</span></span><br><span class="line"><span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line"><span class="keyword">if</span> _, err := c.rds.DelCtx(ctx, key); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Errorf(<span class="string">"failed to clear cache with key: %q, error: %v"</span>, key, err)</span><br><span class="line">c.asyncRetryDelCache(key)<span class="comment">//失败添加重试任务</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> _, err := c.rds.DelCtx(ctx, keys...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Errorf(<span class="string">"failed to clear cache with keys: %q, error: %v"</span>, formatKeys(keys), err)</span><br><span class="line">c.asyncRetryDelCache(keys...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缓存统计"><a class="markdownIt-Anchor" href="#缓存统计"></a> 缓存统计</h4><p>代码：<code>core/stores/cache/cachestat.go</code></p><p>用于统计缓存情况</p><h5 id="新建统计对象"><a class="markdownIt-Anchor" href="#新建统计对象"></a> 新建统计对象</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewStat returns a Stat.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStat</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">Stat</span></span> &#123;</span><br><span class="line">ret := &amp;Stat&#123;</span><br><span class="line">name: name,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> ret.statLoop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//statLoop 开启统计</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stat)</span> <span class="title">statLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">ticker := time.NewTicker(statInterval)</span><br><span class="line"><span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">total := atomic.SwapUint64(&amp;s.Total, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> total == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算缓存情况</span></span><br><span class="line">hit := atomic.SwapUint64(&amp;s.Hit, <span class="number">0</span>)</span><br><span class="line">percent := <span class="number">100</span> * <span class="keyword">float32</span>(hit) / <span class="keyword">float32</span>(total)<span class="comment">//命中率</span></span><br><span class="line">miss := atomic.SwapUint64(&amp;s.Miss, <span class="number">0</span>)<span class="comment">//未命中</span></span><br><span class="line">dbf := atomic.SwapUint64(&amp;s.DbFails, <span class="number">0</span>)<span class="comment">//数据库调用事变</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//发送统计信息</span></span><br><span class="line">logx.Statf(<span class="string">"dbcache(%s) - qpm: %d, hit_ratio: %.1f%%, hit: %d, miss: %d, db_fails: %d"</span>,s.name, total, percent, hit, miss, dbf)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>协程是一个常驻协程，缺少退出</li><li><code>SwapUint64</code>的作用是：将新的值写入 <code>addr</code>，而返回<code>addr</code>中旧的值</li></ol><h4 id="缓存清理"><a class="markdownIt-Anchor" href="#缓存清理"></a> 缓存清理</h4><p>当缓存删除失败，这里添加一个重试机制</p><h5 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">    <span class="comment">//时间轮</span></span><br><span class="line">timingWheel, err = collection.NewTimingWheel(time.Second, timingWheelSlots, clean)</span><br><span class="line">logx.Must(err)</span><br><span class="line"><span class="comment">//监听系统异常退出</span></span><br><span class="line">proc.AddShutdownListener(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">timingWheel.Drain(clean)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clean 时间轮操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clean</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">taskRunner.Schedule(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">dt := value.(delayTask)</span><br><span class="line">err := dt.task() <span class="comment">//执行任务</span></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">next, ok := nextDelay(dt.delay)<span class="comment">//重复任务设置</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">dt.delay = next</span><br><span class="line">timingWheel.SetTimer(key, dt, next)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">msg := fmt.Sprintf(<span class="string">"retried but failed to clear cache with keys: %q, error: %v"</span>,</span><br><span class="line">formatKeys(dt.keys), err)</span><br><span class="line">logx.Error(msg)</span><br><span class="line">stat.Report(msg)<span class="comment">//暂未实现</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里做了一个动态清理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextDelay</span><span class="params">(delay time.Duration)</span> <span class="params">(time.Duration, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> delay &#123;</span><br><span class="line"><span class="keyword">case</span> time.Second:</span><br><span class="line"><span class="keyword">return</span> time.Second * <span class="number">5</span>, <span class="literal">true</span></span><br><span class="line"><span class="keyword">case</span> time.Second * <span class="number">5</span>:</span><br><span class="line"><span class="keyword">return</span> time.Minute, <span class="literal">true</span></span><br><span class="line"><span class="keyword">case</span> time.Minute:</span><br><span class="line"><span class="keyword">return</span> time.Minute * <span class="number">5</span>, <span class="literal">true</span></span><br><span class="line"><span class="keyword">case</span> time.Minute * <span class="number">5</span>:</span><br><span class="line"><span class="keyword">return</span> time.Hour, <span class="literal">true</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加清理任务"><a class="markdownIt-Anchor" href="#添加清理任务"></a> 添加清理任务</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddCleanTask adds a clean task on given keys.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddCleanTask</span><span class="params">(task <span class="keyword">func</span>()</span> <span class="title">error</span>, <span class="title">keys</span> ...<span class="title">string</span>)</span> &#123;</span><br><span class="line">timingWheel.SetTimer(stringx.Randn(taskKeyLen), delayTask&#123;</span><br><span class="line">delay: time.Second,</span><br><span class="line">task:  task,</span><br><span class="line">keys:  keys,</span><br><span class="line">&#125;, time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><ol><li>采用共享调用的方式防止缓存击穿</li><li>采用占位符方式缓存床头</li><li>设置范围过期时间防止缓存雪崩</li><li>增加重试删除机制(时间轮)</li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://talkgo.org/t/topic/1716" target="_blank" rel="noopener">https://talkgo.org/t/topic/1716</a></li><li><a href="https://talkgo.org/t/topic/1505" target="_blank" rel="noopener">https://talkgo.org/t/topic/1505</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题背景&quot;&gt;&lt;/a&gt; 问题背景&lt;/h3&gt;
&lt;p&gt;在 &lt;a href=&quot;https://xboom.github.io/2022/07/19/GoZero/GoZero7-%E8%B
      
    
    </summary>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/categories/go-zero/"/>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>go-zero7-进程内缓存</title>
    <link href="http://xboom.github.io/2022/07/19/GoZero/GoZero7-%E8%BF%9B%E7%A8%8B%E5%86%85%E7%BC%93%E5%AD%98/"/>
    <id>http://xboom.github.io/2022/07/19/GoZero/GoZero7-%E8%BF%9B%E7%A8%8B%E5%86%85%E7%BC%93%E5%AD%98/</id>
    <published>2022-07-19T14:31:29.923Z</published>
    <updated>2022-07-20T16:53:11.020Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h3><p>缓存，目的是减少繁重的IO操作，增加系统并发能力。之前做的内存方案</p><ol><li>同一类数据，设计一个双链表，然后添加一个定时器，动态删除过期内存。</li><li>实现一个简单的<code>LRU</code>缓存淘汰算法。</li></ol><p>设计内进程内缓存主要需要考虑的是</p><ol><li>可拓展性(缓存不同类型的数据)</li><li>过期处理，怎样才能友好的删除过期数据，不能无限存储<ul><li>定时删除，不断循环所有key。缺点：需要遍历所有key，空耗CPU</li><li>惰性删除，访问的时候判断该键是否。缺点：如果不在访问，那么就会一直存在</li></ul></li><li>如果保障进程内缓存一致性<ul><li>单节点通知：一个节点完成修改，通知其他节点(类似raft，但raft有主)。缺点：时效性、可靠性</li><li><code>MQ</code>订阅通知：一个节点完成修改，通知其他节点进行修改。缺点：缓存维护更复杂</li><li>定时更新：单个节点定时器，定时拉去新数据，更新内存数据。缺点：时效性</li></ul></li></ol><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>这里看看<code>go-zero</code>是如何实现进程缓存设计的</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/go-zero-cache.png" alt="go-zero-cache" style="zoom: 33%;" /><p>从图中可以看出</p><ol><li>缓存被存放在map</li><li><code>LRU</code>(使用<code>双向链表+Map</code>实现)用于对缓存的过期删除</li><li><code>limit</code> 进行缓存数量限制</li><li>定时逻辑则是通过<a href="https://xboom.github.io/2022/07/08/GoZero/GoZero5-%E6%97%B6%E9%97%B4%E8%BD%AE/">时间轮</a>进行管理</li><li>还包含一个统计逻辑，进行缓存命中情况的上报</li></ol><p>接下来看看它们是如何运转起来的</p><h4 id="更新缓存"><a class="markdownIt-Anchor" href="#更新缓存"></a> 更新缓存</h4><p>设置缓存要做三件事情</p><ol><li>更新缓存</li><li>将<code>Key</code>到LRU管理中</li><li>添加或更新定时器</li></ol><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/go-zero-cache15.png" alt="go-zero-cache15" style="zoom: 33%;" /><p><strong>问题1</strong>：图中还有一个获取过期时间的过程，设置缓存的时候不是应该已经设置了过期时间了吗，为什么这个地方还要再次获取？</p><p>其实这里获取的与过期时间近似的时间，目的是防止缓存雪崩</p><p><code>deviation</code>:表示一个正负差值</p><p><code>base</code>:给定的过期时间</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>d</mi><mi>e</mi><mi>v</mi><mi>i</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>−</mo><mn>2</mn><mo>∗</mo><mi>d</mi><mi>e</mi><mi>v</mi><mi>i</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>∗</mo><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">v =  (1 + deviation - 2 * deviation * random) * base</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span></span></span></span></span></p><p><strong>问题2</strong>：原理图中还有一个设置<code>limit</code>的过程，为什么在添加的过程中没有体现？</p><p>其实这是<code>LRU</code>内部实现的时候使用的，当<code>LRU</code>双向链表长度大于<code>limit</code>的时候，会直接删除尾部节点</p><h4 id="查询缓存"><a class="markdownIt-Anchor" href="#查询缓存"></a> 查询缓存</h4><p>当缓存存在的时候，需要更新<code>LRU</code>。这里还添加了一个命中的逻辑</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/go-zero-cache16.png" alt="go-zero-cache16" style="zoom: 33%;" /><h4 id="获取缓存"><a class="markdownIt-Anchor" href="#获取缓存"></a> 获取缓存</h4><p>获取缓存与查询缓存不同的是，如果缓存中不存在，那么需要从DB获取数据并插入到缓存中</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/go-zero-cache18.png" alt="go-zero-cache18" style="zoom:33%;" /><p>注意：</p><ol><li>使用共享调用防止缓存穿透</li><li>查询DB操作其实是自定义操作(所以缓存不关心数据来源)</li><li>当缓存不存在，启动共享调用逻辑的时候它再次查询了一次缓存。因为DB操作是IO操作，而查询缓存是 O(1)的<code>map</code>内存操作</li></ol><h4 id="删除缓存"><a class="markdownIt-Anchor" href="#删除缓存"></a> 删除缓存</h4><p>删除分为定时删除以及主动删除，当未更新定时器的时候，那么到期就会主动删除 <code>K/V</code></p><p>如果是主动删除，则直接删除缓存，LRU 和 定时器</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/go-zero-cache17.png" alt="go-zero-cache17" style="zoom:50%;" /><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><p>代码路径：<code>core/collection/cache.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义缓存可选参数</span></span><br><span class="line">CacheOption <span class="function"><span class="keyword">func</span><span class="params">(cache *Cache)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程内缓存对象</span></span><br><span class="line">Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">name           <span class="keyword">string</span><span class="comment">//缓存名称，默认为 defaultCacheName="proc"</span></span><br><span class="line">lock           sync.Mutex             <span class="comment">//map锁</span></span><br><span class="line">data           <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="comment">//存储缓存</span></span><br><span class="line">expire         time.Duration <span class="comment">//过期时间</span></span><br><span class="line">timingWheel    *TimingWheel <span class="comment">//时间轮</span></span><br><span class="line">lruCache       lru <span class="comment">//LRU 缓存淘汰机制</span></span><br><span class="line">barrier        syncx.SingleFlight <span class="comment">//共享调用</span></span><br><span class="line">  unstableExpiry mathx.Unstable <span class="comment">//随机过期时间差值(防止雪崩)</span></span><br><span class="line">stats          *cacheStat            <span class="comment">//缓存统计</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化缓存"><a class="markdownIt-Anchor" href="#初始化缓存"></a> 初始化缓存</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCache</span><span class="params">(expire time.Duration, opts ...CacheOption)</span> <span class="params">(*Cache, error)</span></span> &#123;</span><br><span class="line">cache := &amp;Cache&#123;</span><br><span class="line">data:           <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;),</span><br><span class="line">expire:         expire,</span><br><span class="line">lruCache:       emptyLruCache,</span><br><span class="line">barrier:        syncx.NewSingleFlight(),<span class="comment">//共享调用</span></span><br><span class="line">unstableExpiry: mathx.NewUnstable(expiryDeviation),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//自定义操作包含 limit设置、缓存过期时间范围 expiryDeviation</span></span><br><span class="line"><span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">opt(cache)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(cache.name) == <span class="number">0</span> &#123;</span><br><span class="line">cache.name = defaultCacheName<span class="comment">//默认名称可以忽略</span></span><br><span class="line">&#125;</span><br><span class="line">cache.stats = newCacheStat(cache.name, cache.size)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//时间轮已经订好了1s时间间隔</span></span><br><span class="line">timingWheel, err := NewTimingWheel(time.Second, slots, <span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">key, ok := k.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cache.Del(key)<span class="comment">//到期删除缓存</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cache.timingWheel = timingWheel</span><br><span class="line"><span class="keyword">return</span> cache, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询缓存-2"><a class="markdownIt-Anchor" href="#查询缓存-2"></a> 查询缓存</h4><p>查询缓存很简单</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get returns the item with the given key from c.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">value, ok := c.doGet(key)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">c.stats.IncrementHit()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.stats.IncrementMiss()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> value, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">doGet</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">c.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.lock.Unlock()</span><br><span class="line"></span><br><span class="line">value, ok := c.data[key]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">c.lruCache.add(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> value, ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设置缓存"><a class="markdownIt-Anchor" href="#设置缓存"></a> 设置缓存</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Set 设置缓存，默认使用缓存过期时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Set</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">c.SetWithExpire(key, value, c.expire)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetWithExpire 设置缓存 自定义过期时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">SetWithExpire</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;, expire time.Duration)</span></span> &#123;</span><br><span class="line">c.lock.Lock()</span><br><span class="line">_, ok := c.data[key]</span><br><span class="line">c.data[key] = value</span><br><span class="line">c.lruCache.add(key)</span><br><span class="line">c.lock.Unlock()</span><br><span class="line"></span><br><span class="line">expiry := c.unstableExpiry.AroundDuration(expire)<span class="comment">//获取过期时间</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">c.timingWheel.MoveTimer(key, expiry)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.timingWheel.SetTimer(key, value, expiry)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取缓存-2"><a class="markdownIt-Anchor" href="#获取缓存-2"></a> 获取缓存</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Take</span><span class="params">(key <span class="keyword">string</span>, fetch <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> val, ok := c.doGet(key); ok &#123;<span class="comment">//查询缓存</span></span><br><span class="line">c.stats.IncrementHit()</span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fresh <span class="keyword">bool</span></span><br><span class="line">val, err := c.barrier.Do(key, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// because O(1) on map search in memory, and fetch is an IO query</span></span><br><span class="line"><span class="comment">// so we do double check, cache might be taken by another call</span></span><br><span class="line">    <span class="comment">// 再进行一次缓存操作</span></span><br><span class="line"><span class="keyword">if</span> val, ok := c.doGet(key); ok &#123;</span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v, e := fetch()</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fresh = <span class="literal">true</span></span><br><span class="line">c.Set(key, v)</span><br><span class="line"><span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> fresh &#123;</span><br><span class="line">c.stats.IncrementMiss()</span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// got the result from previous ongoing query</span></span><br><span class="line">c.stats.IncrementHit()</span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除缓存-2"><a class="markdownIt-Anchor" href="#删除缓存-2"></a> 删除缓存</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Del</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">c.lock.Lock()</span><br><span class="line"><span class="built_in">delete</span>(c.data, key)<span class="comment">//删除k/v</span></span><br><span class="line">c.lruCache.remove(key)<span class="comment">//删除LRU</span></span><br><span class="line">c.lock.Unlock()</span><br><span class="line">c.timingWheel.RemoveTimer(key) <span class="comment">//删除定时器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><ol><li>设置缓存过期时间的时候，设置一个范围时间防止缓存雪崩</li><li>使用共享调用去请求数据防止缓存击穿</li><li>通过LRU进行缓存淘汰，当多副本存在可能存在缓存一致性问题</li><li>统计逻辑用于上报，并没有一个开关(可能存在性能问题)</li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://talkgo.org/t/topic/2263" target="_blank" rel="noopener">https://talkgo.org/t/topic/2263</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题背景&quot;&gt;&lt;/a&gt; 问题背景&lt;/h3&gt;
&lt;p&gt;缓存，目的是减少繁重的IO操作，增加系统并发能力。之前做的内存方案&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同一类数据，设计一个双链表，然后添加一
      
    
    </summary>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/categories/go-zero/"/>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>go-zero10-自适应降载</title>
    <link href="http://xboom.github.io/2022/07/19/GoZero/GoZero10-%E8%87%AA%E9%80%82%E5%BA%94%E9%99%8D%E8%BD%BD/"/>
    <id>http://xboom.github.io/2022/07/19/GoZero/GoZero10-%E8%87%AA%E9%80%82%E5%BA%94%E9%99%8D%E8%BD%BD/</id>
    <published>2022-07-19T14:31:29.919Z</published>
    <updated>2022-08-13T07:07:36.473Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h3><p>调用链路错综复杂，做为服务的提供者需要有一种保护自己的机制，防止调用方无脑调用压垮自己，保证自身服务的高可用。自适应降载能根据服务自身的系统负载动态判断是否需要降载，它的目标：</p><ol><li>保证系统不被拖垮</li><li>在系统稳定的前提下，保持系统的吞吐量</li></ol><p><strong>问题</strong>：服务怎么知道自己需要降载？</p><p>通过<code>CPU负载</code>与<code>并发数</code>判断往往存在较大波动，这种被称为毛刺的现象可能导致系统一致频繁的自动进行降载操作。所以如果能通过统计最近一段时间内的指标均值使均值更加平滑</p><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>统计学上有一种算法：<code>滑动平均（exponential moving average）</code>，用来估算变量的<strong>局部均值</strong>，使得变量的更新与历史一段时间的历史取值有关，无需记录所有的历史局部变量就可以实现平均值估算</p><p>变量 V 在 t 时刻记为 Vt，θt 为变量 V 在 t 时刻的取值，即在不使用滑动平均模型时 Vt=θt，在使用滑动平均模型后，Vt 的更新公式如下：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>t</mi><mo>=</mo><mi>β</mi><mo>⋅</mo><mi>V</mi><mi>t</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mi mathvariant="normal">−</mi><mi>β</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>θ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Vt=β⋅Vt−1+(1−β)⋅θt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">t</span><span class="mord">−</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mord mathdefault">t</span></span></span></span></span></p><ul><li>β = 0 时 Vt = θt</li><li>β = 0.9 时,大致相当于过去 10 个 θt 值的平均</li><li>β = 0.99 时,大致相当于过去 100 个 θt 值的平均</li></ul><p>而统计最近一段时间内的数据则可以使用 <a href="https://www.yuankang.top/2022/01/12/Algorithms%20To%20Live%20By/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/#comments" target="_blank" rel="noopener">滑动窗口算法</a>，接下来看看如何进行自适应降载判断</p><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><p>来看看 <code>go-zero</code> 的自适应降载的实现</p><p>代码：<code>core/load/adaptiveshedder.go</code></p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/gozero-zishiying-1.png" alt="gozero-zishiying-1" style="zoom: 50%;" /><h4 id="使用案例"><a class="markdownIt-Anchor" href="#使用案例"></a> 使用案例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnarySheddingInterceptor</span><span class="params">(shedder load.Shedder, metrics *stat.Metrics)</span> <span class="title">grpc</span>.<span class="title">UnaryServerInterceptor</span></span> &#123;</span><br><span class="line">    ensureSheddingStat()</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        handler grpc.UnaryHandler)</span> <span class="params">(val <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">        sheddingStat.IncrementTotal()</span><br><span class="line">        <span class="keyword">var</span> promise load.Promise</span><br><span class="line">        <span class="comment">// 检查是否被降载</span></span><br><span class="line">        promise, err = shedder.Allow()</span><br><span class="line">        <span class="comment">// 降载，记录相关日志与指标</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            metrics.AddDrop()</span><br><span class="line">            sheddingStat.IncrementDrop()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后回调执行结果</span></span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 执行失败</span></span><br><span class="line">            <span class="keyword">if</span> err == context.DeadlineExceeded &#123;</span><br><span class="line">                promise.Fail()</span><br><span class="line">            <span class="comment">// 执行成功</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sheddingStat.IncrementPass()</span><br><span class="line">                promise.Pass()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="comment">// 执行业务方法</span></span><br><span class="line">        <span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅需要调用 Allow 接口进行降载逻辑初始化</p><ol><li>如果降载 <code>shedder.Allow()</code>，那么直接记录信息并返回</li><li>否则执行业务逻辑<ul><li>成功则执行 <code>promise.Pass</code></li><li>失败则执行  <code>promise.Fail</code>，业务调用错误这种算执行成功，这里使用业务超时(<code>DeadlineExceeded</code>)表示执行失败需要降载。</li></ul></li></ol><p>这里的<code>promise</code>变量就是上图中的返回结果句柄，用于将业务逻辑结果更新到降载器中</p><h4 id="接口定义"><a class="markdownIt-Anchor" href="#接口定义"></a> 接口定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">defaultBuckets = <span class="number">50</span><span class="comment">//默认滑动窗口槽</span></span><br><span class="line">defaultWindow  = time.Second * <span class="number">5</span><span class="comment">//默认滑动窗口大小</span></span><br><span class="line">defaultCpuThreshold = <span class="number">900</span><span class="comment">//CPU阈值</span></span><br><span class="line">defaultMinRt        = <span class="keyword">float64</span>(time.Second / time.Millisecond)<span class="comment">//最小速率</span></span><br><span class="line">flyingBeta      = <span class="number">0.9</span><span class="comment">//平均请求 系数</span></span><br><span class="line">coolOffDuration = time.Second<span class="comment">//冷静时间</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">  <span class="comment">//回到函数结果处理</span></span><br><span class="line">Promise <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// 请求成功时回调此函数</span></span><br><span class="line">Pass()</span><br><span class="line"><span class="comment">// 请求失败时回调此函数</span></span><br><span class="line">Fail()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//降载接口</span></span><br><span class="line">Shedder <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// 降载检查</span></span><br><span class="line">    <span class="comment">// 1. 允许调用，需手动执行 Promise.accept()/reject()上报实际执行任务结构</span></span><br><span class="line">    <span class="comment">// 2. 拒绝调用，将会直接返回err：服务过载错误 ErrServiceOverloaded</span></span><br><span class="line">Allow() (Promise, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShedderOption lets caller customize the Shedder.</span></span><br><span class="line">ShedderOption <span class="function"><span class="keyword">func</span><span class="params">(opts *shedderOptions)</span></span></span><br><span class="line"></span><br><span class="line">shedderOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">window       time.Duration</span><br><span class="line">buckets      <span class="keyword">int</span></span><br><span class="line">cpuThreshold <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">adaptiveShedder <span class="keyword">struct</span> &#123;</span><br><span class="line">cpuThreshold    <span class="keyword">int64</span><span class="comment">//CPU阈值</span></span><br><span class="line">windows         <span class="keyword">int64</span><span class="comment">//滑动窗口大小</span></span><br><span class="line">flying          <span class="keyword">int64</span>   <span class="comment">//调度统计</span></span><br><span class="line">avgFlying       <span class="keyword">float64</span> <span class="comment">//平均调度</span></span><br><span class="line">avgFlyingLock   syncx.SpinLock<span class="comment">//调度锁</span></span><br><span class="line">dropTime        *syncx.AtomicDuration<span class="comment">//降载时间</span></span><br><span class="line">droppedRecently *syncx.AtomicBool<span class="comment">//降载标识</span></span><br><span class="line">passCounter     *collection.RollingWindow<span class="comment">//滑动窗口 通过统计</span></span><br><span class="line">rtCounter       *collection.RollingWindow <span class="comment">//滑动窗口 速率统计</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建一个自适应熔断调度器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAdaptiveShedder</span><span class="params">(opts ...ShedderOption)</span> <span class="title">Shedder</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !enabled.True() &#123;</span><br><span class="line"><span class="keyword">return</span> newNopShedder()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//... 可选参数执行</span></span><br><span class="line">  </span><br><span class="line">bucketDuration := options.window / time.Duration(options.buckets)<span class="comment">//滑动窗口槽的大小</span></span><br><span class="line"><span class="keyword">return</span> &amp;adaptiveShedder&#123;</span><br><span class="line">cpuThreshold:    options.cpuThreshold,<span class="comment">//CPU阈值</span></span><br><span class="line">windows:         <span class="keyword">int64</span>(time.Second / bucketDuration), <span class="comment">//1s滑动窗口个数</span></span><br><span class="line">dropTime:        syncx.NewAtomicDuration(),<span class="comment">//熔断时间</span></span><br><span class="line">droppedRecently: syncx.NewAtomicBool(),<span class="comment">//最近是否熔断</span></span><br><span class="line">passCounter: collection.NewRollingWindow(options.buckets, bucketDuration,</span><br><span class="line">collection.IgnoreCurrentBucket()),<span class="comment">//滑动窗口通过统计</span></span><br><span class="line">rtCounter: collection.NewRollingWindow(options.buckets, bucketDuration,</span><br><span class="line">collection.IgnoreCurrentBucket()),<span class="comment">//滑动窗口速率统计</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="逻辑判断"><a class="markdownIt-Anchor" href="#逻辑判断"></a> 逻辑判断</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//降载入口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(as *adaptiveShedder)</span> <span class="title">Allow</span><span class="params">()</span> <span class="params">(Promise, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> as.shouldDrop() &#123;</span><br><span class="line">as.dropTime.Set(timex.Now())</span><br><span class="line">as.droppedRecently.Set(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrServiceOverloaded</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">as.addFlying(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;promise&#123;</span><br><span class="line">start:   timex.Now(),</span><br><span class="line">shedder: as,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="结果句柄操作"><a class="markdownIt-Anchor" href="#结果句柄操作"></a> 结果句柄操作</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> promise <span class="keyword">struct</span> &#123;</span><br><span class="line">start   time.Duration</span><br><span class="line">shedder *adaptiveShedder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *promise)</span> <span class="title">Fail</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.shedder.addFlying(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *promise)</span> <span class="title">Pass</span><span class="params">()</span></span> &#123;</span><br><span class="line">rt := <span class="keyword">float64</span>(timex.Since(p.start)) / <span class="keyword">float64</span>(time.Millisecond)<span class="comment">//花费的毫秒数</span></span><br><span class="line">p.shedder.addFlying(<span class="number">-1</span>)</span><br><span class="line">p.shedder.rtCounter.Add(math.Ceil(rt))</span><br><span class="line">p.shedder.passCounter.Add(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意</p><ol><li>其中的 <code>p.shedder.addFlying(-1)</code> 也就是说 <code>flying</code> 变量用于更新调度请求数量的</li><li>失败并不会记录到调度统计中，因为计算平均请求不需要失败</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(as *adaptiveShedder)</span> <span class="title">addFlying</span><span class="params">(delta <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">flying := atomic.AddInt64(&amp;as.flying, delta) <span class="comment">//请求数量更新</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当请求完成时更新 avgFlying。</span></span><br><span class="line"><span class="comment">// 这个策略使得 avgFlying 相对 flying 有一点延迟，并且更平滑。</span></span><br><span class="line"><span class="comment">// 当 flying 请求快速增加时，avgFlying 增加较慢，接受更多请求。</span></span><br><span class="line"><span class="comment">// 当 flying 请求快速下降时，avgFlying 下降较慢，接受较少的请求。</span></span><br><span class="line"><span class="comment">// 它使服务尽可能多地处理请求。</span></span><br><span class="line"><span class="keyword">if</span> delta &lt; <span class="number">0</span> &#123;<span class="comment">//当 &lt; 0 表示 请求完成，计算平均请求</span></span><br><span class="line">as.avgFlyingLock.Lock()</span><br><span class="line">as.avgFlying = as.avgFlying*flyingBeta + <span class="keyword">float64</span>(flying)*(<span class="number">1</span>-flyingBeta)<span class="comment">//滑动平均算法</span></span><br><span class="line">as.avgFlyingLock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="cpu超过限制"><a class="markdownIt-Anchor" href="#cpu超过限制"></a> CPU超过限制</h5><p>这里的CPU也是经过定时统计得出的最近一段时间CPU负载，防止毛刺</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemOverloadChecker = <span class="function"><span class="keyword">func</span><span class="params">(cpuThreshold <span class="keyword">int64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> stat.CpuUsage() &gt;= cpuThreshold</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="过载中判断"><a class="markdownIt-Anchor" href="#过载中判断"></a> 过载中判断</h5><p>如果是正在过载中则，超过一段时间冷静期就恢复正常</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/gozero-zishiying-2.png" alt="gozero-zishiying-2" style="zoom:50%;" /><p>过载标识/时间 是当初过载时候设置的 <code>dropTime</code> 与<code>droppedRecently</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//过载中判断</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(as *adaptiveShedder)</span> <span class="title">stillHot</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !as.droppedRecently.True() &#123;<span class="comment">//是否过热中</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dropTime := as.dropTime.Load()<span class="comment">//加载降载时间</span></span><br><span class="line"><span class="keyword">if</span> dropTime == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hot := timex.Since(dropTime) &lt; coolOffDuration<span class="comment">//是否超过冷静期</span></span><br><span class="line"><span class="keyword">if</span> !hot &#123;</span><br><span class="line">as.droppedRecently.Set(<span class="literal">false</span>)<span class="comment">//更新降载标识</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="过载判断"><a class="markdownIt-Anchor" href="#过载判断"></a> 过载判断</h5><p>过载判断 的逻辑是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//平均请求数大于 且 当前未完成请求的数量超过了最大请求数</span></span><br><span class="line">avgFlying &gt; maxFlight &amp;&amp; flying &gt; maxFlight</span><br></pre></td></tr></table></figure><p>这个 最大并发数 又是怎样计算的呢？</p><blockquote><p>当前系统的最大并发数 = 窗口单位时间内的最大通过数量 * 窗口单位时间内的最小响应时间</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(as *adaptiveShedder)</span> <span class="title">maxFlight</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"><span class="comment">// windows = buckets per second</span></span><br><span class="line"><span class="comment">// maxQPS = maxPASS * windows</span></span><br><span class="line"><span class="comment">// minRT = min average response time in milliseconds</span></span><br><span class="line"><span class="comment">// maxQPS * minRT / milliseconds_per_second</span></span><br><span class="line">  <span class="comment">// as.maxPass()*as.windows - 每个桶最大的qps * 1s内包含桶的数量</span></span><br><span class="line">  <span class="comment">// as.minRt()/1e3 - 窗口所有桶中最小的平均响应时间 / 1000ms这里是为了转换成秒</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int64</span>(math.Max(<span class="number">1</span>, <span class="keyword">float64</span>(as.maxPass()*as.windows)*(as.minRt()/<span class="number">1e3</span>)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前滑动窗口中的最大请求的统计</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(as *adaptiveShedder)</span> <span class="title">maxPass</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">float64</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">as.passCounter.Reduce(<span class="function"><span class="keyword">func</span><span class="params">(b *collection.Bucket)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> b.Sum &gt; result &#123;</span><br><span class="line">result = b.Sum</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int64</span>(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前滑动窗口中最小速率的统计</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(as *adaptiveShedder)</span> <span class="title">minRt</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">result := defaultMinRt</span><br><span class="line"></span><br><span class="line">as.rtCounter.Reduce(<span class="function"><span class="keyword">func</span><span class="params">(b *collection.Bucket)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> b.Count &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">avg := math.Round(b.Sum / <span class="keyword">float64</span>(b.Count))</span><br><span class="line"><span class="keyword">if</span> avg &lt; result &#123;</span><br><span class="line">result = avg</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>自适应降载逻辑处理 当请求突然增大的时候，虽然没有达到服务能够承受的极限，也有可能出现降载。因为平均请求数量以及最大请求数量 都超过了最近一段时间能承载的最大水平</li><li>按照第一条逻辑，如果服务刚启动那会请求确实比较多，是不是就会出现降载了。不会，这里在计算 最大并发数的时候，给定了一个最小最大并发数 <code>1 * defaultMinRt / milliseconds_per_second</code> 。也就是并发数低于 1000的时候也不会触发降载</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://talkgo.org/t/topic/3058" target="_blank" rel="noopener">https://talkgo.org/t/topic/3058</a></li><li><a href="https://www.cnblogs.com/wuliytTaotao/p/9479958.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuliytTaotao/p/9479958.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题背景&quot;&gt;&lt;/a&gt; 问题背景&lt;/h3&gt;
&lt;p&gt;调用链路错综复杂，做为服务的提供者需要有一种保护自己的机制，防止调用方无脑调用压垮自己，保证自身服务的高可用。自适应降载能根据服务自
      
    
    </summary>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/categories/go-zero/"/>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>go-zero6-服务管理</title>
    <link href="http://xboom.github.io/2022/07/19/GoZero/GoZero6-%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    <id>http://xboom.github.io/2022/07/19/GoZero/GoZero6-%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/</id>
    <published>2022-07-19T14:31:29.919Z</published>
    <updated>2022-07-20T16:55:50.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h3><p>之前云平台是基于MQ实现的通信机制，后来需要将通信方式切换为Grpc但又不想修改老的接口和自定义逻辑。所以就需要修改原本的库。因为内部包含了配置加载、MQ适配、Grpc功能、服务注册发现、链路追踪、自定义功能(限速、大包处理、调试、过滤、统计、存储…)。这些子服务是相互独立且可选(不启用也可以)，部分存在依赖关系。所以就想着使用服务管理的方式管理这些小功能，并按照期望的方式进行启动运行</p><h3 id="实现方案"><a class="markdownIt-Anchor" href="#实现方案"></a> 实现方案</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"context"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServerNum <span class="keyword">uint8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">DemoA ServerNum = <span class="literal">iota</span></span><br><span class="line">DemoB</span><br><span class="line">    MaxServerNum</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> serverList = []Server&#123;</span><br><span class="line">DemoA: &amp;Server1&#123;&#125;,</span><br><span class="line">DemoB: &amp;Server2&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">interface</span> &#123;</span><br><span class="line">Start(ctx context.Context) (Server, error)<span class="comment">//服务启动</span></span><br><span class="line">ID() <span class="keyword">int</span><span class="comment">//返回服务标志，用于循序启动</span></span><br><span class="line">Close() error<span class="comment">//关闭服务</span></span><br><span class="line">IsOpen() <span class="keyword">bool</span><span class="comment">//是否开启</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Start</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> serverList &#123;</span><br><span class="line">v.Start(ctx)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务管理</span></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务启动入口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span><span class="title">Start</span><span class="params">(ctx context.Context, s Server)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> || !s.IsOpen() &#123;<span class="comment">//未设置对象或未开启则直接退出</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">v, err := s.Start(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">key := v.ID()<span class="comment">//构建k/v进行服务句柄存储</span></span><br><span class="line"><span class="comment">//TODO 这里使用 封装的context</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span><span class="title">Stop</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := MaxServerNum - <span class="number">1</span>; i &gt;=<span class="number">0</span>; i++ &#123;</span><br><span class="line">v := serverList[i]</span><br><span class="line"><span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">v.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>单个服务内的子模块是否相互依赖的，所以这里使用切片进行存储，关闭时按照启动顺序的反方向</li><li>构建 <code>IsOpen</code> 方便根据配置加载服务需要的模块</li><li>服务句柄的存储暂时保存，需要使用服务句柄也许直接使用大写暴露会更好，或者使用不需要句柄的外部函数</li><li>注意服务的常驻等待(例如HTTP服务就是Listen之后不做后续处理，这个时候就需要使用协程拉起)，而所有服务加载完成之后，需要有一个常驻等待逻辑</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Loop</span><span class="params">()</span></span> &#123;</span><br><span class="line">exit := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(exit, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> sig := &lt;- exit:</span><br><span class="line">log.Infof(context.Background(), <span class="string">"recv signal %s"</span>, sig.String())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><p>代码： <code>core/service/servicegroup.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/zeromicro/go-zero/core/service"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// more code</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  group := service.NewServiceGroup()<span class="comment">//初始化管理对象</span></span><br><span class="line">  <span class="keyword">defer</span> group.Stop()<span class="comment">//停止</span></span><br><span class="line">  group.Add(Morning&#123;&#125;)<span class="comment">//添加服务morning</span></span><br><span class="line">  group.Add(Evening&#123;&#125;)<span class="comment">//添加服务evening</span></span><br><span class="line">  group.Start()<span class="comment">//服务开启</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">Starter <span class="keyword">interface</span> &#123;<span class="comment">//开启接口</span></span><br><span class="line">Start()</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">Stopper <span class="keyword">interface</span> &#123;<span class="comment">//停止接口</span></span><br><span class="line">Stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务接口，开启与停止</span></span><br><span class="line">Service <span class="keyword">interface</span> &#123;</span><br><span class="line">Starter</span><br><span class="line">Stopper</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务批量管理接口</span></span><br><span class="line">ServiceGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">services []Service<span class="comment">//切片保存服务</span></span><br><span class="line">stopOnce <span class="function"><span class="keyword">func</span><span class="params">()</span>//停止一次接口</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="初始化对象"><a class="markdownIt-Anchor" href="#初始化对象"></a> 初始化对象</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewServiceGroup returns a ServiceGroup.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServiceGroup</span><span class="params">()</span> *<span class="title">ServiceGroup</span></span> &#123;</span><br><span class="line">sg := <span class="built_in">new</span>(ServiceGroup)</span><br><span class="line">sg.stopOnce = syncx.Once(sg.doStop)<span class="comment">//停止逻辑使用sync.Once 处理</span></span><br><span class="line"><span class="keyword">return</span> sg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="增加对象"><a class="markdownIt-Anchor" href="#增加对象"></a> 增加对象</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Add 服务管理中添加自定义服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sg *ServiceGroup)</span> <span class="title">Add</span><span class="params">(service Service)</span></span> &#123;</span><br><span class="line"><span class="comment">// push front, stop with reverse order.</span></span><br><span class="line">sg.services = <span class="built_in">append</span>([]Service&#123;service&#125;, sg.services...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开启服务"><a class="markdownIt-Anchor" href="#开启服务"></a> 开启服务</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Start 服务管理启动</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sg *ServiceGroup)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">proc.AddShutdownListener(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="comment">//将服务添加到退出监听中</span></span><br><span class="line">log.Println(<span class="string">"Shutting down..."</span>)</span><br><span class="line">sg.stopOnce()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">sg.doStart()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//doStart 开始</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sg *ServiceGroup)</span> <span class="title">doStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">routineGroup := threading.NewRoutineGroup()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> sg.services &#123;</span><br><span class="line">service := sg.services[i]</span><br><span class="line">    routineGroup.RunSafe(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="comment">//使用每个服务使用协程开启(包含panic处理)</span></span><br><span class="line">service.Start()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">routineGroup.Wait()<span class="comment">//等待退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用协程池进行每个服务的启动，所以每个服务启动的顺序是不一定的</li><li>使用RunSafe进行服务启动，所以一个服务panic，另外的服务也能启动</li></ol><h4 id="服务关闭"><a class="markdownIt-Anchor" href="#服务关闭"></a> 服务关闭</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stop stops the ServiceGroup.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sg *ServiceGroup)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;NewCache</span><br><span class="line">   sg.stopOnce()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//停止服务管理(服务初始化的时候已经设置好了)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sg *ServiceGroup)</span> <span class="title">doStop</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, service := <span class="keyword">range</span> sg.services &#123;</span><br><span class="line">service.Stop()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="仅有开启服务"><a class="markdownIt-Anchor" href="#仅有开启服务"></a> 仅有开启服务</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WithStart wraps a start func as a Service.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithStart</span><span class="params">(start <span class="keyword">func</span>()</span>) <span class="title">Service</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> startOnlyService&#123;</span><br><span class="line">start: start,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WithStarter wraps a Starter as a Service.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithStarter</span><span class="params">(start Starter)</span> <span class="title">Service</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> starterOnlyService&#123;</span><br><span class="line">Starter: start,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">stopper <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">startOnlyService <span class="keyword">struct</span> &#123;</span><br><span class="line">start <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">stopper</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">starterOnlyService <span class="keyword">struct</span> &#123;</span><br><span class="line">Starter</span><br><span class="line">stopper</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s stopper)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s startOnlyService)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">s.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>由于子服务无法保证启动顺序，所以各服务之间不能有相互依赖或关联</li><li>使用 <code>stopOnce</code> 防止出现多次调用<code>stop</code>的情况</li><li>使用 <code>proc.AddShutdownListener</code>做退出监听</li></ol><p>优化：</p><ol><li>如果能控制服务启动和调用顺序是否会更好(一个服务内的多个子模块必然存在先后启动关系)，那么停止服务的时候也注意先后关系</li><li>如果使用协程池拉起服务，那么单个服务的异常无法让所有子服务都退出。缺少一个同步退出机制</li><li>使用 <code>startOnlyService</code>是否有点多余，在服务停止中不做任何处理，那么退出时也能正常退出</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://mp.weixin.qq.com/s/G6WG_-C6d-raoRmH4hBjoQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/G6WG_-C6d-raoRmH4hBjoQ</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题背景&quot;&gt;&lt;/a&gt; 问题背景&lt;/h3&gt;
&lt;p&gt;之前云平台是基于MQ实现的通信机制，后来需要将通信方式切换为Grpc但又不想修改老的接口和自定义逻辑。所以就需要修改原本的库。因为内
      
    
    </summary>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/categories/go-zero/"/>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>go-zero5-时间轮</title>
    <link href="http://xboom.github.io/2022/07/08/GoZero/GoZero5-%E6%97%B6%E9%97%B4%E8%BD%AE/"/>
    <id>http://xboom.github.io/2022/07/08/GoZero/GoZero5-%E6%97%B6%E9%97%B4%E8%BD%AE/</id>
    <published>2022-07-07T16:22:06.133Z</published>
    <updated>2022-07-17T08:41:58.841Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h3><p>一个系统中存在着大量的延迟/定时任务：</p><ol><li>在一个间隔时间之后做某事: 例如在最后一次消息发送的5分钟之后, 断开连接</li><li>在一个间隔时间之后不停的做某事: 例如每隔5分钟之后去发送心跳，检测连接是否正常</li></ol><p>如果每个任务都使用自己的调度器来管理任务声明周期的话，浪费CPU的资源而且很低效，比如：</p><ol><li>在定时器的数量增长到百万级之后, 基于最小堆实现的定时器的性能会显著降低</li><li>客户端会定时发送心跳以此来确保连接的可用性。导致每个连接都需要新建一些协程去维护</li></ol><h3 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h3><p>延迟操作，通常可以采用两个方案：</p><ol><li><code>Timer</code>：定时器维护一个优先队列，到时间点执行，然后把需要执行的 <code>task</code> 存储在 <code>map</code> 中</li><li><code>collection</code> 中的 <code>timingWheel</code> ，维护一个存放任务组的数组，每一个槽都维护一个存储 <code>task</code> 的双向链表。开始执行时，计时器每隔指定时间执行一个槽里面的 <code>tasks</code></li></ol><p>时间轮是一种高效来利用线程资源来进行批量化调度的一种调度模型。把大批量的调度任务全部都绑定到同一个的调度器上面，使用这一个调度器来进行所有任务的管理<code>(manager)</code>，触发<code>(trigger)</code>以及运行<code>(runnable)</code></p><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>使用一个 <code>类Map</code> 的结构进行时间轮而构建，其中：</p><ol><li>定时器的间隔就是从第n个槽进入到第n+1个槽的时间</li><li>每个槽中的任务通过双向链表进行存储，定时器到达槽的位置之后，并发处理槽的任务(指定时间相同)</li></ol><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/timingwheel21.png" alt="timingwheel21" style="zoom: 50%;" /><p><strong>问题1</strong>：新建的任务如何添加到对应的位置</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/timingwheel22.png" alt="timingwheel22" style="zoom:50%;" /><p>如上图，槽位<code>(numSlots)</code>为12的时间轮，时间轮的定时间隔<code>(interval)</code>为1s，当前正在执行槽<code>(tickedPos)</code>为1位置的任务。</p><p>当添加一个延时时间<code>(delay)</code>为5s的任务的时候，那么：</p><ol><li>需要等待的间隔数<code>step</code>：<strong><code>step = delay / interval</code></strong>  为 5。</li><li>需要放入的槽的位置<code>position</code>:<strong><code>position = (step + tickedPos) % numSlots</code></strong> 为 6。</li></ol><p><strong>问题2</strong>：新建任务超过槽的数目怎么办？</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/timingwheel24.png" alt="timingwheel24" style="zoom:50%;" /><p>如上图，当添加一个延时时间<code>(delay)</code>为18s的时候，根据上面的计算公司</p><ol><li>需要等待的间隔数<code>step = delay / interval =</code> 18</li><li>需要放入的槽的位置 <code>postion = (step + tickedPos) % numSlots =</code> 6。</li></ol><p>这个时候就出现一个问题，延迟5s的任务和延迟18s的任务会一起在5s后执行，这个时候就出现了多层环的概念</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/timingwheel25.png" alt="timingwheel25" style="zoom:50%;" /><p>当第一层环的时间无法满足任务的延时的时候，可以将任务放置到第n层环上。时间轮还是会按照环的顺序进行执行</p><p>环的位置<code>circle</code>: <strong><code>circle = (steps - 1) / numSlots</code></strong></p><p>所以延时5s的任务它的环 <code>circle = (5 - 1) / 12 = 0</code>，延时18s的任务它的环 <code>circle = (18 -1)/12 = 1</code></p><p>随着时间的推移第一层环完成之后再去执行第二层环</p><p><strong>问题3</strong>：不同环的任务是否都需要构建一个新的环来保存任务</p><p><strong>不需要</strong>，不同环但是槽相同的任务放入到同一个双向链表中，当执行该槽任务的时候，只需要判断当前的任务<code>if circle == 0</code>，否则就不是当前环的任务，将<code>circle -= 1</code></p><p>这样也有一个缺点：就是在遍历槽中任务的时候，虽然不是相同时间执行，但是槽中所有任务都需要遍历。不过一个微服务中定时任务也不会太多，所以缺点基本可以忽略</p><p><strong>问题4</strong>：定时任务时间轮都是是如何处理的</p><p>根据任务类型可以分为<strong>延时任务</strong>与<strong>定时任务</strong>。根据任务执行一次可以分为<strong>执行一次</strong>和<strong>重复执行</strong>。这里有两点需要解决</p><ol><li>不同类型任务的开始时间是怎么计算开始时间的</li><li>需要重复的任务是如何存储的</li></ol><ul><li>延时任务<ul><li>执行一次：根据延时时间计算在时间轮中的位置，定时触发即可</li><li>重复执行：每次执行任务完成，判断任务是否重复，然后重新计算任务位置重新插入即可</li></ul></li><li>定时任务：<ul><li>执行一次：</li></ul></li></ul><p><strong>问题5</strong>：如果一个时间间隔内时间任务处理不过来怎么办</p><p>通过下一节技术内幕来查看处理逻辑。不过可以预想到的是每个槽都会拉起协程来进行任务处理，如果是顺序执行有可能导致部分任务超出执行时间，所以每个任务都会使用一个协程处理，那么这里就可以考虑协程池以及对象池了。</p><p><strong>问题6</strong>：如果一个任务的延时时间小于时间轮的时间片间隔，那么任务何时执行</p><p>这里有两个解决方案，<code>go-zero</code>使用第一种方案：</p><ol><li><p>由于小于延时时间小于时间间隔，那么就认为任务不需要等到下一个时间轮的时间片执行，而是立即执行</p></li><li><p>利用多层环的原理处理更细粒度的任务。这样就不能重用<code>circle</code>的概念，而是需要 <code>sub circle</code>子环概念</p><ul><li><code>circle</code>用来解决延时时间超过当前环的问题</li><li><code>sub circle</code>用来解决更细粒度的时间片需求。缺点就是逻辑结构更复杂，每个<code>sub circle</code>都需要有一个更细的时间粒度</li></ul><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/timingwheel27.png" alt="timingwheel27" style="zoom:33%;" /></li></ol><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><p>代码路径：<code>core/collection/timingwheel.go</code>，前一节就是 <code>go-zero</code> 中时间轮的时间原理</p><h4 id="时间轮对象"><a class="markdownIt-Anchor" href="#时间轮对象"></a> 时间轮对象</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A TimingWheel is a timing wheel object to schedule tasks.</span></span><br><span class="line">TimingWheel <span class="keyword">struct</span> &#123;</span><br><span class="line">interval      time.Duration<span class="comment">//时间划分刻度</span></span><br><span class="line">ticker        timex.Ticker</span><br><span class="line">slots         []*list.List<span class="comment">//数组内为双向链表指针</span></span><br><span class="line">timers        *SafeMap <span class="comment">//</span></span><br><span class="line">tickedPos     <span class="keyword">int</span> <span class="comment">//环的位置</span></span><br><span class="line">numSlots      <span class="keyword">int</span> <span class="comment">//时间槽</span></span><br><span class="line">execute       Execute <span class="comment">//时间点执行任务的方法</span></span><br><span class="line">  <span class="comment">//以下为不同任务的隧道</span></span><br><span class="line">setChannel    <span class="keyword">chan</span> timingEntry<span class="comment">//设置任务隧道</span></span><br><span class="line">moveChannel   <span class="keyword">chan</span> baseEntry<span class="comment">//移动任务隧道</span></span><br><span class="line">removeChannel <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;  <span class="comment">//删除任务隧道</span></span><br><span class="line">drainChannel  <span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span> //并发执行任务隧道</span></span><br><span class="line">stopChannel   <span class="keyword">chan</span> lang.PlaceholderType <span class="comment">//时间轮停止通知隧道</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Execute 执行任务的方法</span></span><br><span class="line">Execute <span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//timingEntry </span></span><br><span class="line">timingEntry <span class="keyword">struct</span> &#123;  <span class="comment">//时间轮实体对象</span></span><br><span class="line">baseEntry</span><br><span class="line">value   <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">circle  <span class="keyword">int</span></span><br><span class="line">diff    <span class="keyword">int</span></span><br><span class="line">removed <span class="keyword">bool</span><span class="comment">//是否删除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//baseEntry 基础属性</span></span><br><span class="line">baseEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">delay time.Duration</span><br><span class="line">key   <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//positionEntry 位置对象</span></span><br><span class="line">positionEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">pos  <span class="keyword">int</span></span><br><span class="line">item *timingEntry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//timingTask 时间任务</span></span><br><span class="line">timingTask <span class="keyword">struct</span> &#123;</span><br><span class="line">key   <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ol><li><p>每个槽中因为是链表，所以并没有数量限制</p></li><li><p>时间轮实体<code>timingEntry</code>中有两个值需要关注 <code>diff</code> 和 <code>removed</code></p></li><li><p>时间轮结构中 <code>timers</code> 作用往下看</p><blockquote><p><code>timers</code> 使用的 <code>SafeMap</code> 不仅仅是为了处理并发安全，还有就是原生<code>map</code>内存泄露问题的临时替代品(详见《GoZero-SafeMap》)</p></blockquote></li></ol><h4 id="初始化时间轮"><a class="markdownIt-Anchor" href="#初始化时间轮"></a> 初始化时间轮</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewTimingWheel 初始化并返回一个时间轮</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimingWheel</span><span class="params">(interval time.Duration, numSlots <span class="keyword">int</span>, execute Execute)</span> <span class="params">(*TimingWheel, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> interval &lt;= <span class="number">0</span> || numSlots &lt;= <span class="number">0</span> || execute == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"interval: %v, slots: %d, execute: %p"</span>,</span><br><span class="line">interval, numSlots, execute)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newTimingWheelWithClock(interval, numSlots, execute, timex.NewTicker(interval))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//newTimingWheelWithClock 初始化时间轮</span></span><br><span class="line"><span class="comment">//interval：时间划分刻度</span></span><br><span class="line"><span class="comment">//numSlots：时间槽</span></span><br><span class="line"><span class="comment">//execute：时间点执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTimingWheelWithClock</span><span class="params">(interval time.Duration, numSlots <span class="keyword">int</span>, execute Execute,</span></span></span><br><span class="line"><span class="function"><span class="params">ticker timex.Ticker)</span> <span class="params">(*TimingWheel, error)</span></span> &#123;</span><br><span class="line">tw := &amp;TimingWheel&#123;</span><br><span class="line">  interval:      interval,                     <span class="comment">// 单个时间格时间间隔</span></span><br><span class="line">    ticker:        ticker,                       <span class="comment">// 定时器，做时间推动，以interval为单位推进</span></span><br><span class="line">    slots:         <span class="built_in">make</span>([]*list.List, numSlots), <span class="comment">// 时间轮</span></span><br><span class="line">    timers:        NewSafeMap(),                 <span class="comment">// 存储task&#123;key, value&#125;的map [执行execute所需要的参数]</span></span><br><span class="line">    tickedPos:     numSlots - <span class="number">1</span>,                 <span class="comment">// at previous virtual circle</span></span><br><span class="line">    execute:       execute,                      <span class="comment">// 执行函数</span></span><br><span class="line">    numSlots:      numSlots,                     <span class="comment">// 初始化 slots num</span></span><br><span class="line">    setChannel:    <span class="built_in">make</span>(<span class="keyword">chan</span> timingEntry),       <span class="comment">// 以下几个channel是做task传递的</span></span><br><span class="line">moveChannel:   <span class="built_in">make</span>(<span class="keyword">chan</span> baseEntry),</span><br><span class="line">removeChannel: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;),</span><br><span class="line">drainChannel:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span>),</span></span><br><span class="line">stopChannel:   <span class="built_in">make</span>(<span class="keyword">chan</span> lang.PlaceholderType),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  tw.initSlots()<span class="comment">//使用list.New()初始化每个槽，构建双向链表保存任务</span></span><br><span class="line"><span class="keyword">go</span> tw.run()<span class="comment">//开启协程，使用channel来做task时间任务接收与处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tw, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据隧道类型等待不同的任务执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-tw.ticker.Chan():</span><br><span class="line">tw.onTick()</span><br><span class="line"><span class="keyword">case</span> task := &lt;-tw.setChannel:<span class="comment">//收到设置任务</span></span><br><span class="line">tw.setTask(&amp;task)</span><br><span class="line"><span class="keyword">case</span> key := &lt;-tw.removeChannel:<span class="comment">//删除隧道</span></span><br><span class="line">tw.removeTask(key)</span><br><span class="line"><span class="keyword">case</span> task := &lt;-tw.moveChannel:<span class="comment">//重复任务隧道</span></span><br><span class="line">tw.moveTask(task)</span><br><span class="line"><span class="keyword">case</span> fn := &lt;-tw.drainChannel:<span class="comment">//并发任务</span></span><br><span class="line">tw.drainAll(fn)</span><br><span class="line"><span class="keyword">case</span> &lt;-tw.stopChannel:<span class="comment">//停止隧道</span></span><br><span class="line">tw.ticker.Stop()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/timingwheel26.png" alt="timingwheel26" style="zoom:33%;" /><p>在时间轮拉起协程进行隧道的监听与处理，这里需要注意的是：</p><ol><li>除了时间轮的定时器隧道，其他隧道都可以通过外部接口将消息传入处理</li><li>其中<code>moveChannel</code>和<code>drainChannel</code>需要解释：<ul><li><code>moveChannel</code>：更新任务延时时间</li><li><code>drainChannel</code>：使用自定义函数并发执行所有任务</li></ul></li></ol><h4 id="添加任务"><a class="markdownIt-Anchor" href="#添加任务"></a> 添加任务</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetTimer 设置过期时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">SetTimer</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;, delay time.Duration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> delay &lt;= <span class="number">0</span> || key == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ErrArgument</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> tw.setChannel &lt;- timingEntry&#123;<span class="comment">//向设置隧道中添加一个基础的任务对象</span></span><br><span class="line">baseEntry: baseEntry&#123;</span><br><span class="line">delay: delay,</span><br><span class="line">key:   key,</span><br><span class="line">&#125;,</span><br><span class="line">value: value,</span><br><span class="line">&#125;:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span><span class="comment">//设置完直接结束</span></span><br><span class="line"><span class="keyword">case</span> &lt;-tw.stopChannel:<span class="comment">//当设置过程中收到退出通知则直接退出</span></span><br><span class="line"><span class="keyword">return</span> ErrClosed</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//setTask 时间轮收到设置任务任务之后进行任务添加</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">setTask</span><span class="params">(task *timingEntry)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> task.delay &lt; tw.interval &#123;<span class="comment">//如果任务延迟时间小于时间轮的刻度，那么延迟时间等于刻度</span></span><br><span class="line">task.delay = tw.interval</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> val, ok := tw.timers.Get(task.key); ok &#123; <span class="comment">//如果已经存在这个任务，更新任务</span></span><br><span class="line">entry := val.(*positionEntry)</span><br><span class="line">entry.item.value = task.value</span><br><span class="line">tw.moveTask(task.baseEntry)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pos, circle := tw.getPositionAndCircle(task.delay) <span class="comment">//根据延时获取任务位置</span></span><br><span class="line">task.circle = circle<span class="comment">//设置任务所在的环</span></span><br><span class="line">tw.slots[pos].PushBack(task) <span class="comment">//将任务添加到对应槽中</span></span><br><span class="line">tw.setTimerPosition(pos, task)  <span class="comment">//更新任务最新位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>在添加任务的时候这里的 value 类型是 <code>interface</code> 类型，而不是指定的任务对象</li><li>注意这里使用 <code>setTimerPosition</code> 又缓存任务，它的作用往下看</li></ul><p>如 <em>实现原理</em> 中介绍的那样计算任务所在的<code>槽</code>以及<code>环</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getPositionAndCircle 获取位置与环</span></span><br><span class="line"><span class="comment">//@param: d 任务延时时间</span></span><br><span class="line"><span class="comment">//@return:</span></span><br><span class="line"><span class="comment">// pos 任务所在槽</span></span><br><span class="line"><span class="comment">// circle 任务环</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">getPositionAndCircle</span><span class="params">(d time.Duration)</span> <span class="params">(pos, circle <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//如果将任务的延迟时间按照时间轮刻度划分，那么 steps 就是在第几个刻度内</span></span><br><span class="line">steps := <span class="keyword">int</span>(d / tw.interval)</span><br><span class="line">  <span class="comment">// 时间轮的相对位置 + 延迟相对时间刻度的位置 % 槽的数量  = 任务在时间轮中的位置</span></span><br><span class="line">pos = (tw.tickedPos + steps) % tw.numSlots</span><br><span class="line">circle = (steps - <span class="number">1</span>) / tw.numSlots</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置任务的位置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//setTimerPosition 设置任务位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">setTimerPosition</span><span class="params">(pos <span class="keyword">int</span>, task *timingEntry)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> val, ok := tw.timers.Get(task.key); ok &#123;<span class="comment">//如果任务缓存已经存在，那么更新槽的位置</span></span><br><span class="line">timer := val.(*positionEntry)</span><br><span class="line">timer.item = task</span><br><span class="line">timer.pos = pos</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tw.timers.Set(task.key, &amp;positionEntry&#123;  <span class="comment">//如果任务缓存不存在，则设置任务缓存</span></span><br><span class="line">pos:  pos,</span><br><span class="line">item: task,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 时间轮中 <code>timers</code>其实是通过<code>key</code>保存任务，并把完成任务和位置都保存</p><h4 id="更新任务"><a class="markdownIt-Anchor" href="#更新任务"></a> 更新任务</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MoveTimer移动任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">MoveTimer</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, delay time.Duration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> delay &lt;= <span class="number">0</span> || key == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ErrArgument</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> tw.moveChannel &lt;- baseEntry&#123;</span><br><span class="line">delay: delay,</span><br><span class="line">key:   key,</span><br><span class="line">&#125;:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;-tw.stopChannel:</span><br><span class="line"><span class="keyword">return</span> ErrClosed</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//moveTask 更新任务执行位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">moveTask</span><span class="params">(task baseEntry)</span></span> &#123;</span><br><span class="line">  val, ok := tw.timers.Get(task.key)  <span class="comment">//通过key获取任务(因为是移动，所以当任务不存在，那么直接结束。)</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timer := val.(*positionEntry)</span><br><span class="line"><span class="keyword">if</span> task.delay &lt; tw.interval &#123;<span class="comment">//如果任务的delay小于时间片，那么立即执行</span></span><br><span class="line">threading.GoSafe(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;   <span class="comment">//拉起协程进行执行</span></span><br><span class="line">tw.execute(timer.item.key, timer.item.value) </span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pos, circle := tw.getPositionAndCircle(task.delay)  <span class="comment">//计算任务位置</span></span><br><span class="line"><span class="keyword">if</span> pos &gt;= timer.pos &#123;</span><br><span class="line">timer.item.circle = circle</span><br><span class="line">timer.item.diff = pos - timer.pos   <span class="comment">//计算任务位置与缓存中任务位置的不同</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> circle &gt; <span class="number">0</span> &#123; <span class="comment">//不是当前环的任务，那么 circl - 1</span></span><br><span class="line">circle--</span><br><span class="line">timer.item.circle = circle</span><br><span class="line">timer.item.diff = tw.numSlots + pos - timer.pos <span class="comment">//不同 加上一个环的槽数，判断位置是否相同</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">timer.item.removed = <span class="literal">true</span></span><br><span class="line">newItem := &amp;timingEntry&#123;</span><br><span class="line">baseEntry: task,</span><br><span class="line">value:     timer.item.value,</span><br><span class="line">&#125;</span><br><span class="line">tw.slots[pos].PushBack(newItem)</span><br><span class="line">tw.setTimerPosition(pos, newItem)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>移动任务<code>MoveTimer(key interface{}, delay time.Duration) error {... }</code>并没有参数 <code>Value</code>，用来移动更新已有的任务</li></ol><h4 id="执行任务"><a class="markdownIt-Anchor" href="#执行任务"></a> 执行任务</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时器触发任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">onTick</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//获取需要执行任务的槽位置</span></span><br><span class="line">  tw.tickedPos = (tw.tickedPos + <span class="number">1</span>) % tw.numSlots </span><br><span class="line">l := tw.slots[tw.tickedPos] <span class="comment">//获取槽的对应链表</span></span><br><span class="line">tw.scanAndRunTasks(l)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">scanAndRunTasks</span><span class="params">(l *list.List)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> tasks []timingTask</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e := l.Front(); e != <span class="literal">nil</span>; &#123;<span class="comment">//遍历链表</span></span><br><span class="line">task := e.Value.(*timingEntry)</span><br><span class="line"><span class="keyword">if</span> task.removed &#123;<span class="comment">//如果任务状态为删除，则从任务链表中删除任务</span></span><br><span class="line">next := e.Next()</span><br><span class="line">l.Remove(e)</span><br><span class="line">e = next</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> task.circle &gt; <span class="number">0</span> &#123; <span class="comment">//如果任务所在的环大于0</span></span><br><span class="line">task.circle--</span><br><span class="line">e = e.Next()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> task.diff &gt; <span class="number">0</span> &#123;   <span class="comment">//如果任务位置发生了变化</span></span><br><span class="line">next := e.Next()</span><br><span class="line">l.Remove(e)<span class="comment">//先删掉任务</span></span><br><span class="line"><span class="comment">// (tw.tickedPos+task.diff)%tw.numSlots</span></span><br><span class="line"><span class="comment">// cannot be the same value of tw.tickedPos</span></span><br><span class="line">pos := (tw.tickedPos + task.diff) % tw.numSlots<span class="comment">//根据任务最新的位置计算位置重新放入任务</span></span><br><span class="line">tw.slots[pos].PushBack(task)</span><br><span class="line">tw.setTimerPosition(pos, task)</span><br><span class="line">task.diff = <span class="number">0</span></span><br><span class="line">e = next</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks = <span class="built_in">append</span>(tasks, timingTask&#123;</span><br><span class="line">key:   task.key,</span><br><span class="line">value: task.value,</span><br><span class="line">&#125;)</span><br><span class="line">next := e.Next()</span><br><span class="line">l.Remove(e)</span><br><span class="line">tw.timers.Del(task.key)</span><br><span class="line">e = next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tw.runTasks(tasks)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">runTasks</span><span class="params">(tasks []timingTask)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(tasks) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> tasks &#123;<span class="comment">//拉起一个协程，不断执行任务(多任务非并发)</span></span><br><span class="line">threading.RunSafe(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">tw.execute(tasks[i].key, tasks[i].value)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：每个任务都使用一个协程进行执行，这里使用的是 <code>go-zero</code>封装的协程池，这个go 会等待所有任务执行完毕才会结束</p><h4 id="删除任务"><a class="markdownIt-Anchor" href="#删除任务"></a> 删除任务</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RemoveTimer removes the task with the given key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">RemoveTimer</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ErrArgument</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> tw.removeChannel &lt;- key:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;-tw.stopChannel:</span><br><span class="line"><span class="keyword">return</span> ErrClosed</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//removeTask</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">removeTask</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">val, ok := tw.timers.Get(key) <span class="comment">//任务不存在</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timer := val.(*positionEntry)</span><br><span class="line">timer.item.removed = <span class="literal">true</span><span class="comment">//增加一个状态表示已经被删除</span></span><br><span class="line">tw.timers.Del(key)         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="排空任务"><a class="markdownIt-Anchor" href="#排空任务"></a> 排空任务</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Drain 使用 fn 排空任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">Drain</span><span class="params">(fn <span class="keyword">func</span>(key, value <span class="keyword">interface</span>&#123;&#125;)</span>) <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> tw.drainChannel &lt;- fn:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;-tw.stopChannel:</span><br><span class="line"><span class="keyword">return</span> ErrClosed</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//drainAll 排空任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">drainAll</span><span class="params">(fn <span class="keyword">func</span>(key, value <span class="keyword">interface</span>&#123;&#125;)</span>)</span> &#123;</span><br><span class="line">runner := threading.NewTaskRunner(drainWorkers)</span><br><span class="line"><span class="keyword">for</span> _, slot := <span class="keyword">range</span> tw.slots &#123;</span><br><span class="line"><span class="keyword">for</span> e := slot.Front(); e != <span class="literal">nil</span>; &#123;</span><br><span class="line">task := e.Value.(*timingEntry)</span><br><span class="line">next := e.Next()</span><br><span class="line">slot.Remove(e)</span><br><span class="line">e = next</span><br><span class="line"><span class="keyword">if</span> !task.removed &#123;</span><br><span class="line">runner.Schedule(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fn(task.key, task.value)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排空任务并不是直接删除，而是提供一个自定义函数接口用于处理剩下的任务，有利于安全退出。但需要注意的是每个任务都会拉一个协程进行处理，也就是不能立即执行 时间轮的 <code>Stop</code></p><h4 id="停止时间轮"><a class="markdownIt-Anchor" href="#停止时间轮"></a> 停止时间轮</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stop stops tw. No more actions after stopping a TimingWheel.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">close</span>(tw.stopChannel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li><code>task</code>从 <code>优先队列 O(nlog(n))</code> 降到 <code>双向链表 O(1)</code>，而执行task也只要轮询一个时间点的tasks <code>O(N)</code>，不需要像优先队列，放入和删除元素 <code>O(nlog(n))</code>。</li><li>时间轮中的多层环是一种虚拟概念，用来记录超出范围(<code>nusSlots * interval</code>)的任务</li><li>使用<code>chan</code>接收外部接口调用的好处是并发安全，当然内部逻辑实现还是需要注意<code>map</code>安全</li></ol><p>补充：</p><ol><li>可以添加一个在协程池中讲到的时间轮状态，保证不会有新的任务在退出的时候加进来</li><li>可以使用协程池和内存池的节省内存空间，但如果协程池处理不过来使后续任务阻塞，可能会导致时间轮功能异常</li><li>分布式系统中系统的定时调用则需要使用分布式定时器，这在另外的章节中学习</li></ol><h3 id="技术应用"><a class="markdownIt-Anchor" href="#技术应用"></a> 技术应用</h3><p>go-zero用于缓存的定时删除</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">timingWheel, err := NewTimingWheel(time.Second, slots, <span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">key, ok := k.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cache.Del(key)<span class="comment">//到达则删除缓存</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cache.timingWheel = timingWheel</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://www.ericcai.fun/detail/16" target="_blank" rel="noopener">https://www.ericcai.fun/detail/16</a></li><li><a href="https://juejin.cn/post/6844904110399946766" target="_blank" rel="noopener">https://juejin.cn/post/6844904110399946766</a></li><li><a href="https://xiaorui.cc/archives/6160" target="_blank" rel="noopener">https://xiaorui.cc/archives/6160</a></li><li><a href="https://zhuanlan.zhihu.com/p/264826698" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/264826698</a></li><li><a href="https://lk668.github.io/2021/04/05/2021-04-05-%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E7%94%A8golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAtimewheel/" target="_blank" rel="noopener">https://lk668.github.io/2021/04/05/2021-04-05-手把手教你如何用golang实现一个timewheel/</a></li><li><a href="https://go-zero.dev/cn/docs/blog/principle/timing-wheel" target="_blank" rel="noopener">https://go-zero.dev/cn/docs/blog/principle/timing-wheel</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题背景&quot;&gt;&lt;/a&gt; 问题背景&lt;/h3&gt;
&lt;p&gt;一个系统中存在着大量的延迟/定时任务：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在一个间隔时间之后做某事: 例如在最后一次消息发送的5分钟之后, 
      
    
    </summary>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/categories/go-zero/"/>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>go-zero4-协程池1</title>
    <link href="http://xboom.github.io/2022/07/06/GoZero/GoZero4-%E5%8D%8F%E7%A8%8B%E6%B1%A01/"/>
    <id>http://xboom.github.io/2022/07/06/GoZero/GoZero4-%E5%8D%8F%E7%A8%8B%E6%B1%A01/</id>
    <published>2022-07-06T13:53:58.640Z</published>
    <updated>2022-07-06T14:55:05.108Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h3><p>需要协程池吗？</p><p>虽然协程非常轻量级的，一般用不上协程池。协程池的作用 无休止地创建大量goroutine，势必会因为对大量go 程的创建、调度和销毁带来性能损耗。 为了解决这个问题，可以引入协程池</p><h3 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h3><p>协程池需要什么？</p><ol><li>协程如何重用、任务如何执行</li><li>协程池支持自定义协程池大小</li><li>如果当前任务数量超过协程池大小，那么当前任务需要等待，等待时间支持超时退出</li><li>协程支持自定义退出</li><li>异常捕获，防止因为单个协程的异常处理导致整个协程池无法使用</li></ol><p>协程池大致的逻辑如下图所示：</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/gopools1.png" alt="gopools1" /></p><h4 id="方案1"><a class="markdownIt-Anchor" href="#方案1"></a> 方案1</h4><p>这是一个网上能搜到的 “100行实现一个协程池”，</p><p><strong>第一步</strong>：定义一个任务</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">    Handler <span class="function"><span class="keyword">func</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line">    Params  []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实是将需要执行的协程方法，使用结构体封装起来</p><p><strong>第二步</strong>：定义一个协程池</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">    capacity       <span class="keyword">uint64</span><span class="comment">//容量</span></span><br><span class="line">    runningWorkers <span class="keyword">uint64</span><span class="comment">//正在运行的协程树</span></span><br><span class="line">    status          <span class="keyword">int64</span>           <span class="comment">//状态(防止在退出过程中，仍然在新建协程)</span></span><br><span class="line">    chTask          <span class="keyword">chan</span> *Task      <span class="comment">//任务队列</span></span><br><span class="line">    PanicHandler   <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span>//<span class="title">panic</span>处理函数</span></span><br><span class="line">    sync.Mutex<span class="comment">//原子锁,用于保证runningWorkers原子数据变化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    RUNNING = <span class="number">1</span></span><br><span class="line">    STOPED = <span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>：利用协程池启动一个协程执行任务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.incRunning()<span class="comment">//增加正在运行的协程数目</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.decRunning()<span class="comment">//结束任务</span></span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p.PanicHandler != <span class="literal">nil</span> &#123;</span><br><span class="line">p.PanicHandler(r)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"Worker panic: %s\n"</span>, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p.checkWorker() <span class="comment">// check worker avoid no worker running</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> task, ok := &lt;-p.chTask:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">task.Handler(task.Params...)<span class="comment">//任务处理</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果任务数量大于0，但是这个时候协程都退出，则再次构建一个协程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">checkWorker</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.runningWorkers == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(p.chTask) &gt; <span class="number">0</span> &#123;</span><br><span class="line">p.run()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协程池的协程不是常驻协程吗，为什么会出现协程数量为0，但是任务大于0的情况呢？</p><p>答：工作协程可能因为 <code>panic</code> 都退出了，那么这个时候就需要有一个重新拉起协程去执行任务</p><p><strong>第四步</strong>：生产任务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Put</span><span class="params">(task *Task)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">p.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.status == STOPED &#123;</span><br><span class="line"><span class="keyword">return</span> ErrPoolAlreadyClosed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run worker</span></span><br><span class="line"><span class="keyword">if</span> p.GetRunningWorkers() &lt; p.GetCap() &#123;</span><br><span class="line">p.run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// send task</span></span><br><span class="line"><span class="keyword">if</span> p.status == RUNNING &#123;</span><br><span class="line">p.chTask &lt;- task</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么在存放任务的时候，会多一个协程池的判断呢？</p><p>答：可能会出现协程池结束关闭的情况，如果这个时候又有新的任务，那就又会创建新的协程去执行</p><p><strong>最后</strong>：关闭协程池</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Close close pool graceful</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !p.setStatus(STOPED) &#123; <span class="comment">// stop put task</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(p.chTask) &gt; <span class="number">0</span> &#123; <span class="comment">// 等待所有的任务都被消费</span></span><br><span class="line">time.Sleep(<span class="number">1e6</span>) <span class="comment">// 防止等待任务清空 cpu 负载突然变大, 这里小睡一下</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(p.chTask)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ol><li>这里添加了协程池的状态，防止退出时候的任务增加</li><li>为什么在退出的时候，如果任务大于0，那么需要 <code>sleep</code> 一下？</li><li>异常捕获之后再次检查是否有协程在执行任务，没有则添加一个协程</li><li>使用无缓冲<code>channel</code>进行任务执行，可能会出现添加任务阻塞的情况</li><li>任务是否可以添加一个运行超时时间，防止单个任务死锁？</li></ol><h4 id="方案2"><a class="markdownIt-Anchor" href="#方案2"></a> 方案2</h4><p>字节跳动开源的协程池，仓库地址：<a href="https://github.com/bytedance/gopkg/tree/develop/util/gopool" target="_blank" rel="noopener">https://github.com/bytedance/gopkg/tree/develop/util/gopool</a></p><p>使用 <strong>生产者-消费者模式</strong> 设计协程池</p><p><strong>第一步</strong>：**协程池 ** 具有的功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">interface</span> &#123;</span><br><span class="line">Name() <span class="keyword">string</span><span class="comment">//协程池名称</span></span><br><span class="line">SetCap(<span class="built_in">cap</span> <span class="keyword">int32</span>)<span class="comment">//协程池容量</span></span><br><span class="line">Go(f <span class="function"><span class="keyword">func</span><span class="params">()</span>)//使用协程执行 <span class="title">f</span></span></span><br><span class="line">CtxGo(ctx context.Context, f <span class="function"><span class="keyword">func</span><span class="params">()</span>) //使用协程执行<span class="title">f</span>并支持参数 <span class="title">ctx</span></span></span><br><span class="line">SetPanicHandler(f <span class="function"><span class="keyword">func</span><span class="params">(context.Context, <span class="keyword">interface</span>&#123;&#125;)</span>) //设置协程处理函数</span></span><br><span class="line">WorkerCount() <span class="keyword">int32</span><span class="comment">//返回正在运行的协程数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>：协程池的结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pool <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span><span class="comment">//协程池名称</span></span><br><span class="line"><span class="built_in">cap</span> <span class="keyword">int32</span><span class="comment">//协程池容量</span></span><br><span class="line">config *Config<span class="comment">//协程池配置</span></span><br><span class="line">taskHead  *task<span class="comment">//任务头部</span></span><br><span class="line">taskTail  *task<span class="comment">//任务尾部</span></span><br><span class="line">    taskLock  sync.Mutex<span class="comment">//任务原子锁(竞争)</span></span><br><span class="line">taskCount <span class="keyword">int32</span><span class="comment">//任务数量</span></span><br><span class="line">workerCount <span class="keyword">int32</span><span class="comment">//正在运行的协程数量</span></span><br><span class="line">panicHandler <span class="function"><span class="keyword">func</span><span class="params">(context.Context, <span class="keyword">interface</span>&#123;&#125;)</span>//<span class="title">Panic</span>处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>：看看 任务 <code>task</code> 的定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> task <span class="keyword">struct</span> &#123;</span><br><span class="line">ctx context.Context</span><br><span class="line">f   <span class="function"><span class="keyword">func</span><span class="params">()</span>//执行函数</span></span><br><span class="line"></span><br><span class="line">next *task<span class="comment">//指向下一个任务的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> taskList <span class="keyword">struct</span> &#123;     <span class="comment">//使用双向链表将任务连接起来</span></span><br><span class="line">sync.Mutex</span><br><span class="line">taskHead *task</span><br><span class="line">taskTail *task</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>：查看协程池是怎么运行的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> taskPool sync.Pool <span class="comment">//对象池</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pool)</span> <span class="title">CtxGo</span><span class="params">(ctx context.Context, f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">t := taskPool.Get().(*task)<span class="comment">//从对象池获取任务对象</span></span><br><span class="line">t.ctx = ctx</span><br><span class="line">t.f = f</span><br><span class="line">p.taskLock.Lock()<span class="comment">//获取任务写锁</span></span><br><span class="line"><span class="keyword">if</span> p.taskHead == <span class="literal">nil</span> &#123;      <span class="comment">//如果任务链表为空则新建，否则插入链表尾部</span></span><br><span class="line">p.taskHead = t</span><br><span class="line">p.taskTail = t</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p.taskTail.next = t</span><br><span class="line">p.taskTail = t</span><br><span class="line">&#125;</span><br><span class="line">p.taskLock.Unlock()<span class="comment">//释放任务写锁</span></span><br><span class="line">atomic.AddInt32(&amp;p.taskCount, <span class="number">1</span>) <span class="comment">//增加任务数量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 如果任务数量大于配置的数量 &amp;&amp; 正在执行的协程数量小于协程池容量，说明任务太多，还有空闲的协程</span></span><br><span class="line"><span class="comment">     那么就开启一个新的协程处理</span></span><br><span class="line"><span class="comment">       如果任务数量小于配置的数量 &amp;&amp; 正在执行的协程数量小于协程池容量。说明任务还不多，就让当前协程顺序执行</span></span><br><span class="line"><span class="comment">    2. 正在执行的协程为0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">if</span> (atomic.LoadInt32(&amp;p.taskCount) &gt;= p.config.ScaleThreshold &amp;&amp; p.WorkerCount() &lt; atomic.LoadInt32(&amp;p.<span class="built_in">cap</span>)) || p.WorkerCount() == <span class="number">0</span> &#123;</span><br><span class="line">p.incWorkerCount()   </span><br><span class="line">w := workerPool.Get().(*worker)</span><br><span class="line">w.pool = p</span><br><span class="line">w.run()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里额外定义了一个 <code>workPool</code>，其实是消费者池</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> workerPool sync.Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> worker <span class="keyword">struct</span> &#123;<span class="comment">//消费者其实是一个协程池</span></span><br><span class="line">pool *pool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123; <span class="comment">//这是一个常驻协程</span></span><br><span class="line"><span class="keyword">var</span> t *task</span><br><span class="line">w.pool.taskLock.Lock()   <span class="comment">//获取任务写锁</span></span><br><span class="line"><span class="keyword">if</span> w.pool.taskHead != <span class="literal">nil</span> &#123; <span class="comment">//获取任务并将任务数量-1</span></span><br><span class="line">t = w.pool.taskHead</span><br><span class="line">w.pool.taskHead = w.pool.taskHead.next</span><br><span class="line">atomic.AddInt32(&amp;w.pool.taskCount, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;<span class="comment">//如果没有任务，那么worker销毁</span></span><br><span class="line"><span class="comment">// if there's no task to do, exit</span></span><br><span class="line">w.<span class="built_in">close</span>()</span><br><span class="line">w.pool.taskLock.Unlock()</span><br><span class="line">w.Recycle()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">w.pool.taskLock.Unlock() <span class="comment">//释放任务写锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;<span class="comment">//异常处理</span></span><br><span class="line"><span class="keyword">if</span> w.pool.panicHandler != <span class="literal">nil</span> &#123;</span><br><span class="line">w.pool.panicHandler(t.ctx, r)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">msg := fmt.Sprintf(<span class="string">"GOPOOL: panic in pool: %s: %v: %s"</span>, w.pool.name, r, debug.Stack())</span><br><span class="line">logger.CtxErrorf(t.ctx, msg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">t.f()<span class="comment">//执行任务 f</span></span><br><span class="line">&#125;()</span><br><span class="line">t.Recycle()<span class="comment">//任务结束后，会收work</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span> <span class="title">close</span><span class="params">()</span></span> &#123;<span class="comment">//减少worker数目</span></span><br><span class="line">w.pool.decWorkerCount()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span> <span class="title">zero</span><span class="params">()</span></span> &#123; <span class="comment">//释放缓存池</span></span><br><span class="line">w.pool = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span> <span class="title">Recycle</span><span class="params">()</span></span> &#123;<span class="comment">//释放worker(存入缓存池)</span></span><br><span class="line">w.zero()</span><br><span class="line">workerPool.Put(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，它还定义了一个 <code>poolMap</code> 用于根据名称注册与使用 多个协程池</p><p><strong>注意</strong>：</p><ol><li>使用双向链表存储任务，表示它理论上支持无限个任务。后面的任务可能存在长时间等待的情况</li><li>使用任务上限的好处是，不是每来一个任务都开启一个协程，而是任务超过一定数量而又空闲的协程才开启新的协程去执行</li></ol><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><p><code>go-zero</code>是如何实现协程池的，代码路径：<code>core/threading</code></p><p><strong>第一步</strong>，定义了<code>recover</code>逻辑，用于 <code>panic</code> 之后的清理操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/rescue/recover.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Recover</span><span class="params">(cleanups ...<span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, cleanup := <span class="keyword">range</span> cleanups &#123;</span><br><span class="line">cleanup()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//logx.ErrorStack(p)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，定义了一个安全运行<code>goroutine</code>的方案 <code>GoSafe</code>，包含处理<code>panic</code>逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GoSafe</span><span class="params">(fn <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="keyword">go</span> RunSafe(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RunSafe</span><span class="params">(fn <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> rescue.Recover()</span><br><span class="line"></span><br><span class="line">fn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TaskRunner</code>： 使用 <code>limitChan</code> 协程池 执行协程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TaskRunner 用于并发控制协程数量</span></span><br><span class="line"><span class="keyword">type</span> TaskRunner <span class="keyword">struct</span> &#123;</span><br><span class="line">limitChan <span class="keyword">chan</span> lang.PlaceholderType</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 TaskRunner 对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTaskRunner</span><span class="params">(concurrency <span class="keyword">int</span>)</span> *<span class="title">TaskRunner</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;TaskRunner&#123;</span><br><span class="line">limitChan: <span class="built_in">make</span>(<span class="keyword">chan</span> lang.PlaceholderType, concurrency),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 任务并发控制下执行 task</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rp *TaskRunner)</span> <span class="title">Schedule</span><span class="params">(task <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">  rp.limitChan &lt;- lang.Placeholder<span class="comment">//limitChan 类似一个并发锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> rescue.Recover(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">&lt;-rp.limitChan</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">task()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：当<code>limitChan</code>满那么任务执行会出现超时，缺乏超时逻辑</p><p><code>WorkerGroup</code>：使用 <code>wokers</code> 并发执行任务 <code>job</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WorkerGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">job     <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">workers <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewWorkerGroup returns a WorkerGroup with given job and workers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorkerGroup</span><span class="params">(job <span class="keyword">func</span>()</span>, <span class="title">workers</span> <span class="title">int</span>) <span class="title">WorkerGroup</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> WorkerGroup&#123;</span><br><span class="line">job:     job,</span><br><span class="line">workers: workers,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start starts a WorkerGroup.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg WorkerGroup)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">group := NewRoutineGroup()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; wg.workers; i++ &#123;</span><br><span class="line">group.RunSafe(wg.job)</span><br><span class="line">&#125;</span><br><span class="line">group.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RoutineGroup</code>: 多协程等待</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RoutineGroup 多协程等待</span></span><br><span class="line"><span class="keyword">type</span> RoutineGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">waitGroup sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRoutineGroup</span><span class="params">()</span> *<span class="title">RoutineGroup</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">new</span>(RoutineGroup)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要引用外部参数，可能被其他协程修改</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *RoutineGroup)</span> <span class="title">Run</span><span class="params">(fn <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">g.waitGroup.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> g.waitGroup.Done()</span><br><span class="line">fn()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不要引用外部参数，可能被其他协程修改</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *RoutineGroup)</span> <span class="title">RunSafe</span><span class="params">(fn <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">g.waitGroup.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">GoSafe(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> g.waitGroup.Done()</span><br><span class="line">fn()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待所有协程结束</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *RoutineGroup)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">g.waitGroup.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 go-zero的<code>threading</code> 并不是真正的协程池，仅仅是提供多种并发执行 <code>goroutine</code>的方法</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>所以从目前来看，实现一个协程池都有哪些值得学习的地方呢？</p><ol><li>将需要使用临时协程执行的函数已任务的形式 <code>任务 -- 协程池(Pool) -- 工人</code>执行</li><li>协程池是有容量限制的，有了容量就有正在运行的协程数</li><li>协程池有状态防止在退出的时候仍然进行任务构建与执行</li><li>协程池有异常捕获机制，保证单个异常不会影响整个协程池</li><li>任务已任务合集的形式存在，让消费者并发消费</li><li>有了异常捕获与任务合集，为了防止工人都发生异常，而还有任务没有执行，则需要有工人唤起机制</li><li>可以使用本地缓存池进行工人的重复利用</li><li>任务合集缓隧道还是双链表、每个任务都构建一个协程还是单个任务多任务执行的选择</li></ol><p>下一节，将学习另外一个协程池 ants 的实现方式</p><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://go-zero.dev/cn/docs/goctl/installation/" target="_blank" rel="noopener">https://go-zero.dev/cn/docs/goctl/installation/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题背景&quot;&gt;&lt;/a&gt; 问题背景&lt;/h3&gt;
&lt;p&gt;需要协程池吗？&lt;/p&gt;
&lt;p&gt;虽然协程非常轻量级的，一般用不上协程池。协程池的作用 无休止地创建大量goroutine，势必会因为对
      
    
    </summary>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/categories/go-zero/"/>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>go-zero3-MapReduce</title>
    <link href="http://xboom.github.io/2022/07/03/GoZero/GoZero3-MapReduce/"/>
    <id>http://xboom.github.io/2022/07/03/GoZero/GoZero3-MapReduce/</id>
    <published>2022-07-03T08:37:40.000Z</published>
    <updated>2022-07-03T08:41:55.313Z</updated>
    
    <content type="html"><![CDATA[<p>什么是<code>MapReduce</code>?</p><p><code>MapReduce</code>是Google提出了一个软件架构，用于大规模数据集的并行运算。</p><p><code>MapReduce</code>通过把对数据集的大规模操作分发给网络上的每个节点实现可靠性；每个节点会周期性的把完成的工作和状态的更新报告回来。如果一个节点保持沉默超过一个预设的时间间隔，主节点记录下这个节点状态为死亡，并把分配给这个节点的数据发到别的节点。</p><p><code>go-zero</code>的<code>MapReduce</code>则借鉴其中的思想，接下来一起看下<code>go-zero</code>是如何应用这一思想的</p><h3 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h3><p>在微服务中开发中，如果多个服务串行依赖的话那么整个<code>API</code>的耗时将会大大增加。通过什么手段来优化？</p><ol><li>传输层面通过<code>MQ</code>的解耦特性来降低<code>API</code>的耗时<ul><li><code>MQ</code>通信效率没有<code>grpc</code>高(消息通过<code>MQ</code>服务器进行中转)</li></ul></li><li>业务层面通过Go语言的<code>WaitGroup</code>工具来进行并发控制<ul><li>自行封装<code>Add</code>与<code>Done</code></li></ul></li></ol><p>实际业务场景中：</p><ul><li>如果接口的多个依赖有一个出错，则期望能立即返回且不必等待所有依赖都执行完毕。已经完成的接口调用也应该回滚</li><li>多个依赖可能有部分依赖之间也存在着相互依赖，或者上下关系</li></ul><p>go-zero的主要应用场景为：需要从不同的<code>rpc</code>服务中获取相应属性组装成复杂对象，比如要查询商品详情：</p><ol><li>商品服务-查询商品属性</li><li>库存服务-查询库存属性</li><li>价格服务-查询价格属性</li><li>营销服务-查询营销属性</li></ol><p>如果是串行调用的话响应时间会随着 <code>rpc</code> 调用次数呈线性增长，简单场景下使用 <code>WaitGroup</code> 也能够满足需求，但如果要对 <code>rpc</code> 调用返回的数据进行校验、数据加工转换、数据汇总呢？</p><p><code>go-zero</code>通过<code>mapreduce</code>来处理这种对输入数据进行处理最后输出清洗数据的问题。是一种经典的模式：<strong>生产者消费者模式</strong>。将数据处理分为三个阶段：</p><ol><li>数据生产 generate(查询，必选)</li><li>数据加工 mapper(加工，可选)</li><li>数据聚合 reducer(聚合，可选)</li></ol><p>利用协程处理以及管道通信，实现数据的加速处理</p><h3 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h3><h4 id="场景1"><a class="markdownIt-Anchor" href="#场景1"></a> 场景1</h4><p>对数据批处理，比如对一批用户id，效验每个用户的合法性并且效验过程中有一个出错就认为效验失败，返回的结果为效验合法的用户id</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mapreduce</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/zeromicro/go-zero/core/mr"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(uids []<span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">r, err := mr.MapReduce(<span class="function"><span class="keyword">func</span><span class="params">(source <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, uid := <span class="keyword">range</span> uids &#123;</span><br><span class="line">source &lt;- uid</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;, writer mr.Writer, cancel <span class="keyword">func</span>(error)</span>)</span> &#123;</span><br><span class="line">uid := item.(<span class="keyword">int</span>)</span><br><span class="line">ok, err := check(uid)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;<span class="comment">//如果校验逻辑有问题，这里执行cancel整个校验过程停止</span></span><br><span class="line">cancel(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ok &#123;<span class="comment">//如果校验失败，那么不返回该uid</span></span><br><span class="line">writer.Write(uid)</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(pipe &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, writer mr.Writer, cancel <span class="keyword">func</span>(error)</span>)</span> &#123;</span><br><span class="line"><span class="keyword">var</span> uids []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> p := <span class="keyword">range</span> pipe &#123;</span><br><span class="line">uids = <span class="built_in">append</span>(uids, p.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line">writer.Write(uids)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"check error: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r.([]<span class="keyword">int</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// do something check user legal</span></span><br><span class="line"><span class="keyword">if</span> uid == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, errors.New(<span class="string">"uid wrong"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实是利用N个协程等待数据生产者的数据传输然后转交给聚合逻辑处理</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/mapReduce-1.png" alt="mapReduce-1" /></p><h4 id="场景2"><a class="markdownIt-Anchor" href="#场景2"></a> 场景2</h4><p>某些功能的结果往往需要依赖多个服务，比如商品详情的结果往往会依赖用户服务、库存服务、订单服务等等，一般被依赖的服务都是以rpc的形式对外提供，为了降低依赖的耗时我们往往需要对依赖做并行处理</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productDetail</span><span class="params">(uid, pid <span class="keyword">int64</span>)</span> <span class="params">(*ProductDetail, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> pd ProductDetail</span><br><span class="line">err := mr.Finish(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">pd.User, err = userRpc.User(uid)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">pd.Store, err = storeRpc.Store(pid)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">pd.Order, err = orderRpc.Order(pid)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"product detail error: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;pd, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><p>源码目录：<code>core/mr/mapreduce.go</code></p><p>其中利用到的对外函数有</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MapReduce 包含数据生产、数据处理以及数据聚合阶段并返回结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapReduce</span><span class="params">(generate GenerateFunc, mapper MapperFunc, reducer ReducerFunc,</span></span></span><br><span class="line"><span class="function"><span class="params">               opts ...Option)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MapReduceChan 包含数据生产、数据处理以及数据聚合阶段并返回结果。其中利用chan代替数据生产</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapReduceChan</span><span class="params">(source &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, mapper MapperFunc, reducer ReducerFunc,</span></span></span><br><span class="line"><span class="function"><span class="params">opts ...Option)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">panicChan := &amp;onceChan&#123;channel: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)&#125;</span><br><span class="line"><span class="keyword">return</span> mapReduceWithPanicChan(source, panicChan, mapper, reducer, opts...)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// ForEach 只包含数据生产和数据处理阶段，但没有任何输出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ForEach</span><span class="params">(generate GenerateFunc, mapper ForEachFunc, opts ...Option)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FinishVoid 并行运行 fns</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FinishVoid</span><span class="params">(fns ...<span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Finish 并行运行 fns，在任何错误时取消</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Finish</span><span class="params">(fns ...<span class="keyword">func</span>()</span> <span class="title">error</span>) <span class="title">error</span></span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//WithWorkers 定义一个 mapreduce 有几个协程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithWorkers</span><span class="params">(workers <span class="keyword">int</span>)</span> <span class="title">Option</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="数据生产阶段"><a class="markdownIt-Anchor" href="#数据生产阶段"></a> 数据生产阶段</h4><p>首先定义 <code>buildSource</code>使用协程进行数据生产</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//buildSource 使用协程执行generate 并将协程的参数一个非缓冲的channel返回。如果generate发生panic，则将错误写入 onceChan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildSource</span><span class="params">(generate GenerateFunc, panicChan *onceChan)</span> <span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">source := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">panicChan.write(r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(source)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">generate(source) <span class="comment">//返回的非缓冲隧道也是数据生产的入口</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> source</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 <code>onceChan</code>则是一个非阻塞会缓冲的channel，当channel中还有数据没有处理完，则直接返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> onceChan <span class="keyword">struct</span> &#123;</span><br><span class="line">channel <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">wrote   <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(oc *onceChan)</span> <span class="title">write</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.AddInt32(&amp;oc.wrote, <span class="number">1</span>) &gt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">oc.channel &lt;- val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据处理阶段"><a class="markdownIt-Anchor" href="#数据处理阶段"></a> 数据处理阶段</h4><p>接着利用<code>mapReduceWithPanicChan</code>进行数据处理<code>mapper</code>和数据聚合<code>reducer</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapReduce</span><span class="params">(generate GenerateFunc, mapper MapperFunc, reducer ReducerFunc,</span></span></span><br><span class="line"><span class="function"><span class="params">opts ...Option)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">panicChan := &amp;onceChan&#123;channel: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)&#125;</span><br><span class="line">source := buildSource(generate, panicChan) <span class="comment">//使用协程执行generate并返回数据生产无缓冲隧道source</span></span><br><span class="line"><span class="keyword">return</span> mapReduceWithPanicChan(source, panicChan, mapper, reducer, opts...) <span class="comment">//将隧道和处理函数传入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//source就是数据来源隧道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapReduceWithPanicChan</span><span class="params">(source &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, panicChan *onceChan, mapper MapperFunc,</span></span></span><br><span class="line"><span class="function"><span class="params">reducer ReducerFunc, opts ...Option)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">options := buildOptions(opts...)</span><br><span class="line"><span class="comment">// output is used to write the final result</span></span><br><span class="line">output := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="comment">//...defer</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//collector 用于从mapper收集数据，消费者是数据聚合</span></span><br><span class="line">collector := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, options.workers)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//done表示结束，所有的mappers和reducer都要结束</span></span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> lang.PlaceholderType)</span><br><span class="line">writer := newGuardedWriter(options.ctx, output, done)</span><br><span class="line"><span class="keyword">var</span> closeOnce sync.Once</span><br><span class="line"><span class="comment">// use atomic.Value to avoid data race</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="comment">//起一个协程进行 数据聚合</span></span><br><span class="line">    <span class="comment">//panic.wirte()</span></span><br><span class="line">reducer(collector, writer, cancel)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> executeMappers(mapperContext&#123; <span class="comment">//进行 数据处理</span></span><br><span class="line">ctx: options.ctx,</span><br><span class="line">mapper: <span class="function"><span class="keyword">func</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;, w Writer)</span></span> &#123;</span><br><span class="line">mapper(item, w, cancel)</span><br><span class="line">&#125;,</span><br><span class="line">source:    source,</span><br><span class="line">panicChan: panicChan,</span><br><span class="line">collector: collector,</span><br><span class="line">doneChan:  done,</span><br><span class="line">workers:   options.workers,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123; <span class="comment">//等待结果</span></span><br><span class="line"><span class="keyword">case</span> &lt;-options.ctx.Done():</span><br><span class="line">cancel(context.DeadlineExceeded)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, context.DeadlineExceeded</span><br><span class="line"><span class="keyword">case</span> v := &lt;-panicChan.channel:</span><br><span class="line"><span class="built_in">panic</span>(v)</span><br><span class="line"><span class="keyword">case</span> v, ok := &lt;-output:</span><br><span class="line"><span class="keyword">if</span> err := retErr.Load(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrReduceNoOutput</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中数据处理阶段又定义了一个协程进行处理</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">executeMappers</span><span class="params">(mCtx mapperContext)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="built_in">close</span>(mCtx.collector)</span><br><span class="line">drain(mCtx.source)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> failed <span class="keyword">int32</span></span><br><span class="line">pool := <span class="built_in">make</span>(<span class="keyword">chan</span> lang.PlaceholderType, mCtx.workers) <span class="comment">//协程池</span></span><br><span class="line">writer := newGuardedWriter(mCtx.ctx, mCtx.collector, mCtx.doneChan)</span><br><span class="line"><span class="keyword">for</span> atomic.LoadInt32(&amp;failed) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-mCtx.ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-mCtx.doneChan:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> pool &lt;- lang.Placeholder:<span class="comment">//这里是定义的N个works的chan，也就是会在下面创建n个协程</span></span><br><span class="line">item, ok := &lt;-mCtx.source</span><br><span class="line"><span class="keyword">if</span> !ok &#123; <span class="comment">//如果来源关闭，那么将pool数据释放</span></span><br><span class="line">&lt;-pool</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">atomic.AddInt32(&amp;failed, <span class="number">1</span>)</span><br><span class="line">mCtx.panicChan.write(r)</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&lt;-pool</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//item:生产的数据</span></span><br><span class="line">        <span class="comment">//writer: 数据处理对象</span></span><br><span class="line">mCtx.mapper(item, writer) <span class="comment">//执行map</span></span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据聚合阶段"><a class="markdownIt-Anchor" href="#数据聚合阶段"></a> 数据聚合阶段</h4><p>最后来看一下是数据处理</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> guardedWriter <span class="keyword">struct</span> &#123;<span class="comment">//写入接口</span></span><br><span class="line">ctx     context.Context<span class="comment">//保证超时退出</span></span><br><span class="line">channel <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;<span class="comment">//接收数据，这里传输的就是 长度为 N 的 collect channel</span></span><br><span class="line">done    &lt;-<span class="keyword">chan</span> lang.PlaceholderType<span class="comment">//主动结束退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newGuardedWriter</span><span class="params">(ctx context.Context, channel <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">done &lt;-<span class="keyword">chan</span> lang.PlaceholderType)</span> <span class="title">guardedWriter</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> guardedWriter&#123;</span><br><span class="line">ctx:     ctx,</span><br><span class="line">channel: channel,</span><br><span class="line">done:    done,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="finish"><a class="markdownIt-Anchor" href="#finish"></a> Finish</h4><p><code>Finish</code>逻辑只进行并发处理，其实内部是将执行函数做为数据生产的生产的数据，然后又数据处理逻辑进行处理</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/mapreduce_finish.png" alt="mapreduce_finish" /></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Finish</span><span class="params">(fns ...<span class="keyword">func</span>()</span> <span class="title">error</span>) <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(fns) == <span class="number">0</span> &#123;<span class="comment">//n个外部调用</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> MapReduceVoid(<span class="function"><span class="keyword">func</span><span class="params">(source <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, fn := <span class="keyword">range</span> fns &#123;</span><br><span class="line">source &lt;- fn<span class="comment">//数据生产者将函数传入</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;, writer Writer, cancel <span class="keyword">func</span>(error)</span>)</span> &#123;</span><br><span class="line">fn := item.(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span>)</span></span><br><span class="line"><span class="keyword">if</span> err := fn(); err != <span class="literal">nil</span> &#123;<span class="comment">//数据处理逻辑执行函数</span></span><br><span class="line">cancel(err)<span class="comment">//这里并没有写入，所以第三个函数其实并没有执行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(pipe &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, cancel <span class="keyword">func</span>(error)</span>)</span> &#123;</span><br><span class="line">&#125;, WithWorkers(<span class="built_in">len</span>(fns)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//底层还是执行的MapReduce逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapReduceVoid</span><span class="params">(generate GenerateFunc, mapper MapperFunc, reducer VoidReducerFunc, opts ...Option)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">_, err := MapReduce(generate, mapper, <span class="function"><span class="keyword">func</span><span class="params">(input &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, writer Writer, cancel <span class="keyword">func</span>(error)</span>)</span> &#123;</span><br><span class="line">reducer(input, cancel)</span><br><span class="line">&#125;, opts...)</span><br><span class="line"><span class="keyword">if</span> errors.Is(err, ErrReduceNoOutput) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3><ol><li>适用于并发无顺序依赖的并发调用，如果是多个调用具有前后依赖关系，依然需要有先后调用顺序(废话)</li><li>也不存在回滚的操作，内部只是将不在等待处理结果直接退出 <code>select</code></li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://talkgo.org/t/topic/1452" target="_blank" rel="noopener">https://talkgo.org/t/topic/1452</a></li><li><a href="https://zh.wikipedia.org/wiki/MapReduce" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/MapReduce</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;什么是&lt;code&gt;MapReduce&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MapReduce&lt;/code&gt;是Google提出了一个软件架构，用于大规模数据集的并行运算。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MapReduce&lt;/code&gt;通过把对数据集的大规模操作分发给网络上的
      
    
    </summary>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/categories/go-zero/"/>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>有趣的算法-老鼠毒药问题</title>
    <link href="http://xboom.github.io/2022/07/02/Interesting%20Algorithm/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%AE%97%E6%B3%95-%E8%80%81%E9%BC%A0%E6%AF%92%E8%8D%AF/"/>
    <id>http://xboom.github.io/2022/07/02/Interesting%20Algorithm/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%AE%97%E6%B3%95-%E8%80%81%E9%BC%A0%E6%AF%92%E8%8D%AF/</id>
    <published>2022-07-02T11:08:45.303Z</published>
    <updated>2022-07-21T02:00:35.046Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h3><p>有 1000 个一模一样的瓶子，其中有 999 瓶是普通的水，有一瓶是毒药。任何喝下毒药的生物都会在一星期之后死亡。现在，你只有 10 只小白鼠和一星期的时间，如何检验出哪个瓶子里有毒药？</p><h3 id="问题分析"><a class="markdownIt-Anchor" href="#问题分析"></a> 问题分析</h3><p>这个题目需要面对几个问题</p><ol><li>因为毒药会在一个星期后生效，而只有一星期的时间，那么只能让老鼠多喝几瓶最后根据老鼠中毒情况判断出哪一瓶有毒</li><li>要喝完这一千瓶，那么每只老鼠要喝很多，如果老鼠们喝的不交叉，那么即使老鼠中毒，也无法区分它喝的哪一瓶有毒</li><li>如果它们喝的有交叉，就需要每一瓶都存在部分老鼠喝了部分老鼠没有喝，且每一瓶喝与不喝的老鼠都不一样</li></ol><p>使用二进制思想(当时就是没想到)</p><p>10个老鼠相当于10位的二进制位，可以表达的最大数量为1024</p><table><thead><tr><th>老鼠</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>如果给瓶子从1开始编号到1000，那么根据数字的二进制位，如果位数上是1的对应的老鼠就要喝掉这一瓶。根据老鼠的生存情况，就可以推断出哪一瓶有毒，假如：500是有毒的，那么它的二进制为 <code>0111110100</code>那么，</p><table><thead><tr><th>老鼠</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>500</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>508</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>510</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>512</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>也就是说：第2、3、4、5、6、8只老鼠会死掉。而喝了508，510、512的老鼠都没有事情</p><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://blog.csdn.net/qq_43827595/article/details/104154716" target="_blank" rel="noopener">https://blog.csdn.net/qq_43827595/article/details/104154716</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题描述&quot;&gt;&lt;/a&gt; 问题描述&lt;/h3&gt;
&lt;p&gt;有 1000 个一模一样的瓶子，其中有 999 瓶是普通的水，有一瓶是毒药。任何喝下毒药的生物都会在一星期之后死亡。现在，你只有 1
      
    
    </summary>
    
    
      <category term="Interesting Algorithm" scheme="http://xboom.github.io/categories/Interesting-Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://xboom.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>有趣的算法-赛马问题</title>
    <link href="http://xboom.github.io/2022/07/02/Interesting%20Algorithm/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%AE%97%E6%B3%95-%E8%B5%9B%E9%A9%AC%E9%97%AE%E9%A2%98/"/>
    <id>http://xboom.github.io/2022/07/02/Interesting%20Algorithm/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%AE%97%E6%B3%95-%E8%B5%9B%E9%A9%AC%E9%97%AE%E9%A2%98/</id>
    <published>2022-07-02T11:08:45.303Z</published>
    <updated>2022-07-09T12:06:06.092Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h3><p>64匹马，8个跑道，问最少比赛多少场，可以选出跑得最快的4匹马。每场比赛每个跑道只允许一匹马，且不存在并列情形</p><h3 id="问题分析"><a class="markdownIt-Anchor" href="#问题分析"></a> 问题分析</h3><p><strong>第一步</strong>：先让马儿跑起来，首先将马儿分批次赛跑，一共需要进行8次赛跑。假设结果如下：</p><table><thead><tr><th>分组</th><th>第一名</th><th>第二名</th><th>第三名</th><th>第四名</th><th>第五名</th><th>第六名</th><th>第七名</th><th>第八名</th></tr></thead><tbody><tr><td>A</td><td>A1</td><td>A2</td><td>A3</td><td>A4</td><td><s>A5</s></td><td><s>A6</s></td><td><s>A7</s></td><td><s>A8</s></td></tr><tr><td>B</td><td>B1</td><td>B2</td><td>B3</td><td>B4</td><td><s>B5</s></td><td><s>B6</s></td><td><s>B7</s></td><td><s>B8</s></td></tr><tr><td>C</td><td>C1</td><td>C2</td><td>C3</td><td>C4</td><td><s>C5</s></td><td><s>C6</s></td><td><s>C7</s></td><td><s>C8</s></td></tr><tr><td>D</td><td>D1</td><td>D2</td><td>D3</td><td>D4</td><td><s>D5</s></td><td><s>D6</s></td><td><s>D7</s></td><td><s>D8</s></td></tr><tr><td>E</td><td>E1</td><td>E2</td><td>E3</td><td>E4</td><td><s>E5</s></td><td><s>E6</s></td><td><s>E7</s></td><td><s>E8</s></td></tr><tr><td>F</td><td>F1</td><td>F2</td><td>F3</td><td>F4</td><td><s>F5</s></td><td><s>F6</s></td><td><s>F7</s></td><td><s>F8</s></td></tr><tr><td>G</td><td>G1</td><td>G2</td><td>G3</td><td>G4</td><td><s>G5</s></td><td><s>G6</s></td><td><s>G7</s></td><td><s>G8</s></td></tr><tr><td>H</td><td>H1</td><td>H2</td><td>H3</td><td>H4</td><td><s>H5</s></td><td><s>H6</s></td><td><s>H7</s></td><td><s>H8</s></td></tr></tbody></table><p>可直接排除各组最后四名赛马，剩余<code>64-4*8=32</code>匹赛马待定</p><p><strong>第二步</strong>：将每一组中的第一名进行赛跑(如果每一组选多个参加赛马，那样就存在重复比赛)，需要进行1次赛跑。假设结果如下：</p><table><thead><tr><th>分组</th><th>第一名</th><th>第二名</th><th>第三名</th><th>第四名</th><th>第五名</th><th>第六名</th><th>第七名</th><th>第八名</th></tr></thead><tbody><tr><td>1</td><td><strong>A1</strong></td><td>B1</td><td>C1</td><td>D1</td><td><s>E1</s></td><td><s>F1</s></td><td><s>G1</s></td><td><s>H2</s></td></tr></tbody></table><p>可直接排除各组最后四名赛马，也就是后四组全部淘汰，剩余 <code>32 - 4 * 4 = 16</code>，其中第一名已经知道就是<code>A1</code></p><p>需要注意的是：这里还可以继续排除</p><ol><li>因为在头名争夺中 <code>D1</code>只能排第四，所以<code>D1</code>最快也是第四，D组剩余被淘汰</li><li>同理C组最多只有2名在前4</li><li>同理B组最多只有1名在前4</li></ol><table><thead><tr><th>分组</th><th>第一名</th><th>第二名</th><th>第三名</th><th>第四名</th></tr></thead><tbody><tr><td>A</td><td><strong>A1</strong></td><td>A2</td><td>A3</td><td>A4</td></tr><tr><td>B</td><td>B1</td><td>B2</td><td>B3</td><td><s>B4</s></td></tr><tr><td>C</td><td>C1</td><td>C2</td><td><s>C3</s></td><td><s>C4</s></td></tr><tr><td>D</td><td>D1</td><td><s>D2</s></td><td><s>D3</s></td><td><s>D4</s></td></tr></tbody></table><p>所以剩余需要确认的数量为 16 - 1 - 3 - 2 - 1 = 9。</p><p><strong>第三步</strong>：剩余的9匹赛马中需要选出8匹马再次进行一次赛马</p><p>这里是否有一匹特殊的马，不需要参与赛跑进行这一次赛马就能得出结果？</p><ol><li>排除A组中的3匹马中的一匹，那么除非B1都输或者都赢，否则B1以及后面的排名不确定。也就是排除前面的对后面影响较大</li><li>排除D1/C2，那么可能无法确认D1与C2谁是第四</li><li>排除C1与排除其他一样，可能无法确认自己和它身后的排名</li></ol><p>所以，这里最好从D1与C2中排除一个进行赛跑，如果这一轮得出结果，那么就不用跑。如果没有得出结论就再跑一次</p><p>因为所有赛马的第一名已经确认是第一，所以剩下的比赛就是确认 <code>2 - 4</code> 名次，C1要是所有赛马的前四名，这次必须跑入前三。</p><p>第一种可能：C1第三名或者第三名之后，那么比赛结束，一共经过了 <code>8 + 1 + 1 = 10</code> 赛出前四名</p><p>第二种可能：C1排在第二名，也就是说 C2 和 D1 无法确认谁是第四个，那么就需要加赛一场。排除前三，剩余的马再比一场。一共经过了 <code>8 + 1 + 1 + 1 = 11</code></p><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/103572219" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/103572219</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题描述&quot;&gt;&lt;/a&gt; 问题描述&lt;/h3&gt;
&lt;p&gt;64匹马，8个跑道，问最少比赛多少场，可以选出跑得最快的4匹马。每场比赛每个跑道只允许一匹马，且不存在并列情形&lt;/p&gt;
&lt;h3 id
      
    
    </summary>
    
    
      <category term="Interesting Algorithm" scheme="http://xboom.github.io/categories/Interesting-Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://xboom.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>go-zero2-共享调用</title>
    <link href="http://xboom.github.io/2022/06/28/GoZero/GoZero2-%E5%85%B1%E4%BA%AB%E8%B0%83%E7%94%A8/"/>
    <id>http://xboom.github.io/2022/06/28/GoZero/GoZero2-%E5%85%B1%E4%BA%AB%E8%B0%83%E7%94%A8/</id>
    <published>2022-06-27T16:55:17.000Z</published>
    <updated>2022-07-02T14:45:14.537Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h3><p>并发场景下，可能会有多个线程（协程）同时请求同一份资源，如果每个请求都要走一遍资源的请求过程，除了比较低效之外，还会对资源服务造成并发的压力。</p><p>例如：</p><ol><li>缓存失效的同时多个请求同时到达某服务请求相同资源，这些请求会继续访问DB做查询，会引起数据库压力瞬间增大。而使用 <code>SharedCalls</code> 可以使得同时多个请求只需要发起一次拿结果的调用，其他请求&quot;坐享其成&quot;。有效减少了资源服务的并发压力，可以有效防止缓存击穿</li><li>云平台服务众多，使用<code>grpc</code>通信的时候不期望每个服务之间都建立链接，而只在向对端发送消息的时候，才在服务之间建立通信。老的逻辑是当开始建立连接的时候会将创建改为正在创建链接，后续消息会因为正在建立链接会直接返回错误或阻塞等待结果(自行实现)，而使用<code>SharedCalls</code>可以短时间内等待链接建立然后继续发送消息</li></ol><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/sharecalls.png" alt="sharecalls" /></p><h3 id="演示代码"><a class="markdownIt-Anchor" href="#演示代码"></a> 演示代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> round = <span class="number">5</span></span><br><span class="line">  var wg sync.WaitGroup</span><br><span class="line">  barrier := syncx.NewSharedCalls()</span><br><span class="line"></span><br><span class="line">  wg.Add(round)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; round; i++ &#123;</span><br><span class="line">    <span class="comment">// 多个线程同时执行</span></span><br><span class="line">    <span class="function">go <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      defer wg.Done()</span><br><span class="line">      <span class="comment">// 可以看到，多个线程在同一个 key 上去请求资源，获取资源的实际函数只会被调用一次</span></span><br><span class="line">      val, err := barrier.Do(<span class="string">"once"</span>, func() (interface&#123;&#125;, error) &#123;</span><br><span class="line">        <span class="comment">// sleep 1秒，为了让多个线程同时取 once 这个 key 上的数据</span></span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        <span class="comment">// 生成了一个随机的 id</span></span><br><span class="line">        <span class="keyword">return</span> stringx.RandId(), nil</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><p>文件目录：<code>core/syncx/singleflight.go</code></p><p><code>SingleFlight</code> 通过为并发的请求根据相同的key提供相同的结果</p><p>一共提供了 <code>Do</code> 与 <code>DoEx</code> 两种接口</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SingleFlight <span class="keyword">interface</span> &#123;</span><br><span class="line">   Do(key <span class="keyword">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span></span><br><span class="line">   DoEx(key <span class="keyword">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>, error)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> call <span class="keyword">struct</span> &#123;<span class="comment">//代指一次调用</span></span><br><span class="line">wg  sync.WaitGroup  <span class="comment">//用于等待call结束</span></span><br><span class="line">val <span class="keyword">interface</span>&#123;&#125;     </span><br><span class="line">err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flightGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">calls <span class="keyword">map</span>[<span class="keyword">string</span>]*call</span><br><span class="line">lock  sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先查看两个基础函数</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *flightGroup)</span> <span class="title">createCall</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(c *call, done <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 先申请加锁</span></span><br><span class="line">  g.lock.Lock()</span><br><span class="line"><span class="keyword">if</span> c, ok := g.calls[key]; ok &#123;<span class="comment">//如果key存在，那么等待</span></span><br><span class="line"><span class="comment">// 拿到 call 以后，释放锁，此处 call 可能还没有实际数据，只是一个空的内存占位</span></span><br><span class="line">    g.lock.Unlock()</span><br><span class="line"><span class="comment">//调用 wg.Wait，判断是否有其他 goroutine 正在申请资源，如果阻塞，说明有其他 goroutine 正在获取资源</span></span><br><span class="line">    c.wg.Wait()<span class="comment">//等待相同的call的结束</span></span><br><span class="line">    <span class="comment">// 当 wg.Wait 不再阻塞，表示资源获取已经结束，可以直接返回结果</span></span><br><span class="line"><span class="keyword">return</span> c, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = <span class="built_in">new</span>(call)<span class="comment">//创建一个新的call</span></span><br><span class="line">c.wg.Add(<span class="number">1</span>)     <span class="comment">//并为这个call添加一个的等待</span></span><br><span class="line">g.calls[key] = c</span><br><span class="line">g.lock.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *flightGroup)</span> <span class="title">makeCall</span><span class="params">(c *call, key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>)</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">g.lock.Lock()</span><br><span class="line"><span class="built_in">delete</span>(g.calls, key)<span class="comment">//删除</span></span><br><span class="line">g.lock.Unlock()</span><br><span class="line">c.wg.Done()           <span class="comment">//结束call</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">c.val, c.err = fn()   <span class="comment">//执行函数并返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看实现逻辑</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *flightGroup)</span> <span class="title">Do</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">c, done := g.createCall(key)<span class="comment">//根据key定义一个call</span></span><br><span class="line"><span class="keyword">if</span> done &#123;<span class="comment">//如果是等待结束了，且等待结束了，则返回Call的value</span></span><br><span class="line"><span class="keyword">return</span> c.val, c.err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是新的，那么就首次执行call，并返回结果</span></span><br><span class="line">  g.makeCall(c, key, fn)</span><br><span class="line"><span class="keyword">return</span> c.val, c.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *flightGroup)</span> <span class="title">DoEx</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(val <span class="keyword">interface</span>&#123;&#125;, fresh <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">c, done := g.createCall(key)</span><br><span class="line"><span class="keyword">if</span> done &#123; <span class="comment">//等待结束</span></span><br><span class="line"><span class="keyword">return</span> c.val, <span class="literal">false</span>, c.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g.makeCall(c, key, fn)</span><br><span class="line"><span class="keyword">return</span> c.val, <span class="literal">true</span>, c.err <span class="comment">//新的结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewSingleFlight returns a SingleFlight.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSingleFlight</span><span class="params">()</span> <span class="title">SingleFlight</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;flightGroup&#123;</span><br><span class="line">calls: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*call),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DoEx</code> 相较于 <code>Do</code> 中增加了一个 <code>bool</code> 类型的返回值，表示返回的值是共享的还是首次拿到的</p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://talkgo.org/t/topic/968" target="_blank" rel="noopener">https://talkgo.org/t/topic/968</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题背景&quot;&gt;&lt;/a&gt; 问题背景&lt;/h3&gt;
&lt;p&gt;并发场景下，可能会有多个线程（协程）同时请求同一份资源，如果每个请求都要走一遍资源的请求过程，除了比较低效之外，还会对资源服务造成并
      
    
    </summary>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/categories/go-zero/"/>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>go-zero1-架构</title>
    <link href="http://xboom.github.io/2022/06/28/GoZero/GoZero1-%E6%9E%B6%E6%9E%84/"/>
    <id>http://xboom.github.io/2022/06/28/GoZero/GoZero1-%E6%9E%B6%E6%9E%84/</id>
    <published>2022-06-27T16:55:05.000Z</published>
    <updated>2022-07-17T13:54:33.049Z</updated>
    
    <content type="html"><![CDATA[<p><code>go-zero</code> 包含很多微服务治理能力，所以不一定要完整使用go-zero，通过外部引入也是可以的</p><h4 id="go-zero结构"><a class="markdownIt-Anchor" href="#go-zero结构"></a> Go-Zero结构</h4><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220617011432.png" alt="架构图" /></p><p>包含诸多特点：</p><ul><li>强大的工具支持，尽可能少的代码编写</li><li>极简的接口</li><li>完全兼容 net/http</li><li>支持中间件，方便扩展</li><li>高性能</li><li>面向故障编程，弹性设计</li><li>内建服务发现、负载均衡</li><li>内建限流、熔断、降载，且自动触发，自动恢复</li><li>API 参数自动校验</li><li>超时级联控制</li><li>自动缓存控制</li><li>链路跟踪、统计报警等</li><li>高并发支撑，稳定保障了疫情期间每天的流量洪峰</li></ul><p>如下图，我们从多个层面保障了整体服务的高可用：</p><img src="https://raw.githubusercontent.com/zeromicro/zero-doc/main/doc/images/resilience.jpg" alt="弹性设计" style="zoom: 33%;" /><h3 id="框架设计"><a class="markdownIt-Anchor" href="#框架设计"></a> 框架设计</h3><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/architechture.svg" alt="" /></p><p>设计理念：</p><ul><li>保持简单，第一原则</li><li>弹性设计，面向故障编程</li><li>工具大于约定和文档</li><li>高可用</li><li>高并发</li><li>易扩展</li><li>对业务开发友好，封装复杂度</li><li>约束做一件事只有一种方式</li></ul><h3 id="技术内幕"><a class="markdownIt-Anchor" href="#技术内幕"></a> 技术内幕</h3><ol><li>防止缓存击穿之共享调用</li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://github.com/zeromicro/go-zero/blob/master/readme-cn.md" target="_blank" rel="noopener">https://github.com/zeromicro/go-zero/blob/master/readme-cn.md</a></li><li><a href="https://talkgo.org/c/go-zero/23" target="_blank" rel="noopener">https://talkgo.org/c/go-zero/23</a></li><li><a href="https://go-zero.dev/cn/docs/design/design" target="_blank" rel="noopener">https://go-zero.dev/cn/docs/design/design</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;go-zero&lt;/code&gt; 包含很多微服务治理能力，所以不一定要完整使用go-zero，通过外部引入也是可以的&lt;/p&gt;
&lt;h4 id=&quot;go-zero结构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#go-zero结构&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/categories/go-zero/"/>
    
    
      <category term="go-zero" scheme="http://xboom.github.io/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>ETCD入门3-RAFT协议</title>
    <link href="http://xboom.github.io/2022/03/13/ETCD/ETCD%E5%85%A5%E9%97%A83-RAFT%E5%8D%8F%E8%AE%AE/"/>
    <id>http://xboom.github.io/2022/03/13/ETCD/ETCD%E5%85%A5%E9%97%A83-RAFT%E5%8D%8F%E8%AE%AE/</id>
    <published>2022-03-13T02:25:38.000Z</published>
    <updated>2022-06-25T07:00:00.112Z</updated>
    
    <content type="html"><![CDATA[<p>一致性是指在集群中的多个节点在状态上达成一致，常见的一致性协议有Raft、Paxos、ZAB</p><h3 id="基本规则"><a class="markdownIt-Anchor" href="#基本规则"></a> 基本规则</h3><p>任期(Term)：实际上是一个全局的、连续递增的整数。在raft中，每进行一次选举，任期就会+1</p><p>节点存在三种状态分别是：</p><ul><li>Leader节点：可读可写、处理日志复制、保证⼀致性、维护⼼跳</li><li>Follower节点：可进行读操作，写操作需要路由到Leader处理；参与投票，⼀个term任期内只能投⼀次; 当触发 election timeout 时，晋升为 candidate ;(注意读请求模式的线性读)</li><li>Candidate节点：集群的候选者，会发起投票试图当选leader ; 通过 RequestVote 通知其他节点来投票;</li></ul><p>集群中任意一个节点都处于这三个状态之一</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220125000023.png" alt="image-20220125000018705" style="zoom:80%;" /><p>如上图所示</p><ol><li>当etcd节点刚启动的时候，状态机初始化状态为Follower</li><li>为了进行Leader 选举控制有两个时间<ul><li>选举超时时间(election timeout): 每个Follower节点会因为超过选举超时时间还没有收到Leader的心跳而切换程Candidate状态并发起选举。一般为 150ms ~ 300ms，是一个一定范围的随机数(为了保证各节点不是同时发起选举请求)</li><li>心跳超时时间(heartbeat timeout): Leader节点向集群中其他Follower节点发送心跳消息的时间间隔</li></ul></li></ol><h3 id="脑裂问题"><a class="markdownIt-Anchor" href="#脑裂问题"></a> 脑裂问题</h3><p>原本一个集群，被分成了两个集群，同时出现了两个“大脑”，这就是所谓的“脑裂”现象</p><p>ETCD是否有可能出现脑裂？</p><ol><li>第一种情况：两边都得到过半票数而选举出Leader的情况，不可能出现</li><li>第二种情况：两边都无法得到过半票数而无法选举出Leader的情况，则服务端会返回客户端集群不可用</li></ol><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312195949.png" alt="image-20220312195949615" style="zoom:50%;" /><ol start="3"><li><p>第三种情况：Leader 与 其他节点通信异常，导致其他节点重新选出 Leader</p><ul><li><p>Leader 知道与其他节点通信异常</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220313110944.png" alt="image-20220313110426872" /></p><ul><li>由于 leader A ⽆法同步数据到多数节点, 造成 client 写请求失败 ;</li><li>⽹络分区后 follower c 长时间未收到⼼跳, 则触发选举且当选 ;</li><li>client 按照策略⼀直尝试跟可用的节点进⾏请求 ;</li><li>当⽹络恢复后, leader A B 将降为 follower, 并且强制同步 Leader C 的数据 ;</li></ul></li><li><p>Leader 不知道与还不知道与其他节点通信异常</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220313111102.png" alt="image-20220313111102564" /></p><ul><li>在 leader-A 里标记 client 请求为 未提交模式 ;</li><li>follower c 首先触发超时发起选举投票, folower ED 收到更加新的 term 过去的 requestVote, 则回应同意当选 ;</li><li>leader C 可以接收用户的请求, 由于可以拿到⼤多数的回应, 则可以正常提交数据 ;</li><li>当⽹络分区问题解决后, 由于旧集群的Leader A 的term 低于 Leader C , leader A 强制 同步 Leader C的数据;</li></ul></li></ul></li></ol><h3 id="leader选举"><a class="markdownIt-Anchor" href="#leader选举"></a> Leader选举</h3><p>能称为Leader的条件有</p><ul><li>当前集群⽆可用 leader ;</li><li>触发 election timeout ;</li><li>term 任期最新 ;</li><li>log 日志最新 ;</li><li>获取多数投票 ;</li></ul><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312200222.png" alt="image-20220312200222021" /></p><p>流程可以查看：<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></p><p>需要注意的是：</p><ol><li>超过集群半数节点应答，才将日志写入WAL中，也是就如果没有等到半数应答就挂了，那么数据就丢了</li><li>Follower 收到 Leader 的 复制日志 则直接将日志写入 WAL 中</li><li>当Follower收到 Vote Request 也会重置 election timeout 定时器(降低同时出现两个候选人的概率)</li><li>Term 将持续直到某个节点因为心跳超时而从新发起选举</li><li>出现多个候选人都没有称为 Leader，那么选举失败，切换为Follower，等待下一个选举超时</li><li>Leader 宕机后，其他节点重新选出新 Leader。等到旧Leader 恢复，会因为收到新Leader心跳 而自己的 Term 落后，切换成 Follower，更新自己的Term，然后重新投出自己的选票</li></ol><h4 id="基本流程"><a class="markdownIt-Anchor" href="#基本流程"></a> 基本流程</h4><p>将设ETCD集群中有三个节点(A、B、C)</p><img src="/Users/yuankang/Library/Application%20Support/typora-user-images/image-20220306233505794.png" alt="image-20220306233505794" style="zoom:50%;" /><ol><li>初始化，所有节点起初都是 Follower 状态(Term = 0， 得票数 = 0)</li><li>节点 A 由于长时间未收到 Leader 的心跳消息，就会切换成为Candidate 状态并发起选举（节点 A 的选举计时器 （election timer）己被重置）</li><li>节点 A 首先会将自己的选票投给自己，并会向集群中其他节点发送选举请求（ Request Vote ）以获取其选票，此时的节点 B 和节点 C 还都是处于 Term=0 的任期之中，且都是 Follower 状态，均未投出 Term=1 任期中的选票，所以节点 B 和节点 C 在接收到节点 A 的选举请求后会将选票投给节点 A，任期变为1。</li></ol><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220306235342.png" alt="image-20220306235342760" style="zoom:50%;"/><ol start="4"><li><p>在节点 A 收到节点 B、 C 的投票之后，其收到了集群中超过半数的选票，所以在 Terrn = 1 的任期中，该集群的 Leader 节点就是节点 A，其他节点将切换成 Follower 状态，</p><blockquote><p>集群中的节点除 了记录当期任期号(currentTerrn)，还会记录在该任期中当前节点的投票结果(VoteFor）</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220307000505.png" alt="image-20220307000505928" style="zoom:50%;" /></li><li><p>成为 Terrn = 1 任期的 Leader 节点之后，节点 A 会定期向集群中的其他节点发送心跳消息，防止节点 B 和节点 C 中的选举计时器(election timer) 超时而触发新一轮的选举: 当节点 B 和节点 C (Follower) 收到节点 A 的心跳消息之后会重置选举计时器</p><blockquote><p>心跳超时时间（heartbeat timeout）需要远小于选举超时时间(election timeout)</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220307000654.png" alt="image-20220307000653976" style="zoom:50%;" /></li></ol><blockquote><p>Candidate 发起选举前,会先尝试连接集群中的其他节点。如果连接不上，放弃本次选举。这个状态称之为：Prevote</p></blockquote><p>问题1：如果Leader节点频繁宕机，或者选举反复进行，怎么办？</p><p>要求：广播时间 &lt;&lt; 选举超时时间 &lt;&lt; 平均故障间隔时间</p><ul><li>广播时间：节点直接发送心跳信息的完整返回时间 hearthbeat timeout：0.5ms~50ms</li><li>选举超时时间：election timer：200ms~1s</li><li>故障间隔时间：两次故障的平均时间：1个月或更多(保证节点的不要经常出古故障)</li></ul><p>这样最大程度保证：不会频繁选举（广播时间 &lt;&lt; 选举超时时间），故障时间最多为200ms~1s（选举超时时间 &lt;&lt; 平均故障间隔时间）</p><p>问题2：是不是谁先发起了选举请求，谁就得到了Leader？</p><p>不是，除了看先后顺序，还取决于Candidate节点的日志是不是最新最全的日志，否则拒绝投票，防止出现日志（即数据）丢失的情况</p><h4 id="prevote"><a class="markdownIt-Anchor" href="#prevote"></a> Prevote</h4><p>当出现网络分区，节点因为选举超时而不断的进行 term 增加，而 leader 会因为遇到更新的 term 而退化为 follower，为了防止 term不断的新增，使用了 Prevote 措施，变为 candidate 的条件</p><ul><li>询问其他节点是否有可用 leader ;</li><li>可连通绝⼤数节点 ;</li></ul><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220313104101.png" alt="image-20220313104056708" style="zoom:50%;" /><h3 id="日志复制"><a class="markdownIt-Anchor" href="#日志复制"></a> 日志复制</h3><h4 id="基本流程-2"><a class="markdownIt-Anchor" href="#基本流程-2"></a> 基本流程</h4><p>流程动画：<a href="http://thesecretlivesofdata.com/raft/#replication" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/#replication</a></p><p>步骤如下：</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312204541.png" alt="image-20220312204541060"  /><ol><li>Leader 节点接到 client 请求后（如 set a=10）,将本请求计入本地log</li></ol><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312204707.png" alt="image-20220312204707596" /></p><ol start="2"><li>Leader 节点向 Follower1 和 Follower2 发送Append Entries消息（set a=10）</li><li>Follower1 和 Follower2 将此信息计入本地log，并返回给 Leader</li></ol><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312204848.png" alt="image-20220312204848066" /></p><ol><li>Leader 将日志信息置为 已提交(Commited),然后状态机处理。</li><li>响应 client 请求</li><li>向 Follower1 和 Follower2 发送消息，该信息已提交</li><li>Follower1 和 Follower2 接到消息后，修改日志状态，交给自己的状态机处理</li></ol><blockquote><p>存在的问题：计入本地log是否是写入WAL，按照之前的流程是没有的，而是在提交之后，那么Follower又是什么时候写入WAL的？</p></blockquote><h4 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引</h4><p>集群中各个节点都会维护一个本地Log 用于记录更新操作，还会维护 <code>commitlndex</code> 和<code>lastApplied</code> 两个值，它们是本地Log 的索引值</p><ul><li><code>commitlndex</code> 表示的是当前节点已知的、最大的、己提交的日志索引值</li><li><code>lastApplied</code> 表示的是当前节点最后一条被应用到状态机中的日志索引值。</li></ul><p>当节点中的 <code>commitlndex</code> 值大于 <code>lastApplied</code> 值时，会将 <code>lastApplied+ 1</code> ，并将 <code>lastApplied</code> 对应的日志应用到其状态机中。</p><p>除此之外，在Leader还需要了解集群中其他Follower 节点的这些信息，而决定下次发送Append Entries 消息中包含哪些日志记录。为此， Leader 节点会维护 <code>nextlndex[]</code>和 <code>matchlndex[]</code>两个数组，这两个数组中记录的都是日志索引值</p><ul><li><code>nextlndex[]</code> 记录了需要发送给每个Follower 节点的下一条日志的索引值</li><li><code>matchlndex[]</code> 记录了己经复制给每个Follower 节点的最大的日志索引值</li></ul><blockquote><p>一个数组不就可以表达了吗？</p></blockquote><p>例如：</p><p>Follower 节点中最后一条日志的索引值大于等于该 Follower 节点对应的 <code>nextlndex</code> 值，那么通过Append Entries 消息发送从<code>nextlndex</code> 开始的所有日志。之后， Leader节点会检测该 Follower 节点返回的相应响应，</p><ul><li>如果成功则更新相应该Follower 节点对应的 <code>nextlndex</code> 值和<code>matchlndex</code> 值；</li><li>如果因为日志不一致而失败，则减少 <code>nextlndex</code> 值重试。</li></ul><h4 id="一致性复制"><a class="markdownIt-Anchor" href="#一致性复制"></a> 一致性复制</h4><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312211352.png" alt="image-20220312211352566" style="zoom:50%;" /><p>raft 中的每个日志记录都带有 term 和 log index 来唯⼀标识 ;</p><ul><li>日志记录具有两个特性 如果两条不同节点的某两个日志记录具有相同的 term 和 index 号，则两条记录⼀定是完全相同的 ;</li><li>如果两条不同节点的某两个日志记录具有相同的 term 和 index 号，则两 条记录之前的所有记录也⼀定是完全相同的 ;</li></ul><p>以此来判断 leader与 follower 之间的 日志是否相同</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312210348.png" alt="image-20220312210348704" style="zoom:50%;" /><blockquote><p>上图中：a 和 b 的情况是没有完全收到来自 leader 的 AppendEntries RPC, ⽽ c-f 则是带有不同时期的未提交的日志（有可能是他们当 leader 时产⽣的，但没有提交就 crash了）</p></blockquote><ul><li>leader 从来不会覆盖，删除或者修改其日志 ;</li><li>leader 会初始化⼀个数组 nextIndex[], 该结构对应的值表示本 leader 将给对应 follower 发送的下⼀条日志 index ;</li><li>若 follower 对比其前⼀条 log 不⼀致，则会拒绝 leader 发来的请求. 此时 leader 就将其在 nextIndex[] 中的对应值减⼀ ;</li><li>leader 不断重试直到 follower 比对成功, 然后 <strong>follower 接受 AppendEntries RPC, ⼀个个的抛弃所有冲突的日志</strong> ;</li><li>leader 按照自身日志顺序将日志正常复制给 follower，并不断将 nextIndex[] 对应 值 +1，直到对应值 “追上” 自身日志的 index 为⽌;</li></ul><blockquote><p>为什么要一个一个对比，而不直接找到对应的位置，批量复制？=&gt; 通过数组存储的是索引，但是日志比较是通过 index 与 term</p><p>那数组为什么不存 index 与 term? =&gt; 因为本来每个节点的 操作都是不一样的，其他节点无法</p></blockquote><h4 id="异常情况"><a class="markdownIt-Anchor" href="#异常情况"></a> 异常情况</h4><h5 id="场景1"><a class="markdownIt-Anchor" href="#场景1"></a> 场景1：</h5><p>两个Follower 节点不可用，Leader 如何处理请求</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312201120.png" alt="image-20220312201120077" style="zoom:50%;" /><ul><li><p>leader 通过⼼跳已知 follower 已挂, 则直接返回错误 ;</p></li><li><p>leader 不知节点已挂, 同步数据时得知异常; 触发异常触发超时</p></li></ul><h5 id="场景2"><a class="markdownIt-Anchor" href="#场景2"></a> <strong>场景2：</strong></h5><p>提交给Leader后，发生了crash</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312201343.png" alt="image-20220312201343089" style="zoom:50%;" /><ul><li><p>leader 本地已记录 未提交日志, 重启后强制同步新 leader 数据 ;</p></li><li><p>leader 还没记录未提交日志就crash, 丢了就丢了;</p></li></ul><h5 id="场景3"><a class="markdownIt-Anchor" href="#场景3"></a> 场景3</h5><p>复制给 follower-1 后, leader就发⽣了 crash ?</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312202452.png" alt="image-20220312202452036" style="zoom:50%;" /><ul><li>leader 发⽣了重启，集群触发新的选举 ;</li><li>由于 follower-1 的数据较新, 那么该节点会晋升 leader ;</li><li>follower-1 会把 uncommited 的 v=3 同步给其他节点 ;</li><li>follower-1 收到其他节点接收确认后, 进⾏提交日志 ;</li></ul><h5 id="场景4"><a class="markdownIt-Anchor" href="#场景4"></a> 场景4：</h5><p>follower 返回确认消息时, leader 发⽣了 crash ?</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312202600.png" alt="image-20220312202600126" style="zoom:50%;" /><ul><li>三个节点的数据已经⼀致, 都为 uncommited v=3 ; 这时谁当 Leader 都可以 ; 新leader当选后, 需要进⾏同步提交通知 ;</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li>《ETCD技术内幕》</li><li><a href="http://www.xuyasong.com/?p=1706" target="_blank" rel="noopener">http://www.xuyasong.com/?p=1706</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一致性是指在集群中的多个节点在状态上达成一致，常见的一致性协议有Raft、Paxos、ZAB&lt;/p&gt;
&lt;h3 id=&quot;基本规则&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基本规则&quot;&gt;&lt;/a&gt; 基本规则&lt;/h3&gt;
&lt;p&gt;任期(Term)：实际上
      
    
    </summary>
    
    
      <category term="ETCD" scheme="http://xboom.github.io/categories/ETCD/"/>
    
    
      <category term="ETCD" scheme="http://xboom.github.io/tags/ETCD/"/>
    
  </entry>
  
</feed>
