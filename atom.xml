<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XBoom Dove</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xboom.github.io/"/>
  <updated>2022-08-27T04:37:18.738Z</updated>
  <id>http://xboom.github.io/</id>
  
  <author>
    <name>XBoom Dove</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go入门13-style</title>
    <link href="http://xboom.github.io/2022/08/27/Go/Go%E5%85%A5%E9%97%A813-style/"/>
    <id>http://xboom.github.io/2022/08/27/Go/Go%E5%85%A5%E9%97%A813-style/</id>
    <published>2022-08-27T01:45:57.712Z</published>
    <updated>2022-08-27T04:37:18.738Z</updated>
    
    <content type="html"><![CDATA[<p>所有代码都应该通过<code>golint</code>和<code>go vet</code>的检查并无错误。建议将编辑器设置为：</p><ul><li>保存时运行 <code>goimports</code></li><li>运行 <code>golint</code> 和 <code>go vet</code> 检查错误</li></ul><h2 id="指导原则"><a class="markdownIt-Anchor" href="#指导原则"></a> 指导原则</h2><h3 id="指向-interface-的指针"><a class="markdownIt-Anchor" href="#指向-interface-的指针"></a> 指向 interface 的指针</h3><p>应该将接口作为值进行传递，在这样的传递过程中，实质上传递的底层数据仍然可以是指针。接口实质上在底层用两个字段表示：</p><ol><li>一个指向某些特定类型信息的指针。可以将其视为&quot;type&quot;。</li><li>数据指针。如果存储的数据是指针，则直接存储。如果存储的数据是一个值，则存储指向该值的指针。</li></ol><p>如果希望接口方法修改基础数据，则必须使用指针传递 (将对象指针赋值给接口变量)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> F <span class="keyword">interface</span> &#123;</span><br><span class="line">  f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S1)</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S2)</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f1.f() 无法修改底层数据</span></span><br><span class="line"><span class="comment">// f2.f() 可以修改底层数据，给接口变量 f2 赋值时使用的是对象指针</span></span><br><span class="line"><span class="keyword">var</span> f1 F = S1&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f2 F = &amp;S2&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="interface-合理性验证"><a class="markdownIt-Anchor" href="#interface-合理性验证"></a> Interface 合理性验证</h3><p>在编译时验证接口的符合性。这包括：</p><ul><li>将实现特定接口的导出类型作为接口 API 的一部分进行检查</li><li>实现同一接口的 (导出和非导出) 类型属于实现类型的集合</li><li>任何违反接口合理性检查的场景，都会终止编译，并通知给用户</li></ul><blockquote><p>上面 3 条是编译器对接口的检查机制，错误使用接口会在编译期报错。所以可以利用这个机制让部分问题在编译期暴露&gt;</p></blockquote><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 Handler 没有实现 http.Handler，会在运行时报错</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">ServeHTTP</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  w http.ResponseWriter,</span></span></span><br><span class="line"><span class="function"><span class="params">  r *http.Request,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于触发编译期的接口的合理性检查机制</span></span><br><span class="line"><span class="comment">// 如果 Handler 没有实现 http.Handler，会在编译期报错</span></span><br><span class="line"><span class="keyword">var</span> _ http.Handler = (*Handler)(<span class="literal">nil</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">ServeHTTP</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  w http.ResponseWriter,</span></span></span><br><span class="line"><span class="function"><span class="params">  r *http.Request,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>如果 <code>*Handler</code> 与 <code>http.Handler</code> 的接口不匹配，那么语句 <code>var _ http.Handler = (*Handler)(nil)</code> 将无法编译通过。</p><blockquote><p><strong>赋值的右边应该是断言类型的零值。对于指针类型（如 <code>*Handler</code>）、切片和映射，这是 <code>nil</code>；对于结构类型，这是空结构。</strong></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LogHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">  h   http.Handler</span><br><span class="line">  log *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _ http.Handler = LogHandler&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h LogHandler)</span> <span class="title">ServeHTTP</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  w http.ResponseWriter,</span></span></span><br><span class="line"><span class="function"><span class="params">  r *http.Request,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接收器-receiver-与接口"><a class="markdownIt-Anchor" href="#接收器-receiver-与接口"></a> 接收器 (receiver) 与接口</h3><p>使用值接收器的方法既可以通过值调用，也可以通过指针调用。带指针接收器的方法只能通过指针或 <a href="https://golang.org/ref/spec#Method_values" target="_blank" rel="noopener">addressable values</a> 调用。</p><p>例如，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">  data <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S)</span> <span class="title">Read</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s.data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S)</span> <span class="title">Write</span><span class="params">(str <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  s.data = str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sVals := <span class="keyword">map</span>[<span class="keyword">int</span>]S&#123;<span class="number">1</span>: &#123;<span class="string">"A"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过值只能调用 Read</span></span><br><span class="line">sVals[<span class="number">1</span>].Read()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这不能编译通过：Cannot call pointer method on 'sVals[1]'</span></span><br><span class="line"><span class="comment">// sVals[1].Write("test")</span></span><br><span class="line"></span><br><span class="line">sPtrs := <span class="keyword">map</span>[<span class="keyword">int</span>]*S&#123;<span class="number">1</span>: &#123;<span class="string">"A"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过指针既可以调用 Read，也可以调用 Write 方法</span></span><br><span class="line">sPtrs[<span class="number">1</span>].Read()</span><br><span class="line">sPtrs[<span class="number">1</span>].Write(<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>map[int]*S{1: {&quot;A&quot;}}</code> 与 <code>map[int]s{1: {&quot;A&quot;}}</code> 都是用 <code>{&quot;A&quot;}</code> 进行初始化</p></blockquote><p>类似的，即使方法有了值接收器，也同样可以用指针接收器来满足接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> F <span class="keyword">interface</span> &#123;</span><br><span class="line">  f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S1)</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S2)</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">s1Val := S1&#123;&#125;</span><br><span class="line">s1Ptr := &amp;S1&#123;&#125;</span><br><span class="line">s2Val := S2&#123;&#125;</span><br><span class="line">s2Ptr := &amp;S2&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i F</span><br><span class="line">i = s1Val</span><br><span class="line">i = s1Ptr</span><br><span class="line">i = s2Ptr</span><br><span class="line"></span><br><span class="line"><span class="comment">//  下面代码无法通过编译。因为 s2Val 是一个值，而 S2 的 f 方法中没有使用值接收器</span></span><br><span class="line"><span class="comment">//   i = s2Val</span></span><br></pre></td></tr></table></figure><p><a href="https://golang.org/doc/effective_go.html" target="_blank" rel="noopener">Effective Go</a> 中有一段关于 <a href="https://golang.org/doc/effective_go.html#pointers_vs_values" target="_blank" rel="noopener">pointers vs. values</a> 的精彩讲解。</p><p>补充：</p><ul><li>一个类型可以有值接收器方法集和指针接收器方法集<ul><li>值接收器方法集是指针接收器方法集的子集，反之不是</li></ul></li><li>规则<ul><li>值对象只可以使用值接收器方法集</li><li>指针对象可以使用 值接收器方法集 + 指针接收器方法集</li></ul></li><li>接口的匹配 (或者叫实现)<ul><li>类型实现了接口的所有方法，叫匹配</li><li>具体的讲，要么是类型的值方法集匹配接口，要么是指针方法集匹配接口</li></ul></li></ul><p>具体的匹配分两种：</p><ul><li>值方法集和接口匹配<ul><li>给接口变量赋值的不管是值还是指针对象，都 ok，因为都包含值方法集</li></ul></li><li>指针方法集和接口匹配<ul><li>只能将指针对象赋值给接口变量，因为只有指针方法集和接口匹配</li><li>如果将值对象赋值给接口变量，会在编译期报错 (会触发接口合理性检查机制)</li></ul></li></ul><p>为啥 i = s2Val 会报错，因为值方法集和接口不匹配。</p><h3 id="零值-mutex-是有效的"><a class="markdownIt-Anchor" href="#零值-mutex-是有效的"></a> 零值 Mutex 是有效的</h3><p>零值 <code>sync.Mutex</code> 和 <code>sync.RWMutex</code> 是有效的。所以指向 mutex 的指针基本是不必要的。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mu := <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line">mu.Lock()</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">mu.Lock()</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>如果使用结构体指针，mutex 应该作为结构体的非指针字段。即使该结构体不被导出，也不要直接把 mutex 嵌入到结构体中。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SMap <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.Mutex</span><br><span class="line"></span><br><span class="line">  data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSMap</span><span class="params">()</span> *<span class="title">SMap</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;SMap&#123;</span><br><span class="line">    data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SMap)</span> <span class="title">Get</span><span class="params">(k <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  m.Lock()</span><br><span class="line">  <span class="keyword">defer</span> m.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> m.data[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SMap <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line"></span><br><span class="line">  data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSMap</span><span class="params">()</span> *<span class="title">SMap</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;SMap&#123;</span><br><span class="line">    data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SMap)</span> <span class="title">Get</span><span class="params">(k <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  m.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> m.data[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><p><code>Mutex</code> 字段， <code>Lock</code> 和 <code>Unlock</code> 方法是 <code>SMap</code> 导出的 API 中不刻意说明的一部分。</p> </td><td><p><code>mutex</code> 及其方法是 <code>SMap</code> 的实现细节，对其调用者不可见。</p> </td></tr> </tbody></table><h3 id="在边界处拷贝-slices-和-maps"><a class="markdownIt-Anchor" href="#在边界处拷贝-slices-和-maps"></a> 在边界处拷贝 Slices 和 Maps</h3><p>slices 和 maps 包含了指向底层数据的指针，因此在需要复制它们时要特别注意。</p><h4 id="接收-slices-和-maps"><a class="markdownIt-Anchor" href="#接收-slices-和-maps"></a> 接收 Slices 和 Maps</h4><p>请记住，当 map 或 slice 作为函数参数传入时，如果存储了对它们的引用，则用户可以对其进行修改。</p><table><thead><tr><th>Bad</th> <th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span> <span class="title">SetTrips</span><span class="params">(trips []Trip)</span></span> &#123;</span><br><span class="line">  d.trips = trips</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trips := ...</span><br><span class="line">d1.SetTrips(trips)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要修改 d1.trips 吗？</span></span><br><span class="line">trips[<span class="number">0</span>] = ...</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span> <span class="title">SetTrips</span><span class="params">(trips []Trip)</span></span> &#123;</span><br><span class="line">  d.trips = <span class="built_in">make</span>([]Trip, <span class="built_in">len</span>(trips))</span><br><span class="line">  <span class="built_in">copy</span>(d.trips, trips)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trips := ...</span><br><span class="line">d1.SetTrips(trips)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里修改 trips[0]，但不会影响到 d1.trips</span></span><br><span class="line">trips[<span class="number">0</span>] = ...</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h4 id="返回-slices-或-maps"><a class="markdownIt-Anchor" href="#返回-slices-或-maps"></a> 返回 slices 或 maps</h4><p>同样，请注意用户对暴露内部状态的 map 或 slice 的修改。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line"></span><br><span class="line">  counters <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Snapshot 返回当前状态。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span> <span class="title">Snapshot</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">int</span></span> &#123;</span><br><span class="line">  s.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s.counters</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// snapshot 不再受互斥锁保护</span></span><br><span class="line"><span class="comment">// 因此对 snapshot 的任何访问都将受到数据竞争的影响</span></span><br><span class="line"><span class="comment">// 影响 stats.counters</span></span><br><span class="line">snapshot := stats.Snapshot()</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line"></span><br><span class="line">  counters <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span> <span class="title">Snapshot</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">int</span></span> &#123;</span><br><span class="line">  s.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  result := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(s.counters))</span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> s.counters &#123;</span><br><span class="line">    result[k] = v</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// snapshot 现在是一个拷贝</span></span><br><span class="line">snapshot := stats.Snapshot()</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="使用-defer-释放资源"><a class="markdownIt-Anchor" href="#使用-defer-释放资源"></a> 使用 defer 释放资源</h3><p>使用 defer 释放资源，诸如文件和锁。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">p.Lock()</span><br><span class="line"><span class="keyword">if</span> p.count &lt; <span class="number">10</span> &#123;</span><br><span class="line">  p.Unlock()</span><br><span class="line">  <span class="keyword">return</span> p.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.count++</span><br><span class="line">newCount := p.count</span><br><span class="line">p.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newCount</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当有多个 return 分支时，很容易遗忘 unlock</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.count &lt; <span class="number">10</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.count++</span><br><span class="line"><span class="keyword">return</span> p.count</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更可读</span></span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>Defer 的开销非常小，只有可以证明函数执行时间处于纳秒级的程度时，才应避免这样做。使用 defer 提升可读性是值得的，因为使用它们的成本微不足道。尤其适用于那些不仅仅是简单内存访问的较大的方法，在这些方法中其他计算的资源消耗远超过 <code>defer</code>。</p><h3 id="channel-的-size-要么是-1要么是无缓冲的"><a class="markdownIt-Anchor" href="#channel-的-size-要么是-1要么是无缓冲的"></a> Channel 的 size 要么是 1，要么是无缓冲的</h3><p>channel 通常 size 应为 1 或是无缓冲的。默认情况下，channel 是无缓冲的，其 size 为零。任何其他尺寸都必须经过严格的审查。需要考虑如何确定大小，考虑是什么阻止了 channel 在高负载下和阻塞写时的写入，以及当这种情况发生时系统逻辑有哪些变化。(翻译解释：按照原文意思是需要界定通道边界，竞态条件，以及逻辑上下文梳理)</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应该足以满足任何情况！</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">64</span>)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大小：1</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 或者</span></span><br><span class="line"><span class="comment">// 无缓冲 channel，大小为 0</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="枚举从-1-开始"><a class="markdownIt-Anchor" href="#枚举从-1-开始"></a> 枚举从 1 开始</h3><p>在 Go 中引入枚举的标准方法是声明一个自定义类型和一个使用了 iota 的 const 组。由于变量的默认值为 0，因此通常应以非零值开头枚举。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add=0, Subtract=1, Multiply=2</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add=1, Subtract=2, Multiply=3</span></span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>在某些情况下，使用零值是有意义的（枚举从零开始），例如，当零值是理想的默认行为时。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LogOutput <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  LogToStdout LogOutput = <span class="literal">iota</span></span><br><span class="line">  LogToFile</span><br><span class="line">  LogToRemote</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LogToStdout=0, LogToFile=1, LogToRemote=2</span></span><br></pre></td></tr></table></figure><h3 id="使用-time-处理时间"><a class="markdownIt-Anchor" href="#使用-time-处理时间"></a> 使用 time 处理时间</h3><p>时间处理很复杂。关于时间的错误假设通常包括以下几点。</p><ol><li>一天有 24 小时</li><li>一小时有 60 分钟</li><li>一周有七天</li><li>一年 365 天</li><li><a href="https://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time" target="_blank" rel="noopener">还有更多</a></li></ol><p>例如，<em>1</em> 表示在一个时间点上加上 24 小时并不总是产生一个新的日历日。</p><p>因此，在处理时间时始终使用 <a href="https://golang.org/pkg/time/" target="_blank" rel="noopener"><code>&quot;time&quot;</code></a> 包，因为它有助于以更安全、更准确的方式处理这些不正确的假设。</p><h4 id="使用-timetime-表达瞬时时间"><a class="markdownIt-Anchor" href="#使用-timetime-表达瞬时时间"></a> 使用 <code>time.Time</code> 表达瞬时时间</h4><p>在处理时间的瞬间时使用 <a href="https://golang.org/pkg/time/#Time" target="_blank" rel="noopener"><code>time.Time</code></a>，在比较、添加或减去时间时使用 <code>time.Time</code> 中的方法。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isActive</span><span class="params">(now, start, stop <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> start &lt;= now &amp;&amp; now &lt; stop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isActive</span><span class="params">(now, start, stop time.Time)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (start.Before(now) || start.Equal(now)) &amp;&amp; now.Before(stop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h4 id="使用-timeduration-表达时间段"><a class="markdownIt-Anchor" href="#使用-timeduration-表达时间段"></a> 使用 <code>time.Duration</code> 表达时间段</h4><p>在处理时间段时使用 <a href="https://golang.org/pkg/time/#Duration" target="_blank" rel="noopener"><code>time.Duration</code></a> .</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll</span><span class="params">(delay <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    time.Sleep(time.Duration(delay) * time.Millisecond)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">poll(<span class="number">10</span>) <span class="comment">// 是几秒钟还是几毫秒？</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll</span><span class="params">(delay time.Duration)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    time.Sleep(delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">poll(<span class="number">10</span>*time.Second)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>回到第一个例子，在一个时间瞬间加上 24 小时，用于添加时间的方法取决于意图。如果想要下一个日历日 (当前天的下一天) 的同一个时间点，应该使用 <a href="https://golang.org/pkg/time/#Time.AddDate" target="_blank" rel="noopener"><code>Time.AddDate</code></a>。但是，如果想保证某一时刻比前一时刻晚 24 小时，应该使用 <a href="https://golang.org/pkg/time/#Time.Add" target="_blank" rel="noopener"><code>Time.Add</code></a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newDay := t.AddDate(<span class="number">0</span> <span class="comment">/* years */</span>, <span class="number">0</span> <span class="comment">/* months */</span>, <span class="number">1</span> <span class="comment">/* days */</span>)</span><br><span class="line">maybeNewDay := t.Add(<span class="number">24</span> * time.Hour)</span><br></pre></td></tr></table></figure><h4 id="对外部系统使用-timetime-和-timeduration"><a class="markdownIt-Anchor" href="#对外部系统使用-timetime-和-timeduration"></a> 对外部系统使用 <code>time.Time</code> 和 <code>time.Duration</code></h4><p>尽可能在与外部系统的交互中使用 <code>time.Duration</code> 和 <code>time.Time</code> 例如 :</p><ul><li><p>Command-line 标志: <a href="https://golang.org/pkg/flag/" target="_blank" rel="noopener"><code>flag</code></a> 通过 <a href="https://golang.org/pkg/time/#ParseDuration" target="_blank" rel="noopener"><code>time.ParseDuration</code></a> 支持 <code>time.Duration</code></p></li><li><p>JSON: <a href="https://golang.org/pkg/encoding/json/" target="_blank" rel="noopener"><code>encoding/json</code></a> 通过其 <a href="https://golang.org/pkg/time/#Time.UnmarshalJSON" target="_blank" rel="noopener"><code>UnmarshalJSON</code> method</a> 方法支持将 <code>time.Time</code> 编码为 <a href="https://tools.ietf.org/html/rfc3339" target="_blank" rel="noopener">RFC 3339</a> 字符串</p></li><li><p>SQL: <a href="https://golang.org/pkg/database/sql/" target="_blank" rel="noopener"><code>database/sql</code></a> 支持将 <code>DATETIME</code> 或 <code>TIMESTAMP</code> 列转换为 <code>time.Time</code>，如果底层驱动程序支持则返回</p></li><li><p>YAML: <a href="https://godoc.org/gopkg.in/yaml.v2" target="_blank" rel="noopener"><code>gopkg.in/yaml.v2</code></a> 支持将 <code>time.Time</code> 作为 <a href="https://tools.ietf.org/html/rfc3339" target="_blank" rel="noopener">RFC 3339</a> 字符串，并通过 <a href="https://golang.org/pkg/time/#ParseDuration" target="_blank" rel="noopener"><code>time.ParseDuration</code></a> 支持 <code>time.Duration</code>。</p></li></ul><p>当不能在这些交互中使用 <code>time.Duration</code> 时，请使用 <code>int</code> 或 <code>float64</code>，并在字段名称中包含单位。</p><p>例如，由于 <code>encoding/json</code> 不支持 <code>time.Duration</code>，因此该单位包含在字段的名称中。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;"interval": 2&#125;</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">  Interval <span class="keyword">int</span> <span class="string">`json:"interval"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;"intervalMillis": 2000&#125;</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">  IntervalMillis <span class="keyword">int</span> <span class="string">`json:"intervalMillis"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>当在这些交互中不能使用 <code>time.Time</code> 时，除非达成一致，否则使用 <code>string</code> 和 <a href="https://tools.ietf.org/html/rfc3339" target="_blank" rel="noopener">RFC 3339</a> 中定义的格式时间戳。默认情况下，<a href="https://golang.org/pkg/time/#Time.UnmarshalText" target="_blank" rel="noopener"><code>Time.UnmarshalText</code></a> 使用此格式，并可通过 <a href="https://golang.org/pkg/time/#RFC3339" target="_blank" rel="noopener"><code>time.RFC3339</code></a> 在 <code>Time.Format</code> 和 <code>time.Parse</code> 中使用。</p><p>尽管这在实践中并不成问题，但请记住，<code>&quot;time&quot;</code> 包不支持解析闰秒时间戳（<a href="https://github.com/golang/go/issues/8728" target="_blank" rel="noopener">8728</a>），也不在计算中考虑闰秒（<a href="https://github.com/golang/go/issues/15190" target="_blank" rel="noopener">15190</a>）。如果比较两个时间瞬间，则差异将不包括这两个瞬间之间可能发生的闰秒。</p><h3 id="errors"><a class="markdownIt-Anchor" href="#errors"></a> Errors</h3><h4 id="错误类型"><a class="markdownIt-Anchor" href="#错误类型"></a> 错误类型</h4><p>声明错误的选项很少。在选择最适合的用例的选项之前，请考虑以下事项。</p><ul><li>调用者是否需要匹配错误以便他们可以处理它？<br />如果是，必须通过声明顶级错误变量或自定义类型来支持 <a href="https://golang.org/pkg/errors/#Is" target="_blank" rel="noopener"><code>errors.Is</code></a> 或 <a href="https://golang.org/pkg/errors/#As" target="_blank" rel="noopener"><code>errors.As</code></a> 函数。</li><li>错误消息是否为静态字符串，还是需要上下文信息的动态字符串？<br />如果是静态字符串，可以使用 <a href="https://golang.org/pkg/errors/#New" target="_blank" rel="noopener"><code>errors.New</code></a>，但对于后者，必须使用 <a href="https://golang.org/pkg/fmt/#Errorf" target="_blank" rel="noopener"><code>fmt.Errorf</code></a> 或自定义错误类型。</li><li>是否正在传递由下游函数返回的新错误？<br />如果是这样，请参阅<a href="#%E9%94%99%E8%AF%AF%E5%8C%85%E8%A3%85">错误包装部分</a>。</li></ul><table><thead><tr><th>错误匹配？</th><th>错误消息</th><th>指导</th></tr></thead><tbody><tr><td>No</td><td>static</td><td><a href="https://golang.org/pkg/errors/#New" target="_blank" rel="noopener"><code>errors.New</code></a></td></tr><tr><td>No</td><td>dynamic</td><td><a href="https://golang.org/pkg/fmt/#Errorf" target="_blank" rel="noopener"><code>fmt.Errorf</code></a></td></tr><tr><td>Yes</td><td>static</td><td>top-level <code>var</code> with <a href="https://golang.org/pkg/errors/#New" target="_blank" rel="noopener"><code>errors.New</code></a></td></tr><tr><td>Yes</td><td>dynamic</td><td>custom <code>error</code> type</td></tr></tbody></table><p>例如，使用 <a href="https://golang.org/pkg/errors/#New" target="_blank" rel="noopener"><code>errors.New</code></a> 表示带有静态字符串的错误。<br />如果调用者需要匹配并处理此错误，则将此错误导出为变量以支持将其与 <code>errors.Is</code> 匹配。</p><table><thead><tr><th>无错误匹配</th><th>错误匹配</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.New(<span class="string">"could not open"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="comment">// Can't handle the error.</span></span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrCouldNotOpen = errors.New(<span class="string">"could not open"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ErrCouldNotOpen</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> errors.Is(err, foo.ErrCouldNotOpen) &#123;</span><br><span class="line">    <span class="comment">// handle the error</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>对于动态字符串的错误，<br />如果调用者不需要匹配它，则使用 <a href="https://golang.org/pkg/fmt/#Errorf" target="_blank" rel="noopener"><code>fmt.Errorf</code></a>，<br />如果调用者确实需要匹配它，则自定义 <code>error</code>。</p><table><thead><tr><th>无错误匹配</th><th>错误匹配</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(file <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Errorf(<span class="string">"file %q not found"</span>, file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(<span class="string">"testfile.txt"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="comment">// Can't handle the error.</span></span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NotFoundError <span class="keyword">struct</span> &#123;</span><br><span class="line">  File <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *NotFoundError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">"file %q not found"</span>, e.File)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(file <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;NotFoundError&#123;File: file&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(<span class="string">"testfile.txt"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> notFound *NotFoundError</span><br><span class="line">  <span class="keyword">if</span> errors.As(err, &amp;notFound) &#123;</span><br><span class="line">    <span class="comment">// handle the error</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>请注意，如果从包中导出错误变量或类型，<br />它们将成为包的公共 API 的一部分。</p><h4 id="错误包装"><a class="markdownIt-Anchor" href="#错误包装"></a> 错误包装</h4><p>如果调用其他方法时出现错误, 通常有三种处理方式可以选择：</p><ul><li>将原始错误原样返回</li><li>使用 <code>fmt.Errorf</code> 搭配 <code>%w</code> 将错误添加进上下文后返回</li><li>使用 <code>fmt.Errorf</code> 搭配 <code>%v</code> 将错误添加进上下文后返回</li></ul><p>如果没有要添加的其他上下文，则按原样返回原始错误。<br />这将保留原始错误类型和消息。<br />这非常适合底层错误消息有足够的信息来追踪它来自哪里的错误。</p><p>否则，尽可能在错误消息中添加上下文<br />这样就不会出现诸如“连接被拒绝”之类的模糊错误，<br />会收到更多有用的错误，例如“调用服务 foo：连接被拒绝”。</p><p>使用 <code>fmt.Errorf</code> 为错误添加上下文，根据调用者是否应该能够匹配和提取根本原因，在 <code>%w</code> 或 <code>%v</code> 动词之间进行选择。</p><ul><li>如果调用者应该可以访问底层错误，请使用 <code>%w</code>。<br />对于大多数包装错误，这是一个很好的默认值，<br />但请注意，调用者可能会开始依赖此行为。因此，对于包装错误是已知<code>var</code>或类型的情况，请将其作为函数契约的一部分进行记录和测试。</li><li>使用 <code>%v</code> 来混淆底层错误。<br />调用者将无法匹配它，但如果需要，可以在将来切换到 <code>%w</code>。</li></ul><p>在为返回的错误添加上下文时，通过避免使用&quot;failed to&quot;之类的短语来保持上下文简洁，当错误通过堆栈向上渗透时，它会一层一层被堆积起来：</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s, err := store.New()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(</span><br><span class="line">        <span class="string">"failed to create new store: %w"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s, err := store.New()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(</span><br><span class="line">        <span class="string">"new store: %w"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">failed to x: failed to y: failed to create new store: the error</span><br></pre></td></tr></table></figure></td><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x: y: new store: the error</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>然而，一旦错误被发送到另一个系统，应该清楚消息是一个错误（例如<code>err</code> 标签或日志中的&quot;Failed&quot;前缀）。</p><p>另见 <a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" target="_blank" rel="noopener">不要只检查错误，优雅地处理它们</a>。</p><h4 id="错误命名"><a class="markdownIt-Anchor" href="#错误命名"></a> 错误命名</h4><p>对于存储为全局变量的错误值，<br />根据是否导出，使用前缀 <code>Err</code> 或 <code>err</code>。<br />请看指南 <a href="#%E5%AF%B9%E4%BA%8E%E6%9C%AA%E5%AF%BC%E5%87%BA%E7%9A%84%E9%A1%B6%E5%B1%82%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F%E4%BD%BF%E7%94%A8_%E4%BD%9C%E4%B8%BA%E5%89%8D%E7%BC%80">对于未导出的顶层常量和变量，使用_作为前缀</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// 导出以下两个错误，以便此包的用户可以将它们与 errors.Is 进行匹配。</span></span><br><span class="line"></span><br><span class="line">  ErrBrokenLink = errors.New(<span class="string">"link is broken"</span>)</span><br><span class="line">  ErrCouldNotOpen = errors.New(<span class="string">"could not open"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个错误没有被导出，因为不想让它成为公共 API 的一部分。 可能仍然在带有错误的包内使用它。</span></span><br><span class="line"></span><br><span class="line">  errNotFound = errors.New(<span class="string">"not found"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对于自定义错误类型，请改用后缀 <code>Error</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样，这个错误被导出，以便这个包的用户可以将它与 errors.As 匹配。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NotFoundError <span class="keyword">struct</span> &#123;</span><br><span class="line">  File <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *NotFoundError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">"file %q not found"</span>, e.File)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并且这个错误没有被导出，因为不想让它成为公共 API 的一部分。 仍然可以在带有 errors.As 的包中使用它。</span></span><br><span class="line"><span class="keyword">type</span> resolveError <span class="keyword">struct</span> &#123;</span><br><span class="line">  Path <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *resolveError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">"resolve %q"</span>, e.Path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理断言失败"><a class="markdownIt-Anchor" href="#处理断言失败"></a> 处理断言失败</h3><p><a href="https://golang.org/ref/spec#Type_assertions" target="_blank" rel="noopener">类型断言</a> 将会在检测到不正确的类型时，以单一返回值形式返回 panic。 因此，请始终使用“逗号 ok”习语。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t := i.(<span class="keyword">string</span>)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t, ok := i.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">  <span class="comment">// 优雅地处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="不要使用-panic"><a class="markdownIt-Anchor" href="#不要使用-panic"></a> 不要使用 panic</h3><p>在生产环境中运行的代码必须避免出现 panic。panic 是 <a href="https://en.wikipedia.org/wiki/Cascading_failure" target="_blank" rel="noopener">级联失败</a> 的主要根源 。如果发生错误，该函数必须返回错误，并允许调用方决定如何处理它。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"an argument is required"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  run(os.Args[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"an argument is required"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := run(os.Args[<span class="number">1</span>:]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Fprintln(os.Stderr, err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p><code>panic/recover</code> 不是错误处理策略。仅当发生不可恢复的事情（例如：<code>nil</code> 引用）时，程序才必须 <code>panic</code>。程序初始化是一个例外：程序启动时应使程序中止的不良情况可能会引起 panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _statusTemplate = template.Must(template.New(<span class="string">"name"</span>).Parse(<span class="string">"_statusHTML"</span>))</span><br></pre></td></tr></table></figure><p>即使在测试代码中，也优先使用<code>t.Fatal</code>或者<code>t.FailNow</code>而不是 panic 来确保失败被标记。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestFoo(t *testing.T)</span></span><br><span class="line">f, err := ioutil.TempFile(<span class="string">""</span>, <span class="string">"test"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">"failed to set up test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestFoo(t *testing.T)</span></span><br><span class="line">f, err := ioutil.TempFile(<span class="string">""</span>, <span class="string">"test"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  t.Fatal(<span class="string">"failed to set up test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="使用-gouberorgatomic"><a class="markdownIt-Anchor" href="#使用-gouberorgatomic"></a> 使用 <a href="http://go.uber.org/atomic" target="_blank" rel="noopener">go.uber.org/atomic</a></h3><p>使用 [<code>sync/atomic</code>] 包的原子操作对原始类型 (<code>int32</code>, <code>int64</code>等）进行操作，因为很容易忘记使用原子操作来读取或修改变量。</p><p>[<code>go.uber.org/atomic</code>] 通过隐藏基础类型为这些操作增加了类型安全性。此外，它包括一个方便的<code>atomic.Bool</code>类型。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> foo <span class="keyword">struct</span> &#123;</span><br><span class="line">  running <span class="keyword">int32</span>  <span class="comment">// atomic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f* foo)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> atomic.SwapInt32(&amp;f.running, <span class="number">1</span>) == <span class="number">1</span> &#123;</span><br><span class="line">     <span class="comment">// already running…</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// start the Foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span> <span class="title">isRunning</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> f.running == <span class="number">1</span>  <span class="comment">// race!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> foo <span class="keyword">struct</span> &#123;</span><br><span class="line">  running atomic.Bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> f.running.Swap(<span class="literal">true</span>) &#123;</span><br><span class="line">     <span class="comment">// already running…</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// start the Foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span> <span class="title">isRunning</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> f.running.Load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="避免可变全局变量"><a class="markdownIt-Anchor" href="#避免可变全局变量"></a> 避免可变全局变量</h3><p>使用选择依赖注入方式避免改变全局变量。既适用于函数指针又适用于其他值类型</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sign.go</span></span><br><span class="line"><span class="keyword">var</span> _timeNow = time.Now</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sign</span><span class="params">(msg <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  now := _timeNow()</span><br><span class="line">  <span class="keyword">return</span> signWithTime(msg, now)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sign.go</span></span><br><span class="line"><span class="keyword">type</span> signer <span class="keyword">struct</span> &#123;</span><br><span class="line">  now <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSigner</span><span class="params">()</span> *<span class="title">signer</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;signer&#123;</span><br><span class="line">    now: time.Now,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *signer)</span> <span class="title">Sign</span><span class="params">(msg <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  now := s.now()</span><br><span class="line">  <span class="keyword">return</span> signWithTime(msg, now)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sign_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSign</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  oldTimeNow := _timeNow</span><br><span class="line">  _timeNow = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> someFixedTime</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; _timeNow = oldTimeNow &#125;()</span><br><span class="line">  assert.Equal(t, want, sign(give))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sign_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSigner</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  s := newSigner()</span><br><span class="line">  s.now = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> someFixedTime</span><br><span class="line">  &#125;</span><br><span class="line">  assert.Equal(t, want, s.Sign(give))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="避免在公共结构中嵌入类型"><a class="markdownIt-Anchor" href="#避免在公共结构中嵌入类型"></a> 避免在公共结构中嵌入类型</h3><p>这些嵌入的类型泄漏实现细节、禁止类型演化和模糊的文档。</p><p>假设使用共享的 <code>AbstractList</code> 实现了多种列表类型，请避免在具体的列表实现中嵌入 <code>AbstractList</code>。<br />相反，只需手动将方法写入具体的列表，该列表将委托给抽象列表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AbstractList <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 添加将实体添加到列表中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span> <span class="title">Add</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除从列表中移除实体。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span> <span class="title">Remove</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcreteList 是一个实体列表。</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  *AbstractList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcreteList 是一个实体列表。</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  list *AbstractList</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加将实体添加到列表中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span> <span class="title">Add</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  l.list.Add(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除从列表中移除实体。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span> <span class="title">Remove</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  l.list.Remove(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>Go 允许 <a href="https://golang.org/doc/effective_go.html#embedding" target="_blank" rel="noopener">类型嵌入</a> 作为继承和组合之间的折衷。外部类型获取嵌入类型的方法的隐式副本。默认情况下，这些方法委托给嵌入实例的同一方法。</p><p>结构还获得与类型同名的字段。所以，如果嵌入的类型是 public，那么字段是 public。为了保持向后兼容性，外部类型的每个未来版本都必须保留嵌入类型。</p><p>很少需要嵌入类型。<br />这是一种方便，可以帮助避免编写冗长的委托方法。</p><p>即使嵌入兼容的抽象列表 <em>interface</em>，而不是结构体，这将为开发人员提供更大的灵活性来改变未来，但仍然泄露了具体列表使用抽象实现的细节。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractList 是各种实体列表的通用实现。</span></span><br><span class="line"><span class="keyword">type</span> AbstractList <span class="keyword">interface</span> &#123;</span><br><span class="line">  Add(Entity)</span><br><span class="line">  Remove(Entity)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ConcreteList 是一个实体列表。</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  AbstractList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcreteList 是一个实体列表。</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  list AbstractList</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加将实体添加到列表中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span> <span class="title">Add</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  l.list.Add(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除从列表中移除实体。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span> <span class="title">Remove</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  l.list.Remove(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>无论是使用嵌入结构还是嵌入接口，都会限制类型的演化。</p><ul><li>向嵌入接口添加方法是一个破坏性的改变。</li><li>从嵌入结构体删除方法是一个破坏性改变。</li><li>删除嵌入类型是一个破坏性的改变。</li><li>即使使用满足相同接口的类型替换嵌入类型，也是一个破坏性的改变。</li></ul><p>尽管编写这些委托方法是乏味的，但是额外的工作隐藏了实现细节，留下了更多的更改机会，还消除了在文档中发现完整列表接口的间接性操作。</p><h3 id="避免使用内置名称"><a class="markdownIt-Anchor" href="#避免使用内置名称"></a> 避免使用内置名称</h3><p>Go <a href="https://golang.org/ref/spec" target="_blank" rel="noopener">语言规范</a> 概述了几个内置的，不应在 Go 项目中使用的 <a href="https://golang.org/ref/spec#Predeclared_identifiers" target="_blank" rel="noopener">预先声明的标识符</a>。</p><p>根据上下文的不同，将这些标识符作为名称重复使用，将在当前作用域（或任何嵌套作用域）中隐藏原始标识符，或者混淆代码。<br />在最好的情况下，编译器会报错；在最坏的情况下，这样的代码可能会引入潜在的、难以恢复的错误。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> error <span class="keyword">string</span></span><br><span class="line"><span class="comment">// `error` 作用域隐式覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleErrorMessage</span><span class="params">(error <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// `error` 作用域隐式覆盖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errorMessage <span class="keyword">string</span></span><br><span class="line"><span class="comment">// `error` 指向内置的非覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleErrorMessage</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// `error` 指向内置的非覆盖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 虽然这些字段在技术上不构成阴影，但`error`或`string`字符串的重映射现在是不明确的。</span></span><br><span class="line">    error  error</span><br><span class="line">    <span class="keyword">string</span> <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// `error` 和 `f.error` 在视觉上是相似的</span></span><br><span class="line">    <span class="keyword">return</span> f.error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="comment">// `string` and `f.string` 在视觉上是相似的</span></span><br><span class="line">    <span class="keyword">return</span> f.<span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// `error` and `string` 现在是明确的。</span></span><br><span class="line">    err error</span><br><span class="line">    str <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> f.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> f.str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>注意，编译器在使用预先分隔的标识符时不会生成错误，<br />但是诸如<code>go vet</code>之类的工具会正确地指出这些和其他情况下的隐式问题。</p><h3 id="避免使用-init"><a class="markdownIt-Anchor" href="#避免使用-init"></a> 避免使用 <code>init()</code></h3><p>尽可能避免使用<code>init()</code>。当<code>init()</code>是不可避免或可取的，代码应先尝试：</p><ol><li>无论程序环境或调用如何，都要完全确定。</li><li>避免依赖于其他<code>init()</code>函数的顺序或副作用。虽然<code>init()</code>顺序是明确的，但代码可以更改，<br />因此<code>init()</code>函数之间的关系可能会使代码变得脆弱和容易出错。</li><li>避免访问或操作全局或环境状态，如机器信息、环境变量、工作目录、程序参数/输入等。</li><li>避免<code>I/O</code>，包括文件系统、网络和系统调用。</li></ol><blockquote><p>init 调用顺序</p><ol><li>在同一个 package 中，可以多个文件中定义 init 方法，按照<strong>文件名先后</strong>执行各个文件中的 init 方法</li><li><strong>在同一个 go 文件中，可以重复定义 init 方法</strong>，按照在代码中<strong>编写顺序</strong>依次执行不同的 init 方法</li><li>对于不同的 package，<ul><li>如果不相互依赖的话，按照 main 包中 import 的顺序调用其包中的 <code>init()</code> 函数</li><li>如果 package 存在依赖，调用顺序为最后被依赖的最先被初始化，例如：导入顺序 main –&gt; A –&gt; B –&gt; C，则初始化顺序为 C –&gt; B –&gt; A –&gt; main，一次执行对应的 init 方法</li></ul></li></ol></blockquote><p>不能满足这些要求的代码可能属于要作为<code>main()</code>调用的一部分(或程序生命周期中的其他地方)，或者作为<code>main()</code>本身的一部分写入。特别是，打算由其他程序使用的库应该特别注意完全确定性，而不是执行“init magic”</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _defaultFoo Foo</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _defaultFoo = Foo&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _defaultFoo = Foo&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or，为了更好的可测试性：</span></span><br><span class="line"><span class="keyword">var</span> _defaultFoo = defaultFoo()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">defaultFoo</span><span class="params">()</span> <span class="title">Foo</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Foo&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _config Config</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Bad: 基于当前目录</span></span><br><span class="line">    cwd, _ := os.Getwd()</span><br><span class="line">    <span class="comment">// Bad: I/O</span></span><br><span class="line">    raw, _ := ioutil.ReadFile(</span><br><span class="line">        path.Join(cwd, <span class="string">"config"</span>, <span class="string">"config.yaml"</span>),</span><br><span class="line">    )</span><br><span class="line">    yaml.Unmarshal(raw, &amp;_config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadConfig</span><span class="params">()</span> <span class="title">Config</span></span> &#123;</span><br><span class="line">    cwd, err := os.Getwd()</span><br><span class="line">    <span class="comment">// handle err</span></span><br><span class="line">    raw, err := ioutil.ReadFile(</span><br><span class="line">        path.Join(cwd, <span class="string">"config"</span>, <span class="string">"config.yaml"</span>),</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// handle err</span></span><br><span class="line">    <span class="keyword">var</span> config Config</span><br><span class="line">    yaml.Unmarshal(raw, &amp;config)</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>考虑到上述情况，在某些情况下，<code>init()</code>可能更可取或是必要的，可能包括：</p><ul><li><p>不能表示为单个赋值的复杂表达式。</p></li><li><p>可插入的钩子，如<code>database/sql</code>、编码类型注册表等。</p></li><li><p>对 <a href="https://cloud.google.com/functions/docs/bestpractices/tips#use_global_variables_to_reuse_objects_in_future_invocations" target="_blank" rel="noopener">Google Cloud Functions</a> 和其他形式的确定性预计算的优化。</p></li></ul><h3 id="追加时优先指定切片容量"><a class="markdownIt-Anchor" href="#追加时优先指定切片容量"></a> 追加时优先指定切片容量</h3><p>追加时优先指定切片容量，在尽可能的情况下，在初始化要追加的切片时为<code>make()</code>提供一个容量值。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">  data := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++&#123;</span><br><span class="line">    data = <span class="built_in">append</span>(data, k)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">  data := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, size)</span><br><span class="line">  <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++&#123;</span><br><span class="line">    data = <span class="built_in">append</span>(data, k)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkBad-4    100000000    2.48s</span><br></pre></td></tr></table></figure></td><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkGood-4   100000000    0.21s</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="主函数退出方式-exit"><a class="markdownIt-Anchor" href="#主函数退出方式-exit"></a> 主函数退出方式 (Exit)</h3><p>Go 程序使用 <a href="https://golang.org/pkg/os/#Exit" target="_blank" rel="noopener"><code>os.Exit</code></a> 或者 <a href="https://golang.org/pkg/log/#Fatal" target="_blank" rel="noopener"><code>log.Fatal*</code></a> 立即退出 (使用<code>panic</code>不是退出程序的好方法，请 <a href="#%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8-panic">不要使用 panic</a>。)</p><p><strong>仅在<code>main()</code></strong> 中调用其中一个 <code>os.Exit</code> 或者 <code>log.Fatal*</code>。所有其他函数应将错误返回到信号失败中。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  body := readFile(path)</span><br><span class="line">  fmt.Println(body)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  f, err := os.Open(path)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  b, err := ioutil.ReadAll(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">string</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  body, err := readFile(path)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(body)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">  f, err := os.Open(path)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  b, err := ioutil.ReadAll(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">string</span>(b), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>原则上：退出的具有多种功能的程序存在一些问题：</p><ul><li>不明显的控制流：任何函数都可以退出程序，因此很难对控制流进行推理。</li><li>难以测试：退出程序的函数也将退出调用它的测试。这使得函数很难测试，并引入了跳过 <code>go test</code> 尚未运行的其他测试的风险。</li><li>跳过清理：当函数退出程序时，会跳过已经进入<code>defer</code>队列里的函数调用。这增加了跳过重要清理任务的风险。</li></ul><h4 id="一次性退出"><a class="markdownIt-Anchor" href="#一次性退出"></a> 一次性退出</h4><p>如果可能的话，<code>main（）</code>函数中 <strong>最多一次</strong> 调用 <code>os.Exit</code>或者<code>log.Fatal</code>。如果有多个错误场景停止程序执行，请将该逻辑放在单独的函数下并从中返回错误。<br />这会缩短 <code>main()</code> 函数，并将所有关键业务逻辑放入一个单独的、可测试的函数中。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  args := os.Args[<span class="number">1</span>:]</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">"missing file"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  name := args[<span class="number">0</span>]</span><br><span class="line">  f, err := os.Open(name)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> f.Close()</span><br><span class="line">  <span class="comment">// 如果调用 log.Fatal 在这条线之后</span></span><br><span class="line">  <span class="comment">// f.Close 将会被执行。</span></span><br><span class="line">  b, err := ioutil.ReadAll(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  args := os.Args[<span class="number">1</span>:]</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"missing file"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  name := args[<span class="number">0</span>]</span><br><span class="line">  f, err := os.Open(name)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> f.Close()</span><br><span class="line">  b, err := ioutil.ReadAll(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="在序列化结构中使用字段标记"><a class="markdownIt-Anchor" href="#在序列化结构中使用字段标记"></a> 在序列化结构中使用字段标记</h3><p>任何序列化到JSON、YAML，或其他支持基于标记的字段命名的格式应使用相关标记进行注释。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stock <span class="keyword">struct</span> &#123;</span><br><span class="line">  Price <span class="keyword">int</span></span><br><span class="line">  Name  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">bytes, err := json.Marshal(Stock&#123;</span><br><span class="line">  Price: <span class="number">137</span>,</span><br><span class="line">  Name:  <span class="string">"UBER"</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stock <span class="keyword">struct</span> &#123;</span><br><span class="line">  Price <span class="keyword">int</span>    <span class="string">`json:"price"`</span></span><br><span class="line">  Name  <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">  <span class="comment">// Safe to rename Name to Symbol.</span></span><br><span class="line">&#125;</span><br><span class="line">bytes, err := json.Marshal(Stock&#123;</span><br><span class="line">  Price: <span class="number">137</span>,</span><br><span class="line">  Name:  <span class="string">"UBER"</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>理论上：<br />结构的序列化形式是不同系统之间的契约。<br />对序列化表单结构（包括字段名）的更改会破坏此约定。在标记中指定字段名使约定明确，<br />它还可以通过重构或重命名字段来防止意外违反约定。</p><h2 id="性能"><a class="markdownIt-Anchor" href="#性能"></a> 性能</h2><p>性能方面的特定准则只适用于高频场景。</p><h3 id="优先使用-strconv-而不是-fmt"><a class="markdownIt-Anchor" href="#优先使用-strconv-而不是-fmt"></a> 优先使用 strconv 而不是 fmt</h3><p>将原语转换为字符串或从字符串转换时，<code>strconv</code>速度比<code>fmt</code>快。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  s := fmt.Sprint(rand.Int())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  s := strconv.Itoa(rand.Int())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkFmtSprint-4    143 ns&#x2F;op    2 allocs&#x2F;op</span><br></pre></td></tr></table></figure></td><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkStrconv-4    64.2 ns&#x2F;op    1 allocs&#x2F;op</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="避免字符串到字节的转换"><a class="markdownIt-Anchor" href="#避免字符串到字节的转换"></a> 避免字符串到字节的转换</h3><p>不要反复从固定字符串创建字节 slice。相反，请执行一次转换并捕获结果。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  w.Write([]<span class="keyword">byte</span>(<span class="string">"Hello world"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data := []<span class="keyword">byte</span>(<span class="string">"Hello world"</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  w.Write(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></tr><tr><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkBad-4   50000000   22.2 ns&#x2F;op</span><br></pre></td></tr></table></figure></td><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkGood-4  500000000   3.25 ns&#x2F;op</span><br></pre></td></tr></table></figure></td></tr></tbody></table><blockquote><p>即使是内容相同的字符串，它们都会单独在分配一块内存</p><p>另外在测试的时候发现：字符串常量无法获取地址！！！，因为取值符号&amp; 仅适用于堆栈内存或堆内存中的值，即可以实际写入的值。表达式和常量(它们本身是程序本身)实际上存储在内存中，但无法写入该内存。因此，能够引入该内存就没有意义</p></blockquote><h3 id="指定容器容量"><a class="markdownIt-Anchor" href="#指定容器容量"></a> 指定容器容量</h3><p>尽可能指定容器容量，以便为容器预先分配内存。这将在添加元素时最小化后续分配（通过复制和调整容器大小）。</p><h4 id="指定-map-容量提示"><a class="markdownIt-Anchor" href="#指定-map-容量提示"></a> 指定 Map 容量提示</h4><p>在尽可能的情况下，在使用 <code>make()</code> 初始化的时候提供容量信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[T1]T2, hint)</span><br></pre></td></tr></table></figure><p>向<code>make()</code>提供容量提示会在初始化时尝试调整 map 的大小，这将减少在将元素添加到 map 时为 map 重新分配内存。</p><p>注意，与 slices 不同。<strong>map capacity 提示并不保证完全的抢占式分配，而是用于估计所需的 hashmap bucket 的数量</strong>。因此，在将元素添加到 map 时，甚至在指定 map 容量时，仍可能发生分配。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]os.FileInfo)</span><br><span class="line"></span><br><span class="line">files, _ := ioutil.ReadDir(<span class="string">"./files"</span>)</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;</span><br><span class="line">    m[f.Name()] = f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">files, _ := ioutil.ReadDir(<span class="string">"./files"</span>)</span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]os.FileInfo, <span class="built_in">len</span>(files))</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;</span><br><span class="line">    m[f.Name()] = f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><p><code>m</code> 是在没有大小提示的情况下创建的； 在运行时可能会有更多分配。</p></td><td><p><code>m</code> 是有大小提示创建的；在运行时可能会有更少的分配。</p></td></tr></tbody></table><h4 id="指定切片容量"><a class="markdownIt-Anchor" href="#指定切片容量"></a> 指定切片容量</h4><p>在尽可能的情况下，在使用<code>make()</code>初始化切片时提供容量信息，特别是在追加切片时。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, length, capacity)</span><br></pre></td></tr></table></figure><p>与 maps 不同，slice capacity 不是一个提示：编译器将为提供给<code>make()</code>的 slice 的容量分配足够的内存，<br />这意味着后续的 append()`操作将导致零分配（直到 slice 的长度与容量匹配，在此之后，任何 append 都可能调整大小以容纳其他元素）。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">  data := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++&#123;</span><br><span class="line">    data = <span class="built_in">append</span>(data, k)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">  data := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, size)</span><br><span class="line">  <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++&#123;</span><br><span class="line">    data = <span class="built_in">append</span>(data, k)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkBad-4    100000000    2.48s</span><br></pre></td></tr></table></figure></td><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkGood-4   100000000    0.21s</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h2 id="规范"><a class="markdownIt-Anchor" href="#规范"></a> 规范</h2><h3 id="避免过长的行"><a class="markdownIt-Anchor" href="#避免过长的行"></a> 避免过长的行</h3><p>避免使用需要读者水平滚动或过度转动头部的代码行。建议将行长度限制为 <strong>99 characters</strong> (99 个字符)。但这不是硬性限制。允许代码超过此限制。</p><h3 id="一致性"><a class="markdownIt-Anchor" href="#一致性"></a> 一致性</h3><p>本文中概述的一些标准都是客观性的评估，是根据场景、上下文、或者主观性的判断；</p><p>但是最重要的是，<strong>保持一致</strong>.</p><p>一致性的代码更容易维护、是更合理的、需要更少的学习成本、并且随着新的约定出现或者出现错误后更容易迁移、更新、修复 bug</p><p>相反，在一个代码库中包含多个完全不同或冲突的代码风格会导致维护成本开销、不确定性和认知偏差。所有这些都会直接导致速度降低、代码审查痛苦、而且增加 bug 数量。</p><p>将这些标准应用于代码库时，建议在 package（或更大）级别进行更改，子包级别的应用程序通过将多个样式引入到同一代码中，违反了上述关注点。</p><h3 id="相似的声明放在一组"><a class="markdownIt-Anchor" href="#相似的声明放在一组"></a> 相似的声明放在一组</h3><p>Go 语言支持将相似的声明放在一个组内。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"a"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"b"</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"a"</span></span><br><span class="line">  <span class="string">"b"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>这同样适用于常量、变量和类型声明：</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Area <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> Volume <span class="keyword">float64</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">  Area <span class="keyword">float64</span></span><br><span class="line">  Volume <span class="keyword">float64</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p><strong>仅将相关的声明放在一组。不要将不相关的声明放在一组。</strong></p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">  EnvVar = <span class="string">"MY_ENV"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> EnvVar = <span class="string">"MY_ENV"</span></span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>分组使用的位置没有限制，例如：可以在函数内部使用它们：</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  red := color.New(<span class="number">0xff0000</span>)</span><br><span class="line">  green := color.New(<span class="number">0x00ff00</span>)</span><br><span class="line">  blue := color.New(<span class="number">0x0000ff</span>)</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> (</span><br><span class="line">    red   = color.New(<span class="number">0xff0000</span>)</span><br><span class="line">    green = color.New(<span class="number">0x00ff00</span>)</span><br><span class="line">    blue  = color.New(<span class="number">0x0000ff</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>例外：如果变量声明与其他变量相邻，则应将变量声明（尤其是函数内部的声明）分组在一起。对一起声明的变量执行此操作，即使它们不相关。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *client)</span> <span class="title">request</span><span class="params">()</span></span> &#123;</span><br><span class="line">  caller := c.name</span><br><span class="line">  format := <span class="string">"json"</span></span><br><span class="line">  timeout := <span class="number">5</span>*time.Second</span><br><span class="line">  <span class="keyword">var</span> err error</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *client)</span> <span class="title">request</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> (</span><br><span class="line">    caller  = c.name</span><br><span class="line">    format  = <span class="string">"json"</span></span><br><span class="line">    timeout = <span class="number">5</span>*time.Second</span><br><span class="line">    err error</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="import-分组"><a class="markdownIt-Anchor" href="#import-分组"></a> import 分组</h3><p>导入应该分为两组：</p><ul><li>标准库</li><li>其他库</li></ul><p>默认情况下，这是 goimports 应用的分组。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">  <span class="string">"go.uber.org/atomic"</span></span><br><span class="line">  <span class="string">"golang.org/x/sync/errgroup"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line">  <span class="string">"go.uber.org/atomic"</span></span><br><span class="line">  <span class="string">"golang.org/x/sync/errgroup"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="包名"><a class="markdownIt-Anchor" href="#包名"></a> 包名</h3><p>当命名包时，请按下面规则选择一个名称：</p><ul><li><strong>全部小写。没有大写或下划线</strong>。</li><li>大多数使用命名导入的情况下，不需要重命名。</li><li>简短而简洁。请记住，在每个使用的地方都完整标识了该名称。</li><li><strong>不用复数</strong>。例如<code>net/url</code>，而不是<code>net/urls</code>。</li><li><strong>不要用“common”，“util”，“shared”或“lib”</strong>。这些是不好的，信息量不足的名称。</li></ul><p>另请参阅 <a href="https://blog.golang.org/package-names" target="_blank" rel="noopener">Go 包命名规则</a> 和 <a href="https://rakyll.org/style-packages/" target="_blank" rel="noopener">Go 包样式指南</a>.</p><h3 id="函数名"><a class="markdownIt-Anchor" href="#函数名"></a> 函数名</h3><p>遵循 Go 社区关于使用 <a href="https://golang.org/doc/effective_go.html#mixed-caps" target="_blank" rel="noopener">MixedCaps 作为函数名</a> 的约定。有一个例外，为了对相关的测试用例进行分组，函数名可能包含下划线，如：<code>TestMyFunction_WhatIsBeingTested</code>.</p><h3 id="导入别名"><a class="markdownIt-Anchor" href="#导入别名"></a> 导入别名</h3><p><strong>如果程序包名称与导入路径的最后一个元素不匹配，则必须使用导入别名</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">  client <span class="string">"example.com/client-go"</span></span><br><span class="line">  trace <span class="string">"example.com/trace/v2"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在所有其他情况下，除非导入之间有直接冲突，否则应避免导入别名。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line">  nettrace <span class="string">"golang.net/x/trace"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">  <span class="string">"runtime/trace"</span></span><br><span class="line"></span><br><span class="line">  nettrace <span class="string">"golang.net/x/trace"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="函数分组与顺序"><a class="markdownIt-Anchor" href="#函数分组与顺序"></a> 函数分组与顺序</h3><ul><li>函数应按粗略的调用顺序排序。</li><li>同一文件中的函数应按接收者分组。</li></ul><p>因此，导出的函数应先出现在文件中，放在<code>struct</code>, <code>const</code>, <code>var</code>定义的后面。</p><p>在定义类型之后，但在接收者的其余方法之前，可能会出现一个 <code>newXYZ()</code>/<code>NewXYZ()</code></p><p>由于函数是按接收者分组的，因此普通工具函数应在文件末尾出现。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Cost</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> calcCost(s.weights)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> something <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCost</span><span class="params">(n []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSomething</span><span class="params">()</span> *<span class="title">something</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;something&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> something <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSomething</span><span class="params">()</span> *<span class="title">something</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;something&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Cost</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> calcCost(s.weights)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCost</span><span class="params">(n []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="减少嵌套"><a class="markdownIt-Anchor" href="#减少嵌套"></a> 减少嵌套</h3><p>代码应通过尽可能先处理错误情况/特殊情况并尽早返回或继续循环来减少嵌套。减少嵌套多个级别的代码的代码量。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">  <span class="keyword">if</span> v.F1 == <span class="number">1</span> &#123;</span><br><span class="line">    v = process(v)</span><br><span class="line">    <span class="keyword">if</span> err := v.Call(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">      v.Send()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">"Invalid v: %v"</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">  <span class="keyword">if</span> v.F1 != <span class="number">1</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">"Invalid v: %v"</span>, v)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v = process(v)</span><br><span class="line">  <span class="keyword">if</span> err := v.Call(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  v.Send()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="不必要的-else"><a class="markdownIt-Anchor" href="#不必要的-else"></a> 不必要的 else</h3><p>如果在 if 的两个分支中都设置了变量，则可以将其替换为单个 if。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> b &#123;</span><br><span class="line">  a = <span class="number">100</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  a = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> b &#123;</span><br><span class="line">  a = <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="顶层变量声明"><a class="markdownIt-Anchor" href="#顶层变量声明"></a> 顶层变量声明</h3><p>在顶层，使用标准<code>var</code>关键字。<strong>请勿指定类型</strong>，除非它与表达式的类型不同。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _s <span class="keyword">string</span> = F()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"A"</span> &#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _s = F()</span><br><span class="line"><span class="comment">// 由于 F 已经明确了返回一个字符串类型，因此没有必要显式指定_s 的类型</span></span><br><span class="line"><span class="comment">// 还是那种类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"A"</span> &#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>如果表达式的类型与所需的类型不完全匹配，请指定类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"error"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span> <span class="title">myError</span></span> &#123; <span class="keyword">return</span> myError&#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _e error = F()</span><br><span class="line"><span class="comment">// F 返回一个 myError 类型的实例，但是要 error 类型</span></span><br></pre></td></tr></table></figure><h3 id="对于未导出的顶层常量和变量使用_作为前缀"><a class="markdownIt-Anchor" href="#对于未导出的顶层常量和变量使用_作为前缀"></a> 对于未导出的顶层常量和变量，使用_作为前缀</h3><p>在未导出的顶级<code>vars</code>和<code>consts</code>， 前面加上前缀_，以使它们在使用时明确表示它们是全局符号。</p><p>基本依据：<strong>顶级变量和常量具有包范围作用域</strong>。使用通用名称可能很容易在其他文件中意外使用错误的值。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  defaultPort = <span class="number">8080</span></span><br><span class="line">  defaultUser = <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">  defaultPort := <span class="number">9090</span></span><br><span class="line">  ...</span><br><span class="line">  fmt.Println(<span class="string">"Default port"</span>, defaultPort)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We will not see a compile error if the first line of</span></span><br><span class="line">  <span class="comment">// Bar() is deleted.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  _defaultPort = <span class="number">8080</span></span><br><span class="line">  _defaultUser = <span class="string">"user"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p><strong>例外</strong>：未导出的错误值可以使用不带下划线的前缀 <code>err</code>。 参见<a href="#%E9%94%99%E8%AF%AF%E5%91%BD%E5%90%8D">错误命名</a>。</p><h3 id="结构体中的嵌入"><a class="markdownIt-Anchor" href="#结构体中的嵌入"></a> 结构体中的嵌入</h3><p>嵌入式类型（例如 mutex）应位于结构体内的字段列表的顶部，并且必须有一个空行将嵌入式字段与常规字段分隔开。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">  version <span class="keyword">int</span></span><br><span class="line">  http.Client</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">  http.Client</span><br><span class="line"></span><br><span class="line">  version <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>内嵌应该提供切实的好处，比如以语义上合适的方式添加或增强功能。它应该在对用户没有任何不利影响的情况下使用。（另请参见：<a href="#%E9%81%BF%E5%85%8D%E5%9C%A8%E5%85%AC%E5%85%B1%E7%BB%93%E6%9E%84%E4%B8%AD%E5%B5%8C%E5%85%A5%E7%B1%BB%E5%9E%8B">避免在公共结构中嵌入类型</a>）。例外：即使在未导出类型中，<code>Mutex</code> 也不应该作为内嵌字段。另请参见：<a href="#%E9%9B%B6%E5%80%BC-mutex-%E6%98%AF%E6%9C%89%E6%95%88%E7%9A%84">零值 Mutex 是有效的</a>。</p><p>嵌入 <strong>不应该</strong>:</p><ul><li>纯粹是为了美观或方便。</li><li>使外部类型更难构造或使用。</li><li>影响外部类型的零值。如果外部类型有一个有用的零值，则在嵌入内部类型之后应该仍然有一个有用的零值。</li><li>作为嵌入内部类型的副作用，从外部类型公开不相关的函数或字段。</li><li>公开未导出的类型。</li><li>影响外部类型的复制形式。</li><li>更改外部类型的 API 或类型语义。</li><li>嵌入内部类型的非规范形式。</li><li>公开外部类型的实现详细信息。</li><li>允许用户观察或控制类型内部。</li><li>通过包装的方式改变内部函数的一般行为，这种包装方式会给用户带来一些意料之外情况。</li></ul><p>简单地说，有意识地和有目的地嵌入。一种很好的测试体验是，<br />“是否所有这些导出的内部方法/字段都将直接添加到外部类型”<br />如果答案是<code>some</code>或<code>no</code>，不要嵌入内部类型 - 而是使用字段。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Bad: A.Lock() and A.Unlock() 现在可用</span></span><br><span class="line">    <span class="comment">// 不提供任何功能性好处，并允许用户控制有关 A 的内部细节。</span></span><br><span class="line">    sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> countingWriteCloser <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Good: Write() 在外层提供用于特定目的，</span></span><br><span class="line">    <span class="comment">// 并且委托工作到内部类型的 Write() 中。</span></span><br><span class="line">    io.WriteCloser</span><br><span class="line">    count <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *countingWriteCloser)</span> <span class="title">Write</span><span class="params">(bs []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    w.count += <span class="built_in">len</span>(bs)</span><br><span class="line">    <span class="keyword">return</span> w.WriteCloser.Write(bs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Bad: 指针更改零值的有用性</span></span><br><span class="line">    io.ReadWriter</span><br><span class="line">    <span class="comment">// other fields</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// later</span></span><br><span class="line"><span class="keyword">var</span> b Book</span><br><span class="line">b.Read(...)  <span class="comment">// panic: nil pointer</span></span><br><span class="line">b.String()   <span class="comment">// panic: nil pointer</span></span><br><span class="line">b.Write(...) <span class="comment">// panic: nil pointer</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Good: 有用的零值</span></span><br><span class="line">    bytes.Buffer</span><br><span class="line">    <span class="comment">// other fields</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// later</span></span><br><span class="line"><span class="keyword">var</span> b Book</span><br><span class="line">b.Read(...)  <span class="comment">// ok</span></span><br><span class="line">b.String()   <span class="comment">// ok</span></span><br><span class="line">b.Write(...) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></td></tr><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    sync.WaitGroup</span><br><span class="line">    bytes.Buffer</span><br><span class="line">    url.URL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    mtx sync.Mutex</span><br><span class="line">    wg  sync.WaitGroup</span><br><span class="line">    buf bytes.Buffer</span><br><span class="line">    url url.URL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="本地变量声明"><a class="markdownIt-Anchor" href="#本地变量声明"></a> 本地变量声明</h3><p>如果将变量明确设置为某个值，则应使用短变量声明形式 (<code>:=</code>)。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"foo"</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"foo"</span></span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>但是，在某些情况下，<code>var</code> 使用关键字时默认值会更清晰。例如，<a href="https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices" target="_blank" rel="noopener">声明空切片</a>。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(list []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  filtered := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">10</span> &#123;</span><br><span class="line">      filtered = <span class="built_in">append</span>(filtered, v)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(list []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> filtered []<span class="keyword">int</span></span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">10</span> &#123;</span><br><span class="line">      filtered = <span class="built_in">append</span>(filtered, v)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="nil-是一个有效的-slice"><a class="markdownIt-Anchor" href="#nil-是一个有效的-slice"></a> nil 是一个有效的 slice</h3><p><code>nil</code> 是一个有效的长度为 0 的 <code>slice</code>，这意味着，</p><ul><li><p><strong>不应明确返回长度为零的切片。应该返回<code>nil</code> 来代替</strong>。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x == <span class="string">""</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x == <span class="string">""</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table></li><li><p><strong>要检查切片是否为空</strong>，请始终使用<code>len(s) == 0</code>。而非 <code>nil</code>。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">(s []<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s == <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">(s []<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(s) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table></li><li><p><strong>零值切片（用<code>var</code>声明的切片）可立即使用</strong>，无需调用<code>make()</code>创建。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nums := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// or, nums := make([]int)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add1 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add2 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add1 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add2 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table></li></ul><p>记住，<strong>虽然 nil 切片是有效的切片，但它不等于长度为 0 的切片</strong>（一个为 nil，另一个不是），并且在不同的情况下（例如序列化），这两个切片的处理方式可能不同。</p><h3 id="缩小变量作用域"><a class="markdownIt-Anchor" href="#缩小变量作用域"></a> 缩小变量作用域</h3><p>如果有可能，尽量缩小变量作用范围。除非它与 <a href="#%E5%87%8F%E5%B0%91%E5%B5%8C%E5%A5%97">减少嵌套</a>的规则冲突。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := ioutil.WriteFile(name, data, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := ioutil.WriteFile(name, data, <span class="number">0644</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>如果需要在 if 之外使用函数调用的结果，则不应尝试缩小范围。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> data, err := ioutil.ReadFile(name); err == <span class="literal">nil</span> &#123;</span><br><span class="line">  err = cfg.Decode(data)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(cfg)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err<span class="comment">//注意这个err的范围</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data, err := ioutil.ReadFile(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := cfg.Decode(data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(cfg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>注意 <code>if</code> 中变量的范围</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">"err test"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> v, err := f1(); err == <span class="literal">nil</span> &#123; <span class="comment">//为了在 else中打印 err 这里使用 ==</span></span><br><span class="line">    a := <span class="number">1</span><span class="comment">//</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%v %v"</span>, err, v)</span><br><span class="line">    fmt.Printf(<span class="string">"%v"</span>, a)<span class="comment">//编译错误，undefined: a</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="避免参数语义不明确-avoid-naked-parameters"><a class="markdownIt-Anchor" href="#避免参数语义不明确-avoid-naked-parameters"></a> 避免参数语义不明确 (Avoid Naked Parameters)</h3><p>函数调用中的<code>意义不明确的参数</code>可能会损害可读性。当参数名称的含义不明显时，请为参数添加 C 样式注释 (<code>/* ... */</code>)</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func printInfo(name string, isLocal, done bool)</span></span><br><span class="line"></span><br><span class="line">printInfo(<span class="string">"foo"</span>, <span class="literal">true</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func printInfo(name string, isLocal, done bool)</span></span><br><span class="line"></span><br><span class="line">printInfo(<span class="string">"foo"</span>, <span class="literal">true</span> <span class="comment">/* isLocal */</span>, <span class="literal">true</span> <span class="comment">/* done */</span>)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>对于上面的示例代码，还有一种更好的处理方式是将上面的 <code>bool</code> 类型换成自定义类型。将来，该参数可以支持不仅仅局限于两个状态（true/false）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Region <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  UnknownRegion Region = <span class="literal">iota</span></span><br><span class="line">  Local</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  StatusReady Status= <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  StatusDone</span><br><span class="line">  <span class="comment">// Maybe we will have a StatusInProgress in the future.</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">(name <span class="keyword">string</span>, region Region, status Status)</span></span></span><br></pre></td></tr></table></figure><h3 id="使用原始字符串字面值避免转义"><a class="markdownIt-Anchor" href="#使用原始字符串字面值避免转义"></a> 使用原始字符串字面值，避免转义</h3><p>Go 支持使用 <a href="https://golang.org/ref/spec#raw_string_lit" target="_blank" rel="noopener">原始字符串字面值</a>，也就是 &quot; ` &quot; 来表示原生字符串，在需要转义的场景下，应该尽量使用这种方案来替换。</p><p>可以跨越多行并包含引号。使用这些字符串可以避免更难阅读的手工转义的字符串。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wantError := <span class="string">"unknown name:\"test\""</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wantError := <span class="string">`unknown error:"test"`</span></span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="初始化结构体"><a class="markdownIt-Anchor" href="#初始化结构体"></a> 初始化结构体</h3><h4 id="使用字段名初始化结构"><a class="markdownIt-Anchor" href="#使用字段名初始化结构"></a> 使用字段名初始化结构</h4><p>初始化结构时，<strong>几乎应该始终指定字段名</strong>。目前由 <a href="https://golang.org/cmd/vet/" target="_blank" rel="noopener"><code>go vet</code></a> 强制执行。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k := User&#123;<span class="string">"John"</span>, <span class="string">"Doe"</span>, <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">k := User&#123;</span><br><span class="line">    FirstName: <span class="string">"John"</span>,</span><br><span class="line">    LastName: <span class="string">"Doe"</span>,</span><br><span class="line">    Admin: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>例外：<strong>当有 3 个或更少的字段时，测试表中的字段名<em>may</em>可以省略</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  op Operation</span><br><span class="line">  want <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;Add, <span class="string">"add"</span>&#125;,</span><br><span class="line">  &#123;Subtract, <span class="string">"subtract"</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="省略结构中的零值字段"><a class="markdownIt-Anchor" href="#省略结构中的零值字段"></a> 省略结构中的零值字段</h4><p>初始化具有字段名的结构时，<strong>除非提供有意义的上下文，否则忽略值为零的字段</strong>。也就是，让自动将这些设置为零值</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;</span><br><span class="line">  FirstName: <span class="string">"John"</span>,</span><br><span class="line">  LastName: <span class="string">"Doe"</span>,</span><br><span class="line">  MiddleName: <span class="string">""</span>,</span><br><span class="line">  Admin: <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;</span><br><span class="line">  FirstName: <span class="string">"John"</span>,</span><br><span class="line">  LastName: <span class="string">"Doe"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>这有助于通过省略该上下文中的默认值来减少阅读的障碍。只指定有意义的值。</p><p>在字段名提供有意义上下文的地方包含零值。例如，<a href="#%E8%A1%A8%E9%A9%B1%E5%8A%A8%E6%B5%8B%E8%AF%95">表驱动测试</a> 中的测试用例可以受益于字段的名称，即使它们是零值的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  give <span class="keyword">string</span></span><br><span class="line">  want <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;give: <span class="string">"0"</span>, want: <span class="number">0</span>&#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对零值结构使用-var"><a class="markdownIt-Anchor" href="#对零值结构使用-var"></a> 对零值结构使用 <code>var</code></h4><p>如果在声明中省略了结构的所有字段，请使用 <code>var</code> 声明结构。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user User</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>这将零值结构与那些具有类似于为 <a href="#%E5%88%9D%E5%A7%8B%E5%8C%96-maps">初始化 Maps</a> 创建的，区别于非零值字段的结构区分开来，<br />并与更喜欢的 <a href="https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices" target="_blank" rel="noopener">声明空切片</a> 方式相匹配。</p><h4 id="初始化-struct-引用"><a class="markdownIt-Anchor" href="#初始化-struct-引用"></a> 初始化 Struct 引用</h4><p>在初始化结构引用时，请使用<code>&amp;T{}</code>代替<code>new(T)</code>，以使其与结构体初始化一致。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sval := T&#123;Name: <span class="string">"foo"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inconsistent</span></span><br><span class="line">sptr := <span class="built_in">new</span>(T)</span><br><span class="line">sptr.Name = <span class="string">"bar"</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sval := T&#123;Name: <span class="string">"foo"</span>&#125;</span><br><span class="line"></span><br><span class="line">sptr := &amp;T&#123;Name: <span class="string">"bar"</span>&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="初始化-maps"><a class="markdownIt-Anchor" href="#初始化-maps"></a> 初始化 Maps</h3><p>对于空 map 请使用 <code>make(..)</code> 初始化， 并且 map 是通过编程方式填充的。<br />这使得 map 初始化在表现上不同于声明，并且它还可以方便地在 make 后添加大小提示。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// m1 读写安全;</span></span><br><span class="line">  <span class="comment">// m2 在写入时会 panic</span></span><br><span class="line">  m1 = <span class="keyword">map</span>[T1]T2&#123;&#125;</span><br><span class="line">  m2 <span class="keyword">map</span>[T1]T2</span><br><span class="line">)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// m1 读写安全;</span></span><br><span class="line">  <span class="comment">// m2 在写入时会 panic</span></span><br><span class="line">  m1 = <span class="built_in">make</span>(<span class="keyword">map</span>[T1]T2)</span><br><span class="line">  m2 <span class="keyword">map</span>[T1]T2</span><br><span class="line">)</span><br></pre></td></tr></table></figure></td></tr><tr><td><p>声明和初始化看起来非常相似的。</p></td><td><p>声明和初始化看起来差别非常大。</p></td></tr></tbody></table><p>在尽可能的情况下，请在初始化时提供 map 容量大小，详细请看 <a href="#%E6%8C%87%E5%AE%9AMap%E5%AE%B9%E9%87%8F%E6%8F%90%E7%A4%BA">指定 Map 容量提示</a>。另外，如果 map 包含固定的元素列表，则使用 map literals(map 初始化列表) 初始化映射。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[T1]T2, <span class="number">3</span>)</span><br><span class="line">m[k1] = v1</span><br><span class="line">m[k2] = v2</span><br><span class="line">m[k3] = v3</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[T1]T2&#123;</span><br><span class="line">  k1: v1,</span><br><span class="line">  k2: v2,</span><br><span class="line">  k3: v3,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>基本准则是：<strong>在初始化时使用 map 初始化列表 来添加一组固定的元素。否则使用 <code>make</code> (如果可以，请尽量指定 map 容量)</strong>。</p><h3 id="字符串-string-format"><a class="markdownIt-Anchor" href="#字符串-string-format"></a> 字符串 string format</h3><p>如果在函数外声明<code>Printf</code>-style 函数的格式字符串，请将其设置为<code>const</code>常量。这有助于<code>go vet</code>对格式字符串执行静态分析。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg := <span class="string">"unexpected values %v, %v\n"</span></span><br><span class="line">fmt.Printf(msg, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> msg = <span class="string">"unexpected values %v, %v\n"</span></span><br><span class="line">fmt.Printf(msg, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="命名-printf-样式的函数"><a class="markdownIt-Anchor" href="#命名-printf-样式的函数"></a> 命名 Printf 样式的函数</h3><p>声明<code>Printf</code>-style 函数时，请确保<code>go vet</code>可以检测到它并检查格式字符串。</p><p>这意味着应尽可能使用预定义的<code>Printf</code>-style 函数名称。<code>go vet</code>将默认检查这些。有关更多信息，请参见 <a href="https://golang.org/cmd/vet/#hdr-Printf_family" target="_blank" rel="noopener">Printf 系列</a>。</p><p>如果不能使用预定义的名称，请以 f 结束选择的名称：<code>Wrapf</code>，而不是<code>Wrap</code>。<code>go vet</code>可以要求检查特定的 Printf 样式名称，但名称必须以<code>f</code>结尾。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go vet -printfuncs=wrapf,statusf</span></span><br></pre></td></tr></table></figure><p>另请参阅 <a href="https://kuzminva.wordpress.com/2017/11/07/go-vet-printf-family-check/" target="_blank" rel="noopener">go vet: Printf family check</a>.</p><h2 id="编程模式"><a class="markdownIt-Anchor" href="#编程模式"></a> 编程模式</h2><h3 id="表驱动测试"><a class="markdownIt-Anchor" href="#表驱动测试"></a> 表驱动测试</h3><p>当测试逻辑是重复的时候，通过  <a href="https://blog.golang.org/subtests" target="_blank" rel="noopener">subtests</a> 使用 table 驱动的方式编写 case 代码看上去会更简洁。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestSplitHostPort(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">host, port, err := net.SplitHostPort(<span class="string">"192.0.2.0:8000"</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">"192.0.2.0"</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">"8000"</span>, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(<span class="string">"192.0.2.0:http"</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">"192.0.2.0"</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">"http"</span>, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(<span class="string">":8000"</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">""</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">"8000"</span>, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(<span class="string">"1:8"</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">"1"</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">"8"</span>, port)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestSplitHostPort(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  give     <span class="keyword">string</span></span><br><span class="line">  wantHost <span class="keyword">string</span></span><br><span class="line">  wantPort <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">"192.0.2.0:8000"</span>,</span><br><span class="line">    wantHost: <span class="string">"192.0.2.0"</span>,</span><br><span class="line">    wantPort: <span class="string">"8000"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">"192.0.2.0:http"</span>,</span><br><span class="line">    wantHost: <span class="string">"192.0.2.0"</span>,</span><br><span class="line">    wantPort: <span class="string">"http"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">":8000"</span>,</span><br><span class="line">    wantHost: <span class="string">""</span>,</span><br><span class="line">    wantPort: <span class="string">"8000"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">"1:8"</span>,</span><br><span class="line">    wantHost: <span class="string">"1"</span>,</span><br><span class="line">    wantPort: <span class="string">"8"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">  t.Run(tt.give, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    host, port, err := net.SplitHostPort(tt.give)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line">    assert.Equal(t, tt.wantHost, host)</span><br><span class="line">    assert.Equal(t, tt.wantPort, port)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>很明显，使用 test table 的方式在代码逻辑扩展的时候，比如新增 test case，都会显得更加的清晰。</p><p>遵循这样的约定：将结构体切片称为<code>tests</code>。 每个测试用例称为<code>tt</code>。此外，鼓励使用<code>give</code>和<code>want</code>前缀说明每个测试用例的输入和输出值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  give     <span class="keyword">string</span></span><br><span class="line">  wantHost <span class="keyword">string</span></span><br><span class="line">  wantPort <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并行测试，比如一些专门的循环（例如，生成goroutine或捕获引用作为循环体的一部分的那些循环）<br />必须注意在循环的范围内显式地分配循环变量，以确保它们保持预期的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  give <span class="keyword">string</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">  tt := tt <span class="comment">// for t.Parallel</span></span><br><span class="line">  t.Run(tt.give, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    t.Parallel()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，由于下面使用了<code>t.Parallel()</code>，必须声明一个作用域为循环迭代的<code>tt</code>变量。<br />如果不这样做，大多数或所有测试都会收到一个意外的<code>tt</code>值，或者一个在运行时发生变化的值。</p><h3 id="功能选项"><a class="markdownIt-Anchor" href="#功能选项"></a> 功能选项</h3><p>功能选项是一种模式，可以在其中声明一个不透明 Option 类型，该类型在某些内部结构中记录信息。接受这些选项的可变编号，并根据内部结构上的选项记录的全部信息采取行动。</p><p>将此模式用于需要扩展的构造函数和其他公共 API 中的可选参数，尤其是在这些功能上已经具有三个或更多参数的情况下。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package db</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  addr <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  cache <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  logger *zap.Logger</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*Connection, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package db</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCache</span><span class="params">(c <span class="keyword">bool</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithLogger</span><span class="params">(log *zap.Logger)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open creates a connection.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  addr <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  opts ...Option,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*Connection, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><p>必须始终提供缓存和记录器参数，即使用户希望使用默认值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.Open(addr, db.DefaultCache, zap.NewNop())</span><br><span class="line">db.Open(addr, db.DefaultCache, log)</span><br><span class="line">db.Open(addr, <span class="literal">false</span> <span class="comment">/* cache */</span>, zap.NewNop())</span><br><span class="line">db.Open(addr, <span class="literal">false</span> <span class="comment">/* cache */</span>, log)</span><br></pre></td></tr></table></figure></td><td><p>只有在需要时才提供选项。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.Open(addr)</span><br><span class="line">db.Open(addr, db.WithLogger(log))</span><br><span class="line">db.Open(addr, db.WithCache(<span class="literal">false</span>))</span><br><span class="line">db.Open(</span><br><span class="line">  addr,</span><br><span class="line">  db.WithCache(<span class="literal">false</span>),</span><br><span class="line">  db.WithLogger(log),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>我建议实现此模式的方法是使用一个 <code>Option</code> 接口，该接口保存一个未导出的方法，在一个未导出的 <code>options</code> 结构上记录选项。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> options <span class="keyword">struct</span> &#123;</span><br><span class="line">  cache  <span class="keyword">bool</span></span><br><span class="line">  logger *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;</span><br><span class="line">  apply(*options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cacheOption <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cacheOption)</span> <span class="title">apply</span><span class="params">(opts *options)</span></span> &#123;</span><br><span class="line">  opts.cache = <span class="keyword">bool</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCache</span><span class="params">(c <span class="keyword">bool</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> cacheOption(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> loggerOption <span class="keyword">struct</span> &#123;</span><br><span class="line">  Log *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l loggerOption)</span> <span class="title">apply</span><span class="params">(opts *options)</span></span> &#123;</span><br><span class="line">  opts.logger = l.Log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithLogger</span><span class="params">(log *zap.Logger)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> loggerOption&#123;Log: log&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open creates a connection.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  addr <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  opts ...Option,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*Connection, error)</span></span> &#123;</span><br><span class="line">  options := options&#123;</span><br><span class="line">    cache:  defaultCache,</span><br><span class="line">    logger: zap.NewNop(),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> _, o := <span class="keyword">range</span> opts &#123;</span><br><span class="line">    o.apply(&amp;options)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：还有一种使用闭包实现这个模式的方法，但是相信上面的模式为作者提供了更多的灵活性，并且更容易对用户进行调试和测试。特别是，在不可能进行比较的情况下它允许在测试和模拟中对选项进行比较。此外，它还允许选项实现其他接口，包括 <code>fmt.Stringer</code>，允许用户读取选项的字符串表示形式。</p><p>还可以参考下面资料：</p><ul><li><p><a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html" target="_blank" rel="noopener">Self-referential functions and the design of options</a></p></li><li><p><a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis" target="_blank" rel="noopener">Functional options for friendly APIs</a></p></li></ul><h2 id="linting"><a class="markdownIt-Anchor" href="#linting"></a> Linting</h2><p>比任何 “blessed” linter 集更重要的是，lint 在一个代码库中始终保持一致。</p><p>建议至少使用以下 linters，因为我认为它们有助于发现最常见的问题，并在不需要规定的情况下为代码质量建立一个高标准：</p><ul><li><p><a href="https://github.com/kisielk/errcheck" target="_blank" rel="noopener">errcheck</a> 以确保错误得到处理</p></li><li><p><a href="https://godoc.org/golang.org/x/tools/cmd/goimports" target="_blank" rel="noopener">goimports</a> 格式化代码和管理 imports</p></li><li><p><a href="https://github.com/golang/lint" target="_blank" rel="noopener">golint</a> 指出常见的文体错误</p></li><li><p><a href="https://golang.org/cmd/vet/" target="_blank" rel="noopener">govet</a> 分析代码中的常见错误</p></li><li><p><a href="https://staticcheck.io/" target="_blank" rel="noopener">staticcheck</a> 各种静态分析检查</p></li></ul><h3 id="lint-runners"><a class="markdownIt-Anchor" href="#lint-runners"></a> Lint Runners</h3><p>推荐 <a href="https://github.com/golangci/golangci-lint" target="_blank" rel="noopener">golangci-lint</a> 作为 go-to lint 的运行程序，这主要是因为它在较大的代码库中的性能以及能够同时配置和使用许多规范。这个 repo 有一个示例配置文件 <a href="https://github.com/uber-go/guide/blob/master/.golangci.yml" target="_blank" rel="noopener">.golangci.yml</a> 和推荐的 linter 设置。</p><p>golangci-lint 有 <a href="https://golangci-lint.run/usage/linters/" target="_blank" rel="noopener">various-linters</a> 可供使用。建议将上述 linters 作为基本 set，鼓励团队添加对他们的项目有意义的任何附加 linters。</p><h2 id="stargazers-over-time"><a class="markdownIt-Anchor" href="#stargazers-over-time"></a> Stargazers over time</h2><p><a href="https://starchart.cc/xxjwxc/uber_go_guide_cn" target="_blank" rel="noopener"><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/uber_go_guide_cn.svg" alt="Stargazers over time" /></a></p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://github.com/xxjwxc/uber_go_guide_cn" target="_blank" rel="noopener">https://github.com/xxjwxc/uber_go_guide_cn</a></li><li><a href="https://golang.org/doc/effective_go.html" target="_blank" rel="noopener">https://golang.org/doc/effective_go.html</a></li><li><a href="https://github.com/golang/go/wiki/CommonMistakes" target="_blank" rel="noopener">https://github.com/golang/go/wiki/CommonMistakes</a></li><li><a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="noopener">https://github.com/golang/go/wiki/CodeReviewComments</a></li><li><a href="https://go.dev/doc/effective_go#pointers_vs_values" target="_blank" rel="noopener">https://go.dev/doc/effective_go#pointers_vs_values</a></li><li><a href="https://go.dev/ref/spec#Method_values" target="_blank" rel="noopener">https://go.dev/ref/spec#Method_values</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;所有代码都应该通过&lt;code&gt;golint&lt;/code&gt;和&lt;code&gt;go vet&lt;/code&gt;的检查并无错误。建议将编辑器设置为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保存时运行 &lt;code&gt;goimports&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;运行 &lt;code&gt;golint&lt;/co
      
    
    </summary>
    
    
      <category term="Golang" scheme="http://xboom.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="http://xboom.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-中介模式</title>
    <link href="http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-09T15:30:38.933Z</published>
    <updated>2022-08-14T09:46:21.704Z</updated>
    
    <content type="html"><![CDATA[<p><strong>中介者模式</strong>是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mediator</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//CD驱动 对象</span></span><br><span class="line"><span class="keyword">type</span> CDDriver <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CDDriver 读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CDDriver)</span> <span class="title">ReadData</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.Data = <span class="string">"music,image"</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"CDDriver: reading data %s\n"</span>, c.Data)</span><br><span class="line">GetMediatorInstance().changed(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CPU 对象</span></span><br><span class="line"><span class="keyword">type</span> CPU <span class="keyword">struct</span> &#123;</span><br><span class="line">Video <span class="keyword">string</span></span><br><span class="line">Sound <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CPU 处理数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CPU)</span> <span class="title">Process</span><span class="params">(data <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">sp := strings.Split(data, <span class="string">","</span>)</span><br><span class="line">c.Sound = sp[<span class="number">0</span>]</span><br><span class="line">c.Video = sp[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"CPU: split data with Sound %s, Video %s\n"</span>, c.Sound, c.Video)</span><br><span class="line">GetMediatorInstance().changed(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VideoCard 驱动</span></span><br><span class="line"><span class="keyword">type</span> VideoCard <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VideoCard 播放</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VideoCard)</span> <span class="title">Display</span><span class="params">(data <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">v.Data = data</span><br><span class="line">fmt.Printf(<span class="string">"VideoCard: display %s\n"</span>, v.Data)</span><br><span class="line">GetMediatorInstance().changed(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SoundCard 对象</span></span><br><span class="line"><span class="keyword">type</span> SoundCard <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SoundCard 播放</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SoundCard)</span> <span class="title">Play</span><span class="params">(data <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">s.Data = data</span><br><span class="line">fmt.Printf(<span class="string">"SoundCard: play %s\n"</span>, s.Data)</span><br><span class="line">GetMediatorInstance().changed(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中介</span></span><br><span class="line"><span class="keyword">type</span> Mediator <span class="keyword">struct</span> &#123;</span><br><span class="line">CD    *CDDriver</span><br><span class="line">CPU   *CPU</span><br><span class="line">Video *VideoCard</span><br><span class="line">Sound *SoundCard</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mediator *Mediator</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetMediatorInstance</span><span class="params">()</span> *<span class="title">Mediator</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> mediator == <span class="literal">nil</span> &#123;<span class="comment">//单例模式-懒汉模式</span></span><br><span class="line">mediator = &amp;Mediator&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mediator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mediator)</span> <span class="title">changed</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> inst := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *CDDriver:</span><br><span class="line">m.CPU.Process(inst.Data)</span><br><span class="line"><span class="keyword">case</span> *CPU:</span><br><span class="line">m.Sound.Play(inst.Sound)</span><br><span class="line">m.Video.Display(inst.Video)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mediator</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMediator</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">mediator := GetMediatorInstance()</span><br><span class="line">mediator.CD = &amp;CDDriver&#123;&#125;</span><br><span class="line">mediator.CPU = &amp;CPU&#123;&#125;</span><br><span class="line">mediator.Video = &amp;VideoCard&#123;&#125;</span><br><span class="line">mediator.Sound = &amp;SoundCard&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Tiggle</span></span><br><span class="line">mediator.CD.ReadData()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mediator.CD.Data != <span class="string">"music,image"</span> &#123;</span><br><span class="line">t.Fatalf(<span class="string">"CD unexpect data %s"</span>, mediator.CD.Data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mediator.CPU.Sound != <span class="string">"music"</span> &#123;</span><br><span class="line">t.Fatalf(<span class="string">"CPU unexpect sound data %s"</span>, mediator.CPU.Sound)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mediator.CPU.Video != <span class="string">"image"</span> &#123;</span><br><span class="line">t.Fatalf(<span class="string">"CPU unexpect video data %s"</span>, mediator.CPU.Video)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mediator.Video.Data != <span class="string">"image"</span> &#123;</span><br><span class="line">t.Fatalf(<span class="string">"VidoeCard unexpect data %s"</span>, mediator.Video.Data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mediator.Sound.Data != <span class="string">"music"</span> &#123;</span><br><span class="line">t.Fatalf(<span class="string">"SoundCard unexpect data %s"</span>, mediator.Sound.Data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><ol><li>当一些对象和其他对象紧密耦合以致难以对其进行修改时</li><li>当组件因过于依赖其他组件而无法在不同应用中复用时，可使用中介者模式</li><li>如果为了能在不同情景下复用一些基本行为，导致需要被迫创建大量组件子类时</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li><em>单一职责原则</em>。 可以将多个组件间的交流抽取到同一位置， 使其更易于理解和维护。</li><li><em>开闭原则</em>。 无需修改实际组件就能增加新的中介者</li><li>可以减轻应用中多个组件间的耦合情况。</li><li>可以更方便地复用各个组件。</li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/mediator" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/mediator</a></li><li><a href="https://lailin.xyz/post/mediator.html" target="_blank" rel="noopener">https://lailin.xyz/post/mediator.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;中介者模式&lt;/strong&gt;是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; h
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-代理模式</title>
    <link href="http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-09T15:30:38.933Z</published>
    <updated>2022-08-14T04:40:41.487Z</updated>
    
    <content type="html"><![CDATA[<p><strong>代理模式</strong> 建议新建一个与原服务对象接口相同的代理类， 然后更新应用以将代理对象传递给所有原始对象客户端。 代理类接收到客户端请求后会创建实际的服务对象， 并将所有工作委派给它。</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Subject <span class="keyword">interface</span> &#123;</span><br><span class="line">Do() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RealSubject <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(RealSubject)</span> <span class="title">Do</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"real"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Proxy <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="built_in">real</span> RealSubject</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Proxy)</span> <span class="title">Do</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> res <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在调用真实对象之前的工作，检查缓存，判断权限，实例化真实对象等。。</span></span><br><span class="line">res += <span class="string">"pre:"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用真实对象</span></span><br><span class="line">res += p.<span class="built_in">real</span>.Do()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用之后的操作，如缓存结果，对结果进行处理等。。</span></span><br><span class="line">res += <span class="string">":after"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestProxy</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> sub Subject</span><br><span class="line">sub = &amp;Proxy&#123;&#125;</span><br><span class="line"></span><br><span class="line">res := sub.Do()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res != <span class="string">"pre:real:after"</span> &#123;</span><br><span class="line">t.Fail()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><ol><li><strong>延迟初始化</strong>， 如果有一个偶尔使用的重量级服务对象，一直保持该对象运行会消耗系统资源时使用代理模式(类似单例模式，但单例模式强调的是单实例)</li><li><strong>访问控制(保护代理)</strong>，如果你只希望特定客户端使用服务对象，这里的对象可以是操作系统中非常重要的部分，而客户端则是各种已启动的程序(包括恶意程序)，此时可使用代理模式</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>可以在客户端毫无察觉的情况下控制服务对象</li><li>如果客户端对服务对象的生命周期没有特殊要求， 你可以对生命周期进行管理</li><li>即使服务对象还未准备好或不存在， 代理也可以正常工作</li><li>可以在不对服务或客户端做出修改的情况下创建新代理</li><li>代码可能会变得复杂， 因为需要新建许多类。</li><li>服务响应可能会延迟(经过了一层搭理)</li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://lailin.xyz/post/factory.html" target="_blank" rel="noopener">https://lailin.xyz/post/factory.html</a></li><li><a href="https://refactoringguru.cn/design-patterns/proxy" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/proxy</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;代理模式&lt;/strong&gt; 建议新建一个与原服务对象接口相同的代理类， 然后更新应用以将代理对象传递给所有原始对象客户端。 代理类接收到客户端请求后会创建实际的服务对象， 并将所有工作委派给它。&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;&lt;a class=&quot;mar
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-享元模式</title>
    <link href="http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-09T15:30:38.933Z</published>
    <updated>2022-08-14T06:51:43.898Z</updated>
    
    <content type="html"><![CDATA[<p><strong>享元模式</strong>是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> flyweight</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图片享元工厂</span></span><br><span class="line"><span class="keyword">type</span> ImageFlyweightFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">maps <span class="keyword">map</span>[<span class="keyword">string</span>]*ImageFlyweight</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> imageFactory *ImageFlyweightFactory</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取图片工厂</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetImageFlyweightFactory</span><span class="params">()</span> *<span class="title">ImageFlyweightFactory</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> imageFactory == <span class="literal">nil</span> &#123;</span><br><span class="line">imageFactory = &amp;ImageFlyweightFactory&#123;</span><br><span class="line">maps: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*ImageFlyweight),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> imageFactory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取具体对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *ImageFlyweightFactory)</span> <span class="title">Get</span><span class="params">(filename <span class="keyword">string</span>)</span> *<span class="title">ImageFlyweight</span></span> &#123;</span><br><span class="line">image := f.maps[filename]</span><br><span class="line"><span class="keyword">if</span> image == <span class="literal">nil</span> &#123;</span><br><span class="line">image = NewImageFlyweight(filename)</span><br><span class="line">f.maps[filename] = image</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> image</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">type</span> ImageFlyweight <span class="keyword">struct</span> &#123;</span><br><span class="line">data <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewImageFlyweight</span><span class="params">(filename <span class="keyword">string</span>)</span> *<span class="title">ImageFlyweight</span></span> &#123;</span><br><span class="line"><span class="comment">// Load image file</span></span><br><span class="line">data := fmt.Sprintf(<span class="string">"image data %s"</span>, filename)</span><br><span class="line"><span class="keyword">return</span> &amp;ImageFlyweight&#123;</span><br><span class="line">data: data,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *ImageFlyweight)</span> <span class="title">Data</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> i.data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ImageViewer <span class="keyword">struct</span> &#123;</span><br><span class="line">*ImageFlyweight</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewImageViewer</span><span class="params">(filename <span class="keyword">string</span>)</span> *<span class="title">ImageViewer</span></span> &#123;</span><br><span class="line">image := GetImageFlyweightFactory().Get(filename)</span><br><span class="line"><span class="keyword">return</span> &amp;ImageViewer&#123;</span><br><span class="line">ImageFlyweight: image,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *ImageViewer)</span> <span class="title">Display</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Display: %s\n"</span>, i.Data())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> flyweight</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleFlyweight</span><span class="params">()</span></span> &#123;</span><br><span class="line">viewer := NewImageViewer(<span class="string">"image1.png"</span>)</span><br><span class="line">viewer.Display()</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Display: image data image1.png</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFlyweight</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">viewer1 := NewImageViewer(<span class="string">"image1.png"</span>)</span><br><span class="line">viewer2 := NewImageViewer(<span class="string">"image1.png"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> viewer1.ImageFlyweight != viewer2.ImageFlyweight &#123;</span><br><span class="line">t.Fail()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式(类似与内存池，但是这个重复利用的不是分配的内存而是对象)</li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/flyweight" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/flyweight</a></li><li><a href="https://lailin.xyz/post/flyweight.html" target="_blank" rel="noopener">https://lailin.xyz/post/flyweight.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;享元模式&lt;/strong&gt;是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot;
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-备忘录模式</title>
    <link href="http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-09T15:30:38.933Z</published>
    <updated>2022-08-14T08:23:49.145Z</updated>
    
    <content type="html"><![CDATA[<p><strong>备忘录模式</strong>是一种行为设计模式，允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memento</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//备忘录 接口</span></span><br><span class="line"><span class="keyword">type</span> Memento <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Game 结构</span></span><br><span class="line"><span class="keyword">type</span> Game <span class="keyword">struct</span> &#123;</span><br><span class="line">hp, mp <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// game 备忘录(拥有相同的接口)</span></span><br><span class="line"><span class="keyword">type</span> gameMemento <span class="keyword">struct</span> &#123;</span><br><span class="line">hp, mp <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Game)</span> <span class="title">Play</span><span class="params">(mpDelta, hpDelta <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">g.mp += mpDelta</span><br><span class="line">g.hp += hpDelta</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回 Game 内部成员</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Game)</span> <span class="title">Save</span><span class="params">()</span> <span class="title">Memento</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;gameMemento&#123;</span><br><span class="line">hp: g.hp,</span><br><span class="line">mp: g.mp,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存 备忘录内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Game)</span> <span class="title">Load</span><span class="params">(m Memento)</span></span> &#123;</span><br><span class="line">gm := m.(*gameMemento)</span><br><span class="line">g.mp = gm.mp</span><br><span class="line">g.hp = gm.hp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Game)</span> <span class="title">Status</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Current HP:%d, MP:%d\n"</span>, g.hp, g.mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memento</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleGame</span><span class="params">()</span></span> &#123;</span><br><span class="line">game := &amp;Game&#123;</span><br><span class="line">hp: <span class="number">10</span>,</span><br><span class="line">mp: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">game.Status()</span><br><span class="line">progress := game.Save()</span><br><span class="line"></span><br><span class="line">game.Play(<span class="number">-2</span>, <span class="number">-3</span>)</span><br><span class="line">game.Status()</span><br><span class="line"></span><br><span class="line">game.Load(progress)</span><br><span class="line">game.Status()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Current HP:10, MP:10</span></span><br><span class="line"><span class="comment">// Current HP:7, MP:8</span></span><br><span class="line"><span class="comment">// Current HP:10, MP:10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><ol><li>当需要创建对象状态快照来恢复其之前的状态时</li><li>当直接访问对象的成员变量、获取器或设置器将导致封装被突破时</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li>可以在不破坏对象封装情况的前提下创建对象状态快照</li><li>可以通过让负责人维护原发器状态历史记录来简化原发器代码</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/memento" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/memento</a></li><li><a href="https://lailin.xyz/post/memento.html" target="_blank" rel="noopener">https://lailin.xyz/post/memento.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;备忘录模式&lt;/strong&gt;是一种行为设计模式，允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#代码实现&quot;&gt;&lt;/a&gt; 代码实现&lt;/h3&gt;

      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-命令模式</title>
    <link href="http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-09T15:30:38.933Z</published>
    <updated>2022-08-14T07:39:18.538Z</updated>
    
    <content type="html"><![CDATA[<p><strong>命令模式</strong>是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作</p><h3 id="实现代码"><a class="markdownIt-Anchor" href="#实现代码"></a> 实现代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> command</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//命令接口</span></span><br><span class="line"><span class="keyword">type</span> Command <span class="keyword">interface</span> &#123;</span><br><span class="line">Execute()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StartCommand <span class="keyword">struct</span> &#123;</span><br><span class="line">mb *MotherBoard</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStartCommand</span><span class="params">(mb *MotherBoard)</span> *<span class="title">StartCommand</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;StartCommand&#123;</span><br><span class="line">mb: mb,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *StartCommand)</span> <span class="title">Execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.mb.Start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重启命令</span></span><br><span class="line"><span class="keyword">type</span> RebootCommand <span class="keyword">struct</span> &#123;</span><br><span class="line">mb *MotherBoard</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRebootCommand</span><span class="params">(mb *MotherBoard)</span> *<span class="title">RebootCommand</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;RebootCommand&#123;</span><br><span class="line">mb: mb,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *RebootCommand)</span> <span class="title">Execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.mb.Reboot()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MotherBoard <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*MotherBoard)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Print(<span class="string">"system starting\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*MotherBoard)</span> <span class="title">Reboot</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Print(<span class="string">"system rebooting\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Box 包含两个命令</span></span><br><span class="line"><span class="keyword">type</span> Box <span class="keyword">struct</span> &#123;</span><br><span class="line">button1 Command</span><br><span class="line">button2 Command</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBox</span><span class="params">(button1, button2 Command)</span> *<span class="title">Box</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Box&#123;</span><br><span class="line">button1: button1,</span><br><span class="line">button2: button2,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span> <span class="title">PressButton1</span><span class="params">()</span></span> &#123;</span><br><span class="line">b.button1.Execute()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span> <span class="title">PressButton2</span><span class="params">()</span></span> &#123;</span><br><span class="line">b.button2.Execute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> command</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleCommand</span><span class="params">()</span></span> &#123;</span><br><span class="line">mb := &amp;MotherBoard&#123;&#125;</span><br><span class="line">startCommand := NewStartCommand(mb)</span><br><span class="line">rebootCommand := NewRebootCommand(mb)</span><br><span class="line"></span><br><span class="line">box1 := NewBox(startCommand, rebootCommand)</span><br><span class="line">box1.PressButton1()</span><br><span class="line">box1.PressButton2()</span><br><span class="line"></span><br><span class="line">box2 := NewBox(rebootCommand, startCommand)</span><br><span class="line">box2.PressButton1()</span><br><span class="line">box2.PressButton2()</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// system starting</span></span><br><span class="line"><span class="comment">// system rebooting</span></span><br><span class="line"><span class="comment">// system rebooting</span></span><br><span class="line"><span class="comment">// system starting</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><ol><li>通过操作来参数化对象</li><li>想要将操作放入队列中、操作的执行或者远程执行操作</li><li>想要实现操作回滚功能</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li><em>单一职责原则</em>。 可以解耦触发和执行操作的类</li><li><em>开闭原则</em>。 可以在不修改已有客户端代码的情况下在程序中创建新的命令</li><li>可以实现撤销和恢复功能</li><li>可以实现操作的延迟执行</li><li>可以将一组简单命令组合成一个复杂命令</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/command" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/command</a></li><li><a href="https://lailin.xyz/post/command.html" target="_blank" rel="noopener">https://lailin.xyz/post/command.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;命令模式&lt;/strong&gt;是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作&lt;/p&gt;
&lt;h3 id=&quot;实现代码&quot;&gt;&lt;a class=&quot;m
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-桥接模式</title>
    <link href="http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-09T15:30:38.933Z</published>
    <updated>2022-08-14T05:24:17.824Z</updated>
    
    <content type="html"><![CDATA[<p><strong>桥接模式</strong>是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用。桥接模式类似于策略模式，区别在于策略模式封装一系列算法使得算法可以互相替换。</p><p>策略模式使抽象部分和实现部分分离，可以独立变化。</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bridge</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象消息接口</span></span><br><span class="line"><span class="keyword">type</span> AbstractMessage <span class="keyword">interface</span> &#123;</span><br><span class="line">SendMessage(text, to <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现消息接口</span></span><br><span class="line"><span class="keyword">type</span> MessageImplementer <span class="keyword">interface</span> &#123;</span><br><span class="line">Send(text, to <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//短信消息</span></span><br><span class="line"><span class="keyword">type</span> MessageSMS <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//虚拟短信消息接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ViaSMS</span><span class="params">()</span> <span class="title">MessageImplementer</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;MessageSMS&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//短信消息实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*MessageSMS)</span> <span class="title">Send</span><span class="params">(text, to <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"send %s to %s via SMS"</span>, text, to)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邮件消息</span></span><br><span class="line"><span class="keyword">type</span> MessageEmail <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//虚拟邮件消息接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ViaEmail</span><span class="params">()</span> <span class="title">MessageImplementer</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;MessageEmail&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邮件消息实现短信接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*MessageEmail)</span> <span class="title">Send</span><span class="params">(text, to <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"send %s to %s via Email"</span>, text, to)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共消息</span></span><br><span class="line"><span class="keyword">type</span> CommonMessage <span class="keyword">struct</span> &#123;</span><br><span class="line">method MessageImplementer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCommonMessage</span><span class="params">(method MessageImplementer)</span> *<span class="title">CommonMessage</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;CommonMessage&#123;</span><br><span class="line">method: method,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *CommonMessage)</span> <span class="title">SendMessage</span><span class="params">(text, to <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">m.method.Send(text, to)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//紧急消息</span></span><br><span class="line"><span class="keyword">type</span> UrgencyMessage <span class="keyword">struct</span> &#123;</span><br><span class="line">method MessageImplementer<span class="comment">//消息接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUrgencyMessage</span><span class="params">(method MessageImplementer)</span> *<span class="title">UrgencyMessage</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;UrgencyMessage&#123;</span><br><span class="line">method: method,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *UrgencyMessage)</span> <span class="title">SendMessage</span><span class="params">(text, to <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">m.method.Send(fmt.Sprintf(<span class="string">"[Urgency] %s"</span>, text), to)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bridge</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleCommonSMS</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := NewCommonMessage(ViaSMS())</span><br><span class="line">m.SendMessage(<span class="string">"have a drink?"</span>, <span class="string">"bob"</span>)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// send have a drink? to bob via SMS</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleCommonEmail</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := NewCommonMessage(ViaEmail())</span><br><span class="line">m.SendMessage(<span class="string">"have a drink?"</span>, <span class="string">"bob"</span>)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// send have a drink? to bob via Email</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleUrgencySMS</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := NewUrgencyMessage(ViaSMS())</span><br><span class="line">m.SendMessage(<span class="string">"have a drink?"</span>, <span class="string">"bob"</span>)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// send [Urgency] have a drink? to bob via SMS</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleUrgencyEmail</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := NewUrgencyMessage(ViaEmail())</span><br><span class="line">m.SendMessage(<span class="string">"have a drink?"</span>, <span class="string">"bob"</span>)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// send [Urgency] have a drink? to bob via Email</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><ol><li>想要拆分或重组一个具有多重功能的庞杂类(例如能与多个数据库服务器进行交互的类)，可以使用桥接模式</li><li>希望在几个独立维度上扩展一个类</li><li>需要在运行时切换不同实现方法</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li><em>开闭原则</em>。 你可以新增抽象部分和实现部分， 且它们之间不会相互影响。</li><li><em>单一职责原则</em>。 抽象部分专注于处理高层逻辑， 实现部分处理平台细节</li><li>对高内聚的类使用该模式可能会让代码更加复杂。</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/bridge" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/bridge</a></li><li><a href="https://lailin.xyz/post/bridge.html" target="_blank" rel="noopener">https://lailin.xyz/post/bridge.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;桥接模式&lt;/strong&gt;是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用。桥接模式类似于策略模式，区别在于策略模式封装一系列算法使得算法可以互相替换。&lt;/p&gt;
&lt;p&gt;策略模式使抽象部分和实现
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-模板方法模式</title>
    <link href="http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-09T15:30:38.933Z</published>
    <updated>2022-08-14T09:41:09.393Z</updated>
    
    <content type="html"><![CDATA[<p><strong>模板方法模式</strong>是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤</p><p>举个 例子，假设现在要做一个短信推送的系统，那么需要</p><ol><li>检查短信字数是否超过限制</li><li>检查手机号是否正确</li><li>发送短信</li><li>返回状态</li></ol><p>可以发现，在发送短信的时候由于不同的供应商调用的接口不同，所以会有一些实现上的差异，但短信推送的算法（业务逻辑）是固定的</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> templatemethod</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Downloader <span class="keyword">interface</span> &#123;</span><br><span class="line">Download(uri <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> template <span class="keyword">struct</span> &#123;</span><br><span class="line">implement</span><br><span class="line">uri <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> implement <span class="keyword">interface</span> &#123;</span><br><span class="line">download()</span><br><span class="line">save()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTemplate</span><span class="params">(impl implement)</span> *<span class="title">template</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;template&#123;</span><br><span class="line">implement: impl,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *template)</span> <span class="title">Download</span><span class="params">(uri <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">t.uri = uri</span><br><span class="line">fmt.Print(<span class="string">"prepare downloading\n"</span>)</span><br><span class="line">t.implement.download()</span><br><span class="line">t.implement.save()</span><br><span class="line">fmt.Print(<span class="string">"finish downloading\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *template)</span> <span class="title">save</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Print(<span class="string">"default save\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HTTPDownloader <span class="keyword">struct</span> &#123;</span><br><span class="line">*template</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHTTPDownloader</span><span class="params">()</span> <span class="title">Downloader</span></span> &#123;</span><br><span class="line">downloader := &amp;HTTPDownloader&#123;&#125;</span><br><span class="line">template := newTemplate(downloader)</span><br><span class="line">downloader.template = template</span><br><span class="line"><span class="keyword">return</span> downloader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *HTTPDownloader)</span> <span class="title">download</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"download %s via http\n"</span>, d.uri)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*HTTPDownloader)</span> <span class="title">save</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"http save\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FTPDownloader <span class="keyword">struct</span> &#123;</span><br><span class="line">*template</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFTPDownloader</span><span class="params">()</span> <span class="title">Downloader</span></span> &#123;</span><br><span class="line">downloader := &amp;FTPDownloader&#123;&#125;</span><br><span class="line">template := newTemplate(downloader)</span><br><span class="line">downloader.template = template</span><br><span class="line"><span class="keyword">return</span> downloader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *FTPDownloader)</span> <span class="title">download</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"download %s via ftp\n"</span>, d.uri)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> templatemethod</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleHTTPDownloader</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> downloader Downloader = NewHTTPDownloader()</span><br><span class="line"></span><br><span class="line">downloader.Download(<span class="string">"http://example.com/abc.zip"</span>)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// prepare downloading</span></span><br><span class="line"><span class="comment">// download http://example.com/abc.zip via http</span></span><br><span class="line"><span class="comment">// http save</span></span><br><span class="line"><span class="comment">// finish downloading</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleFTPDownloader</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> downloader Downloader = NewFTPDownloader()</span><br><span class="line"></span><br><span class="line">downloader.Download(<span class="string">"ftp://example.com/abc.zip"</span>)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// prepare downloading</span></span><br><span class="line"><span class="comment">// download ftp://example.com/abc.zip via ftp</span></span><br><span class="line"><span class="comment">// default save</span></span><br><span class="line"><span class="comment">// finish downloading</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h3><ol><li>模板方法将整个算法转换为一系列独立的步骤， 以便子类能对其进行扩展， 同时还可让超类中所定义的结构保持完整</li><li>在将算法转换为模板方法时， 你可将相似的实现步骤提取到超类中以去除重复代码。 子类间各不同的代码可继续保留在子类中</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>可仅允许客户端重写一个大型算法中的特定部分， 使得算法其他部分修改对其所造成的影响减小。</li><li>可将重复代码提取到一个超类中</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;模板方法模式&lt;/strong&gt;是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤&lt;/p&gt;
&lt;p&gt;举个 例子，假设现在要做一个短信推送的系统，那么需要&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检查短信字数是否超过限制&lt;/l
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-概述</title>
    <link href="http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E8%BF%B0/"/>
    <id>http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E8%BF%B0/</id>
    <published>2022-08-09T15:30:38.933Z</published>
    <updated>2022-08-14T12:00:54.601Z</updated>
    
    <content type="html"><![CDATA[<p><strong>设计模式</strong>是软件设计中常见问题的典型解决方案。 它们就像能根据需求进行调整的预制蓝图， 可用于解决代码中反复出现的设计问题</p><p>模式根据其目的来分类：</p><ul><li><strong>创建型模式</strong>提供创建对象的机制， 增加已有代码的灵活性和可复用性</li><li><strong>结构型模式</strong>介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效</li><li><strong>行为模式</strong>负责对象间的高效沟通和职责委派</li></ul><h3 id="创建型模式"><a class="markdownIt-Anchor" href="#创建型模式"></a> 创建型模式</h3><ol><li><a href="https://www.yuankang.top/2022/07/19/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">单例模式(Singleton Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/07/19/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/" target="_blank" rel="noopener">简单工厂模式(Simple Factory Pattern)</a></li><li><a href="https://www.yuankang.top/2022/07/19/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">工厂方法模式(Factory Method Pattern)</a></li><li><a href="https://www.yuankang.top/2022/07/19/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/" target="_blank" rel="noopener">抽象工厂模式(Abstract Factory)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">建造者模式(Builder Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">原型模式(Prototype Design Pattern)</a></li></ol><h3 id="结构性模式"><a class="markdownIt-Anchor" href="#结构性模式"></a> 结构性模式</h3><ol><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">代理模式(Proxy Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">桥接模式(Bridge Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">装饰器模式(Decorator Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">适配器模式(Adapter Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">门面模式(Facade Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">组合模式(Composite Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">享元模式(Flyweight Design Pattern)</a></li></ol><h3 id="行为模式"><a class="markdownIt-Anchor" href="#行为模式"></a> 行为模式</h3><ol><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">观察者模式(Observer Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">模板模式(Template Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">策略模式(Strategy Method Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">职责链模式(Chain Of Responsibility Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">状态模式(State  Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">迭代器模式(Iterator Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">访问者模式(Visitor Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">备忘录模式(Memento Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">命令模式(Command Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">解释器模式(Interpreter Design Pattern)</a></li><li><a href="https://www.yuankang.top/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">中介模式(Mediator Design Pattern)</a></li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://lailin.xyz/post/go-design-pattern.html" target="_blank" rel="noopener">https://lailin.xyz/post/go-design-pattern.html</a></li><li><a href="https://docs.microsoft.com/zh-cn/azure/architecture/patterns/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/azure/architecture/patterns/</a></li><li><a href="https://github.com/senghoo/golang-design-pattern" target="_blank" rel="noopener">https://github.com/senghoo/golang-design-pattern</a></li><li><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;设计模式&lt;/strong&gt;是软件设计中常见问题的典型解决方案。 它们就像能根据需求进行调整的预制蓝图， 可用于解决代码中反复出现的设计问题&lt;/p&gt;
&lt;p&gt;模式根据其目的来分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建型模式&lt;/strong&gt;提供创建对
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-状态模式</title>
    <link href="http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-09T15:30:38.933Z</published>
    <updated>2022-08-14T09:45:54.367Z</updated>
    
    <content type="html"><![CDATA[<p><strong>状态模式</strong>是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> state</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Week <span class="keyword">interface</span> &#123;</span><br><span class="line">Today()</span><br><span class="line">Next(*DayContext)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DayContext <span class="keyword">struct</span> &#123;</span><br><span class="line">today Week</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDayContext</span><span class="params">()</span> *<span class="title">DayContext</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;DayContext&#123;</span><br><span class="line">today: &amp;Sunday&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DayContext)</span> <span class="title">Today</span><span class="params">()</span></span> &#123;</span><br><span class="line">d.today.Today()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DayContext)</span> <span class="title">Next</span><span class="params">()</span></span> &#123;</span><br><span class="line">d.today.Next(d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Sunday <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Sunday)</span> <span class="title">Today</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Sunday\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Sunday)</span> <span class="title">Next</span><span class="params">(ctx *DayContext)</span></span> &#123;</span><br><span class="line">ctx.today = &amp;Monday&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monday <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Monday)</span> <span class="title">Today</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Monday\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Monday)</span> <span class="title">Next</span><span class="params">(ctx *DayContext)</span></span> &#123;</span><br><span class="line">ctx.today = &amp;Tuesday&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Tuesday <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Tuesday)</span> <span class="title">Today</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Tuesday\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Tuesday)</span> <span class="title">Next</span><span class="params">(ctx *DayContext)</span></span> &#123;</span><br><span class="line">ctx.today = &amp;Wednesday&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Wednesday <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Wednesday)</span> <span class="title">Today</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Wednesday\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Wednesday)</span> <span class="title">Next</span><span class="params">(ctx *DayContext)</span></span> &#123;</span><br><span class="line">ctx.today = &amp;Thursday&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Thursday <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Thursday)</span> <span class="title">Today</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Thursday\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Thursday)</span> <span class="title">Next</span><span class="params">(ctx *DayContext)</span></span> &#123;</span><br><span class="line">ctx.today = &amp;Friday&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Friday <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Friday)</span> <span class="title">Today</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Friday\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Friday)</span> <span class="title">Next</span><span class="params">(ctx *DayContext)</span></span> &#123;</span><br><span class="line">ctx.today = &amp;Saturday&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Saturday <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Saturday)</span> <span class="title">Today</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Saturday\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Saturday)</span> <span class="title">Next</span><span class="params">(ctx *DayContext)</span></span> &#123;</span><br><span class="line">ctx.today = &amp;Sunday&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> state</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleWeek</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := NewDayContext()</span><br><span class="line">todayAndNext := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx.Today()</span><br><span class="line">ctx.Next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">todayAndNext()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Sunday</span></span><br><span class="line"><span class="comment">// Monday</span></span><br><span class="line"><span class="comment">// Tuesday</span></span><br><span class="line"><span class="comment">// Wednesday</span></span><br><span class="line"><span class="comment">// Thursday</span></span><br><span class="line"><span class="comment">// Friday</span></span><br><span class="line"><span class="comment">// Saturday</span></span><br><span class="line"><span class="comment">// Sunday</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><ol><li>模式建议将所有特定于状态的代码抽取到一组独立的类中。 这样一来可以在独立于其他状态的情况下添加新状态或修改已有状态， 从而减少维护成本</li><li>状态模式会将这些条件语句的分支抽取到相应状态类的方法中。 同时还可以清除主要类中与特定状态相关的临时成员变量和帮手方法代码</li><li>状态模式让你能够生成状态类层次结构， 通过将公用代码抽取到抽象基类中来减少重复</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li><em>单一职责原则</em>。 将与特定状态相关的代码放在单独的类中。</li><li><em>开闭原则</em>。 无需修改已有状态类和上下文就能引入新状态。</li><li>通过消除臃肿的状态机条件语句简化上下文代码。</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/state" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/state</a></li><li><a href="https://lailin.xyz/post/state.html" target="_blank" rel="noopener">https://lailin.xyz/post/state.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;状态模式&lt;/strong&gt;是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#代码实现&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-策略模式</title>
    <link href="http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-09T15:30:38.933Z</published>
    <updated>2022-08-14T09:14:10.952Z</updated>
    
    <content type="html"><![CDATA[<p><strong>策略模式</strong>是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//支付结构体</span></span><br><span class="line"><span class="keyword">type</span> Payment <span class="keyword">struct</span> &#123;</span><br><span class="line">context  *PaymentContext</span><br><span class="line">strategy PaymentStrategy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//支付上下文</span></span><br><span class="line"><span class="keyword">type</span> PaymentContext <span class="keyword">struct</span> &#123;</span><br><span class="line">Name, CardID <span class="keyword">string</span></span><br><span class="line">Money        <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建新的支付对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPayment</span><span class="params">(name, cardid <span class="keyword">string</span>, money <span class="keyword">int</span>, strategy PaymentStrategy)</span> *<span class="title">Payment</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Payment&#123;</span><br><span class="line">context: &amp;PaymentContext&#123;</span><br><span class="line">Name:   name,</span><br><span class="line">CardID: cardid,</span><br><span class="line">Money:  money,</span><br><span class="line">&#125;,</span><br><span class="line">strategy: strategy,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据策略进行支付</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Payment)</span> <span class="title">Pay</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.strategy.Pay(p.context)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PaymentStrategy <span class="keyword">interface</span> &#123;</span><br><span class="line">Pay(*PaymentContext)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cash <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Cash)</span> <span class="title">Pay</span><span class="params">(ctx *PaymentContext)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Pay $%d to %s by cash"</span>, ctx.Money, ctx.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bank <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Bank)</span> <span class="title">Pay</span><span class="params">(ctx *PaymentContext)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Pay $%d to %s by bank account %s"</span>, ctx.Money, ctx.Name, ctx.CardID)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExamplePayByCash</span><span class="params">()</span></span> &#123;</span><br><span class="line">payment := NewPayment(<span class="string">"Ada"</span>, <span class="string">""</span>, <span class="number">123</span>, &amp;Cash&#123;&#125;)</span><br><span class="line">payment.Pay()</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Pay $123 to Ada by cash</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExamplePayByBank</span><span class="params">()</span></span> &#123;</span><br><span class="line">payment := NewPayment(<span class="string">"Bob"</span>, <span class="string">"0002"</span>, <span class="number">888</span>, &amp;Bank&#123;&#125;)</span><br><span class="line">payment.Pay()</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Pay $888 to Bob by bank account 0002</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><ol><li>当想使用对象中各种不同的算法变体，并希望能在运行时切换算法时</li><li>当有许多仅在执行某些行为时略有不同的相似类时</li><li>如果算法在上下文的逻辑中不是特别重要，使用该模式能将类的业务逻辑与其算法实现细节隔离开来</li><li>当类中使用了复杂条件运算符以在同一算法的不同变体中切换时</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li>可以在运行时切换对象内的算法。</li><li>可以将算法的实现和使用算法的代码隔离开来。</li><li>可以使用组合来代替继承。</li><li><em>开闭原则</em>。 无需对上下文进行修改就能够引入新的策略</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/strategy" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/strategy</a></li><li><a href="https://lailin.xyz/post/strategy.html" target="_blank" rel="noopener">https://lailin.xyz/post/strategy.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;策略模式&lt;/strong&gt;是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#代码实现&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-组合模式</title>
    <link href="http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-09T15:30:38.933Z</published>
    <updated>2022-08-14T10:02:10.763Z</updated>
    
    <content type="html"><![CDATA[<p><strong>组合模式</strong>是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们</p><h3 id="实现代码"><a class="markdownIt-Anchor" href="#实现代码"></a> 实现代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> composite</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Component <span class="keyword">interface</span> &#123;</span><br><span class="line">Parent() Component</span><br><span class="line">SetParent(Component)</span><br><span class="line">Name() <span class="keyword">string</span></span><br><span class="line">SetName(<span class="keyword">string</span>)</span><br><span class="line">AddChild(Component)</span><br><span class="line">Print(<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">LeafNode = <span class="literal">iota</span></span><br><span class="line">CompositeNode</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewComponent</span><span class="params">(kind <span class="keyword">int</span>, name <span class="keyword">string</span>)</span> <span class="title">Component</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c Component</span><br><span class="line"><span class="keyword">switch</span> kind &#123;</span><br><span class="line"><span class="keyword">case</span> LeafNode:</span><br><span class="line">c = NewLeaf()</span><br><span class="line"><span class="keyword">case</span> CompositeNode:</span><br><span class="line">c = NewComposite()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.SetName(name)</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> component <span class="keyword">struct</span> &#123;</span><br><span class="line">parent Component</span><br><span class="line">name   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *component)</span> <span class="title">Parent</span><span class="params">()</span> <span class="title">Component</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.parent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *component)</span> <span class="title">SetParent</span><span class="params">(parent Component)</span></span> &#123;</span><br><span class="line">c.parent = parent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *component)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *component)</span> <span class="title">SetName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">c.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *component)</span> <span class="title">AddChild</span><span class="params">(Component)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *component)</span> <span class="title">Print</span><span class="params">(<span class="keyword">string</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Leaf <span class="keyword">struct</span> &#123;</span><br><span class="line">component</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLeaf</span><span class="params">()</span> *<span class="title">Leaf</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Leaf&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Leaf)</span> <span class="title">Print</span><span class="params">(pre <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s-%s\n"</span>, pre, c.Name())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Composite <span class="keyword">struct</span> &#123;</span><br><span class="line">component</span><br><span class="line">childs []Component</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewComposite</span><span class="params">()</span> *<span class="title">Composite</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Composite&#123;</span><br><span class="line">childs: <span class="built_in">make</span>([]Component, <span class="number">0</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Composite)</span> <span class="title">AddChild</span><span class="params">(child Component)</span></span> &#123;</span><br><span class="line">child.SetParent(c)</span><br><span class="line">c.childs = <span class="built_in">append</span>(c.childs, child)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Composite)</span> <span class="title">Print</span><span class="params">(pre <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s+%s\n"</span>, pre, c.Name())</span><br><span class="line">pre += <span class="string">" "</span></span><br><span class="line"><span class="keyword">for</span> _, comp := <span class="keyword">range</span> c.childs &#123;</span><br><span class="line">comp.Print(pre)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> composite</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleComposite</span><span class="params">()</span></span> &#123;</span><br><span class="line">root := NewComponent(CompositeNode, <span class="string">"root"</span>)</span><br><span class="line">c1 := NewComponent(CompositeNode, <span class="string">"c1"</span>)</span><br><span class="line">c2 := NewComponent(CompositeNode, <span class="string">"c2"</span>)</span><br><span class="line">c3 := NewComponent(CompositeNode, <span class="string">"c3"</span>)</span><br><span class="line"></span><br><span class="line">l1 := NewComponent(LeafNode, <span class="string">"l1"</span>)</span><br><span class="line">l2 := NewComponent(LeafNode, <span class="string">"l2"</span>)</span><br><span class="line">l3 := NewComponent(LeafNode, <span class="string">"l3"</span>)</span><br><span class="line"></span><br><span class="line">root.AddChild(c1)</span><br><span class="line">root.AddChild(c2)</span><br><span class="line">c1.AddChild(c3)</span><br><span class="line">c1.AddChild(l1)</span><br><span class="line">c2.AddChild(l2)</span><br><span class="line">c2.AddChild(l3)</span><br><span class="line"></span><br><span class="line">root.Print(<span class="string">""</span>)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// +root</span></span><br><span class="line"><span class="comment">//  +c1</span></span><br><span class="line"><span class="comment">//   +c3</span></span><br><span class="line"><span class="comment">//   -l1</span></span><br><span class="line"><span class="comment">//  +c2</span></span><br><span class="line"><span class="comment">//   -l2</span></span><br><span class="line"><span class="comment">//   -l3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li>可以利用多态和递归机制更方便地使用复杂树结构。</li><li><em>开闭原则</em>。 无需更改现有代码， 就可以在应用中添加新元素， 使其成为对象树的一部分</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/composite" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/composite</a></li><li><a href="https://lailin.xyz/post/composite.html" target="_blank" rel="noopener">https://lailin.xyz/post/composite.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;组合模式&lt;/strong&gt;是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们&lt;/p&gt;
&lt;h3 id=&quot;实现代码&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#实现代码&quot;&gt;&lt;/a&gt; 实现代码
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-观察者模式</title>
    <link href="http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-09T15:30:38.933Z</published>
    <updated>2022-08-14T08:44:02.726Z</updated>
    
    <content type="html"><![CDATA[<p><strong>观察者模式</strong>是一种行为设计模式，允许你定义一种订阅机制，可在对象事件发生时通知多个“观察” 该对象的其他对象</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> observer</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象</span></span><br><span class="line"><span class="keyword">type</span> Subject <span class="keyword">struct</span> &#123;</span><br><span class="line">observers []Observer<span class="comment">//观察者</span></span><br><span class="line">context   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSubject</span><span class="params">()</span> *<span class="title">Subject</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Subject&#123;</span><br><span class="line">observers: <span class="built_in">make</span>([]Observer, <span class="number">0</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加观察者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Subject)</span> <span class="title">Attach</span><span class="params">(o Observer)</span></span> &#123;</span><br><span class="line">s.observers = <span class="built_in">append</span>(s.observers, o)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知观察者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Subject)</span> <span class="title">notify</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, o := <span class="keyword">range</span> s.observers &#123;</span><br><span class="line">o.Update(s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新上下文</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Subject)</span> <span class="title">UpdateContext</span><span class="params">(context <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">s.context = context</span><br><span class="line">s.notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//订阅接口</span></span><br><span class="line"><span class="keyword">type</span> Observer <span class="keyword">interface</span> &#123;</span><br><span class="line">Update(*Subject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">Reader</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Reader&#123;</span><br><span class="line">name: name,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">Update</span><span class="params">(s *Subject)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s receive %s\n"</span>, r.name, s.context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> observer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleObserver</span><span class="params">()</span></span> &#123;</span><br><span class="line">subject := NewSubject()</span><br><span class="line">reader1 := NewReader(<span class="string">"reader1"</span>)</span><br><span class="line">reader2 := NewReader(<span class="string">"reader2"</span>)</span><br><span class="line">reader3 := NewReader(<span class="string">"reader3"</span>)</span><br><span class="line">subject.Attach(reader1)</span><br><span class="line">subject.Attach(reader2)</span><br><span class="line">subject.Attach(reader3)</span><br><span class="line"></span><br><span class="line">subject.UpdateContext(<span class="string">"observer mode"</span>)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// reader1 receive observer mode</span></span><br><span class="line"><span class="comment">// reader2 receive observer mode</span></span><br><span class="line"><span class="comment">// reader3 receive observer mode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><ol><li>当一个对象状态的改变需要改变其他对象，或实际对象是事先未知的或动态变化的时</li><li>当应用中的一些对象必须观察其他对象时，但仅能在有限时间内或特定情况下使用</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li><em>开闭原则</em>。 <strong>无需修改发布者代码就能引入新的订阅者类</strong> (如果是发布者接口则可轻松引入发布者类)，<code>channel</code> 也存在类似功能。</li><li>可以在运行时建立对象之间的联系。</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/observer" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/observer</a></li><li><a href="https://lailin.xyz/post/observer.html" target="_blank" rel="noopener">https://lailin.xyz/post/observer.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;观察者模式&lt;/strong&gt;是一种行为设计模式，允许你定义一种订阅机制，可在对象事件发生时通知多个“观察” 该对象的其他对象&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#代码实现&quot;&gt;&lt;/a&gt; 代
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-职责链模式</title>
    <link href="http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-09T15:30:38.933Z</published>
    <updated>2022-08-14T07:26:20.563Z</updated>
    
    <content type="html"><![CDATA[<p><strong>责任链模式</strong>是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chain</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">interface</span> &#123;</span><br><span class="line">HaveRight(money <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">HandleFeeRequest(name <span class="keyword">string</span>, money <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RequestChain <span class="keyword">struct</span> &#123;</span><br><span class="line">Manager</span><br><span class="line">successor *RequestChain</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RequestChain)</span> <span class="title">SetSuccessor</span><span class="params">(m *RequestChain)</span></span> &#123;</span><br><span class="line">r.successor = m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RequestChain)</span> <span class="title">HandleFeeRequest</span><span class="params">(name <span class="keyword">string</span>, money <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.Manager.HaveRight(money) &#123;</span><br><span class="line"><span class="keyword">return</span> r.Manager.HandleFeeRequest(name, money)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> r.successor != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.successor.HandleFeeRequest(name, money)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RequestChain)</span> <span class="title">HaveRight</span><span class="params">(money <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------- ProjectManager -------------</span></span><br><span class="line"><span class="keyword">type</span> ProjectManager <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProjectManagerChain</span><span class="params">()</span> *<span class="title">RequestChain</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;RequestChain&#123;</span><br><span class="line">Manager: &amp;ProjectManager&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*ProjectManager)</span> <span class="title">HaveRight</span><span class="params">(money <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> money &lt; <span class="number">500</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*ProjectManager)</span> <span class="title">HandleFeeRequest</span><span class="params">(name <span class="keyword">string</span>, money <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> name == <span class="string">"bob"</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Project manager permit %s %d fee request\n"</span>, name, money)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Project manager don't permit %s %d fee request\n"</span>, name, money)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------- DepManager ------------------</span></span><br><span class="line"><span class="keyword">type</span> DepManager <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDepManagerChain</span><span class="params">()</span> *<span class="title">RequestChain</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;RequestChain&#123;</span><br><span class="line">Manager: &amp;DepManager&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*DepManager)</span> <span class="title">HaveRight</span><span class="params">(money <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> money &lt; <span class="number">5000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*DepManager)</span> <span class="title">HandleFeeRequest</span><span class="params">(name <span class="keyword">string</span>, money <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> name == <span class="string">"tom"</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Dep manager permit %s %d fee request\n"</span>, name, money)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Dep manager don't permit %s %d fee request\n"</span>, name, money)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------- GeneralManager ------------------</span></span><br><span class="line"><span class="keyword">type</span> GeneralManager <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGeneralManagerChain</span><span class="params">()</span> *<span class="title">RequestChain</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;RequestChain&#123;</span><br><span class="line">Manager: &amp;GeneralManager&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*GeneralManager)</span> <span class="title">HaveRight</span><span class="params">(money <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*GeneralManager)</span> <span class="title">HandleFeeRequest</span><span class="params">(name <span class="keyword">string</span>, money <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> name == <span class="string">"ada"</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"General manager permit %s %d fee request\n"</span>, name, money)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"General manager don't permit %s %d fee request\n"</span>, name, money)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chain</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleChain</span><span class="params">()</span></span> &#123;</span><br><span class="line">c1 := NewProjectManagerChain()</span><br><span class="line">c2 := NewDepManagerChain()</span><br><span class="line">c3 := NewGeneralManagerChain()</span><br><span class="line"></span><br><span class="line">c1.SetSuccessor(c2)</span><br><span class="line">c2.SetSuccessor(c3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c Manager = c1</span><br><span class="line"></span><br><span class="line">c.HandleFeeRequest(<span class="string">"bob"</span>, <span class="number">400</span>)</span><br><span class="line">c.HandleFeeRequest(<span class="string">"tom"</span>, <span class="number">1400</span>)</span><br><span class="line">c.HandleFeeRequest(<span class="string">"ada"</span>, <span class="number">10000</span>)</span><br><span class="line">c.HandleFeeRequest(<span class="string">"floar"</span>, <span class="number">400</span>)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Project manager permit bob 400 fee request</span></span><br><span class="line"><span class="comment">// Dep manager permit tom 1400 fee request</span></span><br><span class="line"><span class="comment">// General manager permit ada 10000 fee request</span></span><br><span class="line"><span class="comment">// Project manager don't permit floar 400 fee request</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种责任链的方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> check <span class="keyword">struct</span> &#123;</span><br><span class="line">err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c check)</span> <span class="title">checkName</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">check</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">len</span>(name) &lt; <span class="number">0</span> &#123;</span><br><span class="line"> c.err = errors.New(<span class="string">"name length wrong"</span>)</span><br><span class="line"> <span class="keyword">return</span> c</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> check&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c check)</span> <span class="title">checkAge</span><span class="params">(age <span class="keyword">uint8</span>)</span> <span class="title">check</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> age &gt; <span class="number">200</span> &#123;</span><br><span class="line">c.err = errors.New(<span class="string">"age wrong"</span>)</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> check&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := check&#123;&#125;</span><br><span class="line">c := c.checkName(<span class="string">"hello"</span>).checkAge(<span class="number">18</span>)</span><br><span class="line"><span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><ol><li>当程序需要使用不同方式处理不同种类请求，而且请求类型和顺序预先未知时</li><li>当必须按顺序执行多个处理者时</li><li>如果所需处理者及其顺序必须在运行时进行改变</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li>可以控制请求处理的顺序</li><li><em>单一职责原则</em>。 可对发起操作和执行操作的类进行解耦</li><li><em>开闭原则</em>。 可以在不更改现有代码的情况下在程序中新增处理者</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/chain-of-responsibility" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/chain-of-responsibility</a></li><li><a href="https://lailin.xyz/post/chain.html" target="_blank" rel="noopener">https://lailin.xyz/post/chain.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;责任链模式&lt;/strong&gt;是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; h
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-装饰模式</title>
    <link href="http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-09T15:30:38.933Z</published>
    <updated>2022-08-14T06:04:06.085Z</updated>
    
    <content type="html"><![CDATA[<p><strong>装饰模式</strong>是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。</p><h3 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h3><p>更改一个对象的行为时，不能忽视继承可能引发的几个严重问题</p><ul><li>继承是静态的。 无法在运行时更改已有对象的行为， 只能使用由不同子类创建的对象替代当前的整个对象。</li><li>子类只能有一个父类。 大部分编程语言不允许一个类同时继承多个类的行为</li></ul><p>装饰模式使用对象组合的方式动态改变或增加对象行为，Go语言借助于匿名组合和非入侵式接口可以很方便实现装饰模式。使用匿名组合，在装饰器中不必显式定义转调原对象方法</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="comment">//组件</span></span><br><span class="line"><span class="keyword">type</span> Component <span class="keyword">interface</span> &#123;</span><br><span class="line">Calc() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的组件</span></span><br><span class="line"><span class="keyword">type</span> ConcreteComponent <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*ConcreteComponent)</span> <span class="title">Calc</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法装饰</span></span><br><span class="line"><span class="keyword">type</span> MulDecorator <span class="keyword">struct</span> &#123;</span><br><span class="line">Component</span><br><span class="line">num <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WarpMulDecorator</span><span class="params">(c Component, num <span class="keyword">int</span>)</span> <span class="title">Component</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;MulDecorator&#123;</span><br><span class="line">Component: c,</span><br><span class="line">num:       num,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法装饰实现接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *MulDecorator)</span> <span class="title">Calc</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> d.Component.Calc() * d.num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法装饰</span></span><br><span class="line"><span class="keyword">type</span> AddDecorator <span class="keyword">struct</span> &#123;</span><br><span class="line">Component</span><br><span class="line">num <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WarpAddDecorator</span><span class="params">(c Component, num <span class="keyword">int</span>)</span> <span class="title">Component</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;AddDecorator&#123;</span><br><span class="line">Component: c,</span><br><span class="line">num:       num,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现相同的接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *AddDecorator)</span> <span class="title">Calc</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> d.Component.Calc() + d.num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleDecorator</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c Component = &amp;ConcreteComponent&#123;&#125;</span><br><span class="line">c = WarpAddDecorator(c, <span class="number">10</span>)</span><br><span class="line">c = WarpMulDecorator(c, <span class="number">8</span>)</span><br><span class="line">res := c.Calc()</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"res %d\n"</span>, res)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// res 80</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><ol><li>如果希望在无需修改代码的情况下即可使用对象，且希望在运行时为对象新增额外的行为，可以使用装饰模式</li><li>如果用继承来扩展对象行为的方案难以实现或者根本不可行，你可以使用该模式</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li>无需创建新子类即可扩展对象的行为。</li><li>可以在运行时添加或删除对象的功能。</li><li>可以用多个装饰封装对象来组合几种行为。</li><li><em>单一职责原则</em>。 可以将实现了许多不同行为的一个大类拆分为多个较小的类</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/decorator" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/decorator</a></li><li><a href="https://lailin.xyz/post/decorator.html" target="_blank" rel="noopener">https://lailin.xyz/post/decorator.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;装饰模式&lt;/strong&gt;是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。&lt;/p&gt;
&lt;h3 id=&quot;问题描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题描述&quot;&gt;&lt;/a&gt; 问题描述
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-迭代器模式</title>
    <link href="http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-09T15:30:38.933Z</published>
    <updated>2022-08-14T07:51:26.268Z</updated>
    
    <content type="html"><![CDATA[<p><strong>迭代器模式</strong>是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> iterator</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//聚合</span></span><br><span class="line"><span class="keyword">type</span> Aggregate <span class="keyword">interface</span> &#123;</span><br><span class="line">Iterator() Iterator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="keyword">type</span> Iterator <span class="keyword">interface</span> &#123;</span><br><span class="line">First()<span class="comment">//第一个</span></span><br><span class="line">IsDone() <span class="keyword">bool</span><span class="comment">//是否结束</span></span><br><span class="line">Next() <span class="keyword">interface</span>&#123;&#125;<span class="comment">//下一个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数量</span></span><br><span class="line"><span class="keyword">type</span> Numbers <span class="keyword">struct</span> &#123;</span><br><span class="line">start, end <span class="keyword">int</span><span class="comment">//开始与结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNumbers</span><span class="params">(start, end <span class="keyword">int</span>)</span> *<span class="title">Numbers</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Numbers&#123;</span><br><span class="line">start: start,</span><br><span class="line">end:   end,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NumbersIterator <span class="keyword">struct</span> &#123;</span><br><span class="line">numbers *Numbers</span><br><span class="line">next    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Numbers)</span> <span class="title">Iterator</span><span class="params">()</span> <span class="title">Iterator</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;NumbersIterator&#123;</span><br><span class="line">numbers: n,</span><br><span class="line">next:    n.start,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *NumbersIterator)</span> <span class="title">First</span><span class="params">()</span></span> &#123;</span><br><span class="line">i.next = i.numbers.start<span class="comment">//第一个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否结束</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *NumbersIterator)</span> <span class="title">IsDone</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> i.next &gt; i.numbers.end</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下一个</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *NumbersIterator)</span> <span class="title">Next</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">if</span> !i.IsDone() &#123;</span><br><span class="line">next := i.next</span><br><span class="line">i.next++</span><br><span class="line"><span class="keyword">return</span> next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IteratorPrint</span><span class="params">(i Iterator)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i.First(); !i.IsDone(); &#123;</span><br><span class="line">c := i.Next()</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> iterator</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleIterator</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> aggregate Aggregate</span><br><span class="line">aggregate = NewNumbers(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">IteratorPrint(aggregate.Iterator())</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><ol><li>集合背后为复杂的数据结构且希望对客户端隐藏其复杂性时</li><li>使用该模式可以减少程序中重复的遍历代码</li><li>希望代码能够遍历不同的甚至是无法预知的数据结构</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li><em>单一职责原则</em>。 通过将体积庞大的遍历算法代码抽取为独立的类， 对客户端代码和集合进行整理。</li><li><em>开闭原则</em>。 可实现新型的集合和迭代器并将其传递给现有代码， 无需修改现有代码。</li><li>可以并行遍历同一集合， 因为每个迭代器对象都包含其自身的遍历状态。</li><li>相似的， 可以暂停遍历并在需要时继续。</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/iterator" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/iterator</a></li><li><a href="https://lailin.xyz/post/iterator.html" target="_blank" rel="noopener">https://lailin.xyz/post/iterator.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;迭代器模式&lt;/strong&gt;是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#代码实现&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-解释器模式</title>
    <link href="http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-09T15:30:38.933Z</published>
    <updated>2022-08-14T09:58:57.363Z</updated>
    
    <content type="html"><![CDATA[<p><strong>解释器模式</strong>定义一套语言文法，并设计该语言解释器，使用户能使用特定文法控制解释器行为。解释器模式的意义在于，它分离多种复杂功能的实现，每个功能只需关注自身的解释。对于调用者不用关心内部的解释器的工作，只需要用简单的方式组合命令就可以</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> interpreter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点解释 接口</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">interface</span> &#123;</span><br><span class="line">Interpret() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="keyword">type</span> ValNode <span class="keyword">struct</span> &#123;</span><br><span class="line">val <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *ValNode)</span> <span class="title">Interpret</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> n.val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左右节点</span></span><br><span class="line"><span class="keyword">type</span> AddNode <span class="keyword">struct</span> &#123;</span><br><span class="line">left, right Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左右节点 解释器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *AddNode)</span> <span class="title">Interpret</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> n.left.Interpret() + n.right.Interpret()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最小节点</span></span><br><span class="line"><span class="keyword">type</span> MinNode <span class="keyword">struct</span> &#123;</span><br><span class="line">left, right Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最小节点解释器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *MinNode)</span> <span class="title">Interpret</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> n.left.Interpret() - n.right.Interpret()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解释器</span></span><br><span class="line"><span class="keyword">type</span> Parser <span class="keyword">struct</span> &#123;</span><br><span class="line">exp   []<span class="keyword">string</span></span><br><span class="line">index <span class="keyword">int</span></span><br><span class="line">prev  Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Parser)</span> <span class="title">Parse</span><span class="params">(exp <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">p.exp = strings.Split(exp, <span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p.index &gt;= <span class="built_in">len</span>(p.exp) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> p.exp[p.index] &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">p.prev = p.newAddNode()</span><br><span class="line"><span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">p.prev = p.newMinNode()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">p.prev = p.newValNode()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Parser)</span> <span class="title">newAddNode</span><span class="params">()</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">p.index++</span><br><span class="line"><span class="keyword">return</span> &amp;AddNode&#123;</span><br><span class="line">left:  p.prev,</span><br><span class="line">right: p.newValNode(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Parser)</span> <span class="title">newMinNode</span><span class="params">()</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">p.index++</span><br><span class="line"><span class="keyword">return</span> &amp;MinNode&#123;</span><br><span class="line">left:  p.prev,</span><br><span class="line">right: p.newValNode(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Parser)</span> <span class="title">newValNode</span><span class="params">()</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">v, _ := strconv.Atoi(p.exp[p.index])</span><br><span class="line">p.index++</span><br><span class="line"><span class="keyword">return</span> &amp;ValNode&#123;</span><br><span class="line">val: v,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Parser)</span> <span class="title">Result</span><span class="params">()</span> <span class="title">Node</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> p.prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> interpreter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestInterpreter</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">p := &amp;Parser&#123;&#125;</span><br><span class="line">p.Parse(<span class="string">"1 + 2 + 3 - 4 + 5 - 6"</span>)</span><br><span class="line">res := p.Result().Interpret()</span><br><span class="line">expect := <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> res != expect &#123;</span><br><span class="line">t.Fatalf(<span class="string">"expect %d got %d"</span>, expect, res)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h3><ol><li>自定义实现一个自定义接口告警规则功能</li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://lailin.xyz/post/interpreter.html" target="_blank" rel="noopener">https://lailin.xyz/post/interpreter.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;解释器模式&lt;/strong&gt;定义一套语言文法，并设计该语言解释器，使用户能使用特定文法控制解释器行为。解释器模式的意义在于，它分离多种复杂功能的实现，每个功能只需关注自身的解释。对于调用者不用关心内部的解释器的工作，只需要用简单的方式组合命令就可以&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-访问者模式</title>
    <link href="http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-09T15:30:38.933Z</published>
    <updated>2022-08-14T09:32:12.309Z</updated>
    
    <content type="html"><![CDATA[<p><strong>访问者模式</strong>是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> visitor</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者 接口</span></span><br><span class="line"><span class="keyword">type</span> Customer <span class="keyword">interface</span> &#123;</span><br><span class="line">Accept(Visitor)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问者 接口</span></span><br><span class="line"><span class="keyword">type</span> Visitor <span class="keyword">interface</span> &#123;</span><br><span class="line">Visit(Customer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//企业消费者</span></span><br><span class="line"><span class="keyword">type</span> EnterpriseCustomer <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者池</span></span><br><span class="line"><span class="keyword">type</span> CustomerCol <span class="keyword">struct</span> &#123;</span><br><span class="line">customers []Customer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加消费者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CustomerCol)</span> <span class="title">Add</span><span class="params">(customer Customer)</span></span> &#123;</span><br><span class="line">c.customers = <span class="built_in">append</span>(c.customers, customer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收访问者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CustomerCol)</span> <span class="title">Accept</span><span class="params">(visitor Visitor)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, customer := <span class="keyword">range</span> c.customers &#123;</span><br><span class="line">customer.Accept(visitor)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEnterpriseCustomer</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">EnterpriseCustomer</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;EnterpriseCustomer&#123;</span><br><span class="line">name: name,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *EnterpriseCustomer)</span> <span class="title">Accept</span><span class="params">(visitor Visitor)</span></span> &#123;</span><br><span class="line">visitor.Visit(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IndividualCustomer <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewIndividualCustomer</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">IndividualCustomer</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;IndividualCustomer&#123;</span><br><span class="line">name: name,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *IndividualCustomer)</span> <span class="title">Accept</span><span class="params">(visitor Visitor)</span></span> &#123;</span><br><span class="line">visitor.Visit(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceRequestVisitor <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*ServiceRequestVisitor)</span> <span class="title">Visit</span><span class="params">(customer Customer)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> c := customer.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *EnterpriseCustomer:</span><br><span class="line">fmt.Printf(<span class="string">"serving enterprise customer %s\n"</span>, c.name)</span><br><span class="line"><span class="keyword">case</span> *IndividualCustomer:</span><br><span class="line">fmt.Printf(<span class="string">"serving individual customer %s\n"</span>, c.name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// only for enterprise</span></span><br><span class="line"><span class="keyword">type</span> AnalysisVisitor <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*AnalysisVisitor)</span> <span class="title">Visit</span><span class="params">(customer Customer)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> c := customer.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *EnterpriseCustomer:</span><br><span class="line">fmt.Printf(<span class="string">"analysis enterprise customer %s\n"</span>, c.name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> visitor</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleRequestVisitor</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := &amp;CustomerCol&#123;&#125;</span><br><span class="line">c.Add(NewEnterpriseCustomer(<span class="string">"A company"</span>))</span><br><span class="line">c.Add(NewEnterpriseCustomer(<span class="string">"B company"</span>))</span><br><span class="line">c.Add(NewIndividualCustomer(<span class="string">"bob"</span>))</span><br><span class="line">c.Accept(&amp;ServiceRequestVisitor&#123;&#125;)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// serving enterprise customer A company</span></span><br><span class="line"><span class="comment">// serving enterprise customer B company</span></span><br><span class="line"><span class="comment">// serving individual customer bob</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleAnalysis</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := &amp;CustomerCol&#123;&#125;</span><br><span class="line">c.Add(NewEnterpriseCustomer(<span class="string">"A company"</span>))</span><br><span class="line">c.Add(NewIndividualCustomer(<span class="string">"bob"</span>))</span><br><span class="line">c.Add(NewEnterpriseCustomer(<span class="string">"B company"</span>))</span><br><span class="line">c.Accept(&amp;AnalysisVisitor&#123;&#125;)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// analysis enterprise customer A company</span></span><br><span class="line"><span class="comment">// analysis enterprise customer B company</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><ol><li>访问者模式通过在访问者对象中为多个目标类提供相同操作的变体， 让你能在属于不同类的一组对象上执行同一操作</li><li>该模式会将所有非主要的行为抽取到一组访问者类中， 使得程序的主要类能更专注于主要的工作</li><li>可将该行为抽取到单独的访问者类中， 只需实现接收相关类的对象作为参数的访问者方法并将其他方法留空即可。</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li><em>开闭原则</em>。 可以引入在不同类对象上执行的新行为， 且无需对这些类做出修改。</li><li><em>单一职责原则</em>。 可将同一行为的不同版本移到同一个类中。</li><li>访问者对象可以在与各种对象交互时收集一些有用的信息。 当你想要遍历一些复杂的对象结构 （例如对象树）， 并在结构中的每个对象上应用访问者时， 这些信息可能会有所帮助</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/visitor" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/visitor</a></li><li><a href="https://lailin.xyz/post/visitor.html" target="_blank" rel="noopener">https://lailin.xyz/post/visitor.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;访问者模式&lt;/strong&gt;是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#代码实现&quot;&gt;&lt;/a&gt; 代码实现&lt;/h3&gt;
&lt;figure cl
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-适配器模式</title>
    <link href="http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-09T15:30:38.933Z</published>
    <updated>2022-08-14T06:15:31.535Z</updated>
    
    <content type="html"><![CDATA[<p><strong>适配器模式</strong>是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。</p><p>适配器模式通过封装对象将复杂的转换过程隐藏于幕后， 被封装的对象甚至察觉不到适配器的存在。 其还有助于采用不同接口的对象之间的合作。 它的运作方式如下：</p><ol><li>适配器实现与其中一个现有对象兼容的接口。</li><li>现有对象可以使用该接口安全地调用适配器方法。</li><li>适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象</li></ol><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter</span><br><span class="line"></span><br><span class="line"><span class="comment">//Target 是适配的目标接口</span></span><br><span class="line"><span class="keyword">type</span> Target <span class="keyword">interface</span> &#123;</span><br><span class="line">Request() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Adaptee 是被适配的目标接口</span></span><br><span class="line"><span class="keyword">type</span> Adaptee <span class="keyword">interface</span> &#123;</span><br><span class="line">SpecificRequest() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewAdaptee 是被适配接口的工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAdaptee</span><span class="params">()</span> <span class="title">Adaptee</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;adapteeImpl&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AdapteeImpl 是被适配的目标类</span></span><br><span class="line"><span class="keyword">type</span> adapteeImpl <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SpecificRequest 是目标类的一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*adapteeImpl)</span> <span class="title">SpecificRequest</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"adaptee method"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewAdapter 是Adapter的工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAdapter</span><span class="params">(adaptee Adaptee)</span> <span class="title">Target</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;adapter&#123;</span><br><span class="line">Adaptee: adaptee,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Adapter 是转换Adaptee为Target接口的适配器</span></span><br><span class="line"><span class="keyword">type</span> adapter <span class="keyword">struct</span> &#123;</span><br><span class="line">Adaptee</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Request 实现Target接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *adapter)</span> <span class="title">Request</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a.SpecificRequest()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> expect = <span class="string">"adaptee method"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdapter</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">adaptee := NewAdaptee()</span><br><span class="line">target := NewAdapter(adaptee)</span><br><span class="line">res := target.Request()</span><br><span class="line"><span class="keyword">if</span> res != expect &#123;</span><br><span class="line">t.Fatalf(<span class="string">"expect: %s, actual: %s"</span>, expect, res)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><ol><li>当你希望使用某个类，但是其接口与其他代码不兼容时，可以使用适配器类</li><li>如果您需要复用这样一些类，他们处于同一个继承体系，并且他们又有了额外的一些共同的方法，但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li><em>单一职责原则</em>你可以将接口或数据转换代码从程序主要业务逻辑中分离。</li><li><em>开闭原则</em>。 只要客户端代码通过客户端接口与适配器进行交互， 你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://lailin.xyz/post/adapter.html" target="_blank" rel="noopener">https://lailin.xyz/post/adapter.html</a></li><li><a href="https://refactoringguru.cn/design-patterns/adapter" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/adapter</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;适配器模式&lt;/strong&gt;是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。&lt;/p&gt;
&lt;p&gt;适配器模式通过封装对象将复杂的转换过程隐藏于幕后， 被封装的对象甚至察觉不到适配器的存在。 其还有助于采用不同接口的对象之间的合作。 它的运作方式如下：&lt;
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-门面模式</title>
    <link href="http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xboom.github.io/2022/08/09/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-09T15:30:38.933Z</published>
    <updated>2022-08-14T06:40:52.908Z</updated>
    
    <content type="html"><![CDATA[<p>**门面模式(外观模式)**是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。</p><p>问题描述：假设必须在代码中使用某个复杂的库或框架中的众多对象。 正常情况下，需要负责所有对象的初始化工作、 管理其依赖关系并按正确的顺序执行方法等。最终， 程序中类的业务逻辑将与第三方类的实现细节紧密耦合， 使得理解和维护代码的工作很难进行。</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> facade</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAPI</span><span class="params">()</span> <span class="title">API</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;apiImpl&#123;</span><br><span class="line">a: NewAModuleAPI(),</span><br><span class="line">b: NewBModuleAPI(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//API is facade interface of facade package</span></span><br><span class="line"><span class="keyword">type</span> API <span class="keyword">interface</span> &#123;</span><br><span class="line">Test() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//facade implement</span></span><br><span class="line"><span class="keyword">type</span> apiImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">a AModuleAPI</span><br><span class="line">b BModuleAPI</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *apiImpl)</span> <span class="title">Test</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">aRet := a.a.TestA()</span><br><span class="line">bRet := a.b.TestB()</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s\n%s"</span>, aRet, bRet)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewAModuleAPI return new AModuleAPI</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAModuleAPI</span><span class="params">()</span> <span class="title">AModuleAPI</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;aModuleImpl&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AModuleAPI ...</span></span><br><span class="line"><span class="keyword">type</span> AModuleAPI <span class="keyword">interface</span> &#123;</span><br><span class="line">TestA() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> aModuleImpl <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*aModuleImpl)</span> <span class="title">TestA</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"A module running"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewBModuleAPI return new BModuleAPI</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBModuleAPI</span><span class="params">()</span> <span class="title">BModuleAPI</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;bModuleImpl&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BModuleAPI ...</span></span><br><span class="line"><span class="keyword">type</span> BModuleAPI <span class="keyword">interface</span> &#123;</span><br><span class="line">TestB() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> bModuleImpl <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*bModuleImpl)</span> <span class="title">TestB</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"B module running"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> facade</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> expect = <span class="string">"A module running\nB module running"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TestFacadeAPI ...</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFacadeAPI</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">api := NewAPI()</span><br><span class="line">ret := api.Test()</span><br><span class="line"><span class="keyword">if</span> ret != expect &#123;</span><br><span class="line">t.Fatalf(<span class="string">"expect %s, return %s"</span>, expect, ret)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><ol><li>如果需要一个指向复杂子系统的直接接口，且该接口的功能有限，则可以使用外观模式</li><li>如果需要将子系统组织为多层结构，可以使用外观</li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/facade" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/facade</a></li><li><a href="https://lailin.xyz/post/facade.html" target="_blank" rel="noopener">https://lailin.xyz/post/facade.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;**门面模式(外观模式)**是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。&lt;/p&gt;
&lt;p&gt;问题描述：假设必须在代码中使用某个复杂的库或框架中的众多对象。 正常情况下，需要负责所有对象的初始化工作、 管理其依赖关系并按正确的顺序执行方法等。最终， 
      
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/categories/Design-Patterns/"/>
    
    
      <category term="Design Patterns" scheme="http://xboom.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
</feed>
