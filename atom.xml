<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XBoom Dove</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.yuankang.top/"/>
  <updated>2024-01-28T11:01:31.674Z</updated>
  <id>https://www.yuankang.top/</id>
  
  <author>
    <name>XBoom Dove</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCPIP 网络编程-08-套接字选项</title>
    <link href="https://www.yuankang.top/2024/01/19/Unix%20NetWork/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-08-%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%89%E9%A1%B9/"/>
    <id>https://www.yuankang.top/2024/01/19/Unix%20NetWork/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-08-%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%89%E9%A1%B9/</id>
    <published>2024-01-19T15:00:00.000Z</published>
    <updated>2024-01-28T11:01:31.674Z</updated>
    
    <content type="html"><![CDATA[<p>套接字选项支持对套接字进行设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 查看套接字选项</span></span><br><span class="line"><span class="comment"> * sock 用于查看选项套接字文件描述符</span></span><br><span class="line"><span class="comment"> * level 可查看的可选项的协议层</span></span><br><span class="line"><span class="comment"> * optname 要查看的可选项名</span></span><br><span class="line"><span class="comment"> * optval 保存查看结果的缓存地址值</span></span><br><span class="line"><span class="comment"> * optlen 第四个参数 optval 的参缓存大小，返回四个参数的字节数</span></span><br><span class="line"><span class="comment"> * @return 成功返回 0，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 查看套接字选项</span></span><br><span class="line"><span class="comment"> * sock 用于更改选项套接字文件描述符</span></span><br><span class="line"><span class="comment"> * level 可更改的可选项的协议层</span></span><br><span class="line"><span class="comment"> * optname 要更改的可选项名</span></span><br><span class="line"><span class="comment"> * optval 保存要更改的选项信息的缓存地址值</span></span><br><span class="line"><span class="comment"> * optlen 第四个参数 optval 的字节数</span></span><br><span class="line"><span class="comment"> * @return 成功返回 0，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> oplen)</span></span>;</span><br></pre></td></tr></table></figure><p>示例地址：<a href="https://github.com/XBoom/network-ip.git" target="_blank" rel="noopener">https://github.com/XBoom/network-ip.git</a> 中的 <code>apps/socket/11/</code> 来看看</p><p>应用如下：</p><ol><li><p>查看套接字类型，运行结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[root]#</span><span class="bash">./client </span></span><br><span class="line">[11/client.c:23 main info] get tcp[1] sock opt :1 4 </span><br><span class="line">[11/client.c:27 main info] get udp[2] sock opt :2 4</span><br></pre></td></tr></table></figure></li></ol><p>但是！！！ 套接字类型只能在创建时设置，以后不能再改变</p><ol start="2"><li><p>查看缓冲区大小</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[11/client.c:33 main info] tcp send buff size:16384 </span><br><span class="line">[11/client.c:36 main info] tcp recv buff size:131072 </span><br><span class="line">[11/client.c:39 main info] udp send buff size:212992 </span><br><span class="line">[11/client.c:42 main info] udp recv buff size:212992</span><br></pre></td></tr></table></figure></li><li><p><code>time-wait</code> 重用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> option = <span class="number">1</span>;</span><br><span class="line">optlen = <span class="keyword">sizeof</span>(option);</span><br><span class="line">ret = setsockopt(tcp_sock, SOL_SOCKET, SO_REUSEADDR, </span><br><span class="line">    (<span class="keyword">void</span> *)&amp;option, optlen);</span><br></pre></td></tr></table></figure><p><code>time_wait</code> 在四次挥手过程中会等待 <code>2msl</code> 时间(大多数系统是 120s)，是为了等待最后的 <code>ack</code> 未收到。如果服务端发起 Fin，那么最后会因为 <code>time_wait</code> 而等待端口释放，那么再异常重启状态下，就需要等待大概 4 分钟端口才能恢复(客户端因为端口是随机分配的，所以不太在意立即释放)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_tw_reuse  # 1 表示启用了端口重用，即允许在 TIME_WAIT 状态下的连接所使用的端口被新的连接使用。 0 表示禁止</span><br></pre></td></tr></table></figure></li><li><p>Nagle算法</p><p>Nagle算法是一种用于减少小包传输的网络优化算法。它的目标是减少网络上的小型数据包数量，提高网络效率。会等待当前缓冲区中的数据被确认之后才发送新的数据。这有助于避免发送大量的小数据包，从而提高网络的效率</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20240114181938761.png" alt="image-20240114181938761" style="zoom:50%;" /><p>Nagle算法的原理如下：</p><ol><li>如果长度达到 MSS，则允许发送</li><li>如果数据包中包含<code>FIN</code>（断开连接标致），则允许发送</li><li>当设置了<code>TCP_NODELAY</code>选项，则允许发送，禁止Nagle算法</li><li>未设置<code>TCP_CORK</code>选项时，若所有发送的小数据包（包含长度小于MSS）均被确认，则设置该选项后，内核会尽力把小的数据包拼成一个大的数据包（一个MTU）在发送出去，若到指定时间，一般为200ms，仍未组成一个MTU，也要立刻发送。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//禁用 Nagle</span></span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">setsockopt(socket_fd, IPPROTO_TCP, TCP_NODELAY, (<span class="keyword">char</span>*)&amp;flag, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure><p>在某些情况下，Nagle算法可能会导致一定的延迟，特别是对于那些需要低延迟的应用程序。为了避免这种情况，可以通过设置<code>TCP_NODELAY</code>选项来禁用Nagle算法，强制立即发送数据(默认是开启的)</p></li></ol><p><strong>粘包</strong> 问题的缘由可能发生在发送端也可能发生在接收端：</p><ul><li>由 Nagle 算法造成的发送端的粘包：当提交一段数据给 TCP 发送时，TCP 并不立刻发送此段数据，而是等待一小段时间看看在等待期间是否还有要发送的数据，若有则会一次把这好几段数据发送出去。</li><li>接收端接受不及时造成的接收端粘包：TCP 会把接收到的数据存在自己的缓冲区中，然后通应用层取数据。当应用层由于某些原因不能及时地把 TCP 的数据取出来，就会造成 TCP 缓冲区中存放了几段数据</li></ul><p>解决粘包</p><ul><li>定长消息：协议提前约定好包的长度为多少，每当接收端接收到固定长度的字节就确定一个包；</li><li>消息分隔符：利用特殊符号标志着消息的开始或者结束，例如 HTTP 协议中的换行符；</li><li>长度前缀：先发送N个字节代表包的大小（注意大端和小端问题），后续解析也按长度读取解析。</li></ul><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li>《TCPIP 网络编程》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;套接字选项支持对套接字进行设置&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/s
      
    
    </summary>
    
    
      <category term="Unix NetWork" scheme="https://www.yuankang.top/categories/Unix-NetWork/"/>
    
    
      <category term="Unix" scheme="https://www.yuankang.top/tags/Unix/"/>
    
      <category term="Unix NetWork" scheme="https://www.yuankang.top/tags/Unix-NetWork/"/>
    
  </entry>
  
  <entry>
    <title>TCPIP 网络编程-07-域名地址转换</title>
    <link href="https://www.yuankang.top/2024/01/14/Unix%20NetWork/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-07-%E5%9F%9F%E5%90%8D%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/"/>
    <id>https://www.yuankang.top/2024/01/14/Unix%20NetWork/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-07-%E5%9F%9F%E5%90%8D%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/</id>
    <published>2024-01-14T15:00:00.000Z</published>
    <updated>2024-01-28T11:01:15.787Z</updated>
    
    <content type="html"><![CDATA[<p>访问服务端的时候不能总是通过 IP 访问而是通过域名，于是就有了域名与地址转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   @brief 通过传递字符串格式的域名获取IP地址</span></span><br><span class="line"><span class="comment">*   @return 成功时返回hostent结构体地址，失败时返回 NULL指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">struct hostent *<span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* hostname)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> * h_name;  <span class="comment">//官网域名，代表着某一个主页(可能很多注明的域名并未注册官方域名)</span></span><br><span class="line">    <span class="keyword">char</span> ** h_aliases;  <span class="comment">//通过多个域名访问同一个主页。同一个IP可以绑定多个域名，所以除了官方域名还可以指定其他域名</span></span><br><span class="line">    <span class="keyword">int</span> h_addrtype; <span class="comment">//地址类型 IPv4则是AF_INET</span></span><br><span class="line">    <span class="keyword">int</span> h_length;   <span class="comment">//保存IP地址长度(单位B)。若是IPv4地址，则是4; IPv6 则是16</span></span><br><span class="line">    <span class="keyword">char</span> ** h_addr_list;    <span class="comment">//以证书形式保存域名对应的IP地址，可能多个IP分配给同一个域名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 利用IP地址获取域名</span></span><br><span class="line"><span class="comment">* addr 含有IP地址信息的in_addr结构体指针。为了同时传递IPv4地址之外的其他细心，该变量类型声明为char指针</span></span><br><span class="line"><span class="comment">* len 第一个参数的字节数，IPv4时为4，IPv6 时为16</span></span><br><span class="line"><span class="comment">* family 传递协议族信息，IPv4时为AF_INET，IPv6 时为AF_INET6</span></span><br><span class="line"><span class="comment">* 成功返回hostent结构体变量地址值，失败返回NULL指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">struct hostent *<span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">socklen_t</span> len, <span class="keyword">int</span> family)</span></span>;</span><br></pre></td></tr></table></figure><p>有了上面的函数解析  示例地址：<a href="https://github.com/XBoom/network-ip.git" target="_blank" rel="noopener">https://github.com/XBoom/network-ip.git</a> 中的 <code>apps/socket/10/</code> 来看看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root]#./client www.naver.com</span><br><span class="line">[<span class="number">10</span>/client.c:<span class="number">12</span> main info] www.naver.com <span class="built_in">get</span> host name: </span><br><span class="line">[<span class="number">10</span>/client.c:<span class="number">13</span> main info]      h_name:www.naver.com.nheos.com </span><br><span class="line">[<span class="number">10</span>/client.c:<span class="number">14</span> main info]      h_aliases: </span><br><span class="line">[<span class="number">10</span>/client.c:<span class="number">17</span> main info]              [<span class="number">0</span>]:www.naver.com </span><br><span class="line">[<span class="number">10</span>/client.c:<span class="number">19</span> main info]       type:IPv4 </span><br><span class="line">[<span class="number">10</span>/client.c:<span class="number">20</span> main info]       h_length:<span class="number">4</span> </span><br><span class="line">[<span class="number">10</span>/client.c:<span class="number">21</span> main info]       h_addr_list: </span><br><span class="line">[<span class="number">10</span>/client.c:<span class="number">24</span> main info]              [<span class="number">0</span>]:<span class="number">223.130</span><span class="number">.200</span><span class="number">.104</span> </span><br><span class="line">[<span class="number">10</span>/client.c:<span class="number">24</span> main info]              [<span class="number">1</span>]:<span class="number">223.130</span><span class="number">.200</span><span class="number">.107</span> </span><br><span class="line">[root]#./server <span class="number">223.130</span><span class="number">.200</span><span class="number">.104</span></span><br><span class="line">[<span class="number">10</span>/server.c:<span class="number">14</span> main error] gethostbyaddr failed Unknown host </span><br><span class="line">[root]#./server <span class="number">223.130</span><span class="number">.200</span><span class="number">.107</span></span><br><span class="line">[<span class="number">10</span>/server.c:<span class="number">14</span> main error] gethostbyaddr failed Unknown host</span><br></pre></td></tr></table></figure><p>并不能总是通过 IP 地址获取到域名</p><p>通过抓去端口 53 的报文(DNS)可以得到</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20240113080658112.png" alt="image-20240113080658112" /></p><p>通过 UDP 去发送 DNS 请求，一次返回多个 IP 地址，而无法获取域名则如下返回 <code>No such name</code></p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20240113080753643.png" alt="image-20240113080753643" /></p><p>需要注意的就是 <code>inet_ntoa(*(struct in_addr *)addr_info-&gt;h_addr_list[i])</code> 为什么是一个结构体，而要使用 <code>char*</code> 进行存储</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20240113081503692.png" alt="image-20240113081503692" style="zoom:50%;" /><p>这是因为 这个结构体并不一定有 IPv4，也有可能是 IPv6；另外在定义这个标准之前还没有 <code>void *</code> 标准，所以使用了 <code>char*</code> 定义</p><p>不过目前比较常用的是 <code>getaddrinfo</code> 更加灵活</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *node, <span class="keyword">const</span> <span class="keyword">char</span> *service,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> struct addrinfo *hints, struct addrinfo **res)</span></span>;</span><br><span class="line"><span class="comment">// node 参数是要解析的主机名或 IP 地址，可以为 NULL。</span></span><br><span class="line"><span class="comment">// service 参数是服务名或端口号的字符串表示，可以为 NULL。</span></span><br><span class="line"><span class="comment">// hints 参数是一个指向 struct addrinfo 结构的指针，用于提供解析的提示信息。</span></span><br><span class="line"><span class="comment">// res 参数是一个指向 struct addrinfo 结构链表的指针，用于保存解析结果。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span>ai_flags;<span class="comment">/* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST */</span></span><br><span class="line"><span class="keyword">int</span>ai_family;<span class="comment">/* PF_xxx */</span></span><br><span class="line"><span class="keyword">int</span>ai_socktype;<span class="comment">/* SOCK_xxx */</span></span><br><span class="line"><span class="keyword">int</span>ai_protocol;<span class="comment">/* 0 or IPPROTO_xxx for IPv4 and IPv6 */</span></span><br><span class="line"><span class="keyword">socklen_t</span> ai_addrlen;<span class="comment">/* length of ai_addr */</span></span><br><span class="line"><span class="keyword">char</span>*ai_canonname;<span class="comment">/* canonical name for hostname */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span><span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span><span class="comment">/* binary address */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span><span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span><span class="comment">/* next structure in linked list */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最终输出结果为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getaddrinfo: </span><br><span class="line">[<span class="number">10</span>/client.c:<span class="number">55</span> main info]       ip: <span class="number">182.61</span><span class="number">.200</span><span class="number">.7</span> </span><br><span class="line">[<span class="number">10</span>/client.c:<span class="number">55</span> main info]       ip: <span class="number">182.61</span><span class="number">.200</span><span class="number">.6</span></span><br></pre></td></tr></table></figure><p>最后还有两个小知识点</p><ol><li><p><code>hstrerror(h_errno)</code> ：<code>h_errno</code> 是一个全局错误码，而 <code>hstrerror</code> 用来解析 host相关的错误</p></li><li><p><code>inet_ntop（Internet Network TO Presentation）</code>二进制字符串转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="comment">// af 是地址族，可以是 AF_INET（IPv4）或 AF_INET6（IPv6）。</span></span><br><span class="line"><span class="comment">// src 是指向存储二进制形式地址的指针。</span></span><br><span class="line"><span class="comment">// dst 是一个用于存储字符串形式地址的缓冲区。</span></span><br><span class="line"><span class="comment">// size 是缓冲区的大小</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li>《TCPIP 网络编程》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;访问服务端的时候不能总是通过 IP 访问而是通过域名，于是就有了域名与地址转换&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Unix NetWork" scheme="https://www.yuankang.top/categories/Unix-NetWork/"/>
    
    
      <category term="Unix" scheme="https://www.yuankang.top/tags/Unix/"/>
    
      <category term="Unix NetWork" scheme="https://www.yuankang.top/tags/Unix-NetWork/"/>
    
  </entry>
  
  <entry>
    <title>TCPIP 网络编程-06-套接字断开</title>
    <link href="https://www.yuankang.top/2024/01/08/Unix%20NetWork/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-06-%E5%A5%97%E6%8E%A5%E5%AD%97%E6%96%AD%E5%BC%80/"/>
    <id>https://www.yuankang.top/2024/01/08/Unix%20NetWork/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-06-%E5%A5%97%E6%8E%A5%E5%AD%97%E6%96%AD%E5%BC%80/</id>
    <published>2024-01-08T15:00:00.000Z</published>
    <updated>2024-01-28T11:01:08.763Z</updated>
    
    <content type="html"><![CDATA[<p><code>close</code> 是关闭套接字，调用之后无法再通过 <code>write</code> 与 <code>read</code> 读写数据。但是通过查看 TCP 的四次挥手我们知道</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2023-10-13_22-40-02.png" alt="Snipaste_2023-10-13_22-40-02" style="zoom:50%;" /><p>在 <code>close</code> 之后，对端可能还会发送一部分数据，这部分数据其实是丢失的。所以就引入了半关闭，只能发送数据但是不能接收 或者 只能接收数据但是不能发送。</p><p>这里提到了一个需求：客户端向服务器发起请求，然后服务端将文件传输给客户端之后，客户端接收完文件，然后告知服务端接收完毕了，客户端自动退出。</p><p>这里有一个疑问，客户端怎么知道接收完文件了？</p><ol><li>从 <code>read</code> 函数返回-1表示接收结束，但是<code>read</code> 返回-1 表示对端关闭了连接，那么需求中接收完文件还要发送响应就不行了</li><li>写一个标志位，告知这个标志位就表示文件结束。但是这样的话就必须让文件中没有与标志符一样的内容</li></ol><p>这个时候就用到了半关闭</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 半关闭</span></span><br><span class="line"><span class="comment"> * @param</span></span><br><span class="line"><span class="comment"> *  sock 要被关闭的套接字</span></span><br><span class="line"><span class="comment"> *  howto 传递断开的方式</span></span><br><span class="line"><span class="comment"> *      SHUT_RD: 断开输入流</span></span><br><span class="line"><span class="comment"> *      SHUT_WR: 断开输出流</span></span><br><span class="line"><span class="comment"> *      SHUT_RDWR: 同时断开输入输出流</span></span><br><span class="line"><span class="comment"> * @return 成功返回 0；失败返回 -1 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure><p>知道了 <code>shutdown</code> 函数之后，看看是如何实现的 示例地址：<a href="https://github.com/XBoom/network-ip.git" target="_blank" rel="noopener">https://github.com/XBoom/network-ip.git</a> 中的 <code>apps/socket/09/</code></p><p>运行结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[root]#</span><span class="bash">./server 5555</span></span><br><span class="line">[09/server.c:57 main info] server recv recv all file </span><br><span class="line"></span><br><span class="line"><span class="meta">[root]#</span><span class="bash">./client 127.0.0.1 5555</span></span><br></pre></td></tr></table></figure><p>另外通过抓包可以看出跟平时的四次挥手不一样的地方(5555 表示服务端)</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20240111225428108.png" alt="image-20240111225428108" /></p><ol><li>首先通过三次握手(1~3)</li><li>服务端第一次发送数据给客户端，客户端确认(4~5)</li><li>服务端第二次发送数据给客户端，客户端确认(6、8)</li><li>在服务端第二次发送数据的时候，同时发送了<code>FIN</code> 结束(7)，也就是调用的 <code>shutdown(client_sock, SHUT_WR);</code></li><li>客户端接着向服务端发送数据，客户端发送响应(9-10)，发现客户端调用的 <code>shutdown(server_sock, SHUT_RD);</code> 并没有作用，因为已经收到了服务端的 <code>FIN</code> 报文</li><li>发送结束之后，客户端通过 <code>close</code> 发起 <code>FIN</code></li></ol><p>对于两个 <code>shutdown</code> 可以看成下图这样</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20240111225821497.png" alt="image-20240111225821497" /></p><p><code>shotdown</code> 分别对应的是两个流，当一端关闭之后就不需要再次关闭了。而一条流的关闭也不会影响另外一条流</p><p>那么如果改变一下服务端的关闭流程，先关闭读，再关闭写。改成如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关闭读</span></span><br><span class="line"><span class="built_in">shutdown</span>(client_sock, SHUT_RD);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(buff, <span class="number">0</span> , <span class="keyword">sizeof</span>(buff));</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">read</span>(client_sock, buff, <span class="keyword">sizeof</span>(buff)))</span><br><span class="line">&#123;</span><br><span class="line">    LOG_INFO(<span class="string">"server recv %s"</span>, buff);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭写</span></span><br><span class="line"><span class="built_in">shutdown</span>(client_sock, SHUT_WR);</span><br></pre></td></tr></table></figure><p>程序运行结果如下，好像服务端没有什么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root]#./server <span class="number">5555</span></span><br><span class="line">  </span><br><span class="line">[root]#./client <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">5555</span></span><br><span class="line">[root]#</span><br></pre></td></tr></table></figure><p>看看交互报文</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20240111231443159.png" alt="image-20240111231443159" /></p><ol><li>服务端发送完数据之后，关闭了读 <code>shutdown(client_sock, SHUT_RD);</code></li><li>客户端接收完数据之后也关闭了读，导致客户端与服务端都阻塞等待</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li>《TCPIP 网络编程》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;close&lt;/code&gt; 是关闭套接字，调用之后无法再通过 &lt;code&gt;write&lt;/code&gt; 与 &lt;code&gt;read&lt;/code&gt; 读写数据。但是通过查看 TCP 的四次挥手我们知道&lt;/p&gt;
&lt;img src=&quot;https://images-1307117
      
    
    </summary>
    
    
      <category term="Unix NetWork" scheme="https://www.yuankang.top/categories/Unix-NetWork/"/>
    
    
      <category term="Unix" scheme="https://www.yuankang.top/tags/Unix/"/>
    
      <category term="Unix NetWork" scheme="https://www.yuankang.top/tags/Unix-NetWork/"/>
    
  </entry>
  
  <entry>
    <title>TCPIP 网络编程-05-基于UDP的CS</title>
    <link href="https://www.yuankang.top/2024/01/02/Unix%20NetWork/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-05-%E5%9F%BA%E4%BA%8EUDP%E7%9A%84CS/"/>
    <id>https://www.yuankang.top/2024/01/02/Unix%20NetWork/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-05-%E5%9F%BA%E4%BA%8EUDP%E7%9A%84CS/</id>
    <published>2024-01-02T15:00:00.000Z</published>
    <updated>2024-01-28T11:01:00.544Z</updated>
    
    <content type="html"><![CDATA[<p>在 《TCPIP 网络编程-02-套接字类型与协议设置》 中通过 示例地址：<a href="https://github.com/XBoom/network-ip.git" target="_blank" rel="noopener">https://github.com/XBoom/network-ip.git</a> 中的 <code>apps/socket/03/</code>学习了基于UDP的CS通信，可以发现</p><ol><li><code>Client</code> 是不需要发起<code>connect</code>的，直接使用 <code>sendto</code> 进行发送</li><li><code>Server</code> 不需要 <code>listen/accept</code>，而是直接通过<code>recvfrom</code>进行数据接收</li></ol><p>新增了两个函数 <code>sendto</code> 与 <code>recvfrom</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 使用UDP套接字进行发送 </span></span><br><span class="line"><span class="comment"> * @param </span></span><br><span class="line"><span class="comment"> *      sock 用于传输数据的UDP套接字文件描述符</span></span><br><span class="line"><span class="comment"> *      buff 保存待传输数据的缓冲地址值</span></span><br><span class="line"><span class="comment"> *      nbytes 待传输的数据长度，以B为单位</span></span><br><span class="line"><span class="comment"> *      flags 可选参数、没有则为0</span></span><br><span class="line"><span class="comment"> *      to 存有目的地址信息的sockaddr解耦提变量的地址值</span></span><br><span class="line"><span class="comment"> *      addrlen 参数to的地址值结构体变量长度</span></span><br><span class="line"><span class="comment"> * @return 成功返回传输的字节数，失败时返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct sockaddr *to, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief 使用UDP套接字接收数据</span></span><br><span class="line"><span class="comment"> *  @param</span></span><br><span class="line"><span class="comment"> *   sock 用于接收数据的UDP套接字文件描述符</span></span><br><span class="line"><span class="comment"> *   buff 保存接收数据的缓冲地址值</span></span><br><span class="line"><span class="comment"> *   nbytes   可接收的最大字节数，故无法超过参数buff所指的缓冲大小 </span></span><br><span class="line"><span class="comment"> *   flags 可选项参数，若没有则传入0</span></span><br><span class="line"><span class="comment"> *   from  存有发送端地址信息的sockaddr结构体变量的地址值</span></span><br><span class="line"><span class="comment"> *   addrlen 保存参数from的结构体变量长度的变量值</span></span><br><span class="line"><span class="comment"> *  @return 成功返回传输的字节数，失败时返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct sockaddr *from, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>写一个基于UDP的回声CS，示例地址：<a href="https://github.com/XBoom/network-ip.git" target="_blank" rel="noopener">https://github.com/XBoom/network-ip.git</a> 中的 <code>apps/socket/07/</code>。运行结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[root]#</span><span class="bash">./client 127.0.0.1 5555</span></span><br><span class="line">12345</span><br><span class="line">[07/client.c:28 main info] client send 12345 to 127.0.0.1 </span><br><span class="line">[07/client.c:36 main info] client recv 12345 from 127.0.0.1 </span><br><span class="line">  </span><br><span class="line"><span class="meta">[root]#</span><span class="bash">./server 5555</span></span><br><span class="line">[07/server.c:33 main info] recv message 12345 from 127.0.0.1</span><br></pre></td></tr></table></figure><p>从上面可以看出，**CS都不需要连接，**那么客户端地址又是如何分配的，答案是在 <code>sendto</code>的时候，首次调用 <code>sendto</code> 的时候会自动给套接字分配 IP 与端口，然后一直沿用到套接字关闭。</p><p>所以</p><ol><li><p>客户端其实可以使用 <code>connect</code> 当然此处的作用就不是连接，而是分配地址(TCP 也是在这个时候分配的地址);</p></li><li><p>又因为套接字有了地址之后，就可以不用 <code>sendto</code> 而直接使用 <code>write</code> 进行发送;</p></li><li><p>而且<strong>CS均只需要一个套接字(即只需要一个套接字就能和多个主机通信)</strong></p></li></ol><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/202401052119873.png" alt="image-20240105211959767" style="zoom:50%;" /><p>所以最后将示例 7 修改为 示例8：<a href="https://github.com/XBoom/network-ip.git" target="_blank" rel="noopener">https://github.com/XBoom/network-ip.git</a> 中的 <code>apps/socket/08/</code>，效果一致。通过 <code>connect</code> 进行地址分配，通过 <code>read/write</code> 进行消息发送接收。运行结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root]#./server <span class="number">5555</span></span><br><span class="line">[<span class="number">08</span>/server.c:<span class="number">33</span> main info] recv message <span class="number">12345</span> from <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> </span><br><span class="line"></span><br><span class="line">[root]#./client <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">5555</span></span><br><span class="line"><span class="number">12345</span></span><br><span class="line">[<span class="number">08</span>/client.c:<span class="number">36</span> main info] recv server response:<span class="number">12345</span></span><br></pre></td></tr></table></figure><blockquote><p>TIPS:</p><p><code>sendto</code> 函数主要分为三个阶段</p><ul><li>向 UDP 套接字注册 IP 地址与端口</li><li>传输数据</li><li>删除 UDP 套接字中注册的 IP 地址与套接字</li></ul><p><code>sendto</code> 函数每次调用都执行上述三个阶段，将未注册 IP 地址与端口的称为未连接的 UDP 套接字。用于向不同的目标发送数据</p><p>相反，通过 <code>connect</code> 将 IP 地址与端口注册到 UDP 套接字，称为 已连接的 UDP 套接字。用于向同一个目标发送数据</p></blockquote><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li>《TCPIP 网络编程》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 《TCPIP 网络编程-02-套接字类型与协议设置》 中通过 示例地址：&lt;a href=&quot;https://github.com/XBoom/network-ip.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com
      
    
    </summary>
    
    
      <category term="Unix NetWork" scheme="https://www.yuankang.top/categories/Unix-NetWork/"/>
    
    
      <category term="Unix" scheme="https://www.yuankang.top/tags/Unix/"/>
    
      <category term="Unix NetWork" scheme="https://www.yuankang.top/tags/Unix-NetWork/"/>
    
  </entry>
  
  <entry>
    <title>TCPIP 网络编程-04-基于TCP的CS</title>
    <link href="https://www.yuankang.top/2023/12/27/Unix%20NetWork/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-04-%E5%9F%BA%E4%BA%8ETCP%E7%9A%84CS/"/>
    <id>https://www.yuankang.top/2023/12/27/Unix%20NetWork/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-04-%E5%9F%BA%E4%BA%8ETCP%E7%9A%84CS/</id>
    <published>2023-12-27T15:00:00.000Z</published>
    <updated>2024-01-28T11:00:44.653Z</updated>
    
    <content type="html"><![CDATA[<p>有了地址的设置函数之后，接下来就是开始进行连接</p><p>服务端存在两个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过调用 listen 函数进入等待连接请求状态。(只有调用 listen，客户端才能发起 connect)</span></span><br><span class="line"><span class="comment"> * sock 希望进入等待连接请求的状态的套接字文件描述</span></span><br><span class="line"><span class="comment"> * backlog 连接请求等待队列(Queue)的长度，若位 5，表示最多使5个连接请求进入队列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 受理客户端连接请求，返回一个套接字连接到发起请求的客户端</span></span><br><span class="line"><span class="comment"> * sock 服务端套接字的文件描述符</span></span><br><span class="line"><span class="comment"> * addr 保存发起连接请求的客户端地址信息的变量地址值</span></span><br><span class="line"><span class="comment"> * addrlen 第二个参数 addr 结构体的长度</span></span><br><span class="line"><span class="comment"> * 成功返回创建的套接字文件描述符，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sock, struct sockaddr * addr, <span class="keyword">socklen_t</span> * addr_len)</span></span>;</span><br></pre></td></tr></table></figure><p><code>accept</code> 函数受理连接请求等待队列中待处理的客户端连接请求</p><p>客户端使用 connect发起连接请求</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向服务端发起请求连接</span></span><br><span class="line"><span class="comment"> * sock 客户端套接字文件描述符</span></span><br><span class="line"><span class="comment"> * servaddr 保存目标服务端地址信息的变量地址值</span></span><br><span class="line"><span class="comment"> * addrlen 第二个参数结构体的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sock, struct sockaddr * server_addr, <span class="keyword">socklen_t</span> addr_len)</span></span>;</span><br></pre></td></tr></table></figure><p>客户端调用 <code>connect</code> 之后，可能发生以下情况之一才返回(完成函数调用)</p><ol><li><p>服务端接收连接请求</p></li><li><p>发生断网导致一场情况而中断连接请求(阻塞的)</p></li></ol><p>客户端<code>connect</code>的时候并没有指定客户端的地址，那么是什么时候分配的ip 与端口？其实是自动分配的，所以客户端无需调用标记的 <code>bind</code> 函数进行分配</p><blockquote><p>TIPS: 接收连接并不意味着服务端调用 <code>accept</code> 函数，而是服务端把连接请求信息记录到等待队列。因此 <code>connect</code> 函数返回之后并不立即进行数据交换，那么问题来了，客户端既然不知道服务端是否已经 <code>accept</code> 了，那么如果客户端立即 <code>write</code> 发送数据，数据到服务端会是一个什么状态</p><p>答：如果服务器端尚未调用 <code>accept</code>，连接处于已建立但未接受的状态。在这种情况下，发送的数据将保留在等待队列中，等待服务器端调用 <code>accept</code> 来接受连接。一旦服务器端调用了 <code>accept</code>，则可以开始在客户端和服务器端之间进行数据交换</p></blockquote><p>所以函数的调用关系如下</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2024-01-02_21-49-18.png" alt="Snipaste_2024-01-02_21-49-18" style="zoom:50%;" /><p>这章要求是写一个回写 CS，代码：<a href="https://github.com/XBoom/network-ip.git" target="_blank" rel="noopener">https://github.com/XBoom/network-ip.git</a> 中的 <code>apps/socket/06/</code>执行结果，服务端接收到消息之后恢复给客户端，有两种情况，每一次写入都原样写回；第二种是每次的写入收集起来一次写回</p><p>要求：</p><ol><li>服务器端在同一时刻只能与一个客户端相连，并提供回声服务</li><li>服务器端一次向5个客户端提供服务并退出</li><li>客户端接收用户输入的字符串并发送到服务器端</li><li>服务器端将接收的字符串数据传回客户端，即“回声服务”</li><li>服务器端与客户端之间的字符串回声一致执行到客户端输入Q</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[root]#</span><span class="bash">./server 5555</span></span><br><span class="line">[06/server.c:44 main info] accept socket 4 </span><br><span class="line">[06/server.c:49 main info] recv message:client1 </span><br><span class="line">[06/server.c:55 main info] reponse len 7 message:client1 </span><br><span class="line">[06/server.c:44 main info] accept socket 4 </span><br><span class="line">[06/server.c:49 main info] recv message:client2 </span><br><span class="line">[06/server.c:55 main info] reponse len 7 message:client2 </span><br><span class="line">[06/server.c:44 main info] accept socket 4 </span><br><span class="line">[06/server.c:49 main info] recv message:client3 </span><br><span class="line">[06/server.c:55 main info] reponse len 7 message:client3 </span><br><span class="line">[06/server.c:44 main info] accept socket 4 </span><br><span class="line">[06/server.c:49 main info] recv message:client4 </span><br><span class="line">[06/server.c:55 main info] reponse len 7 message:client4 </span><br><span class="line">[06/server.c:44 main info] accept socket 4 </span><br><span class="line">[06/server.c:49 main info] recv message:client5 </span><br><span class="line">[06/server.c:55 main info] reponse len 7 message:client5 </span><br><span class="line">[06/server.c:60 main info] reponse message end</span><br></pre></td></tr></table></figure><p>读写操作 <code>read/write</code> 由于是无边界，数据存储在IO缓存区等待读写</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/202401052042916.png" alt="image-20240105204229710" style="zoom:50%;" /><p>IO缓存区有以下特点</p><ul><li>IO缓冲在每个TCP套接字中单独存在</li><li>IO缓冲在创建套接字时自动生成</li><li>关闭套接字会继续传递<strong>输出缓冲</strong>中遗留的数据</li><li>关闭套接字会丢失<strong>输入缓冲</strong>中的数据</li></ul><blockquote><p>TIPS: 输出不丢失是因为系统自动进行发送操作，而输入丢失是因为套接字关闭了输入缓冲中的数据也没有人能够读到了，也就丢掉</p></blockquote><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li>《TCPIP 网络编程》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有了地址的设置函数之后，接下来就是开始进行连接&lt;/p&gt;
&lt;p&gt;服务端存在两个函数&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;b
      
    
    </summary>
    
    
      <category term="Unix NetWork" scheme="https://www.yuankang.top/categories/Unix-NetWork/"/>
    
    
      <category term="Unix" scheme="https://www.yuankang.top/tags/Unix/"/>
    
      <category term="Unix NetWork" scheme="https://www.yuankang.top/tags/Unix-NetWork/"/>
    
  </entry>
  
  <entry>
    <title>TCPIP 网络编程-03-地址族与数据序列</title>
    <link href="https://www.yuankang.top/2023/12/22/Unix%20NetWork/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-03-%E5%9C%B0%E5%9D%80%E6%97%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97/"/>
    <id>https://www.yuankang.top/2023/12/22/Unix%20NetWork/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-03-%E5%9C%B0%E5%9D%80%E6%97%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97/</id>
    <published>2023-12-22T15:00:00.000Z</published>
    <updated>2024-01-28T11:00:36.698Z</updated>
    
    <content type="html"><![CDATA[<p>上一章《套接字类型与协议设置》是构建套接字，这一章就是给地址分配 IP 地址和端口号</p><p>首先是结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family;     <span class="comment">//地址族(Address Family) __uint8_t</span></span><br><span class="line">    <span class="keyword">uint16_t</span> sin_port;          <span class="comment">//16 位 TCP/UDP 端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>    <span class="comment">//32 位 IP 地址</span></span><br><span class="line">    <span class="keyword">char</span>   sin_zero[<span class="number">8</span>];    <span class="comment">//不使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">in_addr_t</span> s_addr;   <span class="comment">//32 位 IPv4 地址 (__uint32_t)  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>sin_zero</code> 是为了 使 <code>struct sockaddr_in</code> 与 <code>struct sockaddr</code> 结构大小一致而插入的成员，必须填充为0</p><p><code>struct sockaddr</code> 的结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family; <span class="comment">//协议族</span></span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>];   <span class="comment">//地址信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sa_data</code> 保存的地址信息包含了地址与端口号，剩余部分填充为0</p><blockquote><p>tips: 服务端套接字虽然要绑定一个端口，但是同一个端口 TCP套接字和UDP套接字是可以共用的（虽然一般不共用）</p></blockquote><p>字节序转换有以下内容</p><ol><li>网络字节序规定统一使用大端</li><li>如何记住大小端：端(即 开端)，地址从低到高，低字节在低地址就是小端，高字节在低地址就是大端</li><li>即使系统本身是大端，最好也调用一下，反正也不会有任何变化。提升代码兼容性</li></ol><p>字节序转换函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> short <span class="title">htons</span><span class="params">(<span class="keyword">unsigned</span> short)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> short <span class="title">ntohs</span><span class="params">(<span class="keyword">unsigned</span> short)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>网络地址的转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">//成功时返回32位大端序整数型值，失败返回INADDR_NONE(检查无效IP地址)</span></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="built_in">string</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与上面功能一样，成功返回1，失败返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="built_in">string</span>, struct in_addr *addr)</span></span>;</span><br><span class="line"><span class="comment">//将网络字节序地址转换为字符串形式(注意返回结果的释放)</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr *addr)</span></span>;</span><br></pre></td></tr></table></figure><p><code>ntoa</code> 可以理解为 <code>network to address</code>，<code>aton</code> 同理</p><p>重写代码地址：<a href="https://github.com/XBoom/network-ip.git" target="_blank" rel="noopener">https://github.com/XBoom/network-ip.git</a> 中的 <code>apps/socket/05/</code>执行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[05/server.c:16 main info] host ordered port: 0x1234 </span><br><span class="line">[05/server.c:17 main info] net ordered addr: 0x3412 </span><br><span class="line">[05/server.c:18 main info] host ordered post: 0x12345678 </span><br><span class="line">[05/server.c:19 main info] net ordered post: 0x12345678 </span><br><span class="line">[05/server.c:31 main info] inet addr 127.0.0.1 success 0x100007f </span><br><span class="line">[05/server.c:37 main error] inet addr 127.0.0.258 failed </span><br><span class="line">[05/server.c:53 main info] inet_aton 127.0.0.1 success 0x100007f </span><br><span class="line">[05/server.c:58 main error] inet_aton 127.0.0.258 failed </span><br><span class="line">[05/server.c:69 main info] inet ntoa 127.0.0.1 127.0.0.1</span><br></pre></td></tr></table></figure><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li>《TCPIP 网络编程》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一章《套接字类型与协议设置》是构建套接字，这一章就是给地址分配 IP 地址和端口号&lt;/p&gt;
&lt;p&gt;首先是结构体&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;
      
    
    </summary>
    
    
      <category term="Unix NetWork" scheme="https://www.yuankang.top/categories/Unix-NetWork/"/>
    
    
      <category term="Unix" scheme="https://www.yuankang.top/tags/Unix/"/>
    
      <category term="Unix NetWork" scheme="https://www.yuankang.top/tags/Unix-NetWork/"/>
    
  </entry>
  
  <entry>
    <title>TCPIP 网络编程-02-套接字类型与协议设置</title>
    <link href="https://www.yuankang.top/2023/12/13/Unix%20NetWork/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-02-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8D%8F%E8%AE%AE%E8%AE%BE%E7%BD%AE/"/>
    <id>https://www.yuankang.top/2023/12/13/Unix%20NetWork/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-02-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8D%8F%E8%AE%AE%E8%AE%BE%E7%BD%AE/</id>
    <published>2023-12-13T15:00:00.000Z</published>
    <updated>2024-01-28T11:00:28.962Z</updated>
    
    <content type="html"><![CDATA[<p>第一章《TCPIP 网络编程-01-入门》讲到了 socket 函数，这里将详细看看套接字逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建套接字</span></span><br><span class="line"><span class="comment"> * domain 套接字中使用的协议族信息</span></span><br><span class="line"><span class="comment"> * type 套接字数据传输类型的信息</span></span><br><span class="line"><span class="comment"> * protocol 计算机见通信中使用的协议信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>domain参数</strong>代表的协议族分类可分为以下几类</p><ul><li><strong>PF_INET</strong>: IPv4 互联网协议族</li><li><strong>PF_INET6</strong>: IPv6 互联网协议族</li><li><strong>PF_LOCAL</strong>: 本地通信的 UNIX 协议族</li><li><strong>PF_PACKET</strong>: 底层套接字的协议族</li><li><strong>PF_IPX</strong>: IPX Novell 协议族</li></ul><p><strong>type 参数</strong>代表的套接字数据的传输方式</p><ul><li><strong>SOCK_STREAM</strong>: 面向连接的套接字(TCP)。 面向连接的特点，传输过程中数据不会消失，按序传输数据，传输的数据不存在数据边界(面向连接的可靠字节流)<ul><li>可靠的(不丢失)</li><li>按序传输数据</li><li>传输的数据没有边界</li></ul></li><li><strong>SOCK_DGRAM</strong>: 面向消息的套接字(UDP)。有以下特点<ul><li>强调快速而非传输顺序</li><li>传输的数据可能丢失也可能损毁</li><li>传输数据有边界</li><li>限制每次传输的数据大小</li></ul></li></ul><p><strong>protocol 参数</strong>代表决定了最终的协议，为什么前两个参数无法决定？</p><p>因为同一协议族中可能存在多个数据传输方式相同的协议。所以一般可以传一个 0 表示使用默认协议</p><blockquote><p>Tips:</p><ol><li>为了接收数据，套接字内部有字节数组缓冲区。调用 read 函数从缓冲区读取部分数据，所以缓冲区并不总是满的。即使读的比较慢，缓冲区满了，套接字无法再接受数据，也不会发生数据丢失。因为套接字会根据接收端的状态传输数据(滑动窗口)，传输错误也会有重传服务</li></ol></blockquote><p>示例地址：<a href="https://github.com/XBoom/network-ip.git" target="_blank" rel="noopener">https://github.com/XBoom/network-ip.git</a> 中的 <code>apps/socket/03/</code></p><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[03/server.c:44 main info] server recv 48 len msssage:</span><br><span class="line">client message </span><br><span class="line">client message </span><br><span class="line">client message</span><br></pre></td></tr></table></figure><p>可以看到，即使<strong>一个一个字符的读取也是能读到所有的内容</strong>(注意字符串结束符会影响打印)</p><p>问题 1：既然数据是没有边界的，那么上层是如何获取对应的数据结构的？</p><ul><li>固定长度的消息：每次读取固定长度，既浪费空间也不灵活</li><li>消息头包含长度信息：在消息头包含一个字段，表示整个消息的长度。接收方先读消息头，然后根据长度信息读取对应长度的数据</li><li>使用消息格式协议：使用 JSON、 XML 等消息格式协议</li><li>使用消息起始标志与结束标志：通过检测这些标志来确定消息的边界</li></ul><p>问题 2：如何使用 <code>SOCK_DGRAM</code> 又如何编程？</p><p>示例地址：<a href="https://github.com/XBoom/network-ip.git" target="_blank" rel="noopener">https://github.com/XBoom/network-ip.git</a> 中的 <code>apps/socket/04/</code></p><p>区别在于 客户端并不需要执行连接请求，只需要在发送的时候指定发送地址。而服务端也不需要 <code>bind/listen</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> message[MAX_BUFF_LEN] = <span class="string">"client message \n"</span>;</span><br><span class="line"></span><br><span class="line">    ret = sendto(server_sock, message, <span class="built_in">strlen</span>(message) + <span class="number">1</span>, </span><br><span class="line">        <span class="number">0</span>, (<span class="keyword">const</span> struct sockaddr*)&amp;server_addr, server_addr_len);</span><br><span class="line">    CHECK_RET(ret == <span class="number">-1</span>, <span class="string">"sendto failed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而服务端也不需要监听，直接读取数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((read_len = recvfrom(server_sock, &amp;message[str_len], MAX_BUFF_LEN, <span class="number">0</span>,</span><br><span class="line">    (struct sockaddr *)&amp;client_addr, &amp;clietn_addr_len)) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    LOG_INFO(<span class="string">"recv %d %d"</span>, str_len, read_len);</span><br><span class="line">    str_len += read_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且数据也不一个一个读取，这是读取 <code>MAX_BUFF_LEN</code> 的结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[04/server.c:32 main info] recv 0 17 </span><br><span class="line">[04/server.c:32 main info] recv 17 17 </span><br><span class="line">[04/server.c:32 main info] recv 34 17</span><br></pre></td></tr></table></figure><p>而这是一次读取一个的情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[04/server.c:32 main info] recv 0 1 </span><br><span class="line">[04/server.c:32 main info] recv 1 1 </span><br><span class="line">[04/server.c:32 main info] recv 2 1</span><br></pre></td></tr></table></figure><p>每次读取一个之后整个数据其实就丢了</p><p>最后来看看正常情况下是不是实现了 UDP 通信</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2024-01-01_18-59-41.png" alt="Snipaste_2024-01-01_18-59-41" style="zoom:50%;" /><p>可以看到 UDP 并不需要三次握手也就不需要 connect 以及 listen 这类操作直接进行数据发送与接收，详细的过程后续在介绍 UDP 在详细查看</p><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li>《TCPIP 网络编程》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一章《TCPIP 网络编程-01-入门》讲到了 socket 函数，这里将详细看看套接字逻辑&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/
      
    
    </summary>
    
    
      <category term="Unix NetWork" scheme="https://www.yuankang.top/categories/Unix-NetWork/"/>
    
    
      <category term="Unix" scheme="https://www.yuankang.top/tags/Unix/"/>
    
      <category term="Unix NetWork" scheme="https://www.yuankang.top/tags/Unix-NetWork/"/>
    
  </entry>
  
  <entry>
    <title>TCPIP 网络编程-01-入门</title>
    <link href="https://www.yuankang.top/2023/12/07/Unix%20NetWork/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-01-%E5%85%A5%E9%97%A8/"/>
    <id>https://www.yuankang.top/2023/12/07/Unix%20NetWork/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-01-%E5%85%A5%E9%97%A8/</id>
    <published>2023-12-07T15:00:00.000Z</published>
    <updated>2024-01-28T11:00:20.591Z</updated>
    
    <content type="html"><![CDATA[<p>带着问题看世界：</p><ol><li>套接字在网络编程中的作用是什么？为何称为套接字</li><li>比较说明 listen 函数和 accept 函数的作用</li><li>创建套接字后一般会为它分配地址，为什么？为了完成地址分配需要调用哪些函数</li></ol><p>入门例子就是写一个客户端与服务器通信，示例地址：<a href="https://github.com/XBoom/network-ip.git" target="_blank" rel="noopener">https://github.com/XBoom/network-ip.git</a> 中的 <code>apps/socket/01/</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类似打电话的过程</span></span><br><span class="line"><span class="comment"> * 1. 拥有一个电话机</span></span><br><span class="line"><span class="comment"> * 2. 准备自己的电话号码</span></span><br><span class="line"><span class="comment"> * 3. 插上电话线准备监听</span></span><br><span class="line"><span class="comment"> * 4. 拿起电话进行对话</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 1. 有人打电话</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构建套接字，成功返回文件描述符，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给套接字分配地址(IP PORT)，成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始监听(将套接字转为可接受请求状态)，成功返回 0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理连接请求，成功返回文件描述符，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发起套接字请求</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *serv_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于将点分十进制的IP地址字符串转换为网络字节序（big-endian）的32位IPv4地址</span></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp)</span></span>;</span><br></pre></td></tr></table></figure><p><code>sockaddr</code> 与 <code>sockaddr_in</code> 的区别</p><ul><li><code>sockaddr</code> 用来代表套接字地址，IPv4 or IPv6</li><li><code>sockaddr_in</code> 用来特指 IPv4</li></ul><p>所以套接字接口使用的是 <code>struct sockaddr</code>，如果定义结构如果使用的是 <code>struct sockaddr_in</code> 则注意强制转换</p><p>为了对比，这里也把书中的文件例子重写了一遍，从client.txt读取文件然后写入到另外一个文件server.txt 中</p><p>示例地址：<a href="https://github.com/XBoom/network-ip.git" target="_blank" rel="noopener">https://github.com/XBoom/network-ip.git</a> 中的 apps/socket/02/</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打开文件 成功时返回文件描述符，失败时返回-1</span></span><br><span class="line"><span class="comment"> * path 文件名的字符串地址</span></span><br><span class="line"><span class="comment"> * flag 文件打开模式信息</span></span><br><span class="line"><span class="comment"> *  O_CREAT    必要时创建文件</span></span><br><span class="line"><span class="comment"> *  O_TRUNC     删除全部现有文件</span></span><br><span class="line"><span class="comment"> *  O_APPEND    维持现有数据，保存到其后面</span></span><br><span class="line"><span class="comment"> *  O_RDONLY    只读打开</span></span><br><span class="line"><span class="comment"> *  O_WRONLY    只写打开</span></span><br><span class="line"><span class="comment"> *  O_RDWR      读写打开</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭文件</span></span><br><span class="line"><span class="comment"> * 成功时返回 0，失败时返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据写入文件</span></span><br><span class="line"><span class="comment"> * fd 文件描述符</span></span><br><span class="line"><span class="comment"> * buf 数据的缓冲地址值</span></span><br><span class="line"><span class="comment"> * nbytes 要传输的字节数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取文件中的数据</span></span><br><span class="line"><span class="comment"> * fd 文件描述符</span></span><br><span class="line"><span class="comment"> * buf 数据的缓冲地址值</span></span><br><span class="line"><span class="comment"> * nbytes 要传输的字节数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure><p>服务端运行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[root]#</span><span class="bash">./server 5555</span></span><br><span class="line">[02/server.c:9 write_file info] ./02/server.txt TCP/IP 网络编程 client.txt </span><br><span class="line">[02/server.c:18 write_file info] wirte success </span><br><span class="line">[02/server.c:66 main info] write file success</span><br></pre></td></tr></table></figure><p>客户端结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[root]#</span><span class="bash">./client 127.0.0.1 5555</span></span><br><span class="line">[02/client.c:50 main info] client send msg success </span><br><span class="line">[02/client.c:56 main info] receive server reponse:write file success</span><br></pre></td></tr></table></figure><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li>《TCPIP 网络编程》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;带着问题看世界：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;套接字在网络编程中的作用是什么？为何称为套接字&lt;/li&gt;
&lt;li&gt;比较说明 listen 函数和 accept 函数的作用&lt;/li&gt;
&lt;li&gt;创建套接字后一般会为它分配地址，为什么？为了完成地址分配需要调用哪些函数&lt;/li&gt;
&lt;/
      
    
    </summary>
    
    
      <category term="Unix NetWork" scheme="https://www.yuankang.top/categories/Unix-NetWork/"/>
    
    
      <category term="Unix" scheme="https://www.yuankang.top/tags/Unix/"/>
    
      <category term="Unix NetWork" scheme="https://www.yuankang.top/tags/Unix-NetWork/"/>
    
  </entry>
  
  <entry>
    <title>TCPIP 网络编程-00-简介</title>
    <link href="https://www.yuankang.top/2023/12/06/Unix%20NetWork/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-00%20%E7%AE%80%E4%BB%8B/"/>
    <id>https://www.yuankang.top/2023/12/06/Unix%20NetWork/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-00%20%E7%AE%80%E4%BB%8B/</id>
    <published>2023-12-06T15:00:00.000Z</published>
    <updated>2024-01-28T11:00:12.545Z</updated>
    
    <content type="html"><![CDATA[<p>学习《TCP&amp;IP 网络编程》，将书中的代码结合自己的项目结构重新写一遍</p><p>项目地址在 <a href="https://github.com/XBoom/network-ip.git" target="_blank" rel="noopener">https://github.com/XBoom/network-ip.git</a> 目录 <code>apps/socket/</code> 对应章节如下</p><ul><li>01 第一章 理解网络编程和套接字</li><li>02 第一章 理解网络编程-从文件读写发送</li></ul><p>编译方法只需要在 <code>apps/socket/</code> 目录下执行 <code>make DIR=&lt;directory&gt;</code> 即可编译对应目录下的文件</p><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li>《TCPIP 网络编程》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习《TCP&amp;amp;IP 网络编程》，将书中的代码结合自己的项目结构重新写一遍&lt;/p&gt;
&lt;p&gt;项目地址在 &lt;a href=&quot;https://github.com/XBoom/network-ip.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ht
      
    
    </summary>
    
    
      <category term="Unix NetWork" scheme="https://www.yuankang.top/categories/Unix-NetWork/"/>
    
    
      <category term="Unix" scheme="https://www.yuankang.top/tags/Unix/"/>
    
      <category term="Unix NetWork" scheme="https://www.yuankang.top/tags/Unix-NetWork/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-02-Heap</title>
    <link href="https://www.yuankang.top/2023/09/29/Data%20Structure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-02-Heap/"/>
    <id>https://www.yuankang.top/2023/09/29/Data%20Structure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-02-Heap/</id>
    <published>2023-09-28T16:16:00.000Z</published>
    <updated>2023-09-28T16:22:33.072Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读 libevent 库中另外一个用来存储事件的第二个结构就是小根堆，这里重新学习一下它的实现</p><p>代码路径:<code>minheap-internal.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">min_heap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span>** <span class="title">p</span>;</span></span><br><span class="line"><span class="keyword">size_t</span> n, a;<span class="comment">// n 表示堆的元素数目，a 表示当前分配的内存空间大小</span></span><br><span class="line">&#125; <span class="keyword">min_heap_t</span>;</span><br></pre></td></tr></table></figure><p><code>struct event** p</code> 区别与使用数组进行存储，这样就可以实现动态扩容</p><h3 id="堆初始化"><a class="markdownIt-Anchor" href="#堆初始化"></a> 堆初始化</h3><p>一开始没有元素，而要做的就是初始化一个最小堆对象 <code>min_heap_t</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//event.c:650 event_base_new_with_config</span></span><br><span class="line">min_heap_ctor_(&amp;base-&gt;timeheap);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">min_heap_ctor_</span><span class="params">(<span class="keyword">min_heap_t</span>* s)</span> </span>&#123; s-&gt;p = <span class="number">0</span>; s-&gt;n = <span class="number">0</span>; s-&gt;a = <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p>初始化堆，这里有一个小技巧就是将 <code>s-&gt;p= 0</code> , <strong>就是不指向任何对象，相当于 NULL</strong>，<code>min_heap_t* a = 0;</code>，同时堆的分配内容大小 a 一开始并没指定**(懒加载形式)**</p><p>其他辅助函数包括</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_heap_empty_</span><span class="params">(<span class="keyword">min_heap_t</span>* s)</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == s-&gt;n; &#125;<span class="comment">//堆是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">min_heap_size_</span><span class="params">(<span class="keyword">min_heap_t</span>* s)</span> </span>&#123; <span class="keyword">return</span> s-&gt;n; &#125;<span class="comment">//堆的节点数量</span></span><br><span class="line"><span class="function">struct event* <span class="title">min_heap_top_</span><span class="params">(<span class="keyword">min_heap_t</span>* s)</span> </span>&#123; <span class="keyword">return</span> s-&gt;n ? *s-&gt;p : <span class="number">0</span>; &#125;<span class="comment">//堆顶节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">min_heap_dtor_</span><span class="params">(<span class="keyword">min_heap_t</span>* s)</span> </span>&#123; <span class="keyword">if</span> (s-&gt;p) mm_free(s-&gt;p); &#125;<span class="comment">//释放堆</span></span><br><span class="line"><span class="comment">//节点为堆中最大索引(最后一个节点)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">min_heap_elem_init_</span><span class="params">(struct event* e)</span> </span>&#123; e-&gt;ev_timeout_pos.min_heap_idx = EV_SIZE_MAX; &#125;</span><br></pre></td></tr></table></figure><h3 id="添加节点"><a class="markdownIt-Anchor" href="#添加节点"></a> 添加节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//event.c:2217 event_assign</span></span><br><span class="line"></span><br><span class="line">min_heap_elem_init_(ev);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">min_heap_elem_init_</span><span class="params">(struct event* e)</span> </span>&#123; e-&gt;ev_timeout_pos.min_heap_idx = EV_SIZE_MAX; &#125;</span><br></pre></td></tr></table></figure><p>在添加节点的时候，首先指定节点在堆中的索引是 <code>EV_SIZE_MAX</code>，表示并没有加入到堆中，接着加入到堆中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_heap_push_</span><span class="params">(<span class="keyword">min_heap_t</span>* s, struct event* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (min_heap_reserve_(s, s-&gt;n + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">min_heap_shift_up_(s, s-&gt;n++, e);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就发生了两步操作</p><ol><li>因为可能堆已经满了，所以需要将堆进行扩容 <code>min_heap_reserve_</code></li><li>堆化，需要调整成小顶堆</li></ol><h4 id="扩容"><a class="markdownIt-Anchor" href="#扩容"></a> 扩容</h4><p>首次分配的容量大小是8，后续依次加倍</p><blockquote><p>问题1：如果节点新增很多，会不会导致内存分配暴涨？</p><p>golang 的 map 有一个 2倍增长到了一定数量再1.25倍增长的过程</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_heap_reserve_</span><span class="params">(<span class="keyword">min_heap_t</span>* s, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s-&gt;a &lt; n)<span class="comment">//判断容量是否不够</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span>** <span class="title">p</span>;</span></span><br><span class="line"><span class="keyword">size_t</span> a = s-&gt;a ? s-&gt;a * <span class="number">2</span> : <span class="number">8</span>;<span class="comment">// 小于8则使用8，否则加倍增长</span></span><br><span class="line"><span class="keyword">if</span> (a &lt; n)<span class="comment">//如果仍然小于n, 则直接使用 n </span></span><br><span class="line">a = n;</span><br><span class="line"><span class="keyword">if</span> (!(p = (struct event**)mm_realloc(s-&gt;p, a * <span class="keyword">sizeof</span> *p)))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">s-&gt;p = p;</span><br><span class="line">s-&gt;a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>当容量不够的时候，需要进行扩容操作，不需要考虑 golang map 那种因为装载量过大而影响查询效率的情况</li><li>容量首先是8，然后依次递增，当等待事件比较多，注意内存占用(一大块内存)</li><li>使用 <code>realloc</code> 操作，直接保留了原来的内容(<strong>realloc 的底层并不一定在原有的基础上，因为无法保证内存后面是否仍然有足够的空闲空间</strong>）</li></ol><h4 id="向上调整"><a class="markdownIt-Anchor" href="#向上调整"></a> 向上调整</h4><p>元素入堆的基本流程是：</p><ol><li><p>将元素添加到堆尾(堆最后一个元素)</p></li><li><p>将元素与父节点进行比较</p><p>a. 如果比父节点大则与父节点交换位置 然后重复 1～2 操作</p><p>b. 如果不比父节点大则停止入堆，完成元素添加</p></li></ol><p>接着看它的实际操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//min_heap_shift_up_(s, s-&gt;n++, e);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">min_heap_shift_up_</span><span class="params">(<span class="keyword">min_heap_t</span>* s, <span class="keyword">size_t</span> hole_index, struct event* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//找到节点的父节点</span></span><br><span class="line">    <span class="keyword">size_t</span> parent = (hole_index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (hole_index &amp;&amp; min_heap_elem_greater(s-&gt;p[parent], e))</span><br><span class="line">    &#123;</span><br><span class="line">        (s-&gt;p[hole_index] = s-&gt;p[parent])-&gt;ev_timeout_pos.min_heap_idx = hole_index;</span><br><span class="line">        hole_index = parent;</span><br><span class="line">        parent = (hole_index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    (s-&gt;p[hole_index] = e)-&gt;ev_timeout_pos.min_heap_idx = hole_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>hole_index</code> 一开始为堆的最后一个元素的索引，即当前事件 e 的位置</li><li>找到最后一个节点的父节点 <code>(hole_index - 1) / 2;</code></li><li>如果当前位置 <code>hole_index</code> 还不是堆顶(<code>hole_index != 0</code> )且 父节点超时时间比自己大<ul><li>当前元素等于父节点，索引位置更新为 <code>hole_index</code></li><li>当前索引 <code>hole_index</code> 为父节点索引，<code>hole_index = parent;</code></li><li>找到父节点位置</li><li>重复操作 3</li></ul></li><li>更新当前节点为e，设置索引为 <code>hole_index</code></li></ol><p>比较逻辑则是使用超时时间进行对比</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min_heap_elem_greater(a, b) \</span></span><br><span class="line">(evutil_timercmp(&amp;(a)-&gt;ev_timeout, &amp;(b)-&gt;ev_timeout, &gt;))</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果秒相同就是用毫秒</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>evutil_timercmp(tvp, uvp, cmp)\</span></span><br><span class="line">(((tvp)-&gt;tv_sec == (uvp)-&gt;tv_sec) ?\</span><br><span class="line"> ((tvp)-&gt;tv_usec cmp (uvp)-&gt;tv_usec) :\</span><br><span class="line"> ((tvp)-&gt;tv_sec cmp (uvp)-&gt;tv_sec))</span><br></pre></td></tr></table></figure><h3 id="弹出节点"><a class="markdownIt-Anchor" href="#弹出节点"></a> 弹出节点</h3><p>有增加就有删除，出堆常规操作是</p><ol><li>将堆顶与堆尾元素进行交换</li><li>将堆尾元素出堆</li><li>从对顶元素开始从上到下，与子节点比较交换</li></ol><p>看看它是如何做到的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event* <span class="title">min_heap_pop_</span><span class="params">(<span class="keyword">min_heap_t</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s-&gt;n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span>* <span class="title">e</span> = *<span class="title">s</span>-&gt;<span class="title">p</span>;</span></span><br><span class="line">min_heap_shift_down_(s, <span class="number">0</span>, s-&gt;p[--s-&gt;n]);</span><br><span class="line">e-&gt;ev_timeout_pos.min_heap_idx = EV_SIZE_MAX;</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>--s-&gt;n</code> 因为要弹出，所以 数量减 1，<code>s-&gt;p[--s-&gt;n]</code> 指向堆尾</li><li>如果堆元素数量大于 0，记录堆顶事件。否则返回 0(与前面一样，0 指向指针表示 NULL)</li><li>向下调整，注意最后一个节点指向的是最后一个节点</li><li>更新出堆事件的索引(表示不在堆里面)</li></ol><h4 id="向下调整"><a class="markdownIt-Anchor" href="#向下调整"></a> 向下调整</h4><p>将 <code>hole_index</code>  与 <code>struct event* e 进行交换</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">min_heap_shift_down_</span><span class="params">(<span class="keyword">min_heap_t</span>* s, <span class="keyword">size_t</span> hole_index, struct event* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> min_child = <span class="number">2</span> * (hole_index + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (min_child &lt;= s-&gt;n)</span><br><span class="line">&#123;</span><br><span class="line">min_child -= min_child == s-&gt;n || min_heap_elem_greater(s-&gt;p[min_child], s-&gt;p[min_child - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (!(min_heap_elem_greater(e, s-&gt;p[min_child])))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">(s-&gt;p[hole_index] = s-&gt;p[min_child])-&gt;ev_timeout_pos.min_heap_idx = hole_index;</span><br><span class="line">hole_index = min_child;</span><br><span class="line">min_child = <span class="number">2</span> * (hole_index + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    (s-&gt;p[hole_index] = e)-&gt;ev_timeout_pos.min_heap_idx = hole_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>找到节点的右子节点 <code>min_child</code></p></li><li><p>如果右节点存在(不应该超过数目上线)</p><ul><li><p>找到左右节点种较大的</p></li><li><p>如果当前超时时间比子节点小则停止</p><blockquote><p>为什么有 <code>min_child == s-&gt;n</code> 的比较操作，感觉没有必要！！因为 <code>while (min_child &lt;= s-&gt;n)</code> 已经判断了</p></blockquote></li><li><p>当前节点为子节点，并更新索引</p></li><li><p>更新当前节点位置</p></li><li><p>找到当前节点的右子节点</p></li></ul></li><li><p>当前位置设置为 e，并更新事件的索引</p></li></ol><h3 id="删除元素"><a class="markdownIt-Anchor" href="#删除元素"></a> 删除元素</h3><p>删除元素常用于事件发生异常，需要从堆中直接删除而不是从堆顶，这个时候就会出现堆空洞的情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_heap_erase_</span><span class="params">(<span class="keyword">min_heap_t</span>* s, struct event* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (EV_SIZE_MAX != e-&gt;ev_timeout_pos.min_heap_idx)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">last</span> = <span class="title">s</span>-&gt;<span class="title">p</span>[--<span class="title">s</span>-&gt;<span class="title">n</span>];</span></span><br><span class="line"><span class="keyword">size_t</span> parent = (e-&gt;ev_timeout_pos.min_heap_idx - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (e-&gt;ev_timeout_pos.min_heap_idx &gt; <span class="number">0</span> &amp;&amp; min_heap_elem_greater(s-&gt;p[parent], last))</span><br><span class="line">min_heap_shift_up_unconditional_(s, e-&gt;ev_timeout_pos.min_heap_idx, last);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">min_heap_shift_down_(s, e-&gt;ev_timeout_pos.min_heap_idx, last);</span><br><span class="line">e-&gt;ev_timeout_pos.min_heap_idx = EV_SIZE_MAX;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果  <code>e-&gt;ev_timeout_pos.min_heap_idx != EV_SIZE_MAX</code> 表示已经不在堆中了，添加和弹出的时候都会更新这个索引</li><li>获取堆尾元素</li><li>获取事件的父节点</li><li>如果事件不在堆顶而且父结点大于最后一个节点<ul><li>向上调整</li></ul></li><li>如果事件在堆顶，类似 <code>min_heap_pop_</code><ul><li>向下调整</li></ul></li></ul><h4 id="向上调整2"><a class="markdownIt-Anchor" href="#向上调整2"></a> 向上调整2</h4><p>这里为了防止空洞，出现了一个不一样的操作 <code>min_heap_shift_up_unconditional_</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">min_heap_shift_up_unconditional_</span><span class="params">(<span class="keyword">min_heap_t</span>* s, <span class="keyword">size_t</span> hole_index, struct event* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> parent = (hole_index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">(s-&gt;p[hole_index] = s-&gt;p[parent])-&gt;ev_timeout_pos.min_heap_idx = hole_index;</span><br><span class="line">hole_index = parent;</span><br><span class="line">parent = (hole_index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (hole_index &amp;&amp; min_heap_elem_greater(s-&gt;p[parent], e));</span><br><span class="line">    (s-&gt;p[hole_index] = e)-&gt;ev_timeout_pos.min_heap_idx = hole_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先找到当前元素的父节点</li><li>将父节点更新到当前位置，并跟新索引</li><li>设置当前位置为父节点，找到父节点的父节点 <code>parent2</code></li><li>如果 <code>parent2</code> 不是堆顶，而且 <code>parent2</code> 大于 last，那么重复 2~3操作（感觉不会，因为是小根堆）</li><li>更新 last 到合适的位置</li></ol><p>也就是说通过 将 last 填补到要删除元素的位置，解决空洞问题。</p><p>问题1：<code>min_heap_shift_up_unconditional_</code> 与 <code>min_heap_shift_up_</code> 不同的是，后者先判断了 当前位置以及 当前位置事件与 e 的大小，为什么要做这个区别？</p><p>答：是因为前者的位置肯定不是堆顶(走乡下条)</p><p>问题2：<code>min_heap_erase_</code> 删除元素中为什么会出现向下调整与向上调整</p><p>答：首先需要明白向上调整与向下调整的作用分别是什么，</p><blockquote><p>向下调整：被用于在删除堆顶元素后，将最后一个元素移到堆顶并逐步将其“下沉”至合适的位置，以保持堆的有序性质。</p><p>向上调整：被用于在向堆中插入新元素后，将其逐步“上浮”至合适的位置，以保持堆的有序性质</p></blockquote><p>如果删除位置不是堆顶元素，且父节点大于 last 。那么根据小根堆的性质，last 应该从这个位置开始向上调整</p><p>如果删除位置是堆顶元素或者父节点小于last。那么根据小根堆的性质，last应该在删除位置的下发（或不变）</p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://www.hello-algo.com/chapter_heap/heap/" target="_blank" rel="noopener">https://www.hello-algo.com/chapter_heap/heap/</a></li><li><a href="https://www.hello-algo.com/chapter_sorting/heap_sort/" target="_blank" rel="noopener">https://www.hello-algo.com/chapter_sorting/heap_sort/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在阅读 libevent 库中另外一个用来存储事件的第二个结构就是小根堆，这里重新学习一下它的实现&lt;/p&gt;
&lt;p&gt;代码路径:&lt;code&gt;minheap-internal.h&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="https://www.yuankang.top/categories/Data-Structure/"/>
    
    
      <category term="Heap" scheme="https://www.yuankang.top/tags/Heap/"/>
    
      <category term="Data Structure" scheme="https://www.yuankang.top/tags/Data-Structure/"/>
    
      <category term="Libevent" scheme="https://www.yuankang.top/tags/Libevent/"/>
    
  </entry>
  
  <entry>
    <title>算法-01-Heap</title>
    <link href="https://www.yuankang.top/2023/09/29/Algorithm/%E7%AE%97%E6%B3%95-01-Heap/"/>
    <id>https://www.yuankang.top/2023/09/29/Algorithm/%E7%AE%97%E6%B3%95-01-Heap/</id>
    <published>2023-09-28T16:15:00.000Z</published>
    <updated>2023-09-28T16:21:25.689Z</updated>
    
    <content type="html"><![CDATA[<p>堆(Heap)是具有以下性质的<strong>完全二叉树</strong></p><ul><li><p>每个结点的值都<strong>大于或等于其左右孩子</strong>结点的值，称为<strong>大顶堆</strong></p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2023-09-28_22-16-36.png" alt="Snipaste_2023-09-28_22-16-36" /></p></li><li><p>每个结点的值都<strong>小于或等于其左右孩子</strong>结点的值，称为<strong>小顶堆</strong></p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2023-09-28_22-17-26.png" alt="Snipaste_2023-09-28_22-17-26" /></p></li></ul><p><strong>完全二叉树</strong>：除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列</p><p>**问题 **：那左右子节点有谁大谁小？<strong>没有要求！！！</strong></p><p>大根堆，每个子结点都要小于父结点，不区分左右儿子谁大谁小，<strong>也不必保证某个 孙子结点 一定要小于另一个 儿子结点</strong><br />小根堆，每个子结点都要大于父结点，不区分左右儿子谁大谁小，**也不必保证某个 孙子结点 一定要大于另一个 儿子结点 **</p><p>也就是说，<strong>即使组成了 大小根堆，它们的排列还不是有序的</strong>，只是保证</p><p><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong></p><p><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong></p><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>首先明白两个概念：<strong>向下调整</strong> 与 <strong>向上调整</strong></p><p><strong>向下调整</strong>：指的是为了满足堆的性质而向下不断比较调整父子节点的关系，一般用于堆删除一个元素</p><ul><li>从堆的根节点开始(通常是数组的第一个元素)，比较当前节点与其子节点的值。</li><li>如果当前节点的值小于其子节点中的一个或多个节点的值，那么将当前节点与最大的子节点进行交换，以满足大顶堆的性质。</li><li>重复上述步骤，直到节点没有子节点或者节点的值大于等于其子节点的值</li></ul><p>这里删除堆顶元素之后还向下调整的原因是，会将最后一个元素放置到堆顶</p><p><strong>向上调整</strong>：指的是为了满足堆的性质而向上不断比较调整父子节点的关系，一般用于堆插入一个元素</p><ul><li>在堆的最后一个位置(通常是数组的最后一个元素)插入新元素。</li><li>比较新插入的元素与其父节点的值。</li><li>如果新元素的值大于其父节点的值（对于大顶堆），则交换新元素与父节点，以满足堆性质。</li><li>重复上述步骤，直到新元素的值小于等于其父节点的值或者新元素已经成为根节点</li></ul><p>实际应用中还有一种情况，比如需要从堆中直接删除一个元素(元素已经失效，需要释放该元素重新调整<strong>小根堆</strong>的结构)，此时会出现一个<strong>空洞</strong></p><ul><li>将最后一个元素 last 放到被删除的位置</li><li>如果删除位置不是堆顶元素，且父节点大于 last 。那么根据小根堆的性质，last 应该从这个位置开始向上调整</li><li>如果删除位置是堆顶元素或者父节点小于last。那么根据小根堆的性质，last应该在删除位置的下发(或不变)</li></ul><p>所以上面其实就是堆的插入和删除过程了，原理就是只在头尾处理，然后进行向上或者向下调整，保证大根堆、小根堆的性质</p><p><strong>问题 1</strong>：为什么不在删除对顶元素之后，直接将第二大元素放到堆顶呢？</p><p>答：这样的后出现空洞的情况，就需要进一步处理</p><img src="https://static001.geekbang.org/resource/image/59/81/5916121b08da6fc0636edf1fc24b5a81.jpg?wh=1142*867" alt="img" style="zoom:50%;" /><p>所以，这里改变思路：将最后一个节点与堆顶交换，然后删除最后一个元素，最后利用同样的父子节点对比方法。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。这就是<strong>从上往下</strong>的堆化方法</p><img src="https://static001.geekbang.org/resource/image/11/60/110d6f442e718f86d2a1d16095513260.jpg?wh=1142*856" alt="img" style="zoom:50%;" /><p><strong>问题 2</strong>：知道了插入和删除，它首要条件是有一个堆，所以堆从哪里来</p><p>答：方案有两种</p><ul><li>从前往后，尽管数组中包含 n 个数据，假设起初堆中只包含一个数据，就是下标为 0 的数据。然后不断的插入将下标从 1 到 n - 1 的数据依次插入到堆中。每插入一个元素都向上调整到合适位置</li><li>从后往前，依次与子节点进行比较，因为叶子节点无法与子节点比较，所以就需要从最后一个非叶子节点比较。每次都向下调整到合适的位置</li></ul><p><strong>问题 3</strong>：最后一个非叶子节点如何表示</p><p>答：假设最后一个非叶子节点下表是 i (<strong>i 从 0 开始</strong>)</p><ul><li>如果它的左子节点是最后一个节点，那么最后一个节点下标就是 <code>2i + 1</code>。整个二叉树的长度就是 <code>len = 2i + 2</code></li><li>如果他的右子节点是最后一个节点，那么最后一个节点下标就是 <code>2i + 2</code>。整个二叉树的长度就是 <code>len = 2i + 3</code></li><li>所以最后一个非叶子节点的下标就是 <code>i = len / 2 - 1</code></li></ul><p><strong>问题 4</strong>：建堆的过程有两种，哪种更好</p><p>答：第二种方式可以节省一半的时间</p><ul><li>第一种方式需要对<code>n-1</code>个节点进行堆化，每个节点堆化的时间复杂度为 <code>O(logn)</code>，所以它精确的时间复杂度为<code>(n-1)*O(logn)</code></li><li>第二种方式从非叶子节点开始，需要对 <code>n/2</code>个节点进行堆化，精确的时间复杂度为<code>(n/2)*O(logn)</code></li></ul><p><strong>问题 5</strong>：既然不关心左右节点大小，那样怎么样做到整个有序呢？</p><p>答：就像删除堆顶元素一样。当堆顶元素移除之后，把下标为 n 的元素放到堆顶，然后向下调整，让剩下的 n−1 个元素重新构建成堆。堆化完成之后，再取堆顶的元素，放到下标是 n−1 的位置，一直重复这个过程，直到最后堆中只剩下标为 1 的一个元素，排序工作就完成了。</p><img src="https://static001.geekbang.org/resource/image/23/d1/23958f889ca48dbb8373f521708408d1.jpg?wh=1142*790" alt="img" style="zoom:50%;" /><p>一个包含 n 个节点的完全二叉树，树的高度不会超过 <code>log2n</code>，堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 <code>O(logn)</code>。</p><p>插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 <code>O(logn)</code></p><p>因为每个元素都需要进行删除的过程，所以堆排序整体的时间复杂度为 <code>O(nlogn)</code></p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//heapAdjust 作用从上往下构建，保证数组 a[] 中 第low个元素为堆顶的元素构成的结构为大顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapAdjust</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span><span class="comment">//调整的过程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pivotKey = a[low - <span class="number">1</span>];<span class="comment">//注意数组的索引从0开始</span></span><br><span class="line">  <span class="keyword">int</span> i;                        <span class="comment">//当前节点下标</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">2</span> * low; i &lt;= high; i *= <span class="number">2</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; high &amp;&amp; a[i - <span class="number">1</span>] &lt; a[i])<span class="comment">//找到左右子节点中较大的那个</span></span><br><span class="line">    &#123;</span><br><span class="line">      i++; <span class="comment">//i指向较大值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pivotKey &gt;= a[i - <span class="number">1</span>])<span class="comment">//如果大于等于子节点说明已经是大顶堆</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    a[low - <span class="number">1</span>] = a[i - <span class="number">1</span>];<span class="comment">//否则将子节点更换到父节点的位置</span></span><br><span class="line">    low = i;                <span class="comment">//然后继续判断子节点与孙子节点的大小,保证子节点与起构成的子节点也是大堆顶</span></span><br><span class="line">  &#125;</span><br><span class="line">  a[low - <span class="number">1</span>] = pivotKey;    <span class="comment">//将最开始的堆顶放到合适的位置</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, tmp;</span><br><span class="line">  <span class="comment">//堆化</span></span><br><span class="line">  <span class="keyword">for</span>(i = n/<span class="number">2</span>; i &gt; <span class="number">0</span>; i--) <span class="comment">//从非叶子节点开始，开始调整(最后一个非叶子节点是 len/2 - 1)</span></span><br><span class="line">  &#123;</span><br><span class="line">    heapAdjust(a, i, n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = n; i &gt; <span class="number">1</span>; i--)<span class="comment">//将堆顶元素放置最后，开始调整</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//调整最后一个元素于第一个元素的位置</span></span><br><span class="line">    tmp = a[i <span class="number">-1</span>];</span><br><span class="line">    a[i - <span class="number">1</span>] = a[<span class="number">0</span>];</span><br><span class="line">    a[<span class="number">0</span>] = tmp;</span><br><span class="line">    <span class="comment">//向下调整</span></span><br><span class="line">    heapAdjust(a, <span class="number">1</span>, i - <span class="number">1</span>); </span><br><span class="line">    <span class="built_in">print</span>(a, n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[] = &#123;<span class="number">30</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">60</span>, <span class="number">80</span>, <span class="number">70</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);  <span class="comment">//计算数组长度</span></span><br><span class="line">  heapSort(a, n);</span><br><span class="line">  <span class="built_in">print</span>(a, n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序应用"><a class="markdownIt-Anchor" href="#堆排序应用"></a> 堆排序应用</h3><ol><li><p>Top K问题</p><p>从堆的定义来说，很容易想到堆顶元素是TOP 1，那么如何求经典的TOP K问题?</p><p>如果求最大的Top K 元素，是建立大顶堆，还是小顶堆</p><ol><li>如果用大顶堆，堆顶是最大的元素，新加入的元素必须和所有的堆中元素做比对，显然不够划算；</li><li>如果用小顶堆，那堆顶元素是最小的元素，新加入的元素只要和堆顶元素做对比，如果比堆顶元素大，就可以把堆顶的元素删除，将新加入的元素加入到堆中</li></ol><p>每次求TopK的问题的时候，只需要直接返回堆中所有元素即可，每次堆化的算法复杂度为O(logK),那么N个元素堆化的时间为O(nlogK),如果不用堆，每次新增元素都要重新排序，再取前面N个</p></li><li><p>定时器应用</p><p>独立线程，以超时时间建立了一个小顶堆，如果堆顶元素为2分钟，清理连接的线程的休眠时间设置为2分钟，2分钟后取堆顶元素，执行连接关闭操作。</p></li><li><p><strong>求中位数和99%的响应时间</strong></p><p>动态数组取中位数：</p><ul><li>如果n为偶数，前n/2数据存储在大顶堆中，n/2存储小顶堆中，则大顶堆的堆顶元素为要找的中位数</li><li>如果n为奇数，可以将前n/2+1个数据存储在大顶堆中，后n/2存储在小顶堆中</li></ul><p>如果添加新数据，则将数据与大顶堆中的堆顶元素比较</p><ul><li>如果小于等于大顶堆中的元素，就插入到大顶堆中</li><li>如果比大顶堆的堆顶大，那就插入到小顶堆中</li><li>如果插入数据后不满足要求两个堆的数量为n/2和n/2 或n/2 和n+1/2 的要求，需要调整两个堆的大小，从大顶堆中删除堆顶元素，或小顶堆中删除堆顶元素，移动到另外一个堆中即可。</li></ul><blockquote><p>99%的响应时间：如果一个接口的有100个访问请求，分别耗时1ms，2ms，3ms…100ms，那么按照访问时间从小到大排列，排在第99位的访问时间，就是99%的访问时间，我们维护两个堆，大顶堆的元素个数为n * 99%，小顶堆的元素个数为n*1%，那么大顶堆中的堆顶元素即是所求的99%的响应时间，和中位数的应用一样，只是中位数中的应用更特殊一点</p></blockquote></li><li><p>优先级队列</p><p>优先级队列和通常的栈和队列一样，只不过里面的每一个元素都有一个&quot;优先级”，在处理的时候，首先处理优先级最高的。如果两个元素具有相同的优先级，则按照他们插入到队列中的先后顺序处理</p></li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6129630.html</a></li><li><a href="https://mp.weixin.qq.com/s/OqpSdFfK12NhPpcsXTMvtA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/OqpSdFfK12NhPpcsXTMvtA</a></li><li><a href="https://blog.csdn.net/weixin_45728685/article/details/105115912" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45728685/article/details/105115912</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;堆(Heap)是具有以下性质的&lt;strong&gt;完全二叉树&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个结点的值都&lt;strong&gt;大于或等于其左右孩子&lt;/strong&gt;结点的值，称为&lt;strong&gt;大顶堆&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;htt
      
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://www.yuankang.top/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="https://www.yuankang.top/tags/Algorithms/"/>
    
      <category term="Heap" scheme="https://www.yuankang.top/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-01-List</title>
    <link href="https://www.yuankang.top/2023/09/18/Data%20Structure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-01-List/"/>
    <id>https://www.yuankang.top/2023/09/18/Data%20Structure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-01-List/</id>
    <published>2023-09-18T14:58:29.000Z</published>
    <updated>2023-09-28T16:22:28.149Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读 Libevent 库的时候看到 <code>TAILQ_ENTRY</code>的宏定义有点特别，这里记录一下，代码路径 <code>libevent/compat/sys/queue.h</code></p><p>首先它实现的类似泛型的功能</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_ENTRY(type)\</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">tqe_next</span>;</span><span class="comment">/* next element */</span>\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type</span> **<span class="title">tqe_prev</span>;</span><span class="comment">/* address of previous next element */</span>\</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !TAILQ_ENTRY */</span></span></span><br></pre></td></tr></table></figure><blockquote><p>C11 中还能通过 _Generic关键字 实现泛型编程</p></blockquote><p>但是有一个奇怪的地方，<code>tqe_prev</code> 为什么是指针的指针，这里可能跟平时的好像不太一样?</p><p>平时定义的双向链表节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个结构体，表示链表中的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span> <span class="comment">// 后一个节点的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">prev</span>;</span> <span class="comment">// 前一个节点的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由它构建的双向链表结构</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="双向链表" /></p><p>删除节点的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在链表中删除指定值的节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(struct Node** head, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">current</span> = *<span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到要删除的节点</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;data != target) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果节点存在，则删除它</span></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;prev != <span class="literal">NULL</span>) &#123;<span class="comment">//头节点不用调整 prev 指向</span></span><br><span class="line">            current-&gt;prev-&gt;next = current-&gt;next;<span class="comment">//前一个节点的 next 指向下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;next != <span class="literal">NULL</span>) &#123;<span class="comment">//尾节点不用调整 next 指向</span></span><br><span class="line">            current-&gt;next-&gt;prev = current-&gt;prev;<span class="comment">//下一个节点的前一个节点指向当前的前一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而平时定义的单向链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span><span class="comment">//指向下一个节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由它构建的单向链表</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/%E5%8D%95%E9%93%BE%E8%A1%A8.png" alt="单链表" /></p><p>而单链表的删除操作是这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在链表中删除指定值的节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(struct Node** head, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">current</span> = *<span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到要删除的节点</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;data != target) &#123;</span><br><span class="line">        prev = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果节点存在，则删除它</span></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 要删除的节点是头节点</span></span><br><span class="line">            *head = current-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev-&gt;next = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是我又去看了 linux 内核中的链表结构，发现了它的使用</p><p>代码路径：<code>libevent/compat/sys/queue.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">first</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">next</span>, **<span class="title">pprev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它在定义双向链表的同时，还定义了一个<code>hlist_node</code>用于 hash 表的桶链表，头节点使用 <code>hlist_head</code>表示。它的删除操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __hlist_del(struct hlist_node *n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">next</span> = <span class="title">n</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> **<span class="title">pprev</span> = <span class="title">n</span>-&gt;<span class="title">pprev</span>;</span></span><br><span class="line"></span><br><span class="line">WRITE_ONCE(*pprev, next);</span><br><span class="line"><span class="keyword">if</span> (next)</span><br><span class="line">WRITE_ONCE(next-&gt;pprev, pprev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>WRITE_ONCE</code>的宏是 Linux 内核中用于确保写入操作是原子的宏，也就是说 <code>WRITE_ONCE(*pprev, next);</code> 相当于原子操作 <code>*pprev = next</code>, 那么这个双向链表的结构是</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%202.png" alt="双向链表 2" /></p><p>跟自己定义的区别就是将 <code>prev</code> 的指针指向的是前一个节点的 <code>next</code> 指针，为什么这样做其实从删除操作可以看出来，<strong>不需要额外判断是否是头节点与尾节点</strong></p><p>回到刚才的宏定义，有个双向链表节点，看它是如何完整的实现双向链表的</p><p>首先是初始化一个头部节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_list</span> <span class="title">events</span>;</span></span><br><span class="line">TAILQ_INIT(&amp;events);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TAILQ_INIT(head) do &#123;\</span></span><br><span class="line">(head)-&gt;tqh_first = <span class="literal">NULL</span>;\</span><br><span class="line">(head)-&gt;tqh_last = &amp;(head)-&gt;tqh_first;\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="comment">/*CONSTCOND*/</span><span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>也就是说 <code>head</code> 是一个包含 <code>tqh_first</code> 与 <code>tqh_last</code> 的节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TAILQ_HEAD (event_list, event);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_HEAD(name, type)\</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span>\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">tqh_first</span>;</span>\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type</span> **<span class="title">tqh_last</span>;</span>\</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">TAILQ_ENTRY(event)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_ENTRY(type)\</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">tqe_next</span>;</span><span class="comment">/* next element */</span>\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type</span> **<span class="title">tqe_prev</span>;</span><span class="comment">/* address of previous next element */</span>\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TAILQ_HEAD</code> 定义了一个名字为 <code>event_list</code> 的双向链表，记录了第一个节点与最后一个节点</p><p>它的删除操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_REMOVE(head, elm, field) do &#123;\</span></span><br><span class="line"><span class="keyword">if</span> (((elm)-&gt;field.tqe_next) != <span class="literal">NULL</span>)\</span><br><span class="line">(elm)-&gt;field.tqe_next-&gt;field.tqe_prev =\</span><br><span class="line">    (elm)-&gt;field.tqe_prev;\</span><br><span class="line"><span class="keyword">else</span>\</span><br><span class="line">(head)-&gt;tqh_last = (elm)-&gt;field.tqe_prev;\</span><br><span class="line">*(elm)-&gt;field.tqe_prev = (elm)-&gt;field.tqe_next;\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>其中 <code>(elm)-&gt;field</code> 表示的是 <code>elm 指针</code>的成员字段 <code>field</code></p><p>而 <code>(elm)-&gt;field.tqe_next-&gt;field.tqe_prev = (elm)-&gt;field.tqe_prev;</code> 与上面的 WRITE_ONCE(next-&gt;pprev, pprev); 效果一样</p><p>那么 <code>*(elm)-&gt;field.tqe_prev = (elm)-&gt;field.tqe_next;</code> 理解为 <code>WRITE_ONCE(*pprev, next);</code>，所以这里的 <code>*(elm)</code> 而不是 <code>elm</code></p><p>这里不同的是，头节点记录的链表的头节点与尾节点，所以它的结构是</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%203.png" alt="双向链表 3" /></p><p>这样的好处是 <strong>可以同时在双向链表的头尾都进行增删操作，变成了一个双向队列</strong>，那为什么 linux 中的 hash 表没有弄成一个双向队列，因为新增的值直接加入到链表头，不需要头尾都都操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在阅读 Libevent 库的时候看到 &lt;code&gt;TAILQ_ENTRY&lt;/code&gt;的宏定义有点特别，这里记录一下，代码路径 &lt;code&gt;libevent/compat/sys/queue.h&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;首先它实现的类似泛型的功能&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="https://www.yuankang.top/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="https://www.yuankang.top/tags/Data-Structure/"/>
    
      <category term="List" scheme="https://www.yuankang.top/tags/List/"/>
    
      <category term="Libevent" scheme="https://www.yuankang.top/tags/Libevent/"/>
    
  </entry>
  
  <entry>
    <title>Protocol-04-DHCP</title>
    <link href="https://www.yuankang.top/2023/09/07/Protocol/Protocol-04-DHCP/"/>
    <id>https://www.yuankang.top/2023/09/07/Protocol/Protocol-04-DHCP/</id>
    <published>2023-09-07T02:25:38.000Z</published>
    <updated>2023-09-08T15:38:23.323Z</updated>
    
    <content type="html"><![CDATA[<p>动态主机配置协议<code>DHCP</code>(Dynamic Host Configuration Protocol) 是一种网络管理协议，用于集中对用户 IP 地址进行动态管理和配置。<br /><strong>DHCP协议</strong>由 <code>RFC 2131</code> 定义，采用 Client /服务器通信模式，由 <strong>客户端(DHCP Client)</strong> 向 **服务器(DHCP Server)**提出配置申请，<strong>Server</strong>为网络上的每个设备动态分配 <strong>IP 地址</strong>、<strong>子网掩码</strong>、<strong>默认网关地址</strong>，<strong>域名服务器(DNS)地址</strong>等参数</p><p>相关协议(按时间从远到近排序) <a href="http://www.ietf.org/rfc/rfc1531.txt" target="_blank" rel="noopener">RFC1531</a> 、<a href="http://www.ietf.org/rfc/rfc1541.txt" target="_blank" rel="noopener">RFC1541</a>、<a href="http://www.ietf.org/rfc/rfc2131.txt" target="_blank" rel="noopener">RFC2131</a> 、<a href="http://www.ietf.org/rfc/rfc3396.txt" target="_blank" rel="noopener">RFC3396</a></p><h3 id="dhcp好处"><a class="markdownIt-Anchor" href="#dhcp好处"></a> DHCP好处</h3><p>网络中，每个连接Internet的设备都需要分配唯一的 IP。DHCP 使网络管理员能<strong>从中心结点监控和分配IP地址</strong>，从以下几个方面降低了配置和部署设备的时间</p><ul><li>减少 IP 地址冲突：每个连接的设备都必须有一个IP地址。但是，每个地址只能使用一次，重复的地址将导致无法连接一个或两个设备的冲突。</li><li>IP地址管理的自动化：如果没有 DHCP，网络管理员将需要手动分配和撤消地址。手动需要随时知道设备何时需要访问网络以及何时需要离开网络。</li><li>高效的变更管理：<strong>DHCP 的使用使更改地址，范围或端点变得非常简单</strong>。例如，组织可能希望将其IP寻址方案从一个范围更改为另一个范围。Server配置有新信息，该信息将传播到新端点。同样，如果升级并更换了网络设备，则不需要网络配置</li></ul><h3 id="dhcp-工作原理"><a class="markdownIt-Anchor" href="#dhcp-工作原理"></a> DHCP 工作原理</h3><p>DHCP 协议采用 <strong>UDP</strong> 作为传输协议，<strong>Client</strong> 发送请求消息到 <strong>Server</strong> 的 <strong>Port 67</strong>，<strong>Server</strong> 回应应答消息给 <strong>Client</strong> 的 <strong>Port 68</strong>，只有跟 Client 在同一个网段的 Server 才能收到 Client 广播的 <strong>DISCOVER报文</strong>。当 Client 与 Server 不在同一个网段时，必须部署DHCP中继来转发 Client 和Server之间的DHCP报文</p><h4 id="非中继"><a class="markdownIt-Anchor" href="#非中继"></a> 非中继</h4><p>在没有部署 <strong>DHCP中继</strong> 的场景下，首次接入网络 Client 与 Server 的报文交互过程，该过程称为<strong>DHCP报文四步交互</strong></p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/download.png" alt="无中继场景时 Client 首次接入网络的报文交互示意图" /></p><p><strong>第一步：发现阶段</strong></p><p>首次接入网络的 Client 不知道 Server 的IP地址，为了学习到 Server 的IP地址，Client 以广播方式发送<strong>DISCOVER报文</strong>(目的IP地址为255.255.255.255)给同一网段内的所有设备(包括Server或中继)。<strong>DISCOVER报文</strong>中携带了 Client 的MAC地址等信息</p><p><strong>第二步：提供阶段</strong></p><p>与 Client 位于同一网段的 Server 都会接收到 <strong>DISCOVER报文</strong>，Server 选择跟接收 <strong>DISCOVER报文</strong>接口的IP地址处于同一网段的地址池，并且从中选择一个可用的IP地址，然后通过<strong>OFFER报文</strong>发送给Client，Server 在地址池中为 Client 分配IP地址的顺序如下：</p><ol><li>Server 上已配置的与 Client MAC地址静态绑定的 IP 地址。</li><li>Client 发送的 <strong>DISCOVER报文</strong>中 <code>Option50</code>(请求IP地址选项)指定的地址</li><li>地址池内查找 <code>Expired</code> 状态的IP地址，即曾经分配给 Client 的超过租期的IP地址</li><li>在地址池内随机查找一个 <code>Idle</code> 状态的IP地址。</li><li>如果未找到可供分配的 IP 地址，则地址池依次自动回收超过租期的 <code>Expired</code> 和处于冲突状态 <code>Conflict</code> 的IP地址。回收后如果找到可用的IP地址，则进行分配；否则，Client 等待应答超时后，重新发送<strong>DHCP DISCOVER报文</strong>来申请IP地址</li></ol><p>通常，<strong>Server</strong> 的地址池中会指定IP地址的租期，如果 <strong>Client</strong> 发送的 <strong>DISCOVER报文</strong> 中携带了期望租期，服务器会将 Client 请求的<strong>期望租期</strong>与其<strong>指定的租期</strong>进行比较，选择其中时间<strong>较短的租期</strong></p><p>为了防止分配出去的IP地址跟网络中其他 Client 的IP地址冲突，比如Client所在网段已经手工配置了一个地址池中的地址用于DNS服务器，Server 在发送<strong>DHCP OFFER报文</strong>前通过发送 Source IP = ServerIP地址、Target IP 为预分配出去IP地址的 <strong>ICMP ECHO REQUEST报文</strong> 对分配的IP地址进行地址冲突探测。</p><ul><li>如果在指定的时间内没有收到应答报文，表示网络中没有 Client 使用这个IP地址，可以分配给 Client ；</li><li>如果指定时间内收到应答报文，表示网络中已经存在使用此IP地址的 Client ，则把此地址列为冲突地址，然后等待重新接收到DHCP DISCOVER报文后重新选择（TODO 这个时间会不会很长，为什么不直接找一个IP地址分配）</li></ul><p>此阶段 Server 分配给 Client 的IP地址不一定是最终确定使用的IP地址，因为<strong>DHCP OFFER报文</strong>发送给 Client 等待<strong>16秒</strong> 后如果没有收到 Client 的响应，此地址就可以继续分配给其他 Client 。</p><p><strong>第三步：选择阶段</strong></p><p>在发现阶段 <code>DISCOVER报文</code> 是广播报文，也就是说有可能有多个 Server 向 Client 回应 <strong>DHCP OFFER报文</strong>，则 Client 一般只接收第一个收到的 DHCP OFFER报文，然后以<strong>广播方式</strong>发送 DHCP REQUEST报文，该报文中包含 Client 想选择的 Server标识符(即Option50，填充了接收的DHCP OFFER报文中<strong>yiaddr字段</strong>的IP地址)</p><p>Client 广播发送 DHCP REQUEST报文通知所有的Server，它将选择某个Server提供的IP地址，其他Server可以重新将曾经分配给 Client 的IP地址分配给其他 Client 。</p><blockquote><p>Server怎么判断这个报文是来请求自己分配出去的IP，还是 Client 用来告诉  Server 不用这个地址（两个DHCP 服务器分配的IP地址可能还都一样，不能通过IP判断是否是自己给的）？</p></blockquote><p><strong>第四步：确认阶段</strong></p><p>当Server收到 Client 发送的<strong>DHCP REQUEST报文</strong>后，Server回应 <strong>DHCP ACK报文</strong>，表示 <strong>DHCP REQUEST报文</strong> 中请求的IP地址(Option50 填充的)分配给 Client 使用。</p><ol><li><p>Client 收到 <strong>DHCP ACK报文</strong>，会广播发送免费<strong>ARP报文</strong>，探测本网段是否有其他终端使用服务器分配的IP地址</p><ul><li><p>如果在指定时间内没有收到回应，表示 Client 可以使用此地址。</p></li><li><p>如果收到了回应，说明有其他终端使用了此地址， Client 会向服务器发送 <strong>DHCP DECLINE报文</strong>，并重新向服务器请求IP地址，同时，服务器会将此地址列为<strong>冲突地址</strong>。当服务器没有空闲地址可分配时，再选择冲突地址进行分配，尽量减少分配出去的地址冲突</p><blockquote><p>DECLINE 是广播报文吗， 如果发送失败或者  Server无法分配其他地址呢？</p></blockquote></li></ul></li><li><p>当 Server 收到 Client 发送的 <strong>DHCP REQUEST报文</strong> 后，如果Client 由于某些原因（例如协商出错或者由于发送REQUEST过慢导致服务器已经把此地址分配给其他 Client )无法分配 <strong>DHCP REQUEST报文</strong>中 <code>Option50</code> 填充的IP地址，则发送<strong>DHCP NAK报文</strong>作为应答，通知 Client 无法分配此IP地址。** Client 需要重新发送DHCP DISCOVER报文来申请新的IP地址**</p></li></ol><h4 id="中继"><a class="markdownIt-Anchor" href="#中继"></a> 中继</h4><p>有DHCP中继的场景中，首次接入网络的 Client 和Server的工作原理与<strong>无中继场景时 Client 首次接入网络的工作原理</strong>相同。主要差异是DHCP中继在Server和 Client 之间转发DHCP报文，以保证Server和 Client 可以正常交互。在 Client 看来，DHCP中继就像Server；在Server看来，DHCP中继就像 Client</p><p>如下图所示，在部署DHCP中继的场景下，首次接入网络 Client 与Server的报文交互过程</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/download-20230907220000104.png" alt="有中继场景时 Client 首次接入网络的报文交互示意图" /></p><p><strong>第一步：发现阶段</strong></p><p>DHCP中继接收到 Client 广播发送的 DHCP DISCOVER报文后，进行如下处理：</p><ol><li><p>检查DHCP报文中的<code>hops</code>字段，<strong>如果大于16，则丢弃DHCP报</strong>文；否则，将<code>hops</code>字段加1(表明经过一次DHCP中继)，并继续下面的操作。</p></li><li><p>检查DHCP报文中的<code>giaddr</code>字段。如果是0，将<code>giaddr</code>字段设置为接收DHCP DISCOVER报文的接口IP地址。如果不是0，则不修改该字段，继续下面的操作。</p><blockquote><p>记录 <code>giaddr</code> 的目的就是在 DHCP 地址池中分配相同网段的 IP 地址</p></blockquote></li><li><p>将DHCP报文的目的IP地址改为<strong>Server或下一跳中继的IP地址</strong>，<strong>源地址改为中继连接 Client 的接口地址</strong>，通过路由转发将DHCP报文<strong>单播</strong>发送到Server或下一跳中继</p></li></ol><p>如果 Client 与Server之间存在多个DHCP中继，后面的中继接收到DHCP DISCOVER报文的处理流程同前面所述</p><p><strong>第二步：提供阶段</strong></p><p>Server接收到DHCP DISCOVER报文后，<strong>选择与报文中<code>giaddr</code>字段为同一网段的地址池</strong>，并为 Client 分配IP地址等参数，然后向<code>giaddr</code>字段标识的DHCP中继单播发送DHCP OFFER报文。</p><p>DHCP中继收到DHCP OFFER报文后，会进行如下处理：</p><ol><li><p>检查报文中的<code>giaddr</code>字段，<strong>如果不是接口的地址，则丢弃该报文</strong>；否则，继续下面的操作。</p><blockquote><p>DHCP 服务器怎么知道是不是中继过来的？通过 hops 吗？</p></blockquote></li><li><p>DHCP中继检查报文的<strong>广播标志位</strong>。如果广播标志位为1，则将DHCP OFFER报文广播发送给 Client ；否则将DHCP OFFER报文单播发送给 Client 。</p><blockquote><p>广播标志位是什么时候设置的？</p><p>为什么 DHCP OFFER 需要官博发送给 DHCP  Client</p></blockquote></li></ol><p><strong>第三步：选择阶段</strong></p><p>中继接收到来自 Client 的DHCP REQUEST报文的处理过程同无中继场景下的选择阶段。</p><p><strong>第四步：确认阶段</strong></p><p>中继接收到来自服务器的DHCP ACK报文的处理过程同无中继场景下的确认阶段。</p><h4 id="续租"><a class="markdownIt-Anchor" href="#续租"></a> 续租</h4><p>DHCP提供了两种地址分配机制，可以根据网络需求为不同的主机选择不同的分配策略。</p><ul><li>动态分配机制：通过DHCP为主机分配一个有使用期限的IP地址</li><li>静态分配机制：网络管理员通过DHCP为指定的主机分配固定的IP地址。</li></ul><p>Client 向 Server 申请地址时可以携带期望租期，将分配租期与期望租期比较，**分配其中一个较短的租期给 Client **。租期到期或者 Client 下线释放地址后，服务器会收回该IP地址，收回的IP地址可以继续分配给其他 Client 使用。这种机制可以提高IP地址的利用率，避免 Client 下线后IP地址继续被占用。如果 Client 希望继续使用该地址，需要更新IP地址的租期(如延长IP地址租期)，更新租期过程如下</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/download-20230907220722271.png" alt=" Client 更新租期示意图" /></p><ol><li>当租期达到<strong>50%(T1)<strong>时，Client 会自动以</strong>单播</strong>的方式向 Server 发送 <strong>DHCP REQUEST报文</strong>，请求更新IP地址租期<ul><li>如果收到 Server 回应的 <strong>DHCP ACK报文</strong>，则租期更新成功(即租期从0开始计算)；</li><li>如果收到 <strong>DHCP NAK报文</strong>，则重新发送 <strong>DHCP DISCOVER报文</strong>请求新的IP地址。</li></ul></li><li>当租期达到<strong>87.5%(T2)<strong>时，如果仍未收到Server的应答，Client 会自动以</strong>广播</strong>的方式向 Server 发送 <strong>DHCP REQUEST报文</strong>，请求更新IP地址租期。后续处理逻辑同上</li><li>如果租期时间到时都没有收到服务器的回应， Client 停止使用此IP地址，重新发送DHCP DISCOVER报文请求新的IP地址。</li></ol><p>Client 在租期时间到之前，如果不想使用分配的IP地址(例如 Client 网络位置需要变更)，会触发 Client 向 Server 发送 <strong>DHCP RELEASE报文</strong>，通知 Server 释放IP地址的租期。Server 会保留这个 Client 的配置信息，将IP地址列为曾经分配过的IP地址中，以便后续重新分配给该 Client 或其他 Client 。 Client 可以通过发送 <strong>DHCP INFORM报文</strong>向服务器请求更新配置信息</p><p>部署DHCP中继时，更新租期的过程与上述过程相似。</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/download-20230907220805159.png" alt=" Client 通过DHCP中继更新租期示意图" /></p><p>**如果不是首次呢，比如客户端重启了 ？**如果客户端重启后，会自动发送 <strong>DHCP REQUEST广播</strong> 给 Server 以便请求继续租用原来使用的IP地址，</p><ul><li>如果服务器收到这个消息，确认客户端可以使用该地址，则回答一个<strong>DHCP ACK</strong>确认消息</li><li>如果此IP地址已经无法再分配，则返回一个 <strong>DHCP NCK</strong>否认信息，客户端收到这个信息以后，则必须重新发送 DHCP Discovery消息获取新的地址(启动首次登录的流程)。 <strong>若没有得到响应，则尝试与网关通信，如果通信正常，这个租期还没到期的话，则可以继续使用，但是不能和网关通信的话，则会获得169.254.0.1~169.254.255.254之间的IP地址，然后每隔5min尝试更新租约</strong></li></ul><h3 id="dhcp-报文"><a class="markdownIt-Anchor" href="#dhcp-报文"></a> DHCP 报文</h3><p>Server 与 Client 之间通过DHCP报文进行通信。DHCP报文是基于UDP协议传输的。Client 使用的端口号为68，Server 使用的端口号为67。目前DHCP定义了如下八种类型报文，<strong>每种报文的格式相同，只是某些字段的取值不同</strong></p><table><thead><tr><th>报文名称</th><th>说明</th></tr></thead><tbody><tr><td>DHCP DISCOVER</td><td>Client 首次登录网络时进行DHCP交互过程发送的第一个报文，用来寻找Server。</td></tr><tr><td>DHCP OFFER</td><td>Server用来响应<strong>DHCP DISCOVER报文</strong>，此报文携带了各种配置信息。</td></tr><tr><td>DHCP REQUEST</td><td>此报文用于以下三种用途。<br />1.  Client 初始化后，发送广播的 <strong>DHCP REQUEST报文</strong>来回应服务器的<strong>DHCP OFFER报文</strong>。<br />2.  Client 重启后，发送广播的 <strong>DHCP REQUEST报文</strong>来确认先前被分配的IP地址等配置信息。<br />3. 当 Client 已经和某个IP地址绑定后，发送 <strong>DHCP REQUEST单播或广播报文</strong>来更新IP地址的租约。</td></tr><tr><td>DHCP ACK</td><td>Server 对 Client 的<strong>DHCP REQUEST报文</strong>的确认响应报文，Client收到此报文后，才真正获得了IP地址和相关的配置信息。</td></tr><tr><td>DHCP NAK</td><td>服务器对Client 的<strong>DHCP REQUEST报文</strong>的拒绝响应报文，例如Server收到DHCP REQUEST报文后，没有找到相应的租约记录，则发送DHCP NAK 报文作为应答，告知 Client 无法分配合适IP地址。</td></tr><tr><td>DHCP DECLINE</td><td>当 Client 发现服务器分配给它的IP地址发生冲突时会通过发送此报文来通知服务器，并且会重新向服务器申请地址。</td></tr><tr><td>DHCP RELEASE</td><td>Client 可通过发送此报文主动释放服务器分配给它的IP地址，当服务器收到此报文后，可将这个IP地址分配给其它的 Client 。</td></tr><tr><td>DHCP INFORM</td><td>Client 获取IP地址后，如果需要向Server获取更为详细的配置信息(网关地址、DNS服务器地址)，则向Server发送DHCP INFORM请求报文。</td></tr></tbody></table><p>报文地址：<a href="https://wiki.wireshark.org/uploads/" target="_blank" rel="noopener">https://wiki.wireshark.org/uploads/</a><strong>moin_import</strong>/attachments/Development/PcapNg/dhcp.pcapng</p><p>DHCP 四步交互如下</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230907230303654.png" alt="image-20230907230303654" style="zoom:80%;" /><p>服务端的端口是 67，客户端的端口是 68</p><p>这里有一个疑问就是 192.168.0.10 是从哪里来的，DHCP 服务器分配之后直接写进去了</p><h4 id="discover"><a class="markdownIt-Anchor" href="#discover"></a> Discover</h4><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230907230549875.png" alt="image-20230907230549875" style="zoom:50%;" /><p>DHCP 报文格式一样，只是最后的 Option 不同，前面包含的字段如下：</p><ul><li><strong>Message type</strong>：报文的操作类型。分为请求报文和响应报文，1为请求报文，2为响应报文。具体报文类型在option字段中标识</li><li><strong>Hardware type</strong>：DHCP客户端的硬件地址类型。1表示ethernet地址</li><li><strong>Hardeare address length</strong>：DHCP客户端的硬件地址长度。Ethernet地址为6</li><li><strong>Hops</strong>：DHCP报文经过的DHCP中继的数目。初始为0，报文每经过一个DHCP中继，该字段就会增加1</li><li><strong>Transaction ID</strong>: 客户端发起一次请求时选择的随机数，用来标识一次地址请求过程</li><li><strong>Seconds elapsed</strong>: Client 开始DHCP请求后所经过的时间。目前尚未使用，固定取0</li><li><strong>Bootp flags</strong>：DHCP服务器响应报文是采用单播还是广播方式发送。<strong>只使用第0比特位，0表示采用单播方式，1表示采用广播方式</strong>，其余比特保留不用</li><li><strong>Client IP address</strong>: DHCP客户端的IP地址</li><li><strong>Your(client) IP address</strong>: DHCP服务器分配给客户端的IP地址</li><li><strong>Next server IP address</strong>：DHCP客户端获取IP地址等信息的服务器IP地址</li><li><strong>Relay agent IP address</strong>: DHCP客户端发出请求报文后经过的第一个DHCP中继的IP地址</li><li><strong>Client MAC address</strong>: DHCP客户端的硬件地址</li><li><strong>Server host name</strong>: DHCP客户端获取IP地址等信息的服务器名称</li><li><strong>Boot file name</strong>: DHCP服务器为DHCP客户端指定的启动配置文件名称及路径信息</li><li><strong>Magic cookie</strong>: 标识和解释DHCP消息的元素，有助于确保不同设备之间的协议兼容性，并提供了消息类型和选项格式的关键信息</li><li><strong>Option</strong>：可选变长选项字段，包含报文的类型、有效租期、DNS服务器的IP地址和WINS服务器的IP地址等配置信息。</li></ul><p>因为是广播报文，所以目的地址是 <code>255.255.255.255</code>，其中</p><ul><li>Option(53): 表示 DHCP 消息类型，Discover(1)</li><li>Option(50): 用来记录请求的 IP</li><li>Option(55): 用来请求其他参数</li><li>Option(61): 客户端标识符</li></ul><h4 id="offer"><a class="markdownIt-Anchor" href="#offer"></a> Offer</h4><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230907230844722.png" alt="image-20230907230844722" style="zoom:50%;" /><p>这里也包含了很多 Option:</p><ul><li>Option(53): DHCP 消息类型，Offer(2)</li><li>Option(1): 子网掩码， <code>255.255.255.0</code></li><li>Option(58): 续租时间 T1，一般为租期的 50%</li><li>Option(59): 重新发起T2, 租约响应超时，重新发起广播时间，一般位租期的 87.5%</li><li>Option(51): 租约</li><li>Option(54): DHCP服务器标识符选项</li></ul><h4 id="request"><a class="markdownIt-Anchor" href="#request"></a> Request</h4><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230907231535947.png" alt="image-20230907231535947" style="zoom:50%;" /><p>这里也包含了很多 Option:</p><ul><li>Option(53): DHCP 消息类型，Request(3)</li><li>Option(61): 客户段标识</li><li>Option(50):  请求的 IP</li><li>Option(54):  服务端标识</li><li>Option(55): 请求的参数</li></ul><h4 id="ack"><a class="markdownIt-Anchor" href="#ack"></a> ACK</h4><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230907231557794.png" alt="image-20230907231557794" style="zoom:50%;" /><p>这里也包含了很多 Option:</p><ul><li>Option(53): DHCP 消息类型，Ack(5)</li><li>Option(1): 子网掩码， <code>255.255.255.0</code></li><li>Option(58): 续租时间 T1，一般为租期的 50%</li><li>Option(59): 重新发起T2, 租约响应超时，重新发起广播时间，一般位租期的 87.5%</li><li>Option(51): 租约</li><li>Option(54): DHCP服务器标识符选项</li></ul><h3 id="dhcp-snooping"><a class="markdownIt-Anchor" href="#dhcp-snooping"></a> DHCP Snooping</h3><p>DHCP Snooping 是DHCP的一种安全特性，用于保证 DHCP客户端从合法的 DHCP服务器获取IP地址，并记录DHCP客户端IP地址与MAC地址等参数的对应关系。<code>DHCP Snooping</code> 用来抵御网络中针对DHCP的各种攻击</p><blockquote><ol><li>DHCP攻击有哪些</li><li>它的原理是什么</li></ol></blockquote><h4 id="dhcp-攻击"><a class="markdownIt-Anchor" href="#dhcp-攻击"></a> DHCP 攻击</h4><h5 id="1-dhcp-server仿冒者攻击"><a class="markdownIt-Anchor" href="#1-dhcp-server仿冒者攻击"></a> 1. DHCP Server仿冒者攻击</h5><p>由于 Server 和 Client 之间没有认证机制，而 DHCP Discover报文 是以<strong>广播</strong>形式发送，如果在网络上随意添加一台 DHCP服务器，它就可以为 Client 分配IP地址以及其他网络参数。</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/download-20230908224500248.png" alt="DHCP Client发送DHCP Discover报文示意图" /></p><p>如果此时 DHCP Server仿冒者 回应给 Client 仿冒信息，如错误的网关地址、错误的DNS(Domain Name System)服务器、错误的IP等信息。Client 将无法获取正确的IP地址和相关信息，导致合法客户无法正常访问网络或信息安全受到严重威胁。</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/download.png" alt="img" /></p><p>解决办法：为了防止DHCP Server仿冒者攻击，可配置设备接口的 <code>信任(Trusted)/非信任(Untrusted)</code>工作模式</p><p>将与合法DHCP服务器直接或间接连接的接口设置为信任接口，其他接口设置为非信任接口。此后，从<code>非信任(Untrusted)</code>接口上收到的DHCP回应报文将被直接丢弃，这样可以有效防止DHCP Server仿冒者的攻击</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/download-20230908224631147.png" alt="img" /></p><h5 id="2-防止非dhcp用户攻击"><a class="markdownIt-Anchor" href="#2-防止非dhcp用户攻击"></a> 2. 防止非DHCP用户攻击</h5><p>在DHCP网络中，静态获取IP地址的用户（非DHCP用户）对网络可能存在多种攻击，譬如仿冒DHCP Server、构造虚假DHCP Request报文等。这将为合法DHCP用户正常使用网络带来了一定的安全隐患</p><p>解决办法：开启设备根据 <strong>DHCP Snooping绑定表</strong> 生成接口的静态MAC表项功能，设备将根据接口下所有的DHCP用户对应的DHCP Snooping绑定表项自动执行命令生成这些用户的静态MAC表项，并同时关闭接口学习动态MAC表项的能力。此时，只有源MAC与静态MAC表项匹配的报文才能够通过该接口，否则报文会被丢弃。因此对于该接口下的非DHCP用户，只有管理员手动配置了此类用户的静态MAC表项其报文才能通过，否则报文将被丢弃。</p><p><strong>动态MAC表项是设备自动学习并生成的，静态MAC表项则是根据命令配置而成的</strong>。MAC表项中包含用户的MAC、所属VLAN、连接的接口号等信息，设备可根据MAC表项对报文进行二层转发</p><h5 id="3-防止仿冒dhcp报文攻击"><a class="markdownIt-Anchor" href="#3-防止仿冒dhcp报文攻击"></a> 3. 防止仿冒DHCP报文攻击</h5><p>已获取到IP地址的合法用户通过向服务器发送 DHCP Request 或 DHCP Release 报文用以续租或释放IP地址。</p><ul><li>如果攻击者冒充合法用户不断向DHCP Server发送DHCP Request报文来续租IP地址，会导致这些到期的IP地址无法正常回收，以致一些合法用户不能获得IP地址；</li><li>而若攻击者仿冒合法用户的DHCP Release报文发往DHCP Server，将会导致用户异常下线</li></ul><p>解决办法：利用DHCP Snooping绑定表的功能。设备通过将DHCP Request续租报文和DHCP Release报文与绑定表进行匹配操作能够有效的判别报文是否合法(主要是检查报文中的VLAN、IP、MAC、接口信息是否匹配动态绑定表)，若匹配成功则转发该报文，匹配不成功则丢弃</p><h5 id="4-防止dhcp-server服务拒绝攻击"><a class="markdownIt-Anchor" href="#4-防止dhcp-server服务拒绝攻击"></a> 4. 防止DHCP Server服务拒绝攻击</h5><p>若设备接口if1 下存在大量攻击者恶意申请IP地址，会导致DHCP Server中IP地址快速耗尽而不能为其他合法用户提供IP地址分配服务。</p><p>另一方面，DHCP Server通常仅根据DHCP Request报文中的(Client Hardware Address)字段来确认客户端的MAC地址。如果某一攻击者通过不断改变<strong>CHADDR字段</strong>向DHCP Server申请IP地址，同样将会导致DHCP Server上的地址池被耗尽，从而无法为其他正常用户提供IP地址</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/download-20230908230901387.png" alt="img" /></p><p>解决办法：</p><ul><li><p>为了抑制大量 Client 恶意申请IP地址，在使能设备的DHCP Snooping功能后，可配置设备或接口允许接入的最大DHCP用户数，当接入的用户数达到该值时，则不再允许任何用户通过此设备或接口成功申请到IP地址。</p></li><li><p>通过改变DHCP Request报文中的CHADDR字段方式的攻击，可使能设备检测DHCP Request报文帧头MAC与DHCP数据区中<code>CHADDR</code>字段是否一致功能，此后设备将检查上送的DHCP Request报文中的帧头MAC地址是否与<strong>CHADDR值</strong>相等</p></li></ul><h5 id="5-ldra功能感知用户位置信息"><a class="markdownIt-Anchor" href="#5-ldra功能感知用户位置信息"></a> 5. LDRA功能感知用户位置信息</h5><p><strong>LDRA</strong>称为轻量级DHCPv6中继代理，该<strong>中继代理能够记录用户位置信息</strong>并将其发送到 DHCPv6 Server，从而使得DHCPv6 Server能够获取到用户详细的物理位置信息，以实现对用户客户端部署诸如地址分配、计费、接入控制等策略</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/download-20230908231042126.png" alt="LDRA应用组网图" /></p><p>解决办法：在使能Switch的DHCP Snooping功能之后，可使能其LDRA功能。Switch既能够获取用户详细的位置信息并将其发送到DHCPv6 Server。DHCPv6 Server即可根据用户的详细位置信息为其部署地址分配策略或其他安全策略</p><p>LDRA功能仅是记录了DHCPv6用户的详细位置信息并通过 RELAY-FORW报文 将该信息发送给DHCPv6 Server，对不同的用户部署诸如地址分配、计费、接入控制等策略，由DHCPv6 Server实现</p><h4 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h4><p>DHCP Snooping分为DHCPv4 Snooping和DHCPv6 Snooping，两者实现原理相似。开启 DHCP Snooping 的接口会根据 DHCP 请求与响应生成 DHCP Snoop 绑定表，后续设备再从盖接口接受用户发送的 DHCP 报文时，会进行匹配检查</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/download-20230908231452273.png" alt="img" /></p><p>如下图所示的DHCP场景中，连接在二层接入设备上的PC配置为自动获取IP地址。PC作为DHCP客户端通过广播形式发送DHCP请求报文，使能了DHCP Snooping功能的二层接入设备将其通过信任接口转发给DHCP服务器。最后DHCP服务器将含有IP地址信息的DHCP ACK报文通过单播的方式发送给PC。在这个过程中，二层接入设备收到DHCP ACK报文后，会从该报文中提取关键信息（包括PC的MAC地址以及获取到的IP地址、地址租期），并获取与PC连接的使能了DHCP Snooping功能的接口信息（包括接口编号及该接口所属的VLAN，根据这些信息生成DHCP Snooping绑定表。</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/download-20230908231606817.png" alt="img" /></p><p><strong>DHCP Snooping绑定表 根据DHCP租期进行老化或根据用户释放IP地址时发出的DHCP Release报文自动删除对应表项</strong></p><p>由于DHCP Snooping绑定表记录了DHCP客户端IP地址与MAC地址等参数的对应关系，故通过对报文与DHCP Snooping绑定表进行匹配检查，能够有效防范非法用户的攻击。</p><p>为了保证设备在生成DHCP Snooping绑定表时能够获取到用户MAC等参数，DHCP Snooping功能<strong>需应用于二层网络中的接入设备或第一个DHCP Relay上</strong>。</p><p>在DHCP中继使能DHCP Snooping场景中，<strong>DHCP Relay设备不需要设置信任接口</strong>。因为DHCP Relay收到DHCP请求报文后进行源目的IP、MAC转换处理，然后以单播形式发送给指定的合法DHCP服务器，所以DHCP Relay收到的DHCP ACK报文都是合法的，生成的DHCP Snooping绑定表也是正确的</p><p><strong>总结来说，是有一个 DHCP Snooping 绑定表用来记录以及校验 DHCP 报文</strong>，另外还有校验 二层 MAC 地址与 DHCP 的 <code>Client mac address</code> 的功能</p><h3 id="dhcpv6"><a class="markdownIt-Anchor" href="#dhcpv6"></a> DHCPv6</h3><p><code>546</code>号端口用于 <code>DHCPv6 Client</code>，而不用于DHCPv4，是为<code>DHCP failover</code>服务，这是需要特别开启的服务，<code>DHCP failover</code>是用来做<code>双机热备</code>的</p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/DHCP.html" target="_blank" rel="noopener">https://info.support.huawei.com/info-finder/encyclopedia/zh/DHCP.html</a></li><li><a href="https://support.huawei.com/hedex/hdx.do?docid=EDOC1100087046&amp;id=ZH-CN_CONCEPT_0176371515" target="_blank" rel="noopener">https://support.huawei.com/hedex/hdx.do?docid=EDOC1100087046&amp;id=ZH-CN_CONCEPT_0176371515</a></li><li><a href="https://support.huawei.com/hedex/hdx.do?docid=EDOC1100087046&amp;id=ZH-CN_CONCEPT_0176371535" target="_blank" rel="noopener">https://support.huawei.com/hedex/hdx.do?docid=EDOC1100087046&amp;id=ZH-CN_CONCEPT_0176371535</a></li><li><a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/ICMP.html" target="_blank" rel="noopener">https://info.support.huawei.com/info-finder/encyclopedia/zh/ICMP.html</a></li><li><a href="https://wiki.wireshark.org/DHCP.md" target="_blank" rel="noopener">https://wiki.wireshark.org/DHCP.md</a></li><li><a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/DHCP+Snooping.html" target="_blank" rel="noopener">https://info.support.huawei.com/info-finder/encyclopedia/zh/DHCP+Snooping.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;动态主机配置协议&lt;code&gt;DHCP&lt;/code&gt;(Dynamic Host Configuration Protocol) 是一种网络管理协议，用于集中对用户 IP 地址进行动态管理和配置。&lt;br /&gt;
&lt;strong&gt;DHCP协议&lt;/strong&gt;由 &lt;code&gt;RFC
      
    
    </summary>
    
    
      <category term="Protocol" scheme="https://www.yuankang.top/categories/Protocol/"/>
    
    
      <category term="DHCP" scheme="https://www.yuankang.top/tags/DHCP/"/>
    
      <category term="Protocol" scheme="https://www.yuankang.top/tags/Protocol/"/>
    
  </entry>
  
  <entry>
    <title>Go-27-SyncPool</title>
    <link href="https://www.yuankang.top/2023/07/15/Go/Go-27-SyncPool/"/>
    <id>https://www.yuankang.top/2023/07/15/Go/Go-27-SyncPool/</id>
    <published>2023-07-15T05:32:45.000Z</published>
    <updated>2023-07-15T05:38:19.201Z</updated>
    
    <content type="html"><![CDATA[<p>前面一篇讲解了<strong>Sync.Pool</strong>的底层数据结构 <a href="https://www.yuankang.top/2023/07/01/Go/Go%E5%85%A5%E9%97%A825-PoolDequeue/">poolDequeue</a>，接着看看<code>Sync.Pool</code>的具体实现原理。如果想看看 <code>Sync.Pool</code> 的使用 可以看看我的 <a href="https://www.yuankang.top/2023/07/13/Go/Go%E5%85%A5%E9%97%A826-Issue/">Go 入门 26-Issue</a>，使用的时候最好分配固定大小的对象否则注意清理</p><p>带着问题看世界</p><ol><li><code>Sync.Pool</code> 与  <code>Goroutine</code>  的关系</li><li><code>Sync.Pool</code> 是如何释放的(并没有主动释放接口)</li></ol><p>代码：<code>src/sync/pool.go</code>，1.20版本</p><p>首先来看内存池的说明，翻译过来就是就是：</p><ol><li>存放在<code>Pool</code> 中的元素任何时候都有可能在没有被其他引用的情况下释放掉</li><li><code>Pool</code> 是并发安全的</li><li>使用 <code>Pool</code> 之后不能再复制它。<em>假设缓存池对象 A 被对象 B 拷贝了，如果 A 被清空，B 的缓存对象指针指向的对象将会不可控</em></li></ol><p>先来看看整体的结构图</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/syncpools1.png" alt="syncpools1" /></p><h3 id="全局变量"><a class="markdownIt-Anchor" href="#全局变量"></a> 全局变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> poolRaceHash [<span class="number">128</span>]<span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">allPoolsMu Mutex<span class="comment">//互斥锁，用于更新 allPools，因为所有的 sync.pool 都存放在里面 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// allPools is the set of pools that have non-empty primary</span></span><br><span class="line"><span class="comment">// caches. Protected by either 1) allPoolsMu and pinning or 2)</span></span><br><span class="line"><span class="comment">// STW.</span></span><br><span class="line">allPools []*Pool</span><br><span class="line"></span><br><span class="line"><span class="comment">// oldPools is the set of pools that may have non-empty victim</span></span><br><span class="line"><span class="comment">// caches. Protected by STW.</span></span><br><span class="line">oldPools []*Pool</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>allPoolsMu</code>：用于对<code>allPools</code>的更新进行保护</li><li><code>allPools</code>: <code>[]*Pool</code>切片，存储具有非空私有缓存的对象池。可以被多个 <code>goroutine</code> 访问</li><li><code>oldPools</code>：<code>[]*Pool</code>类型的切片，用于存储可能具有非空受害者缓存的对象池，由于只有在 <code>STW</code> 时候才会更新，不会被并发访问</li></ul><h3 id="基本结构"><a class="markdownIt-Anchor" href="#基本结构"></a> 基本结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">  noCopy noCopy <span class="comment">// 提示不要复制</span></span><br><span class="line">  </span><br><span class="line">  local     unsafe.Pointer <span class="comment">// 指向每个 P(处理器) 的本地池的指针。它的类型是 [P]poolLocal，其中P是处理器数量</span></span><br><span class="line">  localSize <span class="keyword">uintptr</span>        <span class="comment">// 本地数组的大小</span></span><br><span class="line"></span><br><span class="line">  victim     unsafe.Pointer <span class="comment">// GC上一个周期中的本地池的指针。在当前周期中，这个本地池变成了受害者。它的类型是 unsafe.Pointer</span></span><br><span class="line">  victimSize <span class="keyword">uintptr</span>        <span class="comment">// 受害者缓存数组的大小，以字节为单位</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//可选地指定一个函数，当 Get 方法本来会返回 nil 时，可以用于生成一个值。</span></span><br><span class="line">  New <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">any</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>noCopy</code> 用于提示不要进行对象复制</p></li><li><p><code>local</code> 与 <code>victim</code> 的关系在后面 <strong>内存池清理</strong> 中说明</p></li><li><p><code>New</code> 则是自定义的分配对象函数</p></li></ul><h4 id="nocopy"><a class="markdownIt-Anchor" href="#nocopy"></a> noCopy</h4><p><code>noCopy</code> 支持 使用 <code>go vet</code> 检查对象是否被复制，它是一个内置的空结构体类型，当然也可以自行实现类似功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> noCopy <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n noCopy)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//TODO implement me</span></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"implement me"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n noCopy)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//TODO implement me</span></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"implement me"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ sync.Locker = (*noCopy)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">noCopy</span><br><span class="line">age    <span class="keyword">int</span></span><br><span class="line">height <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它第一次使用后不能被复制，其实代码是能够编译通过运行的，只是在 <code>go vet</code> 或者 <code>部分编辑器</code>会提示而已。可以看看没有成为标准的原因 <a href="https://golang.org/issues/8005#issuecomment-190753527" target="_blank" rel="noopener">https://golang.org/issues/8005#issuecomment-190753527</a></p><h4 id="poollocal"><a class="markdownIt-Anchor" href="#poollocal"></a> poolLocal</h4><p>每个处理器 <code>P</code> 都有一个 <code>poolLocal</code> 的本地池对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个 P 的本地对象池</span></span><br><span class="line"><span class="keyword">type</span> poolLocalInternal <span class="keyword">struct</span> &#123;</span><br><span class="line">private any       <span class="comment">// 仅能被当前 P 进行读写</span></span><br><span class="line">shared  poolChain <span class="comment">// 共享，当前 P 能对其进行 pushHead/popHead; 任何 P 都能执行popTail</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> poolLocal <span class="keyword">struct</span> &#123;</span><br><span class="line">poolLocalInternal</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prevents false sharing on widespread platforms with</span></span><br><span class="line"><span class="comment">// 128 mod (cache line size) = 0 .</span></span><br><span class="line">pad [<span class="number">128</span> - unsafe.Sizeof(poolLocalInternal&#123;&#125;)%<span class="number">128</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>private</code> 是一个仅用于当前 P 进行读写的字段(即没有并发读写的问题)</li><li><code>shared</code> 可以在多个 P 之间进行共享读写，是一个 <code>poolChain</code> 链式队列结构， 当前 P 上可以进行 <code>pushHead</code> 和 <code>popHead</code> 操作(队头读写)， 在所有 P 上都可以进行 <code>popTail</code> (队尾出队)操作</li><li><code>pad</code>  用于 <strong>伪共享</strong> 保证 <code>poolLocal</code> 的大小是 128 字节的倍数</li></ul><h4 id="runtime_procpin"><a class="markdownIt-Anchor" href="#runtime_procpin"></a> runtime_procPin</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">procPin</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">gp := getg()<span class="comment">//获取当前goroutine的指针</span></span><br><span class="line">mp := gp.m<span class="comment">//当前goroutine 对应的 协程代表</span></span><br><span class="line"></span><br><span class="line">  mp.locks++<span class="comment">//这个变量用于跟踪当前线程(m)持有的锁的数量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">int</span>(mp.p.ptr().id)<span class="comment">//代表当前线程(m)执行的处理器(p)的唯一标识符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">procUnpin</span><span class="params">()</span></span> &#123;</span><br><span class="line">gp := getg()</span><br><span class="line">gp.m.locks--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>locks</code>:通过增加锁的计数，表明当前线程被固定（pinned）在处理器上</li><li><code>mp.p</code>表示当前线程所绑定的处理器，<code>.ptr()</code>方法返回处理器的指针，<code>.id</code>表示处理器的唯一标识符</li></ul><h4 id="pinslow"><a class="markdownIt-Anchor" href="#pinslow"></a> pinSlow</h4><p>将当前的<code>goroutine</code>绑定到<code>Pool</code>中的一个<code>poolLocal</code>上，并返回该<code>poolLocal</code>及其索引</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">pinSlow</span><span class="params">()</span> <span class="params">(*poolLocal, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//1. 解除当前goroutine与之前绑定的poolLocal的绑定关系，使当前goroutine可以进行重新绑定</span></span><br><span class="line">  <span class="comment">//使用 mutex 时候 P 必须可抢占</span></span><br><span class="line">  runtime_procUnpin()</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//2. 获取池的全局锁 </span></span><br><span class="line">  allPoolsMu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> allPoolsMu.Unlock()</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//3. 将当前的goroutine绑定到一个poolLocal上，并返回其索引pid。</span></span><br><span class="line"><span class="comment">//再次固定 P 时 poolCleanup 不会被调用</span></span><br><span class="line">  pid := runtime_procPin()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//获取未越界返回poolLocal</span></span><br><span class="line">  s := p.localSize  </span><br><span class="line">  l := p.local</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">uintptr</span>(pid) &lt; s &#123;</span><br><span class="line">    <span class="keyword">return</span> indexLocal(l, pid), pid</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 如果数组为空，将其添加到 allPools，垃圾回收器从这里获取所有 Pool 实例</span></span><br><span class="line">  <span class="keyword">if</span> p.local == <span class="literal">nil</span> &#123;</span><br><span class="line">    allPools = <span class="built_in">append</span>(allPools, p)</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 根据 P 数量创建 slice，如果 GOMAXPROCS 在 GC 间发生变化</span></span><br><span class="line"><span class="comment">// 我们重新分配此数组并丢弃旧的</span></span><br><span class="line">size := runtime.GOMAXPROCS(<span class="number">0</span>)  <span class="comment">// 获取当前的GOMAXPROCS值，即当前系统的最大并发数</span></span><br><span class="line">local := <span class="built_in">make</span>([]poolLocal, size)    <span class="comment">//创建本地池</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将底层数组起始指针保存到 p.local，并设置 p.localSize</span></span><br><span class="line">atomic.StorePointer(&amp;p.local, unsafe.Pointer(&amp;local[<span class="number">0</span>]))</span><br><span class="line">runtime_StoreReluintptr(&amp;p.localSize, <span class="keyword">uintptr</span>(size))  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回所需的 pollLocal</span></span><br><span class="line"><span class="keyword">return</span> &amp;local[pid], pid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个逻辑的前提是当前 P 已经发生了动态调整，需要重新计算<code>localPool</code></p><ul><li>首先解除 <code>goroutine</code> 与 <code>Process</code> 的绑定，让 <code>goroutine</code> 可以重新绑定</li><li>获取 <code>allPools</code>的全局锁</li><li>将当前  <code>goroutine</code> 与 <code>Process</code> 重新绑定</li><li>如果<code>Process</code> 未发生变化，返回 <code>Process</code> 的 <code>localPool</code></li><li>如果没有变化则<ul><li>如果 <code>Pool.local</code>为空，则需要将 <code>Pool</code> 加入到 <code>allPools</code> 中，用于 GC 扫描回收</li><li>重新创建 <code>[p]poolLocal</code></li><li>重新将 <code>Pool.local</code> 指向 <code>[p]poolLocal</code></li></ul></li></ul><h4 id="pin"><a class="markdownIt-Anchor" href="#pin"></a> pin</h4><p>获取当前 <code>Process</code> 中的 <code>poolLocal</code>，将当前的<code>goroutine</code>绑定到一个特定的<code>Process</code>上，禁用抢占并返回<code>Process</code>的<code>poolLocal</code>本地池和<code>P</code>的标识</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">pin</span><span class="params">()</span> <span class="params">(*poolLocal, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1. 将当前的goroutine绑定到一个P上，并返回P的标识pid。</span></span><br><span class="line">pid := runtime_procPin()</span><br><span class="line">  </span><br><span class="line">s := runtime_LoadAcquintptr(&amp;p.localSize) <span class="comment">// load-acquire</span></span><br><span class="line">l := p.local    <span class="comment">// load-consume</span></span><br><span class="line">  <span class="comment">//可能存在动态的 P（运行时调整 P 的个数）procresize/GOMAXPROCS，如果 P.id 没有越界，则直接返回</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uintptr</span>(pid) &lt; s &#123;</span><br><span class="line"><span class="keyword">return</span> indexLocal(l, pid), pid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p.pinSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试通过加载<code>local</code>和<code>localSize</code>字段的方式来判断是否可以直接返回一个可用的<code>poolLocal</code>，如果不满足条件，则调用<code>pinSlow</code>方法来重新分配并返回一个新的<code>poolLocal</code>。调用者在使用完<code>poolLocal</code>之后，必须调用<code>runtime_procUnpin()</code>来解除与<code>P</code>的绑定关系。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexLocal</span><span class="params">(l unsafe.Pointer, i <span class="keyword">int</span>)</span> *<span class="title">poolLocal</span></span> &#123;</span><br><span class="line">lp := unsafe.Pointer(<span class="keyword">uintptr</span>(l) + <span class="keyword">uintptr</span>(i)*unsafe.Sizeof(poolLocal&#123;&#125;))</span><br><span class="line"><span class="keyword">return</span> (*poolLocal)(lp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存池清理"><a class="markdownIt-Anchor" href="#内存池清理"></a> 内存池清理</h3><p>在使用 init 仅执行了一个逻辑，就是注册内存池回收机制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">runtime_registerPoolCleanup(poolCleanup)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>poolCleanup</code> 用于实现内存池的清理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poolCleanup</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Because the world is stopped, no pool user can be in a</span></span><br><span class="line"><span class="comment">// pinned section (in effect, this has all Ps pinned).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Drop victim caches from all pools.</span></span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> oldPools &#123;</span><br><span class="line">p.victim = <span class="literal">nil</span></span><br><span class="line">p.victimSize = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Move primary cache to victim cache.</span></span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> allPools &#123;</span><br><span class="line">p.victim = p.local</span><br><span class="line">p.victimSize = p.localSize</span><br><span class="line">p.local = <span class="literal">nil</span></span><br><span class="line">p.localSize = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The pools with non-empty primary caches now have non-empty</span></span><br><span class="line"><span class="comment">// victim caches and no pools have primary caches.</span></span><br><span class="line">oldPools, allPools = allPools, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>垃圾回收的策略就是</p><ul><li>将 <code>oldPools</code> 中也就是所有<code>localPool</code>的 <code>victim</code> 对象丢弃</li><li>将 <code>allPools</code> 的 <code>local</code> 复制给<code>victim</code>，并 <code>local</code> 重置</li><li>最后将 <code>allPools</code> 复制给 <code>oldPools</code>，<code>allPools</code> 置空</li></ul><h3 id="get"><a class="markdownIt-Anchor" href="#get"></a> Get</h3><p>整体流程如下</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/syncpool4.png" alt="syncpool4" style="zoom:50%;" /><ol><li>首先获取当前 <code>Process</code> 的 <code>poolLocal</code>，<strong>也就是说当 Goroutine 在哪个 Process 运行的时候就会从哪个 Process 的 localPool中获取对象</strong></li><li>优先从 <code>private</code> 中选择对象，并将 <code>private = nil</code></li><li>若取不到，则尝试从 <code>shared</code> 队列的队头进行读取</li><li>若取不到，则尝试从其他的 <code>Process</code> 中进行偷取 <code>getSlow</code><strong>（跨 Process 读写）</strong></li><li>若还是取不到，则使用自定义的 <code>New</code> 方法新建对象</li></ol><p>获取对象代码如下操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">any</span></span> &#123;</span><br><span class="line">  <span class="comment">//...race</span></span><br><span class="line">  <span class="comment">//1. 获取一个poolLocal</span></span><br><span class="line">  l, pid := p.pin()</span><br><span class="line">  <span class="comment">//2. 先从private获取对象</span></span><br><span class="line">x := l.private</span><br><span class="line">l.private = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 尝试从 localPool 的 shared 队列队头读取</span></span><br><span class="line">x, _ = l.shared.popHead()</span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 如果取不到，则获取新的缓存对象</span></span><br><span class="line">x = p.getSlow(pid)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">runtime_procUnpin()</span><br><span class="line"><span class="comment">//...race</span></span><br><span class="line">  <span class="comment">// 如果 getSlow 还是获取不到，则 New 一个</span></span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &amp;&amp; p.New != <span class="literal">nil</span> &#123;</span><br><span class="line">x = p.New()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 <code>getSlow</code> 就是从 其他 <code>Process</code> 或者 <code>victim</code> 中获取</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">getSlow</span><span class="params">(pid <span class="keyword">int</span>)</span> <span class="title">any</span></span> &#123;</span><br><span class="line"><span class="comment">//1. 加载本地池</span></span><br><span class="line">size := runtime_LoadAcquintptr(&amp;p.localSize) <span class="comment">// load-acquire</span></span><br><span class="line">locals := p.local                            <span class="comment">// load-consume</span></span><br><span class="line"><span class="comment">// Try to steal one element from other procs.</span></span><br><span class="line">  <span class="comment">//2. 尝试从其他 process 偷取元素</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(size); i++ &#123;</span><br><span class="line">l := indexLocal(locals, (pid+i+<span class="number">1</span>)%<span class="keyword">int</span>(size))</span><br><span class="line"><span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3. 从其他 process 也没有偷到</span></span><br><span class="line">  <span class="comment">//那么判断是否 process数量发生了变化</span></span><br><span class="line">size = atomic.LoadUintptr(&amp;p.victimSize)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uintptr</span>(pid) &gt;= size &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//4. 从 victim 中获取</span></span><br><span class="line">locals = p.victim</span><br><span class="line">l := indexLocal(locals, pid)</span><br><span class="line"><span class="keyword">if</span> x := l.private; x != <span class="literal">nil</span> &#123;</span><br><span class="line">l.private = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(size); i++ &#123;</span><br><span class="line">l := indexLocal(locals, (pid+i)%<span class="keyword">int</span>(size))</span><br><span class="line"><span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//到这里说明没有了，那么就将 victimSize 设置为 0后续不会访问</span></span><br><span class="line">atomic.StoreUintptr(&amp;p.victimSize, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put"><a class="markdownIt-Anchor" href="#put"></a> Put</h3><p>Put 的操作如下</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/syncpool5.png" alt="syncpool5" style="zoom:50%;" /><p>存放策略是：</p><ol><li>如果存放 <code>nil</code> 直接返回</li><li>获取当前 <code>Process</code> 的 <code>poolLocal</code></li><li>如果 <code>private == nil</code> 则放到 <code>private</code> 中</li><li>如果<code>private != nil</code> 则将起放入到 链表头部</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Put</span><span class="params">(x any)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...race</span></span><br><span class="line">  <span class="comment">// 获得一个 localPool</span></span><br><span class="line">l, _ := p.pin()</span><br><span class="line">  <span class="comment">// 优先放入private</span></span><br><span class="line"><span class="keyword">if</span> l.private == <span class="literal">nil</span> &#123;</span><br><span class="line">l.private = x</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l.shared.pushHead(x)</span><br><span class="line">&#125;</span><br><span class="line">runtime_procUnpin()</span><br><span class="line"><span class="comment">//...race</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>Pool 本质是为了提高<strong>临时对象的复用率</strong>；</li><li>Pool 使用两层回收策略（local + victim）避免性能波动；</li><li>Pool 本质是一个杂货铺属性，啥都可以放，Pool 池本身不做限制；</li><li>Pool 池里面 cache 对象也是分层的，一层层的 cache，取用方式从最热的数据到最冷的数据递进；</li><li>Pool 是并发安全的，但是内部是无锁结构，原理是对每个 P 都分配 cache 数组（ <code>poolLocalInternal</code>  数组），这样 cache 结构就不会导致并发；</li><li>永远不要 copy 一个 Pool，明确禁止，不然会导致内存泄露和程序并发逻辑错误；</li><li>代码编译之前用 <code>go vet</code>  做静态检查，能减少非常多的问题；</li><li>每轮 GC 开始都会清理一把 Pool 里面 cache 的对象，注意流程是分两步，当前 Pool 池 local 数组里的元素交给 victim 数组句柄，victim 里面 cache 的元素全部清理。换句话说，引入 victim 机制之后，对象的缓存时间变成两个 GC 周期；</li><li>不要对 Pool 里面的对象做任何假定，有两种方案：要么就归还的时候 memset 对象之后，再调用 <code>Pool.Put</code> ，要么就 <code>Pool.Get</code> 取出来的时候 memset 之后再使用；</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://mp.weixin.qq.com/s/dLzWAqM9lCln83jhkvmtMw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dLzWAqM9lCln83jhkvmtMw</a></li><li><a href="https://geektutu.com/post/hpg-sync-pool.html" target="_blank" rel="noopener">https://geektutu.com/post/hpg-sync-pool.html</a></li><li><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/pool/" target="_blank" rel="noopener">https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/pool/</a></li><li><a href="https://xie.infoq.cn/article/55f28d278cccf0d8195459263" target="_blank" rel="noopener">https://xie.infoq.cn/article/55f28d278cccf0d8195459263</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面一篇讲解了&lt;strong&gt;Sync.Pool&lt;/strong&gt;的底层数据结构 &lt;a href=&quot;https://www.yuankang.top/2023/07/01/Go/Go%E5%85%A5%E9%97%A825-PoolDequeue/&quot;&gt;poolDequeue
      
    
    </summary>
    
    
      <category term="Go" scheme="https://www.yuankang.top/categories/Go/"/>
    
    
      <category term="Go" scheme="https://www.yuankang.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go-26-Issue</title>
    <link href="https://www.yuankang.top/2023/07/13/Go/Go-26-Issue/"/>
    <id>https://www.yuankang.top/2023/07/13/Go/Go-26-Issue/</id>
    <published>2023-07-13T14:59:45.000Z</published>
    <updated>2023-07-19T15:34:46.967Z</updated>
    
    <content type="html"><![CDATA[<h3 id="issue-23199"><a class="markdownIt-Anchor" href="#issue-23199"></a> Issue-23199</h3><p>在阅读 <code>sync.Pool</code> 在 <code>fmt</code> 中的使用时候看到了这样一段代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pp)</span> <span class="title">free</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Proper usage of a sync.Pool requires each entry to have approximately</span></span><br><span class="line"><span class="comment">// the same memory cost. To obtain this property when the stored type</span></span><br><span class="line"><span class="comment">// contains a variably-sized buffer, we add a hard limit on the maximum</span></span><br><span class="line"><span class="comment">// buffer to place back in the pool. If the buffer is larger than the</span></span><br><span class="line"><span class="comment">// limit, we drop the buffer and recycle just the printer.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// See .https://golang.org/issue/23199</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span>(p.buf) &gt; <span class="number">64</span>*<span class="number">1024</span> &#123;</span><br><span class="line">p.buf = <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p.buf = p.buf[:<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//存入内存池</span></span><br><span class="line">ppFree.Put(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述英文解释的大致意思是</p><blockquote><p><code>sync.Pool</code>在使用的时候<strong>每个对象的内存消耗应该大致相同</strong>。当存储的类型包含可变大小的缓冲区时，需要对最大缓冲区设置一个硬限制，以确保如果缓冲区的大小超过限制，将丢弃缓冲区，并仅回收</p></blockquote><p>因为 <code>fmt</code> 使用内存池分配的对象大小不是固定的，如下 <code>buf</code> 其实是一个缓冲区</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ppFree = sync.Pool&#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">any</span></span> &#123; <span class="keyword">return</span> <span class="built_in">new</span>(pp) &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> pp <span class="keyword">struct</span> &#123;</span><br><span class="line">buf buffer</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> buffer []<span class="keyword">byte</span></span><br></pre></td></tr></table></figure><p>这里做一个测试就会明白这样的处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(a), <span class="built_in">len</span>(a))<span class="comment">//100 100</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(b), <span class="built_in">len</span>(b)) <span class="comment">//100 100</span></span><br><span class="line"></span><br><span class="line">a = <span class="literal">nil</span></span><br><span class="line">b = b[:<span class="number">0</span>]</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(a), <span class="built_in">len</span>(a))<span class="comment">//0 0</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(b), <span class="built_in">len</span>(b)) <span class="comment">///100 0</span></span><br></pre></td></tr></table></figure><p>使用 b[:0] 之后只是切片长度变化，容量并不会变，也就是内存仍然占用那么多</p><p>所以，如果内存池大小不固定的时候注意主动释放，防止额外占用空间而不被释放。再来看看它的测试结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">finalizer</span><span class="params">(buffer *bytes.Buffer)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"GC %d buffer \n"</span>, buffer.Cap())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> stats runtime.MemStats</span><br><span class="line">runtime.ReadMemStats(&amp;stats)</span><br><span class="line">fmt.Printf(<span class="string">"start %d B\n"</span>, stats.Alloc)</span><br><span class="line"></span><br><span class="line">pool := sync.Pool&#123;New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">runtime.SetFinalizer(buf, finalizer)</span><br><span class="line"><span class="keyword">return</span> buf</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line">processRequest := <span class="function"><span class="keyword">func</span><span class="params">(size <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">b := pool.Get().(*bytes.Buffer)</span><br><span class="line">time.Sleep(<span class="number">500</span> * time.Millisecond) <span class="comment">// Simulate processing time</span></span><br><span class="line">b.Grow(size)</span><br><span class="line">pool.Put(b)</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Millisecond) <span class="comment">// Simulate idle time</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟一组大规模写入</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">processRequest(<span class="number">1</span> &lt;&lt; <span class="number">20</span>) <span class="comment">// 256MiB</span></span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second) <span class="comment">// Let the initial set finish</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟小规模写入且不会停</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">processRequest(<span class="number">1</span> &lt;&lt; <span class="number">10</span>) <span class="comment">// 1KiB</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次GC之后查看分配的内存</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">runtime.ReadMemStats(&amp;stats)</span><br><span class="line">fmt.Printf(<span class="string">"Cycle %d: %dB\n"</span>, i, stats.Alloc)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">runtime.GC()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <a href="https://www.yuankang.top/2023/01/04/Go/Go-21-SetFinalizer/">runtime.SetFinalizer</a> 大概说明对象的回收时间，会发现大对象并不是立即回收的，而是经过了一段时间，内存才趋于稳定。高并发场景下，比如处理网络请求的时候，可能导致大量内存的占用而没有及时释放</p><p><strong>解决办法</strong>: 就在在判断超过一定大小的时候直接丢弃</p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://golang.org/issue/23199" target="_blank" rel="noopener">https://golang.org/issue/23199</a></li><li><a href="https://go-review.googlesource.com/c/go/+/136035/1/src/encoding/json/encode.go" target="_blank" rel="noopener">https://go-review.googlesource.com/c/go/+/136035/1/src/encoding/json/encode.go</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;issue-23199&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#issue-23199&quot;&gt;&lt;/a&gt; Issue-23199&lt;/h3&gt;
&lt;p&gt;在阅读 &lt;code&gt;sync.Pool&lt;/code&gt; 在 &lt;code&gt;fmt&lt;/code&gt;
      
    
    </summary>
    
    
      <category term="Go" scheme="https://www.yuankang.top/categories/Go/"/>
    
    
      <category term="Go" scheme="https://www.yuankang.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go-25-PoolDequeue</title>
    <link href="https://www.yuankang.top/2023/07/01/Go/Go-25-PoolDequeue/"/>
    <id>https://www.yuankang.top/2023/07/01/Go/Go-25-PoolDequeue/</id>
    <published>2023-07-01T08:51:45.000Z</published>
    <updated>2023-07-15T05:38:08.054Z</updated>
    
    <content type="html"><![CDATA[<p>在学习Golang 中 的内存池 <code>Sync.Pool</code> 之前，底层是使用的 一个<strong>无锁</strong>的 <strong>动态扩容</strong> 的<strong>双端队列</strong>支持 <strong>单生产者</strong> <strong>多消费者</strong>  的 <code>Sync.Pool</code> 内存分配模式，它是一个私有结构体，所以外部无法访问它，这里来看看如何实现的</p><p><strong>代码：</strong><code>src/sync/poolqueue.go</code></p><p>带着问题看世界</p><ol><li>如何动态扩容的</li><li>为什么内存池要是用这样的 数组 + 链表</li></ol><h3 id="pooldequeue"><a class="markdownIt-Anchor" href="#pooldequeue"></a> poolDequeue</h3><p>首先看一下基本结构结构体，使用数组实现了一个 <code>ring buffer</code> 的结构</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/PoolDequeue1.png" alt="PoolDequeue1" style="zoom:50%;" /><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolDequeue <span class="keyword">struct</span> &#123;    </span><br><span class="line">  <span class="comment">// headTail 包含了 32bit的头部索引与32位尾部索引指向 vals</span></span><br><span class="line">  <span class="comment">// head 高 32 位, 指向下一个存放对象的索引</span></span><br><span class="line">  <span class="comment">// tail 低 32 位, 指向队列中最早(下一个读取)的对象索引</span></span><br><span class="line"><span class="comment">// 索引区间 tail &lt;= i &lt; head, 是消费者可以在该区间不断获取对象，直至获取到的对象为 nil</span></span><br><span class="line">headTail <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// vals 表示队列元素容器，大小必须为 2 的 N 次幂</span></span><br><span class="line"><span class="comment">// 容器会在初始化时指定容量，实现数据元素内存预初始化</span></span><br><span class="line"><span class="comment">// 队列会将未使用的槽位设置为nil</span></span><br><span class="line">vals []eface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么要将 <code>head</code> 和 <code>tail</code> 合并到一个变量里面？</strong></p><p>当队列中存在多个对象，两边同时操作貌似没什么问题，但为了防止队列中仅剩一个对象时，就需要锁住两个索引进行操作，所以利用了 <code>atomic</code> 包的提供的 <code>CAS</code> 操作，完成两个字段的 <code>lock free</code> 无锁编程</p><p>更新 <code>head</code> 和 <code>tail</code> 两个字段的时候，也是通过 <code>CAS + 位运算</code> 进行操作的。更新逻辑如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dequeueNil 是用于在 poolDequeue 中表示 interface&#123;&#125;(nil) 的类型。由于使用 nil 来表示空槽位，所以需要一个特殊值来表示 nil。</span></span><br><span class="line"><span class="keyword">type</span> dequeueNil *<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span> <span class="title">unpack</span><span class="params">(ptrs <span class="keyword">uint64</span>)</span> <span class="params">(head, tail <span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> mask = <span class="number">1</span>&lt;&lt;dequeueBits - <span class="number">1</span><span class="comment">//获取掩码</span></span><br><span class="line">head = <span class="keyword">uint32</span>((ptrs &gt;&gt; dequeueBits) &amp; mask)<span class="comment">//获取头部索引</span></span><br><span class="line">tail = <span class="keyword">uint32</span>(ptrs &amp; mask)<span class="comment">//获取尾部索引</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span> <span class="title">pack</span><span class="params">(head, tail <span class="keyword">uint32</span>)</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> mask = <span class="number">1</span>&lt;&lt;dequeueBits - <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">uint64</span>(head) &lt;&lt; dequeueBits) |</span><br><span class="line"><span class="keyword">uint64</span>(tail&amp;mask)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>unpack</code> 与 <code>pack</code> 实现了在 <code>poolDequeue</code> 结构中进行索引值的打包和解包操作。使得在 <code>poolDequeue</code> 结构中使用单个 64 位整数来同时存储头部索引和尾部索引</p><p>所以整体就如下图所示</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/PoolDequeue3.png" alt="PoolDequeue3" style="zoom:50%;" /><p>接着是对队列的操作，分为 <strong>头部写入</strong>、<strong>头部弹出</strong>、<strong>尾部弹出</strong></p><h4 id="pushhead"><a class="markdownIt-Anchor" href="#pushhead"></a> pushHead</h4><p>头部写入返回成功失败</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span> <span class="title">pushHead</span><span class="params">(val any)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="comment">//1. 原子操作获取索引</span></span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)</span><br><span class="line">  <span class="comment">//2. 解析头尾索引</span></span><br><span class="line">head, tail := d.unpack(ptrs)</span><br><span class="line">  <span class="comment">//3. (当尾部索引 + 队列长度)&amp; 掩码 == 头部索引，说明队列满了</span></span><br><span class="line"><span class="keyword">if</span> (tail+<span class="keyword">uint32</span>(<span class="built_in">len</span>(d.vals)))&amp;(<span class="number">1</span>&lt;&lt;dequeueBits<span class="number">-1</span>) == head &#123;</span><br><span class="line">  <span class="comment">// Queue is full.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//4. 没有满则获取头部位置</span></span><br><span class="line">slot := &amp;d.vals[head&amp;<span class="keyword">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 判断头部是否已经被释放</span></span><br><span class="line">typ := atomic.LoadPointer(&amp;slot.typ)</span><br><span class="line"><span class="keyword">if</span> typ != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Another goroutine is still cleaning up the tail, so</span></span><br><span class="line"><span class="comment">// the queue is actually still full.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The head slot is free, so we own it.</span></span><br><span class="line">    <span class="comment">//如果存放的是nil，那么使用 dequeueNil(nil) 表示存放的是一个nil类型</span></span><br><span class="line"><span class="keyword">if</span> val == <span class="literal">nil</span> &#123;</span><br><span class="line">val = dequeueNil(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">*(*any)(unsafe.Pointer(slot)) = val</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为头部索引是高32位，所以 增加 1&lt;&lt;dequeueBits，同理尾部索引是低32，直接减1</span></span><br><span class="line">atomic.AddUint64(&amp;d.headTail, <span class="number">1</span>&lt;&lt;dequeueBits)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>type == nil</code>，则表示 <code>slot</code> 已经被释放，如果 <code>value = dequeueNil(nil)</code> 表示存放的是一个 <code>nil</code> (但注意，<code>Sync.Pool</code> 的<code>Put(nil)</code> 会直接返回，而不会真的存放一个 <code>nil</code>)</p><h4 id="pophead"><a class="markdownIt-Anchor" href="#pophead"></a> popHead</h4><p>返回头部索引位置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span> <span class="title">popHead</span><span class="params">()</span> <span class="params">(any, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> slot *eface</span><br><span class="line">    <span class="comment">//使用 CAS 不断尝试获取头部值</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//加载并解析索引获取头部位置，判断是否为空</span></span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)</span><br><span class="line">head, tail := d.unpack(ptrs)</span><br><span class="line"><span class="keyword">if</span> tail == head &#123;</span><br><span class="line"><span class="comment">// Queue is empty.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算更新后的索引值</span></span><br><span class="line">head--</span><br><span class="line">ptrs2 := d.pack(head, tail)</span><br><span class="line">        <span class="comment">//CAS 更新</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;</span><br><span class="line"><span class="comment">//获取头部位置</span></span><br><span class="line">slot = &amp;d.vals[head&amp;<span class="keyword">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 如果 不是 ptrs 所以已经发生了变化那么重试</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val := *(*any)(unsafe.Pointer(slot))</span><br><span class="line"><span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;<span class="comment">//如果存放的是nil，那么返回nil</span></span><br><span class="line">val = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将槽置位 zero，为什么不会与pushHead冲突</span></span><br><span class="line">*slot = eface&#123;&#125; </span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>popTail</code> 与 <code>popHead</code>差不多，最后的赋值有区别</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slot.val = <span class="literal">nil</span><span class="comment">//直接赋值空值</span></span><br><span class="line">atomic.StorePointer(&amp;slot.typ, <span class="literal">nil</span>)<span class="comment">//表示为空</span></span><br></pre></td></tr></table></figure><p><strong>为什么 <code>popTail</code>  与 <code>popHead</code> 处理方式不一样</strong>，是因为设计的就是单个生产者与多个消费者，所以<code>popHead</code>并不会有竞争的问题，最后都是存放的 <code>slot{}</code></p><h3 id="poolchainelt"><a class="markdownIt-Anchor" href="#poolchainelt"></a> poolChainElt</h3><p><code>poolChainElt</code> 是一个双向链表的节点，包含林一个每个节点 <code>poolDequeue</code> 结构 以及 双向指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolChainElt <span class="keyword">struct</span> &#123;</span><br><span class="line">poolDequeue</span><br><span class="line">next, prev *poolChainElt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="poolchain"><a class="markdownIt-Anchor" href="#poolchain"></a> poolChain</h3><p>有了双向链表节点，那么就有双向链表 <code>poolChain</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolChain <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//由于只有生产者访问该字段，因此不需要同步操作</span></span><br><span class="line">head *poolChainElt</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于消费者访问该字段，因此读写必须是原子操作</span></span><br><span class="line">tail *poolChainElt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>poolChain</code> 是一个双向链表队列，其中每个 <code>poolDequeue</code> 的大小是前一个 <code>poolDequeue</code> 的两倍。一旦一个 <code>poolDequeue</code> 填满，就会分配一个新的 <code>poolDequeue</code>，并且只会将数据推入到最新的 <strong>poolDequeue</strong>。弹出操作发生在列表的另一端，当一个 <code>poolDequeue</code> 被耗尽后，它会从链表中移除。</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/PoolDequeue4.png" alt="PoolDequeue4" style="zoom:50%;" /><p>通过这种设计，<code>poolChain</code> 实现了一个可以动态增长的队列，以适应对象池中的元素数量变化。它能够高效地管理多个不同大小的队列，并提供生产者和消费者之间的并发访问。生产者将数据推入到最新的 <code>poolDequeue</code>，而消费者从链表的另一端弹出数据。这样可以避免竞争条件和锁等待，并提高并发性能</p><h4 id="pushhead-2"><a class="markdownIt-Anchor" href="#pushhead-2"></a> pushHead</h4><p>有了双向链表之后，再来看它是如何写入一个值的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span> <span class="title">pushHead</span><span class="params">(val any)</span></span> &#123;</span><br><span class="line">    <span class="comment">//1. 获取双向链表头部节点</span></span><br><span class="line">d := c.head</span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">//2. 如果头部节点是空的，说明整个链表都是空的，那么就需要初始化一个链表节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initSize = <span class="number">8</span> <span class="comment">// 默认大小是8，必须是2的倍数</span></span><br><span class="line">d = <span class="built_in">new</span>(poolChainElt)</span><br><span class="line">d.vals = <span class="built_in">make</span>([]eface, initSize)<span class="comment">//节点popDequeue的默认大小是8</span></span><br><span class="line">c.head = d<span class="comment">//双向链表的的头部指针指向这个节点</span></span><br><span class="line">        storePoolChainElt(&amp;c.tail, d) <span class="comment">//将节点追加到双向链表尾部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将值写入头部节点的内存池队列中，如果成功就结束</span></span><br><span class="line"><span class="keyword">if</span> d.pushHead(val) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果到这里，说明插入失败了，那么就会创建一个更大(2倍)的内存池队列 poolDequeue</span></span><br><span class="line">newSize := <span class="built_in">len</span>(d.vals) * <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> newSize &gt;= dequeueLimit &#123;<span class="comment">//最大不能超过 1 &lt;&lt; 32 / 4 = 1 &lt;&lt; 30</span></span><br><span class="line">newSize = dequeueLimit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">d2 := &amp;poolChainElt&#123;prev: d&#125;<span class="comment">//新建节点前驱是 d</span></span><br><span class="line">d2.vals = <span class="built_in">make</span>([]eface, newSize)<span class="comment">//构建指定大小的切片</span></span><br><span class="line">c.head = d2<span class="comment">//将d2设置为头部节点</span></span><br><span class="line">storePoolChainElt(&amp;d.next, d2) <span class="comment">//d的后继为d2</span></span><br><span class="line">d2.pushHead(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照效果如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">8</span>] -- [<span class="number">16</span>] -- [<span class="number">32</span>] -- head</span><br></pre></td></tr></table></figure><h4 id="pophead-2"><a class="markdownIt-Anchor" href="#pophead-2"></a> popHead</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span> <span class="title">popHead</span><span class="params">()</span> <span class="params">(any, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//获取头部节点</span></span><br><span class="line">d := c.head</span><br><span class="line"><span class="keyword">for</span> d != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">//获取队列头部节点</span></span><br><span class="line"><span class="keyword">if</span> val, ok := d.popHead(); ok &#123;</span><br><span class="line"><span class="keyword">return</span> val, ok</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 到这里是没有获取到，然后指向前驱继续获取</span></span><br><span class="line">d = loadPoolChainElt(&amp;d.prev)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="poptail"><a class="markdownIt-Anchor" href="#poptail"></a> popTail</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span> <span class="title">popTail</span><span class="params">()</span> <span class="params">(any, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//1. 加载尾部队列节点，如果没有表示链表为空则返回 false</span></span><br><span class="line">d := loadPoolChainElt(&amp;c.tail)</span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 记录尾部的后驱</span></span><br><span class="line">d2 := loadPoolChainElt(&amp;d.next)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出队列尾部值</span></span><br><span class="line"><span class="keyword">if</span> val, ok := d.popTail(); ok &#123;</span><br><span class="line"><span class="keyword">return</span> val, ok</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 d 没有了，d2 也为空，说明没有值</span></span><br><span class="line"><span class="keyword">if</span> d2 == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// CAS 尝试获取 d</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;c.tail)), unsafe.Pointer(d), unsafe.Pointer(d2)) &#123;</span><br><span class="line"><span class="comment">//如果获取到那么去掉前继</span></span><br><span class="line">storePoolChainElt(&amp;d2.prev, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//更新尾部指针</span></span><br><span class="line">d = d2</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>无锁的原因是队列形式，单个生产者在头部操作，消费者从队尾消费</li><li>并不是固定大小，而是作为双向链表节点的队列最大长度是 <code>1 &lt;&lt; 32/ 4</code>  ，并且用环形缓冲区 <code>ring buffer</code> 实现</li><li>Pool 底层 使用 数组 + 链表的形式的原因是由 Pool 的特性决定的，它需要频繁的内存分配，所以数组是一个好的选择。又为了解决扩容的问题，使用链表来连接数组</li></ul><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://mp.weixin.qq.com/s/dLzWAqM9lCln83jhkvmtMw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dLzWAqM9lCln83jhkvmtMw</a></li><li><a href="https://geektutu.com/post/hpg-sync-pool.html" target="_blank" rel="noopener">https://geektutu.com/post/hpg-sync-pool.html</a></li><li><a href="https://studygolang.com/articles/28386" target="_blank" rel="noopener">https://studygolang.com/articles/28386</a></li><li><a href="https://juejin.cn/post/7213257917255385149" target="_blank" rel="noopener">https://juejin.cn/post/7213257917255385149</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习Golang 中 的内存池 &lt;code&gt;Sync.Pool&lt;/code&gt; 之前，底层是使用的 一个&lt;strong&gt;无锁&lt;/strong&gt;的 &lt;strong&gt;动态扩容&lt;/strong&gt; 的&lt;strong&gt;双端队列&lt;/strong&gt;支持 &lt;strong&gt;单生产者&lt;/str
      
    
    </summary>
    
    
      <category term="Go" scheme="https://www.yuankang.top/categories/Go/"/>
    
    
      <category term="Go" scheme="https://www.yuankang.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Protocol-03-Raft</title>
    <link href="https://www.yuankang.top/2023/06/26/Protocol/Protocol-03-Raft/"/>
    <id>https://www.yuankang.top/2023/06/26/Protocol/Protocol-03-Raft/</id>
    <published>2023-06-26T02:25:38.000Z</published>
    <updated>2023-09-08T15:38:09.211Z</updated>
    
    <content type="html"><![CDATA[<p>在学习分布式系统过程中，经常能碰到一致性算法，即使出现部分节点故障，网络延时等情况，也不影响整体可用性，进而提高系统的整体可用性。Raft协议是一种分布式一致性算法(共识算法)，共识就是多个节点对某一个事件达成一致的算法，常见的一致性协议有Raft、Paxos、ZAB，根据 《ETCD 技术内幕》 学习 Raft 协议</p><h3 id="基本定义"><a class="markdownIt-Anchor" href="#基本定义"></a> 基本定义</h3><p>Raft 为了实现共识，会选举出主从节点，任意节点都处于下面3类角色：</p><ul><li><strong>Leader(领袖)</strong>：领袖由群众投票选举得出，每次选举，只能选出一名领袖；</li><li><strong>Candidate(候选人)</strong>：当没有领袖时，某些群众可以成为候选人，然后去竞争领袖的位置；</li><li><strong>Follower(群众)</strong>：相对于 Leader 来说，在非选举过程中的其他节点就是 Follower，任何节点都可能通过 Candidate 成为 Leader</li></ul><p>在进行选举过程中，还有几个重要的概念：</p><ul><li><strong>Leader Election(领导人选举)</strong>：简称选举，就是指选出 Leader；</li><li><strong>Term(任期)</strong>：其实是一个单独递增的连续数字，每一次任期就会重新发起一次 Leader Election，每个节点都会记录当前的任期值</li><li><strong>Election Timeout(选举超时)</strong>：就是一个超时时间，当 Follower 超时未收到 Leader 的心跳时，会重新进行选举</li></ul><p><strong>任期(Term)</strong>：实际上是一个全局的、连续递增的整数。<strong>在raft中，每进行一次选举，任期就会+1</strong></p><p>节点存在三种状态分别是：</p><ul><li>Leader节点：可读可写、处理日志复制、保证⼀致性、维护⼼跳</li><li>Follower节点：可进行读操作，写操作需要路由到Leader处理；参与投票，<strong>⼀个term任期内只能投⼀次;</strong> 当触发 election timeout 时，晋升为 Candidate</li><li>Candidate节点：集群的候选者，会发起投票试图当选leader ; 通过 <code>RequestVote</code> 通知其他节点来投票;</li></ul><p>集群中任意一个节点都处于这三个状态之一</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220125000023.png" alt="image-20220125000018705" style="zoom:80%;" /><p>如上图所示</p><ol><li><p><strong>当 Etcd节点刚启动的时候，节点初始化状态为 Follower</strong></p></li><li><p>为了进行 Leader Election 有两个时间</p><ul><li><strong>选举超时时间(Election timeout)</strong>: 每个 Follower 节点在接收不到 Leader 节点的心跳消息之后，并不会立即发起新一轮选举，而是需要等待一段时间之后才切换成 Candidate 状态发起新一轮选举。<strong>是一个一定范围的随机数，为了保证各节点不是同时发起选举请求</strong></li><li><strong>心跳超时时间(Heartbeat timeout):</strong> Leader节点向集群中其他Follower节点发送心跳消息的时间间隔</li></ul></li><li><ul><li><ul><li></li></ul></li></ul></li></ol><h3 id="leader选举"><a class="markdownIt-Anchor" href="#leader选举"></a> Leader选举</h3><p>能成为 Leader 的条件有</p><ul><li>当前集群⽆可用 leader</li><li>触发 Election timeout</li><li>Term 任期最新</li><li>Log 日志最新</li><li>获取多数投票</li></ul><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312200222.png" alt="image-20220312200222021" /></p><p>流程可以查看：<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></p><p>需要注意的是：</p><ol><li>超过集群半数节点应答，才将日志写入WAL中，也是就如果没有等到半数应答就挂了，那么数据就丢了</li><li>Follower 收到 Leader 的 复制日志 则直接将日志写入 WAL 中</li><li>当Follower收到 Vote Request 也会重置 election timeout 定时器(降低同时出现两个候选人的概率)</li><li>Term 将持续直到某个节点因为心跳超时而从新发起选举</li><li>出现多个候选人都没有称为 Leader，那么选举失败，切换为Follower，等待下一个选举超时</li><li>Leader 宕机后，其他节点重新选出新 Leader。等到旧Leader 恢复，会因为收到新Leader心跳 而自己的 Term 落后，切换成 Follower，更新自己的Term，然后重新投出自己的选票</li></ol><h4 id="基本流程"><a class="markdownIt-Anchor" href="#基本流程"></a> 基本流程</h4><p>将设ETCD集群中有三个节点(A、B、C)</p><img src="/Users/xboom/Library/Application Support/typora-user-images/image-20230626161744828.png" alt="image-20230626161744828" style="zoom:50%;" /><ol><li>初始化，<strong>所有节点起初都是 Follower 状态</strong>(Term = 0， 得票数 = 0)</li><li>节点 A 由于长时间未收到 Leader 的心跳消息，就会切换成为 Candidate 状态并发起选举<ul><li>节点 A 的选举计时器 Election Timer 己被重置</li></ul></li><li>节点 A 首先会将自己的选票投给自己，并会向集群中其他节点发送选举请求 **Request Vote **以获取其选票，此时节点会有几种状态<ul><li>当前状态是 Leader(初始化的时候不会)</li><li>当前状态是 Candidate，当处于 Candidate 状态而收到 <code>Request Vote</code> 的时候，如果接收到 Term 值比自身记录的 Term 值大的请求时，节点会切换成 Follower 状态井更新自身记录的 Term 值</li><li>当前状态是 Follower，此时的节点 B 和节点 C 还都是处于 Term=0 的任期之中，且都是 Follower 状态，均未投出 Term=1 任期中的选票，所以节点 B 和节点 C 在接收到节点 A 的选举请求后会将选票投给节点 A，任期变为1</li></ul></li></ol><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220306235342.png" alt="image-20220306235342760" style="zoom:50%;"/><ol start="4"><li><p>在节点 A 收到节点 B、 C 的投票之后，其收到了集群中超过半数的选票，所以在 Term = 1 的任期中，该集群的 Leader 节点就是节点 A，其他节点将切换成 Follower 状态，</p><blockquote><p>节点除了记录当期任期号(CurrentTerm)，还记录在该任期中当前节点的投票结果(VoteFor)</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220307000505.png" alt="image-20220307000505928" style="zoom:50%;" /></li><li><p>成为 Term = 1 任期的 Leader 节点之后，节点 A 会定期向集群中的其他节点发送心跳消息，防止节点 B 和节点 C 中的选举计时器Election timer 超时而触发新一轮的选举(重置定时器)，此时当前节点的状态</p><ul><li>当前状态是 Follower，当节点 B 和节点 C (Follower) 收到节点 A 的心跳消息之后会重置选举计时器，更新 Term</li><li>当前状态是 Candidate， 当处于 Candidate 状态而收到 <code>Request Vote</code> 的时候，如果接收到 Term 值比自身记录的 Term 值大的请求时，节点会切换成 Follower 状态井更新自身记录的 Term 值</li></ul><blockquote><p>心跳超时时间（heartbeat timeout）需要远小于选举超时时间(election timeout)</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220307000654.png" alt="image-20220307000653976" style="zoom:50%;" /></li></ol><blockquote><p>Candidate 发起选举前,会先尝试连接集群中的其他节点。如果连接不上，放弃本次选举。这个状态称之为：<strong>Prevote</strong></p></blockquote><p>带着问题看世界</p><ol><li><p>如果Leader节点频繁宕机，或者选举反复进行，怎么办？</p><p>答：要求 心跳超时时间 &lt;&lt; 选举超时时间 &lt;&lt; 平均故障间隔时间</p><ul><li><p>心跳超时时间：节点直接发送心跳信息的完整返回时间 Hearthbeat timeout：0.5ms~50ms</p></li><li><p>选举超时时间：election timer：200ms~1s</p></li><li><p>故障间隔时间：两次故障的平均时间：1个月或更多(保证节点的不要经常出故障)</p></li></ul></li><li><p>是不是谁先发起了选举请求，谁就得到了Leader？</p><p>答：不是，除了看先后顺序，还取决于Candidate节点日志是不是最新最全的日志，否则拒绝投票，防止出现日志(即数据)丢失的情况</p></li><li><p>如果两个节点同时成为 Candidate 发起选举，刚好它们的日志 都是最新的是如何选举的</p><p>答：虽然每个节点的 Election Timer 都不同，但也是不能避免两个节点同时触发选举。比如有 4 个节点</p></li></ol><h4 id="异常情况"><a class="markdownIt-Anchor" href="#异常情况"></a> 异常情况</h4><p><strong>场景 1</strong>：假设A、B同时触发选举，A 的<code>Request Vote</code>先抵达节点 C ，B 的<code>Request Vote</code>先抵达节点 D，A、B 除了得到自身的选票之外，还分别得到了节点 C 和节点 D 的 <code>Vote</code>且票数相同没有超过半数</p><p>在这种情况下， Term = 4 这个任期会以选举失败结束，随着时间的流逝，当任意节点的 Election Timer 到期之后，会再次发起新一轮的选举。由于 <code>election timeout</code> 是在一个时间区间内取的随机数，所以在配置合理的时候，像上述情况多次出现的概率并不大</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230626165029693.png" alt="image-20230626165029693" style="zoom:50%;" /><p><strong>场景 2</strong>：假设选举已经完成， Leader 在运行过程中 Down 掉了</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230626170654713.png" alt="image-20230626170654713" style="zoom:50%;" /><p>当 A 恢复之后，会收到节点 D 发来的心跳消息，该<strong>消息中携带的任期号 Term=6 &gt; 节点 A 前记录的任期号 Term=5</strong> ，A 切换成 Follower</p><p>并更新自身的 Term，同时重置远举计时器</p><p>场景 3：当节点与其他节点断开连接(出现网络分区)，不断触发选举超时，在恢复的时候因为 Term 比较大又成了 Leader</p><p>为了防止选举超时而不断的增加 Term ，当恢复的时候因为 Term 而变成 Leader，所以采取了 Prevote 措施，变为 candidate 的条件</p><ul><li>询问其他节点是否有可用 leader</li><li>可连通绝⼤数节点</li></ul><h3 id="日志复制"><a class="markdownIt-Anchor" href="#日志复制"></a> 日志复制</h3><p>Leader 节点除了向 Follower 节点发送心跳消息，还会处理客户端的请求，并将客户端的写操作 以消息(Append Entries 消息)的形式发送到集群中所有Follower节点</p><p>步骤如下：</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312204541.png" alt="image-20220312204541060"  /><ol><li>Leader 节点接到 client 请求后 <code>set a=10</code>,将本请求计入本地log</li></ol><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312204707.png" alt="image-20220312204707596" /></p><ol start="2"><li>Leader 节点向 Follower1 和 Follower2 发送Append Entries消息 <code>set a=10</code></li><li>Follower1 和 Follower2 将此信息计入本地log，并返回给 Leader</li></ol><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312204848.png" alt="image-20220312204848066" /></p><ol start="4"><li>Leader 将日志信息置为 已提交(Commited),然后状态机处理。</li><li>响应 client 请求</li><li>向 Follower1 和 Follower2 发送消息，该信息已提交</li><li>Follower1 和 Follower2 接到消息后，修改日志状态，交给自己的状态机处理</li></ol><h4 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引</h4><p>集群中各个节点都会维护一个本地 Log 用于记录更新操作，还会维护 <code>commitlndex</code> 和<code>lastApplied</code> 两个值，它们是本地Log 的索引值</p><ul><li><code>commitlndex</code> 表示的是当前节点已知的、最大的、己提交的日志索引值</li><li><code>lastApplied</code> 表示的是当前节点最后一条被应用到状态机中的日志索引值。</li></ul><p>当节点中的 <code>commitlndex</code> 值大于 <code>lastApplied</code> 值时，会将 <code>lastApplied + 1</code> ，并将 <code>lastApplied</code> 对应的日志应用到其状态机中。</p><p>Leader 还需要了解集群中其他 Follower 节点的这些信息，而决定下次发送 Append Entries 消息中包含哪些日志记录。为此， Leader 节点会维护 <code>nextlndex[]</code>和 <code>matchlndex[]</code>两个数组，这两个数组中记录的都是日志索引值</p><ul><li><code>nextlndex[]</code> 记录了需要发送给 Follower 节点的下一条日志的索引值</li><li><code>matchlndex[]</code> 记录了己经复制给每个Follower 节点的最大的日志索引值</li></ul><blockquote><p>一个数组不就可以表达了吗？</p><p>答：不行，<code>nextIndex</code>用于指示Leader节点将要发送给Follower节点的下一个日志条目的位置，帮助Leader节点推进复制进度；<code>matchIndex</code>用于指示Leader节点已经复制到Follower节点上的最高日志条目的位置，帮助Leader节点确定已经<strong>被大多数节点确认的日志条目</strong>，可以进行提交</p></blockquote><p>Leader 节点中 <code>matchlndex</code> 大于等于该 Follower 节点对应的 <code>nextlndex</code> 值，那么通过 Append Entries 消息发送从<code>nextlndex</code> 开始的所有日志。之后，Leader节点会检测该 Follower 节点返回的相应响应，</p><ul><li>如果成功则更新相应该 Follower 节点对应的 <code>nextlndex</code> 值和<code>matchlndex</code> 值；</li><li>如果因为日志不一致而失败，则减少 <code>nextlndex</code> 值重试</li></ul><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230626172915420.png" alt="image-20230626172915420" style="zoom:50%;" /><p>A 作为 Leader 节点记录了 <code>nextlnde</code> 和 <code>matchlndex</code>，所以 A 应该知道向 B 、C 节点发送哪日志</p><p>Raft 协议采用批量发送的方式，当B、C 收到 Append Entries 消息后将日志记录到本地 Log 中，然后向 Leader 节点返回追加日志成功的响应，Leader 节点收到响应之后会递增节点对应的<code>nextlndex</code> 、<code>matchlnde</code> 这样，Leader 节点就知道下次发送日志的位置</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230626173725246.png" alt="image-20230626173725246" style="zoom:50%;" /><p>上面是 Leader 的情况，当 Leader 从 A 切换到 B，B 并不知道 Leader 节点记录 <code>nextlndex</code>、<code>matchlndex</code> 信息 ，所以新 Leader 节点<strong>会重置 nextlndex、matchlnd</strong> ，其中会将 <code>nextlndex</code> 全部重置为其自身 Log 的最后一条己提交日志的 Index，而 <code>matchlndex</code> 全部重置为 0</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230626173850377.png" alt="image-20230626173850377" style="zoom:50%;" /><p>新任期中的 Leader 节点向其他节点发送 Append Entrie 消息，拥有了当前 Leader 全部日志记录，会返回追加成功的响应并等后续的日志，而 C 没有 Index=2 Index=3 两条日志，所以追加日志失败的响应， Leader 节点会将 <code>nextindex</code> 前移</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230626174033113.png" alt="image-20230626174033113" style="zoom:50%;" /><p>然后新 Leader 会再次尝试发送 append entries 消息，循环往复，不断减小 nextlndex值，直至节点C 返回追加成功的响应，之后就进入了正常追加消息记录的流程</p><h4 id="日志判断"><a class="markdownIt-Anchor" href="#日志判断"></a> 日志判断</h4><p>那么又是如何判断两条日志是相同的呢，可能两个节点的 log index 相同但是内容并不相同</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312211352.png" alt="image-20220312211352566" style="zoom:50%;" /><p>raft 中的每个日志记录都带有 term 和 log index 来唯⼀标识，日志记录具有两个特性</p><ul><li>如果两条不同节点的某两个日志记录具有相同的 term 和 index 号，则两条记录⼀定是完全相同的 ;</li><li>如果两条不同节点的某两个日志记录具有相同的 term 和 index 号，则两条记录之前的所有记录也⼀定是完全相同的 ;</li></ul><p>以此来判断 leader与 follower 之间的日志是否相同</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312210348.png" alt="image-20220312210348704" style="zoom:50%;" /><ul><li>leader 从来不会覆盖，删除或者修改其日志 ;</li><li>若 follower 对比其前⼀条 log 不⼀致，则会拒绝 leader 发来的请求. 此时 leader 就将其在 <code>nextIndex[]</code> 中的对应值减⼀</li><li>leader 按照自身日志顺序将日志正常复制给 follower，并不断将 nextIndex[] 对应 值 +1，直到对应值 “追上” 自身日志的 index 为⽌;</li></ul><blockquote><p>问题 1：为什么要一个一个对比，而不直接找到对应的位置，批量复制？</p><p>答：通过数组存储的是索引，但是日志比较是通过 index 与 term</p></blockquote><p>所以，在选举过程中，Follower 节点还需要比较该 Candidate 节点的日志记录与自身的日志记录，拒绝那些日志没有自己新的 Candidat 节点发来的投票请求，确保将选票投给包含了全部己提交(Commited)日志记录的 Candidate 节点</p><p>Raft 协议通过较两节点日志中的最后一条日志记录的索引值和任期号，以决定谁的日志比较新</p><ul><li>首先比较最后一条日志记录的任期号，如果最后的日志记录的任期号不同，那么任期号大的日志记录比较新：</li><li>如果最后一条日志记录的任期号相同，那么日志索引较大的比较新</li></ul><h4 id="复制异常"><a class="markdownIt-Anchor" href="#复制异常"></a> 复制异常</h4><p><strong>场景1</strong>：两个Follower 节点不可用，Leader 如何处理请求</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312201120.png" alt="image-20220312201120077" style="zoom:50%;" /><ul><li><p>leader 通过⼼跳已知 follower 已挂, 则直接返回错误 ;</p></li><li><p>leader 不知节点已挂, 同步数据时得知异常; 触发异常触发超时</p></li></ul><p><strong>场景2</strong>： 提交给Leader后，发生了crash</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312201343.png" alt="image-20220312201343089" style="zoom:50%;" /><ul><li><p>leader 本地已记录已提交日志, 重启后强制同步新 leader 数据 ;</p></li><li><p>leader 还没记录未提交日志就crash, 丢了就丢了;</p></li></ul><p><strong>场景3</strong>：复制给 follower-1 后, leader就发⽣了 crash ?</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312202452.png" alt="image-20220312202452036" style="zoom:50%;" /><ul><li>leader 发⽣了重启，集群触发新的选举 ;</li><li>由于 follower-1 的数据较新, 那么该节点会晋升 leader ;</li><li>follower-1 会把 uncommited 的 v=3 同步给其他节点 ;</li><li>follower-1 收到其他节点接收确认后, 进⾏提交日志 ;</li></ul><p><strong>场景4</strong>：follower 返回确认消息时, leader 发⽣了 crash ?</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312202600.png" alt="image-20220312202600126" style="zoom:50%;" /><ul><li>三个节点的数据已经⼀致, 都为 uncommited v=3 ; 这时谁当 Leader 都可以 ; 新leader当选后, 需要进⾏同步提交通知 ;</li></ul><h3 id="脑裂问题"><a class="markdownIt-Anchor" href="#脑裂问题"></a> 脑裂问题</h3><p>脑裂问题是原本一个集群，被分成了两个集群，同时出现了两个“大脑”，这就是所谓的“脑裂”现象</p><p>出现脑裂的情况：</p><ol><li><p>两边都得到过半票数而选举出Leader的情况，不可能出现</p></li><li><p>两边都无法得到过半票数而无法选举出Leader的情况，则服务端会返回客户端集群不可用</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312195949.png" alt="image-20220312195949615" style="zoom:50%;" /></li><li><p>第三种情况：Leader 与 其他节点通信异常，导致其他节点重新选出 Leader</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230626175732437.png" alt="image-20230626175732437" style="zoom:50%;" /><p>由于 E 能收到超过半数的节点选举票 3 而成为新的 Leader，而 A 、B 会发起 PreVote 因为无法获取半数响应，所以不会触发选举</p><h3 id="客户端交互"><a class="markdownIt-Anchor" href="#客户端交互"></a> 客户端交互</h3><p>集群中只有 Leader 点可以处理客户端发来的请求，当  follower 节点收到客户端的请求时，也须将 Leader 信息告知客户端，然后由 Leader 点处理其请求，具体步骤如下：</p><ol><li>当客户端初次 接到集群时， 会随机挑选个服务器节点进行通信</li><li>如果客户端第一次挑选的节点不是 Leader 节点 ，那么该节点会拒绝客户端的请求，并且将它所知道的 Leader 节点的信息返回给客户端。</li><li>当客户端连接到 Leader 节点之后，即可发送消息进行交互</li><li>如果在交互过程中 Leader 节点宕机，那么客户端的请求会超时，客户端会再次随挑选集群中的节点，并从步骤2重新开始执行</li></ol><p><strong>异常 1</strong>：发生脑裂</p><p>与节点之间发生网络分区之后，客户端发往节点 A 请求将会超时，这是因为节点 A 无法将请求发送到集群中超过半数的节点 ，该请求相应的日志记录也就无法提交，从而导致无法给客户端返回相应的响应</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230626181508973.png" alt="image-20230626181508973" style="zoom:50%;" /><p><strong>异常 2</strong>：Leader 与其他节点通信异常</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/20220313111102.png" alt="image-20220313111102564" style="zoom:40%;" /><ul><li>由于 leader A ⽆法同步数据到多数节点, 造成 client 写请求失败 ;</li><li>⽹络分区后 follower c 长时间未收到⼼跳, 则触发选举且当选 ;</li><li>client 按照策略⼀直尝试跟可用的节点进⾏请求 ;</li><li>当⽹络恢复后, leader A B 将降为 follower, 并且强制同步 Leader C 的数据 ;</li></ul></li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li>《ETCD技术内幕》</li><li><a href="http://www.xuyasong.com/?p=1706" target="_blank" rel="noopener">http://www.xuyasong.com/?p=1706</a></li><li><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习分布式系统过程中，经常能碰到一致性算法，即使出现部分节点故障，网络延时等情况，也不影响整体可用性，进而提高系统的整体可用性。Raft协议是一种分布式一致性算法(共识算法)，共识就是多个节点对某一个事件达成一致的算法，常见的一致性协议有Raft、Paxos、ZAB，根据
      
    
    </summary>
    
    
      <category term="Protocol" scheme="https://www.yuankang.top/categories/Protocol/"/>
    
    
      <category term="ETCD" scheme="https://www.yuankang.top/tags/ETCD/"/>
    
      <category term="Distributed System" scheme="https://www.yuankang.top/tags/Distributed-System/"/>
    
      <category term="Raft" scheme="https://www.yuankang.top/tags/Raft/"/>
    
  </entry>
  
  <entry>
    <title>Go-15-SyncMap</title>
    <link href="https://www.yuankang.top/2023/04/04/Go/Go-15-SyncMap/"/>
    <id>https://www.yuankang.top/2023/04/04/Go/Go-15-SyncMap/</id>
    <published>2023-04-04T13:01:05.349Z</published>
    <updated>2023-07-15T05:37:13.807Z</updated>
    
    <content type="html"><![CDATA[<p>一开始以为 <code>Sync.Map</code> 仅仅是封装的了一层，后来在与同事的讨论中发现并不是这样，这里重新学习一下源码</p><h3 id="线程安全"><a class="markdownIt-Anchor" href="#线程安全"></a> 线程安全</h3><p>首先搞清楚一个问题，什么是并发安全。由于没有完整的解释，我找了一段Java中的表达</p><blockquote><p>当多个线程访问某个类时，不管运行环境采用何种调度方式或者这些进程将如何交替执行，并且在主调代码中不需要任何额外的协同或者同步，这个类都能表现出正确的行为，那么这个类是线程安全的</p></blockquote><p>大致抓住两点 <strong>无论如何交替执行</strong> <strong>表现出正确的行为</strong>，有点抽象，反过来问 <strong>什么情况会导致线程不安全</strong>？<strong>怎样才能保证线程安全？</strong></p><p><u>当前的一个操作可能不是原子的，执行过程中会被打断，其他线程有能力修改共享变量的值，同时存在线程修改的值不是立即对其他线程可见的，因为线程有自己的执行空间，另外一点就是存在程序可能存在乱序执行的情况，单线程没问题，但是多个线程同时执行，线程共享的数据会出现错乱</u>。那么保证线程安全的三个特征：</p><ul><li><strong>原子性</strong>：提供互斥访问、同一时刻只能有一个线程在操作</li><li><strong>可见性</strong>：一个线程对主内容的修改可以及时被其他线程看到</li><li><strong>有序性</strong>：程序在执行的时候，程序的代码执行顺序和语句的顺序是一致的有序性<ul><li>多个协程并发执行，那么<strong>几个协程之间是没有有序性的</strong>，但是协程里面的代码是有序的</li><li>什么情况下代码的执行顺序与语句顺序不一致？比如指令重排序，将多次访问主存合并到一起执行</li></ul></li></ul><p>这样就好理解为啥普通的map会存在并发安全问题了，因为一个协程的修改对于另外一个协程可能是不可见的。另外当map并发读写时候触发的panic是map内部实现的，结构体的并发读写只会报错不会panic。</p><h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3><p>普通的map并发处理实践</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="keyword">struct</span>&#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>sync.Map</code> 则可以</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter sync.Map</span><br></pre></td></tr></table></figure><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>源码：<code>src/sync/map.go</code></p><p>为了实现并发安全的Map，<code>Sync.Map</code>实现了一种读写分离的方式</p><ol><li>空间换时间。 通过冗余的两个数据结构(read、dirty),实现加锁对性能的影响。</li><li>动态调整，miss次数多了之后，将dirty数据提升为read。</li><li>double-checking，因为是判断与获取并不是原子操作，所以会出现 double-checking</li><li>延迟删除。 删除一个键值只是打标记，只有在提升dirty的时候才清理删除的数据。</li><li>优先从read读取、更新、删除，因为对read的读取不需要锁。</li></ol><p><strong>问题1</strong>：如何在并发情况下修改或删除已经存在的Key？</p><p>答：通过将 key 映射到 val 的地址，然后 val 指针指向真正的值，那么只需要保证 <code>address</code> 指针的原子操作，就能解决并发安全问题</p><blockquote><p>key -&gt; &amp;地址 --&gt; 真正的值</p></blockquote><p><strong>问题2</strong>：如何在写的同时保证读的准确性</p><p>答：读写指向的是同一个指针，首先在写时会通过互斥锁防止并发操作 <code>dirty</code>，其次就是用到了<code>atomic</code>原子操作<code>value</code>指针</p><p><strong>问题3</strong>：如果读写分离，如何将写入的数据同步到读中</p><p>答： 1. 第一种是当<code>misses == len(dirty)</code>的时候就会升级<code>dirty</code>到<code>read</code>中；第二种就是在遍历的如果<code>dirty</code>有<code>read</code>中没有的数据；</p><p>第三其实也不是读写分离，而是乐观锁，因为如果<code>read</code>中已经有key/val，也会尝试去更新<code>read</code>，发现已经删除，则去dirty中更新</p><p>最后的实现就变成了下面这个样子</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/20200505120255.png" alt="sync.map 整体结构" style="zoom:50%;" /><p><strong>问题4</strong>：指向的是同一个<code>entry</code>，不还是一样需要加锁吗？内部 的<code>mutex</code> 与 <code>atomic.pointer</code>的区别跟作用又是什么？</p><p><code>mutex</code> 与 <code>atomic</code> 的区别是：<code>mutex</code> 通过阻塞其他协程起到了原子操作的功能，是用来保护 dirty 的读写的。而<code>atomic</code>是通过CPU指令，来达到值操作的原子性，所以 <code>atomic</code>与<code>mutex</code>并不是一个层面的东西，<code>atomic</code>也比<code>mutex</code>更快。</p><p>所以才会出现 <code>mutex</code> 保护的是 <code>dirty</code>，而 <code>atomic</code> 保护的是 <code>entry</code> 具体值</p><h4 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h4><p>定义的 <code>Map</code> 中 除普通的map 与 互斥锁，还增加了两个字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">//当涉及到dirty的操作的时候，需要使用这个锁</span></span><br><span class="line">   mu Mutex</span><br><span class="line">  <span class="comment">// 一个只读结构(实际也会更新这个数据的entries，标记为未删除的unexpunger)</span></span><br><span class="line">   read atomic.Pointer[readOnly]</span><br><span class="line">  <span class="comment">// dirty包含最新的entries(包括read中未删除的数据,虽有冗余，但也提升dirty字段为read的时候非常快，不用一个一个的复制，而是直接将这个数据结构作为read字段的一部分),有些数据还可能没有移动到read字段中。</span></span><br><span class="line"><span class="comment">// 对于dirty的操作需要加锁，因为对它的操作可能会有读写竞争。</span></span><br><span class="line"><span class="comment">// 当dirty为空的时候， 比如初始化或者刚提升完，下一次的写操作会复制read字段中未删除的数据到这个数据中。</span></span><br><span class="line">   dirty <span class="keyword">map</span>[any]*entry</span><br><span class="line">  <span class="comment">// 当从Map中读取entry的时候，如果read中不包含这个entry,会尝试从dirty中读取，这个时候会将misses加一，</span></span><br><span class="line"><span class="comment">// 当misses累积到 dirty的长度的时候， 就会将dirty提升为read,避免从dirty中miss太多次。因为操作dirty需要加锁</span></span><br><span class="line">   misses <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中存在两个结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">m       <span class="keyword">map</span>[any]*entry</span><br><span class="line">amended <span class="keyword">bool</span> <span class="comment">// 为true 表示dirty中存在一些新增的键值对</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基本"><a class="markdownIt-Anchor" href="#基本"></a> 基本</h4><ol><li><code>read</code> 与 <code>dirty</code> 的转换</li><li><code>entry</code>的操作</li></ol><h5 id="entry"><a class="markdownIt-Anchor" href="#entry"></a> entry</h5><p><code>entry</code> 代表的是每个 key 在<code>Map</code>中对应的一个 <code>entry</code>，并且还记录了 <strong>其他信息</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">p atomic.Pointer[any]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> expunged = <span class="built_in">new</span>(any) <span class="comment">//</span></span><br></pre></td></tr></table></figure><p><code>p</code> 一共记录林 <code>entry</code> 的三种状态</p><ol><li><code>nil</code>: <code>entry</code>已被删除了，并且<code>m.dirty</code>为<code>nil</code></li><li><code>expunged</code>: <code>entry</code>已被删除了，并且<code>m.dirty</code>不为<code>nil</code>，而且这个<code>entry</code>不存在于<code>m.dirty</code>中</li><li>其它： <code>entry</code>是一个正常的值</li></ol><p>构建一个 <code>entry</code> 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newEntry</span><span class="params">(i any)</span> *<span class="title">entry</span></span> &#123;</span><br><span class="line">   e := &amp;entry&#123;&#125;</span><br><span class="line">   e.p.Store(&amp;i)</span><br><span class="line">   <span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">load</span><span class="params">()</span> <span class="params">(value any, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">p := e.p.Load()</span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;<span class="comment">//表示不存在</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *p, <span class="literal">true</span><span class="comment">//表示存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>entry</code> 使用 <code>atomic.Pointer[n]</code> 的作用在后面才体现出来, <code>atomic.Pointer</code> 原子地读取和存储指针类型的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">trySwap</span><span class="params">(i *any)</span> <span class="params">(*any, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      p := e.p.Load()</span><br><span class="line">      <span class="keyword">if</span> p == expunged &#123;<span class="comment">//如果已经被删除则返回false</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> e.p.CompareAndSwap(p, i) &#123;<span class="comment">//否则不断的CAS更新</span></span><br><span class="line">         <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h4><p>操作与正常的map类似，包含 存储、获取、删除、遍历。除此之外还增加的 交换、比较交换、比较删除</p><h5 id="获取"><a class="markdownIt-Anchor" href="#获取"></a> 获取</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Load</span><span class="params">(key any)</span> <span class="params">(value any, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1.首先从m.read中得到只读readOnly,从它的map中查找，不需要加锁</span></span><br><span class="line">  read := m.loadReadOnly()</span><br><span class="line">e, ok := read.m[key]</span><br><span class="line">  <span class="comment">//2. 如果没找到，并且m.dirty中有新数据，需要从m.dirty查找，这个时候需要加锁</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123; <span class="comment">// a 操作</span></span><br><span class="line">m.mu.Lock()  <span class="comment">//b 操作</span></span><br><span class="line">    <span class="comment">//双检查，避免加锁的时候m.dirty提升为m.read,这个时候m.read可能被替换了。</span></span><br><span class="line">read = m.loadReadOnly()</span><br><span class="line">e, ok = read.m[key]</span><br><span class="line">    <span class="comment">// 如果m.read中还是不存在，并且m.dirty中有新数据</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">      <span class="comment">// 从m.dirty查找</span></span><br><span class="line">e, ok = m.dirty[key]</span><br><span class="line">      <span class="comment">// 不管m.dirty中存不存在，都将misses计数加一</span></span><br><span class="line"><span class="comment">// missLocked()中满足条件后就会提升m.dirty</span></span><br><span class="line">m.missLocked()</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个注意事项</p><ol><li><p>出现double-check，是因为在执行 <code>if !ok &amp;&amp; read.amended</code> 的过程中，dirty可能升级为read，所以还是需要锁操作</p></li><li><p>不管 m.dirty中是否存在，都需要misses+1，表明 read中不存在才到 dirty中获取</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">missLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">m.misses++</span><br><span class="line"><span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">m.read.Store(&amp;readOnly&#123;m: m.dirty&#125;)<span class="comment">//直接将dirty升级到read中，然后</span></span><br><span class="line">m.dirty = <span class="literal">nil</span></span><br><span class="line">m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>什么时候讲dirty提升为 read，当 <code>misses &gt;= len(m.dirty)</code></p><h5 id="存储"><a class="markdownIt-Anchor" href="#存储"></a> 存储</h5><p>从接口实现可以看出，存储 k/v 内部使用的其实 Swap 接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Store</span><span class="params">(key, value any)</span></span> &#123;</span><br><span class="line">   _, _ = m.Swap(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接查看 <code>Swap</code> 的实现原理</p><p>根据描述，<code>Swap</code> 的作用是 将 <code>newValue</code> 更新入 <code>key</code> 所对应的 <code>value</code>中，并将 <code>oldValue</code> 返回。另外一个返回值<code>loaded</code>表示 <code>key</code> 是否存在</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Swap</span><span class="params">(key, value any)</span> <span class="params">(previous any, loaded <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 如果m.read存在这个键，并且这个entry没有被标记删除，尝试直接存储。</span></span><br><span class="line"><span class="comment">// 因为m.dirty也指向这个entry,所以m.dirty也保持最新的entry。</span></span><br><span class="line">   read := m.loadReadOnly()</span><br><span class="line">   <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;<span class="comment">//如果只读存在</span></span><br><span class="line">      <span class="keyword">if</span> v, ok := e.trySwap(&amp;value); ok &#123;<span class="comment">//尝试去更新value，如果未 标记删除</span></span><br><span class="line">         <span class="keyword">if</span> v == <span class="literal">nil</span> &#123;<span class="comment">//value为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> *v, <span class="literal">true</span><span class="comment">//更新成功 返回 true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   m.mu.Lock()<span class="comment">// 加锁，如果`m.read`不存在或者已经被标记删除</span></span><br><span class="line">   read = m.loadReadOnly()</span><br><span class="line">   <span class="keyword">if</span> e, ok := read.m[key]; ok &#123; <span class="comment">//只读存在</span></span><br><span class="line">     <span class="keyword">if</span> e.unexpungeLocked() &#123;<span class="comment">//如果未标记删除则删除read,然后存入dirty(写数据到dirty中)</span></span><br><span class="line">         m.dirty[key] = e<span class="comment">//存入 dirty</span></span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">if</span> v := e.swapLocked(&amp;value); v != <span class="literal">nil</span> &#123;<span class="comment">//未标记删除则直接更新read</span></span><br><span class="line">         loaded = <span class="literal">true</span></span><br><span class="line">         previous = *v</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;<span class="comment">//只读不存在但是dirty存在</span></span><br><span class="line">      <span class="keyword">if</span> v := e.swapLocked(&amp;value); v != <span class="literal">nil</span> &#123;</span><br><span class="line">         loaded = <span class="literal">true</span></span><br><span class="line">         previous = *v</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;<span class="comment">//都不存在</span></span><br><span class="line">      <span class="keyword">if</span> !read.amended &#123;<span class="comment">//dirty中没有新值</span></span><br><span class="line">         m.dirtyLocked()<span class="comment">//如果dirty为空，从 m.read中复制未删除的数据</span></span><br><span class="line">         m.read.Store(&amp;readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;) <span class="comment">//read中存储</span></span><br><span class="line">      &#125;</span><br><span class="line">      m.dirty[key] = newEntry(value)<span class="comment">//dirty 存储一个新的 value地址</span></span><br><span class="line">   &#125;</span><br><span class="line">   m.mu.Unlock()</span><br><span class="line">   <span class="keyword">return</span> previous, loaded</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>dirtyLocked的</code>作用是将未删除的复制到<code>dirty</code>中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">dirtyLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;<span class="comment">//如果不为空直接返回</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   read := m.loadReadOnly()</span><br><span class="line">   m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[any]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line">   <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">      <span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">         m.dirty[k] = e</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">tryExpungeLocked</span><span class="params">()</span> <span class="params">(isExpunged <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   p := e.p.Load()<span class="comment">//加载entry中的地址</span></span><br><span class="line">   <span class="keyword">for</span> p == <span class="literal">nil</span> &#123;<span class="comment">//如果为空</span></span><br><span class="line">      <span class="keyword">if</span> e.p.CompareAndSwap(<span class="literal">nil</span>, expunged) &#123;<span class="comment">//尝试使用 expunged更新状态</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      p = e.p.Load()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> p == expunged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Delete</span><span class="params">(key any)</span></span> &#123;</span><br><span class="line">m.LoadAndDelete(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">LoadAndDelete</span><span class="params">(key any)</span> <span class="params">(value any, loaded <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//先从read中加载</span></span><br><span class="line">read := m.loadReadOnly()</span><br><span class="line">e, ok := read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;<span class="comment">//read没有且dirty中有新数据</span></span><br><span class="line">    <span class="comment">//开启锁</span></span><br><span class="line">m.mu.Lock()</span><br><span class="line">read = m.loadReadOnly()</span><br><span class="line">e, ok = read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;<span class="comment">//如果read没有，则dirty中有新数据</span></span><br><span class="line">e, ok = m.dirty[key]</span><br><span class="line"><span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">      m.missLocked()<span class="comment">//当misses数量达到 len(m.dirty),dirty升级为read</span></span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">return</span> e.<span class="built_in">delete</span>()<span class="comment">//如果read存在则标记删除</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果read中存在，那么仅会标记删除</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">delete</span><span class="params">()</span> <span class="params">(value any, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      p := e.p.Load()</span><br><span class="line">      <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;<span class="comment">//如果为空或者标记删除，返回没有数据</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> e.p.CompareAndSwap(p, <span class="literal">nil</span>) &#123;<span class="comment">//标记为nil，并不会直接删除</span></span><br><span class="line">         <span class="keyword">return</span> *p, <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遍历"><a class="markdownIt-Anchor" href="#遍历"></a> 遍历</h5><p>因为是读写分离，所以在遍历的过程中</p><ol><li>如果dirty中没有新数据，那么就使用read遍历</li><li>如果dirty中有新数据，那么就将dirty升级为read，然后遍历read</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Range</span><span class="params">(f <span class="keyword">func</span>(key, value any)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">   <span class="comment">//判断dirty是否有新值</span></span><br><span class="line">   read := m.loadReadOnly()</span><br><span class="line">   <span class="keyword">if</span> read.amended &#123;</span><br><span class="line">      m.mu.Lock()<span class="comment">//开锁</span></span><br><span class="line">      read = m.loadReadOnly()</span><br><span class="line">      <span class="keyword">if</span> read.amended &#123;<span class="comment">//dirty是否有新值</span></span><br><span class="line">         read = readOnly&#123;m: m.dirty&#125;</span><br><span class="line">         m.read.Store(&amp;read)<span class="comment">//升级dirty为read</span></span><br><span class="line">         m.dirty = <span class="literal">nil</span></span><br><span class="line">         m.misses = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">      m.mu.Unlock()</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//遍历read</span></span><br><span class="line">   <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">      v, ok := e.load()</span><br><span class="line">      <span class="keyword">if</span> !ok &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> !f(k, v) &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3><ol><li><p>该map仅针对特定的场景</p><ul><li>Key 读多写少的情况，例如只增长的缓存</li><li>多个协程针对不同的key合集进行读写更新时候可以用</li><li>sync.Map 不能在第一次使用后复制</li></ul></li><li><p>由于dirty达到一定条件就需要升级为read，所以适用读多写少的场景</p></li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://www.cnblogs.com/qcrao-2018/p/12833787.html" target="_blank" rel="noopener">https://www.cnblogs.com/qcrao-2018/p/12833787.html</a></li><li><a href="https://colobu.com/2017/07/11/dive-into-sync-Map/#sync-Map%E7%9A%84%E6%80%A7%E8%83%BD" target="_blank" rel="noopener">https://colobu.com/2017/07/11/dive-into-sync-Map/#sync-Map的性能</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一开始以为 &lt;code&gt;Sync.Map&lt;/code&gt; 仅仅是封装的了一层，后来在与同事的讨论中发现并不是这样，这里重新学习一下源码&lt;/p&gt;
&lt;h3 id=&quot;线程安全&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线程安全&quot;&gt;&lt;/a&gt; 线程安全&lt;
      
    
    </summary>
    
    
      <category term="Go" scheme="https://www.yuankang.top/categories/Go/"/>
    
    
      <category term="Go" scheme="https://www.yuankang.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go-24-协程池问题</title>
    <link href="https://www.yuankang.top/2023/03/05/Go/Go-24-%E5%8D%8F%E7%A8%8B%E6%B1%A0%E9%97%AE%E9%A2%98/"/>
    <id>https://www.yuankang.top/2023/03/05/Go/Go-24-%E5%8D%8F%E7%A8%8B%E6%B1%A0%E9%97%AE%E9%A2%98/</id>
    <published>2023-03-05T06:46:45.000Z</published>
    <updated>2023-07-15T05:38:02.316Z</updated>
    
    <content type="html"><![CDATA[<p>之前在整理 <a href="https://www.yuankang.top/2022/07/06/GoZero/GoZero4-%E5%8D%8F%E7%A8%8B%E6%B1%A01/">GoZero4-协程池</a>的过程中发现 <a href="https://github.com/bytedance/gopkg/tree/develop/util/gopool" target="_blank" rel="noopener">字节跳动开源的协程池</a>在使用中需要注意的地方：</p><p>​<strong>使用双向链表存储任务，表示它理论上支持无限个任务。后面的任务可能存在长时间等待的情况，并不存在任务过期处理逻辑</strong></p><p>没想到在实际应用中真的没注意踩了一遍，这里记录一下这个原因与后续的解决思路，排查过程就不赘述了。</p><p>伪代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Send</span><span class="params">(conn *grpc.ClientConn)</span></span> &#123;</span><br><span class="line">c := pb.NewGreeterClient(conn)</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">3</span>*time.Second)</span><br><span class="line"></span><br><span class="line">gopool.CtxGo(ctx, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="comment">//1. 通信消息自定义处理</span></span><br><span class="line">Handle(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 发送消息</span></span><br><span class="line">_, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: *name&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"could not greet: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="comment">//log.Printf("end success")</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">5</span>):</span><br><span class="line">log.Printf(<span class="string">"time out"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题原因</strong>：负责底层通信的 grpc-go(进行过二次开发) 使用了上述的协程池进行发送接口的超时控制。当突然大量的消息进入，消息接受速率 大于 消息发送-响应速率。导致过量的消息全部堆积到这个双向链表中，而本身消息是有超时时间的，就导致堆积的消息越来越多，消息等到发送的时候已经超时了，所以就出现了服务OOM，消息也无法发送出去。</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/%E5%8D%8F%E7%A8%8B%E6%B1%A0%E9%97%AE%E9%A2%982.png" alt="协程池问题2" style="zoom:50%;" /><p>类似上图所示，模拟客户端通过协程池的发送协程 <strong>work</strong> 实现超时控制消息任务 <strong>t</strong> 的发送</p><ul><li>第一阶段，发送协程 <strong>work</strong> 的消费速率 大于 消息任务 <strong>t</strong> 的生产速率，一切正常</li><li>第二阶段，发送协程 <strong>work</strong> 的消费速率 小于 消息任务 <strong>t</strong> 的生产速率的时候，消息开始在双向链表中堆积，出现内存快速增长</li><li>第三阶段，当 消息任务 <strong>t</strong> 的堆积 超过自定义超时时间的时候，所有消息都发送超时失败</li><li>第四阶段，当 双向链表中的任务堆积导致内存超时服务上限的时候，服务OOM</li></ul><p>这里产生了如下几个思考</p><ol><li>能否在任务双向链表中限制数量大小当发送超过限制的时候直接失败?</li><li>为什么不直接使用管道来代替底层的双向链表？</li><li>能否自动丢弃超时的消息并返回结果，注意这个时候是在协程里面运行的</li><li>如何像linux一样保存 pod因为OOM而产生的core方便后续分析</li></ol><p>第一个问题是可以解决的，协程池对象存在 taskCount 记录当前任务数量，也就是说可以增加协程池容量判断来达到限制目的</p><ul><li>增加协程池任务容量字段 <code>taskCap</code></li><li>增加接口，协程失败返回错误 error</li><li>添加协程池容量判断</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pool)</span> <span class="title">CtxGo2</span><span class="params">(ctx context.Context, f <span class="keyword">func</span>()</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">  cur := atomic.AddInt32(&amp;p.taskCount, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> cur &gt; p.taskCap &#123;<span class="comment">//当前任务容量判断</span></span><br><span class="line"><span class="keyword">return</span> errors.New</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个问题管道的缺点是管道数量是固定的，也就是达不到根据任务数量动态扩容 <code>work</code> 的功效</p><p>第三个问题由于任务放入协程中相当于异步处理，并不能直接将任务待执行超时的情况返回给客户端，可以通过自定义处理函数或者内部的panic处理任务超时的情况；但又能如何发现任务超时，时间轮貌似是个好东西</p><p>第四个问题找到<a href="https://juejin.cn/post/6844903792136159239" target="_blank" rel="noopener">一篇实践</a>，实操之后再单独记录</p><p>总结：</p><ol><li>我在使用过程中忽视了双向队列任务堆积的情况，令牌桶的使用也可能存在这样的情况(正常情况不会配置速率上千万的情况)，注意异常情况下的配置范围</li><li>上述需要改进与实操的部分尝试解决之后再来补充这边文章</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在整理 &lt;a href=&quot;https://www.yuankang.top/2022/07/06/GoZero/GoZero4-%E5%8D%8F%E7%A8%8B%E6%B1%A01/&quot;&gt;GoZero4-协程池&lt;/a&gt;的过程中发现 &lt;a href=&quot;https://g
      
    
    </summary>
    
    
      <category term="Go" scheme="https://www.yuankang.top/categories/Go/"/>
    
    
      <category term="Go" scheme="https://www.yuankang.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>算法-E10C-最大公约数</title>
    <link href="https://www.yuankang.top/2023/02/02/Algorithm/%E7%AE%97%E6%B3%95-E10C-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"/>
    <id>https://www.yuankang.top/2023/02/02/Algorithm/%E7%AE%97%E6%B3%95-E10C-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</id>
    <published>2023-02-02T12:25:25.494Z</published>
    <updated>2023-09-28T16:21:03.132Z</updated>
    
    <content type="html"><![CDATA[<p>今天碰到一道有意思的题目，学到了很多东西，所以记录一下</p><p><a href="https://leetcode.cn/problems/check-if-it-is-a-good-array/" target="_blank" rel="noopener">检查好数组</a></p><p>碰到之后完全不知道如何入手，最后通过看解答才弄明白，但是中间有很多知识点可以记录一下</p><p><strong>首先</strong> 需要知道裴蜀定理，又称贝祖定理，是一个最大公约数定理：设 a, b 是不全为零的整数，则存在整数 x , y , 使得</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ax + by = gcd(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span></p><ol><li><p>若任何一个等于0，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">gcd(a, b) == a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span></p></li><li><p>对任何整数a、b和它们的最大公约数d，关于未知数x和y的线性丢番图方程</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">ax + by = m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span></span></p><p>有解当前仅当 m 是 d 的倍数</p></li></ol><blockquote><p>这里有一个奇特的点 0 因为没有因数，所以 0 不与其他数存在最大公约数，等我看了 类欧几里德算法 再补充</p></blockquote><p>所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ax + by = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 有解，那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(a, b) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><p>其次 我们如何求一个两个数的最大公约数，经典的 <strong>辗转相除法</strong>(又称 <strong>欧几里德算法</strong>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以使用现有函数 gcd(a, b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b ? GCD(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>证明 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a, b) = gcd(b, a \% b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 过程如下</p><ol><li><p>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi><mi>k</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a = bk + c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>，所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">c = a \% b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span></span></span></span></p></li><li><p>设 d 是 a , b 的公约数</p></li><li><p>所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>=</mo><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>∗</mo><mi>k</mi><mo>+</mo><mi>c</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">a / d = b / d * k + c / d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span></p></li><li><p>因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">a / d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">b / d * k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 是整数，所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">c / d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span> 也是整数</p></li><li><p>将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">c = a \% b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span></span></span></span> 带入第3步得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>−</mo><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>∗</mo><mi>k</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">a / d - b / d * k = a \% b / d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span>，因为 左边是整数，所有等式右边也是整数</p></li><li><p>那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>+</mo><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">a / d = a \% b / d + b / d * k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，那么 d 也是  b, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">a \% b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span></span></span></span> 的约数，也是 a, b 的约数</p></li><li><p>尽然两式的公约数是相同的，那么最大公约数也会相同</p></li><li><p>所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a, b) = gcd(b, a mod b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p></li></ol><p>最后就是这个题目的解答</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b ? Gcd(b, a % b) : a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isGoodArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//1与任意正整数的最大公约数是1</span></span><br><span class="line">            v = Gcd(nums[i], v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://oi-wiki.org/math/number-theory/gcd/" target="_blank" rel="noopener">https://oi-wiki.org/math/number-theory/gcd/</a></li><li><a href="https://leetcode.cn/problems/check-if-it-is-a-good-array/" target="_blank" rel="noopener">https://leetcode.cn/problems/check-if-it-is-a-good-array/</a></li><li><a href="https://oi-wiki.org/math/number-theory/bezouts/" target="_blank" rel="noopener">https://oi-wiki.org/math/number-theory/bezouts/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天碰到一道有意思的题目，学到了很多东西，所以记录一下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/check-if-it-is-a-good-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;检查好
      
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://www.yuankang.top/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="https://www.yuankang.top/tags/Algorithms/"/>
    
  </entry>
  
</feed>
