<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XBoom Dove</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xboom.github.io/"/>
  <updated>2023-07-29T07:17:28.850Z</updated>
  <id>http://xboom.github.io/</id>
  
  <author>
    <name>XBoom Dove</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CPP-06-指针</title>
    <link href="http://xboom.github.io/2023/07/29/C++/CPP-06-%E6%8C%87%E9%92%88/"/>
    <id>http://xboom.github.io/2023/07/29/C++/CPP-06-%E6%8C%87%E9%92%88/</id>
    <published>2023-07-29T07:17:29.000Z</published>
    <updated>2023-07-29T07:17:28.850Z</updated>
    
    <content type="html"><![CDATA[<p>指针是一个变量，其存储的是值的地址，而不是值本身</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p_updates;</span><br></pre></td></tr></table></figure><ul><li><code>* p_updates</code> 的类型为 <code>int</code>，不是指针</li><li><code>p_updates</code> 的类型是 <code>int *</code>，是指向 <code>int</code> 的指针</li></ul><p>指针在地址中的存储格式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ducks = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> *birddog = &amp;ducks;</span><br></pre></td></tr></table></figure><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/cpp_pointer_06_0729.png" alt="cpp_pointer_06_0729" style="zoom:50%;" /><p><code>ducks</code> 的地址是 <code>0x1000</code>，存储的值是 12。而 <code>birddog</code> 的地址是 <code>0x1006</code>，存储的值就是 <code>ducks</code> 的地址 <code>0x1000</code></p><p>指针变量的声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> *p1, p2, *p3;</span><br><span class="line">p1 = &amp;a;</span><br><span class="line">p3 = &amp;a;</span><br><span class="line">*p1 = <span class="number">100</span>;</span><br><span class="line">p2 = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p1 &lt;&lt; <span class="string">" "</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;p2 &lt;&lt; <span class="string">" "</span> &lt;&lt; p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p3 &lt;&lt; <span class="string">" "</span> &lt;&lt; *p3 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">0x7ff7b7a6b458</span> <span class="number">100</span></span><br><span class="line"><span class="number">0x7ff7b7a6b44c</span> <span class="number">200</span></span><br><span class="line"><span class="number">0x7ff7b7a6b458</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><p>从结果来看：</p><ol><li>声明的时候 <code>int *p1, p2;</code>，声明的是两种类型</li><li>当两个指针指向同一个地址时，修改一个会影响另外一个</li></ol><p>既然是地址，是不是可以直接给地址复制，答案是可以的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p3;</span><br><span class="line"><span class="comment">//p3 = 0x7ff7b7a6b458; //incompatible integer to pointer conversion assigning to 'int *' from 'long'</span></span><br><span class="line">p3 = (<span class="keyword">int</span> *)<span class="number">0x7ff7b7a6b458</span></span><br></pre></td></tr></table></figure><p>不能直接将整型复制给指针，可通过类型转换赋值给 p3，但是会段错误(Segmentation fault)，即未知的地址</p><h3 id="new"><a class="markdownIt-Anchor" href="#new"></a> new</h3><p>在C语言中，可以 用库函数<code>malloc( )</code>来分配内存；在C<ins>中仍然可以这样做，但C</ins>还有<code>new</code>运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> night = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> *pt = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*pt = <span class="number">1001</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; night &lt;&lt; <span class="string">" "</span> &lt;&lt; *pt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(pt) &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="keyword">sizeof</span>(*pt) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1000 1001</span><br><span class="line">8 4</span><br></pre></td></tr></table></figure><p>地址本身只指出了对象存储地址的开始，而没有指出其类型(使用的字节数)。而通过</p><p>变量值都存储在被称为栈(stack)的内存区域中，而new从被称为堆(heap)或自由存储区(free store)的内存区域分配内存</p><p>在 C<ins>中，值为0的指针被称为空指针(null pointer)。C</ins>确保空指针不会指向有效的数据</p><p>归还或释放(<code>free</code>)的内存可供程序的其他部分使用。使用 <code>delete</code> 时，后面要加上指向内存块的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pt = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">delete</span>(pt);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">delete</span>(pt); <span class="comment">//malloc: Double free of object 0x7f822cf05ce0</span></span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7f93c3705ce0</span></span><br><span class="line"><span class="number">0x7f93c3705ce0</span></span><br></pre></td></tr></table></figure><ol><li><p>使用 <code>delete</code> 仅会释放内存块，但是不会将指针的地址置为空</p></li><li><p><code>new</code> 与 <code>delete</code> 需要配合使用，否则将发生内存泄露(<code>memory leak</code>)</p></li><li><p>不能重复释放已经释放的内存块</p></li></ol><p><code>delete</code> 不能删除一个不是 <code>new</code> 分配的内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *pt = &amp;a;</span><br><span class="line"><span class="keyword">delete</span> pt;</span><br></pre></td></tr></table></figure><p><code>delete</code> 能删除一个空指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pt2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">delete</span> pt2;</span><br></pre></td></tr></table></figure><h3 id="动态数组"><a class="markdownIt-Anchor" href="#动态数组"></a> 动态数组</h3><p>在编译时给数组分配内存被称为<strong>静态联编(static binding)</strong>，在编写程序时指定数组的长度，意味着数组是在编译时加入到程序中的</p><p>还可以在程序运行时选择数组的长度，被称为<strong>动态联编(dynamic binding)</strong>，程序将在运行时确定数组的长度，这种数组叫作<strong>动态数组(dynamic array)</strong></p><p>在C++中，创建动态数组，只要将数组的元素类型和元素数目告诉<code>new</code>即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *psome = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> []psome;</span><br><span class="line"><span class="comment">//delete psome; //'delete' applied to a pointer that was allocated with 'new[]';</span></span><br></pre></td></tr></table></figure><p>方括号告诉程序，应释放整个数组，而不仅仅是指针指向的元素。 <strong>注意<code>delete</code>和指针之间的方括号</strong></p><ul><li><p>如果使用<code>new</code>时，不带方括号，则使用<code>delete</code>时，也不应带方括号。</p></li><li><p>如果使用<code>new</code>时带方括号，则使用<code>delete</code> 时也应带方括号</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> * p1 = <span class="keyword">new</span> <span class="keyword">double</span> [<span class="number">3</span>];</span><br><span class="line">p1[<span class="number">0</span>] = <span class="number">0.2</span>;</span><br><span class="line">p1[<span class="number">1</span>] = <span class="number">0.3</span>;</span><br><span class="line">p1[<span class="number">2</span>] = <span class="number">0.8</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"p1[1] is "</span> &lt;&lt; p1[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">p1 = p1 + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Now p1[0] is "</span> &lt;&lt; p1[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"p1[1] is "</span> &lt;&lt; p1[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">p1 = p1 - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">delete</span> [] p1;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "p1[0] is " &lt;&lt; p1[0] &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1[1] is 0.3</span><br><span class="line">Now p1[0] is 0.3</span><br><span class="line">p1[1] is 0.8</span><br></pre></td></tr></table></figure><p>注意在释放指针的时候执行了 <code>p1 = p1 - 1;</code>否则会提示错误 <code>error for object 0x7fe25e705ce8: pointer being freed was not allocated</code></p><p><strong>将整数变量加 1 后，其值将增加1；但将指针变量加1后，增加的量等于它指向的类型的字节数</strong>。将指向<code>double</code>的指针加1后，如果系统对<code>double</code>使用8个字节存储，则数值将增加8；将指向short的指针加1后，如果系统对short使用2 个字节存储，则指针值将增加2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> wages[<span class="number">3</span>] = &#123;<span class="number">10000.0</span>, <span class="number">20000.0</span>, <span class="number">30000.0</span>&#125;;</span><br><span class="line">short stacks[<span class="number">3</span>] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> * pw = wages;</span><br><span class="line">short * ps = &amp;stacks[<span class="number">0</span>];</span><br><span class="line">short * ps2 = stacks;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *(pw + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *(ps + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *(ps2 + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">20000</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/cpp_pointer_1449_0729.png" alt="cpp_pointer_1449_0729" style="zoom:50%;" /><p>数组名被解释为其第一个元素的地址，而对数组名应用地址运算符时，得到的是整个数组的地址：</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li>不要使用<code>delete</code>来释放不是<code>new</code>分配的内存</li><li>不要使用<code>delete</code>释放同一个内存块两次</li><li>如果使用<code>new [ ]</code>为数组分配内存，则应使用<code>delete [ ]</code>来释放。</li><li>如果使用<code>new</code>为一个实体分配内存，则应使用<code>delete</code>（没有方括 号）来释放。</li><li>对空指针应用<code>delete</code>是安全的。</li></ul><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li>《C++ Primer Plus》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;指针是一个变量，其存储的是值的地址，而不是值本身&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;
      
    
    </summary>
    
    
      <category term="C++" scheme="http://xboom.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://xboom.github.io/tags/C/"/>
    
      <category term="PrimerPlus" scheme="http://xboom.github.io/tags/PrimerPlus/"/>
    
  </entry>
  
  <entry>
    <title>CPP-05-结构</title>
    <link href="http://xboom.github.io/2023/07/29/C++/CPP-05-%E7%BB%93%E6%9E%84/"/>
    <id>http://xboom.github.io/2023/07/29/C++/CPP-05-%E7%BB%93%E6%9E%84/</id>
    <published>2023-07-28T16:20:29.000Z</published>
    <updated>2023-07-28T16:20:37.748Z</updated>
    
    <content type="html"><![CDATA[<h3 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h3><p>结构是一种比数组更灵活的数据格式，一个结构可以存储多种类型的数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inflatable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">  <span class="keyword">float</span> volume;</span><br><span class="line">  <span class="keyword">double</span> price;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义之后就可以使用结构体声明变量，与C不同的是，<strong>C++允许在声 明结构变量时省略关键字<code>struct</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inflatable hat;<span class="comment">//ok</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inflatable</span> <span class="title">mainframe</span>;</span>    <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><p>与数组一样，C++11也支持将列表初始化用于结构，且等号 <code>=</code> 是可选的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">inflatable guest =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"Glorious Gloria"</span>,</span><br><span class="line">  <span class="number">1.88</span>,</span><br><span class="line">  <span class="number">29.99</span></span><br><span class="line">&#125;;</span><br><span class="line">inflatable local = &#123;<span class="string">"Audacious Arthur"</span>, <span class="number">3.12</span>&#125;;</span><br><span class="line">inflatable other&#123;&#125;;</span><br><span class="line"><span class="comment">//cout &lt;&lt; guest &lt;&lt; endl;//没有与这种操作相匹配的 &lt;&lt; 运算符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; other.name &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; local.price &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>所以</p><ol><li><code>=</code> 是可选的</li><li>如果为设置值的情况下，默认为0值</li></ol><p>同理在复制过程中，结构体也是值复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">inflatable guest =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"Glorious Gloria"</span>,</span><br><span class="line">  <span class="number">1.88</span>,</span><br><span class="line">  <span class="number">29.99</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inflatable other&#123;&#125;;</span><br><span class="line">other = guest;</span><br><span class="line"><span class="comment">//other.name = "hello wrold";//表达式必须是可修改的左值</span></span><br><span class="line">strcpy_s(other.name, <span class="keyword">sizeof</span>(other.name) - <span class="number">1</span>, guest.name);</span><br><span class="line">other.price = <span class="number">1.2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; other.price&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; guest.price&lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.2</span><br><span class="line">2.99</span><br></pre></td></tr></table></figure><ol><li>结构体的复制也是值复制，修改并不会影响另外一个结构体对象</li><li>为什么使用 <code>strcpy_s</code>  而不是使用 <code>strncpy</code> 或者 <code>strcpy</code>，可以参考 <a href="https://www.yuankang.top/2023/07/28/C++/CPP-04-string%E7%B1%BB/" target="_blank" rel="noopener">https://www.yuankang.top/2023/07/28/C++/CPP-04-string类/</a> 中的说明</li></ol><p>结构体变量还有其他创建方式</p><ol><li><p>声明两个结构体变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inflatable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">  <span class="keyword">float</span> volume;</span><br><span class="line">  <span class="keyword">double</span> price;</span><br><span class="line">&#125; infla1, infla2;<span class="comment">//声明两个结构体变量</span></span><br></pre></td></tr></table></figure></li><li><p>直接初始化结构体变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perks</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> key_number;</span><br><span class="line">  <span class="keyword">char</span> car[<span class="number">12</span>];</span><br><span class="line">&#125; per = </span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">7</span>,</span><br><span class="line">  <span class="string">"Packard"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>声明结构体变量(无法重复声明一样结构体变量，不建议使用)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>// <span class="title">no</span> <span class="title">tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> x;  <span class="comment">//2 member</span></span><br><span class="line">  <span class="keyword">int</span> y;</span><br><span class="line">&#125; <span class="built_in">position</span>; <span class="comment">//a structure variable</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="共用体"><a class="markdownIt-Anchor" href="#共用体"></a> 共用体</h3><p>共用体(union)是一种数据格式，它能够存储不同的数据类型， 但只能同时存储其中的一种类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> one4all</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> int_val;</span><br><span class="line">  <span class="keyword">long</span> long_val;</span><br><span class="line">  <span class="keyword">double</span> double_val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">one4all pail = &#123;&#125;;</span><br><span class="line">pail.bool_val = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pail.bool_val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pail.int_val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pail.double_val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pail.double_val = <span class="number">1.1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pail.bool_val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pail.int_val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pail.double_val &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4.94066e-324</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">-1717986918</span></span><br><span class="line"><span class="number">1.1</span></span><br></pre></td></tr></table></figure><p>从运行结果可以看出</p><ol><li>未设置共用体情况下，共用体的字段值是未知的</li><li>当设置一个字段的情况下，另外一个字段将失效</li></ol><p><strong>由于共用体每次只能存储一个值，因此它必须 有足够的空间来存储最大的成员，所以，共用体的长度为其最大成员的 长度</strong></p><p>将结构体与共用体结合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> brand[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">union</span> id</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> id_num;</span><br><span class="line">        <span class="keyword">char</span> id_char[<span class="number">20</span>];</span><br><span class="line">    &#125; id_val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">widget prize;</span><br><span class="line"><span class="keyword">if</span>(prize.type == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; prize.id_val.id_num;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; prize.id_val.id_char;</span><br></pre></td></tr></table></figure><p>可以通过匿名共用体的方式减少名称调用，其成员将成为相同地址处的变量。每次只有一个成员是当前的成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> brand[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> id_num;</span><br><span class="line">        <span class="keyword">char</span> id_char[<span class="number">20</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">widget prize;</span><br><span class="line"><span class="keyword">if</span>(prize.type == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; prize.id_num;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; prize.id_char;</span><br></pre></td></tr></table></figure><p>共用体常用于(但并非只能用于)节省内存</p><h3 id="枚举"><a class="markdownIt-Anchor" href="#枚举"></a> 枚举</h3><p>C++的enum提供了另一种创建符号常量的方式，这种方式可以代替const，使用 enum的句法与使用结构相似</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> spectrum</span><br><span class="line">&#123;</span><br><span class="line">    red,</span><br><span class="line">    orange,</span><br><span class="line">    yellow,</span><br><span class="line">    greed,</span><br><span class="line">    blue</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">spectrum band;</span><br><span class="line">band = yellow;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; band &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//band = 2000;    //不能将 "int" 类型的值分配到 "spectrum" 类型的实体</span></span><br><span class="line">band = spectrum(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; band &lt;&lt; <span class="string">" "</span>&lt;&lt; (band == orange) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><ol><li>enum 可以直接通过枚举序号获取 <code>band = spectrum(1);</code></li><li>枚举类型可以比较默认从 0 开始</li></ol><p>更进一步，可以为枚举设置值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> spectrum</span><br><span class="line">&#123;</span><br><span class="line">    red = <span class="number">9</span>,</span><br><span class="line">    orange = <span class="number">10</span>,</span><br><span class="line">    yellow = <span class="number">100</span>,</span><br><span class="line">    greed = <span class="number">4</span>,</span><br><span class="line">    blue = <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">spectrum band;</span><br><span class="line">band = red;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; band &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">band = spectrum(<span class="number">99</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; band &lt;&lt; <span class="string">" "</span>&lt;&lt; (band == orange) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">99 0</span><br></pre></td></tr></table></figure><ol><li>可以直接使用 <code>spectrum(99)</code> 声明一个新的枚举类型值</li><li>枚举类型设置的值并没有顺序要求</li><li>枚举值的最大值 = 枚举量的最大值。找到大于这个最大值的、最小的2的幂，将它减去1，得到的便是取 值范围的上限。</li></ol><p>既能顺便设置值，又能不设置值，name</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> spectrum</span><br><span class="line">&#123;</span><br><span class="line">    red,</span><br><span class="line">    orange = <span class="number">0</span>,</span><br><span class="line">    yellow = <span class="number">1</span>,</span><br><span class="line">    greed = <span class="number">1</span>,</span><br><span class="line">    blue</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (red == orange) &lt;&lt; (orange == yellow) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; red &lt;&lt; orange &lt;&lt; yellow &lt;&lt; greed &lt;&lt; blue &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">00112</span><br></pre></td></tr></table></figure><ol><li>默认是从 0 开始的</li><li>枚举可以设置成相同的值</li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li>《C++ Primer Plus》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;结构体&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#结构体&quot;&gt;&lt;/a&gt; 结构体&lt;/h3&gt;
&lt;p&gt;结构是一种比数组更灵活的数据格式，一个结构可以存储多种类型的数据&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;t
      
    
    </summary>
    
    
      <category term="C++" scheme="http://xboom.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://xboom.github.io/tags/C/"/>
    
      <category term="PrimerPlus" scheme="http://xboom.github.io/tags/PrimerPlus/"/>
    
  </entry>
  
  <entry>
    <title>CPP-04-string类</title>
    <link href="http://xboom.github.io/2023/07/28/C++/CPP-04-string%E7%B1%BB/"/>
    <id>http://xboom.github.io/2023/07/28/C++/CPP-04-string%E7%B1%BB/</id>
    <published>2023-07-27T16:14:29.000Z</published>
    <updated>2023-07-28T15:06:42.466Z</updated>
    
    <content type="html"><![CDATA[<p>要使用<code>string</code>类，必须在程序中包含头文件<code>string</code>。<code>string</code>类位于名称空间<code>std</code>中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name1 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> name2[<span class="number">6</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">string</span> name3 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="comment">//char name4[5] = "hello";//"const char [6]" 类型的值不能用于初始化 "char [5]" 类型的实体</span></span><br><span class="line"><span class="keyword">if</span>(name1 == name3) <span class="built_in">cout</span> &lt;&lt; <span class="string">"name1 == name3 "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span>(name2 == name3) <span class="built_in">cout</span> &lt;&lt; <span class="string">"name2 == name3"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>这里有两个注意点</p><ol><li>字符串可以通过 <code>==</code> 比较，且 <code>name1 == name3</code></li><li>字符串可以通过 <code>char[]</code> 表示，且相等</li><li>字符数组后面有一个 <code>‘\0’</code></li></ol><p>C++11也允许将列表初始化用于C-风格字符串和string对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> charr1[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> charr2[<span class="number">20</span>] = <span class="string">"jaguar"</span>;</span><br><span class="line"><span class="built_in">string</span> str1;</span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">"panther"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a kind of feline: "</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; charr1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter another kind of feline: "</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; charr1 &lt;&lt; <span class="string">" "</span> &lt;&lt; charr2 &lt;&lt; <span class="string">" "</span> &lt;&lt; str1 &lt;&lt; <span class="string">" "</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; charr2[<span class="number">2</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; str2[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Enter a kind of feline: hello</span><br><span class="line">Enter another kind of feline: world</span><br><span class="line">hello jaguar world panther</span><br><span class="line">g n</span><br></pre></td></tr></table></figure><p>所以</p><ul><li>可以使用C-风格字符串来初始化string对象。</li><li>可以使用cin来将键盘输入存储到string对象中。</li><li>可以使用cout来显示string对象。</li><li>可以使用数组表示法来访问存储在string对象中的字符。</li></ul><p>对于一个数组，返回这个数组占的总空间，所以 sizeof(name2) 取的额是字符串name2占的总空间</p><p>头文件<code>cstring</code>（以前为<code>string.h</code>）提供了字符串操作函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>*<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *__dst, <span class="keyword">const</span> <span class="keyword">char</span> *__src)</span></span>; <span class="comment">//copy __src to __dst</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>*<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *__s1, <span class="keyword">const</span> <span class="keyword">char</span> *__s2)</span></span>; <span class="comment">//append contents of charr2 to char1</span></span><br></pre></td></tr></table></figure><p>接着看看实际操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str1 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">string</span> str2 = str1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="string">" "</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">str2[<span class="number">0</span>] = <span class="string">'0'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="string">" "</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> name1[<span class="number">6</span>] = <span class="string">"world"</span>;</span><br><span class="line"><span class="keyword">char</span> name2[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(name2, name1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; name1 &lt;&lt; <span class="string">" "</span> &lt;&lt; name2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">name2[<span class="number">0</span>] = <span class="string">'0'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; name1 &lt;&lt; <span class="string">" "</span> &lt;&lt; name2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//strcpy(name1, str1); //不存在从 "std::__1::string" 到 "const char *" 的适当转换函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> name3[<span class="number">6</span>] = <span class="string">"xboom"</span>;</span><br><span class="line"><span class="keyword">char</span> name4[<span class="number">6</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(name4, name3);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; name3 &lt;&lt; <span class="string">" "</span> &lt;&lt; name3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">name3[<span class="number">0</span>] = <span class="string">'0'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; name4 &lt;&lt; <span class="string">" "</span> &lt;&lt; name3 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hello hello</span><br><span class="line">hello 0ello</span><br><span class="line"> world</span><br><span class="line"> 0orld</span><br><span class="line">xboom xboom</span><br><span class="line">xboom 0boom</span><br></pre></td></tr></table></figure><p>可以得出几点：</p><ol><li><code>strcpy</code> 是复制，不会影响原来的字符串</li><li><code>string</code> 类可以直接使用 = 复制，并且也不会影响原来的</li><li><code>string</code> 转换为 <code>const char *</code>，因为 <code>const char *</code> 是一个指向字符常量的指针，类型不匹配</li><li>使用 <code>strcpy</code> 注意目标空间大于等于源目标，否则导致目标缓冲区异常，导致崩溃或未知错误</li></ol><p>计算字符长度也是不一样的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> name1[<span class="number">6</span>] = <span class="string">"world"</span>;</span><br><span class="line"><span class="keyword">char</span> name2[<span class="number">6</span>] = &#123;<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> name3 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(name1) &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">strlen</span>(name2) &lt;&lt;<span class="string">" "</span>&lt;&lt; name3.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 5 5</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">string</span> str2;</span><br><span class="line"><span class="built_in">cin</span>.getline(name, <span class="number">20</span>);</span><br><span class="line">getline(<span class="built_in">cin</span>, str);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" "</span> &lt;&lt; str &lt;&lt; <span class="string">" "</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello world#输入</span><br><span class="line">hello world#输入</span><br><span class="line">hello world#输入</span><br><span class="line">hello world hello world hello</span><br></pre></td></tr></table></figure><ul><li><code>getline()</code> 是 C++ 标准库中的一个自由函数（不是成员函数），用于从标准输入流 <code>cin</code> 中读取一行文本，并将其存储到 <code>std::string</code> 对象 <code>str</code> 中</li><li><code>cin.getline()</code> 是 <code>istream</code> 类的成员函数，用于从标准输入流 <code>cin</code> 中读取一行文本，并将其存储到字符数组 <code>name</code> 中</li></ul><p>C++11 新增了原始字符串，字符表示的就是自己</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">R"(Jim "King" Tutt users "\n" instead of endl.)"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">R"+*("(Who wouldn't?)", she whispered.)+*"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输入结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Jim <span class="string">"King"</span> Tutt users <span class="string">"\n"</span> instead of <span class="built_in">endl</span>.</span><br><span class="line"><span class="string">"(Who wouldn't?)"</span>, she whispered.</span><br></pre></td></tr></table></figure><p>原始字符串将 <code>（</code>和<code>）</code>用作定界符，并使用前缀 R 来标识原始字符串</p><p>也可以使用 <code>R&quot;+*(</code>  表示原始字符串的开头的时候，必须使用 <code>)+*&quot;</code> 标识原始字符串的结尾</p><p>最后看一波 <code>strcpy</code> 的源码实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dest, <span class="keyword">const</span> <span class="keyword">char</span>* src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* tmp = dest;  <span class="comment">// 保存目标字符串的起始地址，用于返回复制后的目标字符串的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*src != <span class="string">'\0'</span>) &#123;</span><br><span class="line">        *dest = *src;  <span class="comment">// 复制源字符串的字符到目标字符串</span></span><br><span class="line">        ++dest;</span><br><span class="line">        ++src;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *dest = <span class="string">'\0'</span>;  <span class="comment">// 在目标字符串的末尾添加 null 终止符</span></span><br><span class="line">    <span class="keyword">return</span> tmp;    <span class="comment">// 返回复制后的目标字符串的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>src</code> 为指针常量不会被修改</li><li>定义一个指针 <code>tmp</code> 并将其指向目标字符串 <code>dest</code> 的起始地址。这样在复制结束后，可以通过 <code>tmp</code> 指针找到复制后的目标字符串的起始地址，并返回该指针</li></ul><p>实际的使用中会发现 <code>strcpy</code> 几乎不是用，原因是 <code>strcpy</code>当一直遍历到 <code>src</code> 结束才会停止写入 <code>dest</code>，当 <code>src</code> 长度大于 <code>dest</code> 的时候，会导致溢出</p><p>就提到了另外函数 <code>strncpy</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char *strncpy(char *dest, <span class="keyword">const</span> char *src, size_t count)</span><br><span class="line">&#123;</span><br><span class="line">    char *tmp = dest;   </span><br><span class="line"></span><br><span class="line">    while (count) &#123;     <span class="comment">//仅复制指定大小的长度</span></span><br><span class="line">        <span class="keyword">if</span> ((*tmp = *src) != <span class="number">0</span>)    <span class="comment">//如果没有移动到字符串末尾‘\0’ </span></span><br><span class="line">            src++;      </span><br><span class="line">        tmp++;          </span><br><span class="line">        count--;            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有几个关键的问题</p><ol><li><p><code>*temp != 0</code> 进行判断是否结束，不是 <code>\0</code> 吗？</p><p><code>'0'</code>代表ASCII值为48的数字零字符，而<code>'\0'</code>代表空字符(null terminator)，其ASCII值为0</p></li><li><p>如果 <code>src_len &gt;= count</code> 会怎样？</p><p><code>src</code> 的全部内容都回被copy 到 <code>dest</code> 中，但是 <code>dest</code> 末尾并不是<code>\0</code></p></li><li><p>如果 <code>src_len &lt; count</code> ， <code>tmp++</code> 直到 <code>count == 0</code>，也就是说超过 <code>count</code> 的部分不变</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> arr[<span class="number">6</span>] = <span class="string">"world"</span>;</span><br><span class="line"><span class="keyword">char</span> dest[<span class="number">12</span>] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">strncpy</span>(dest, arr, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dest &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出结果 <code>world</code>, 是因为将<code>'\0'</code> 也复制进去了，那是不是当超过 <code>src_len &lt; count</code> 就可以结束了</p></li></ol><p>在使用 strncpy 又会有一个新的提示</p><blockquote><p>This function or variable may be unsafe. Consider using <code>strncpy_s</code> instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details</p></blockquote><p>下面是 strcpy_s 的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">_FUNC_PROLOGUE</span><br><span class="line"><span class="keyword">errno_t</span> __cdecl _FUNC_NAME(_CHAR *_DEST, <span class="keyword">size_t</span> _SIZE, <span class="keyword">const</span> _CHAR *_SRC)</span><br><span class="line">&#123;</span><br><span class="line">    _CHAR *p;</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">available</span>;</span><br><span class="line">    _VALIDATE_STRING(_DEST, _SIZE);  <span class="comment">//验证目标字符串 _DEST 的合法性</span></span><br><span class="line">  <span class="comment">//验证源字符串 _SRC 的合法性。它可能会检查 _SRC 是否为有效的指针，并确保 _DEST 和 _SIZE 参数在一定条件下都是合法的</span></span><br><span class="line">    _VALIDATE_POINTER_RESET_STRING(_SRC, _DEST, _SIZE);</span><br><span class="line">    p = _DEST;</span><br><span class="line">    <span class="built_in">available</span> = _SIZE;</span><br><span class="line">    <span class="comment">//_SRC 到头或者数量达到目标就停止复制</span></span><br><span class="line">    <span class="keyword">while</span> ((*p++ = *_SRC++) != <span class="number">0</span> &amp;&amp; --<span class="built_in">available</span> &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//达到复制长度，说明 _DEST 还没存入'\0', 即 src_len &gt;= cout 的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">available</span> == <span class="number">0</span>)</span><br><span class="line">    &#123; </span><br><span class="line">      </span><br><span class="line">        <span class="comment">//将_DEST 全部重置为 '\0'</span></span><br><span class="line">        _RESET_STRING(_DEST, _SIZE);</span><br><span class="line">        <span class="comment">//返回_DEST 长度不够存储_SIZE 的错误</span></span><br><span class="line">        _RETURN_BUFFER_TOO_SMALL(_DEST, _SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//src_len &lt;  count 的情况</span></span><br><span class="line">    <span class="comment">//否则天车工剩下的部分为 '\0'</span></span><br><span class="line">    _FILL_STRING(_DEST, _SIZE, _SIZE - <span class="built_in">available</span> + <span class="number">1</span>);</span><br><span class="line">    _RETURN_NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是 <code>strcpy_s</code> 除了字符校验还解决了当 <code>dest_len &lt; cout</code> 时候的溢出</p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li>《C++ Primer Plus》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;要使用&lt;code&gt;string&lt;/code&gt;类，必须在程序中包含头文件&lt;code&gt;string&lt;/code&gt;。&lt;code&gt;string&lt;/code&gt;类位于名称空间&lt;code&gt;std&lt;/code&gt;中&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;tab
      
    
    </summary>
    
    
      <category term="C++" scheme="http://xboom.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://xboom.github.io/tags/C/"/>
    
      <category term="PrimerPlus" scheme="http://xboom.github.io/tags/PrimerPlus/"/>
    
  </entry>
  
  <entry>
    <title>CPP-03-数组</title>
    <link href="http://xboom.github.io/2023/07/27/C++/CPP-03-%E6%95%B0%E7%BB%84/"/>
    <id>http://xboom.github.io/2023/07/27/C++/CPP-03-%E6%95%B0%E7%BB%84/</id>
    <published>2023-07-26T17:05:29.000Z</published>
    <updated>2023-07-29T07:15:54.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h3><p>声明数组的通用格式如下</p><ul><li>存储在每个元素中的值的类型</li><li>数组名</li><li>数组中的元素数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeName arrayName[arraySize];</span><br></pre></td></tr></table></figure><p>包含了每个元素的值类型、数组名、数组中的元素个数，<code>arraySize</code> 必须是整形常量（如10）或 <code>const</code>值，也可以是常量表达式（如 <code>8 * sizeof(int)</code>），<strong>即其中所有的值在编译时都是已知的</strong></p><p>数组的初始化有以下几种</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cards[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> hand[<span class="number">4</span>];</span><br><span class="line">hand[<span class="number">4</span>] = &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">hand = cards;</span><br></pre></td></tr></table></figure><p>另外还有特殊的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> hotelTips[<span class="number">5</span>] = &#123;<span class="number">5.0</span>, <span class="number">2.5</span>&#125;;<span class="comment">//只初始化hotelTips的前两个元素</span></span><br><span class="line"><span class="keyword">long</span> totals[<span class="number">500</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//全部是0</span></span><br><span class="line"><span class="keyword">long</span> nums[<span class="number">500</span>] = &#123;<span class="number">1</span>&#125;;<span class="comment">//第一个是1，其他都是0</span></span><br><span class="line"><span class="keyword">long</span> sum[<span class="number">500</span>] = &#123;&#125;;<span class="comment">//???</span></span><br></pre></td></tr></table></figure><p><strong>如果只对数组的一部分进行初始化，则编译器将把其他元素设置为 0</strong></p><p><strong>如果不指定数组的元素个数，编译器将计算元素个数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">short things[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>&#125;;<span class="comment">//编译器将使things数组包含4个元素</span></span><br><span class="line"><span class="keyword">int</span> num_elements = <span class="keyword">sizeof</span>(things)/<span class="keyword">sizeof</span>(short);</span><br></pre></td></tr></table></figure><p><code>C++11</code>将使用大括号的初始化(列表初始化)作为一 种通用初始化方式，可用于所有类型，C++11 中的列表初始化新增了一些功能</p><ul><li>初始化数组时，可省略等号 <code>=</code></li><li>可不在大括号内包含任何东西，这将把所有元素都设置为</li><li>列表初始化禁止缩窄转换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> earnings[<span class="number">4</span>] &#123;<span class="number">1.2e4</span>, <span class="number">1.6e4</span>, <span class="number">1.1e4</span>, <span class="number">1.7e4</span>&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> cunts[<span class="number">10</span>] = &#123;&#125;;<span class="comment">//all elements set to 0</span></span><br><span class="line"><span class="keyword">float</span> balances[<span class="number">100</span>] &#123;&#125;;<span class="comment">//all elements set to 0</span></span><br><span class="line"><span class="keyword">long</span> plifs[] = &#123;<span class="number">25</span>, <span class="number">92</span>, <span class="number">3.0</span>&#125;;<span class="comment">//not allowed</span></span><br><span class="line"><span class="keyword">char</span> slifs[<span class="number">4</span>] &#123;<span class="string">'h'</span>, <span class="string">'i'</span>, <span class="number">1232311</span>, <span class="string">'\0'</span>&#125;;<span class="comment">//not allowed</span></span><br><span class="line"><span class="keyword">char</span> tlifs[<span class="number">4</span>] &#123;<span class="string">'h'</span>, <span class="string">'i'</span>, <span class="number">112</span>, <span class="string">'\0'</span>&#125;;<span class="comment">//allowed</span></span><br></pre></td></tr></table></figure><p>C++标准模板库<code>STL</code>提供了一种数组替代品—模板类<code>vector</code>，而 <code>C++11</code>新增了模板类<code>array</code></p><h3 id="字符数组"><a class="markdownIt-Anchor" href="#字符数组"></a> 字符数组</h3><p>字符串是存储在内存的连续字节中的一系列字符，意味着可以将字符串存储在char数组中，其中每个字符都位于自己的数组元素中，但注意以 <strong>以空字符（null character）结尾！！！！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> dog[<span class="number">10</span>] = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'w'</span>, <span class="string">'o'</span>, <span class="string">'r'</span>, <span class="string">'l'</span>, <span class="string">'d'</span>&#125;;<span class="comment">//not a string</span></span><br><span class="line"><span class="keyword">char</span> cat[<span class="number">10</span>] = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'y'</span>, <span class="string">'\0'</span>&#125;;<span class="comment">//a string</span></span><br><span class="line"><span class="keyword">char</span> cat[<span class="number">10</span>] = <span class="string">"hellobaby"</span>; <span class="comment">//等价第 2 行</span></span><br></pre></td></tr></table></figure><p>所以字符常量 <code>'S'</code> 与字符串常量 <code>&quot;S&quot;</code> 是不等价的，<code>&quot;S&quot;</code> 表示的是两个字符（字符S和\0）组成的字 符串。更糟糕的是，<code>&quot;S&quot;</code>实际上表示的是字符串所在的内存地址，以下是非法的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> shirt_size = <span class="string">"S"</span>; <span class="comment">//illegal type mismatch</span></span><br></pre></td></tr></table></figure><p>另外，跟数组的初始化类似，字符数组也会为没有初始化的自动设置值</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/c++_0726_11.png" alt="c++_0726_11" style="zoom:50%;" /><p>为了在数组中使用字符串，可以有两种办法</p><ul><li>将数组初始化为字符串常量 <code>char cat[10] = &quot;hellobaby&quot;;</code></li><li>将键盘或文件输入读入到数组中，如下</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Size = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">char</span> name1[Size];</span><br><span class="line"><span class="keyword">char</span> name2[Size] = <span class="string">"Hello World!"</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; name1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"name1 len "</span> &lt;&lt; <span class="built_in">strlen</span>(name1) &lt;&lt; <span class="string">" size "</span> &lt;&lt; <span class="keyword">sizeof</span>(name1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; name1 &lt;&lt; <span class="string">" | "</span> &lt;&lt; name2;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nihao</span><br><span class="line">name1 len 5 size 15</span><br><span class="line">nihao | Hello World!</span><br></pre></td></tr></table></figure><p>可以看到 <code>strlen</code> 返回的是字符串的长度，但是 <code>sizeof</code> 返回的数组的长度。另外 <code>strlen</code> 只计算可见的字符，而不把空字符计算在内。</p><p>如果输入长度超过字符数组长度怎么办？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Size = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> name1[Size];</span><br><span class="line"><span class="keyword">char</span> name2[Size];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; name1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; name1 &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">strlen</span>(name1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; name2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; name2 &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">strlen</span>(name2) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ni hello world #输入</span><br><span class="line">ni 2</span><br><span class="line">hello 5</span><br></pre></td></tr></table></figure><p>这里有两个注意的地方</p><ol><li><code>name1</code> 是 <code>ni</code> 而不是 <code>ni he</code> ,这是因为<code>cin</code> 使用空白(空格、制表符和换行符)来确定字符串的结束位置</li><li>没有执行(用户输入) <code>cin &gt;&gt; name2;</code>，<code>cin</code> 把 <code>hello</code> 放入 <code>name1</code> 中并添加空字符。然后输出队列中剩余的 <code>world</code> 直接输入到 <code>name2</code> 中，所以感觉不到输入第二次</li></ol><p>要是就是想将 <code>ni hello world</code> 保存到一个字符串中怎么办？</p><ol><li><p><code>getline()</code> 函数读取整行，通过换行符来确定输入结尾</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Size = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> name1[Size];</span><br><span class="line"><span class="keyword">char</span> name2[Size];</span><br><span class="line"><span class="built_in">cin</span>.getline(name1, Size);</span><br><span class="line"><span class="built_in">cin</span>.getline(name2, Size);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; name1 &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">strlen</span>(name1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; name2 &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">strlen</span>(name2) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ni hello world#输入</span><br><span class="line">ni h 4</span><br><span class="line"> 0</span><br></pre></td></tr></table></figure><p>这里不一样的是</p><ul><li>输入超过字符数组长度的会被自动截断</li><li>如果输入超过长度，那么后面的会等于直接输入<code>'\0'</code></li></ul></li><li><p><code>get()</code>与 getline() 不同的是，<code>get()</code> 并不再读取并丢弃换行符，而是将其留在输入队列中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Size = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> name1[Size];</span><br><span class="line"><span class="keyword">char</span> name2[Size];</span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(name1, Size);</span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(name2, Size);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; name1 &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">strlen</span>(name1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; name2 &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">strlen</span>(name2) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ni hello world#输入</span><br><span class="line">ni h 4</span><br><span class="line">ello 4</span><br></pre></td></tr></table></figure></li><li><p>可以将上述逻辑合并到一起</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Size = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">char</span> name1[Size];</span><br><span class="line"><span class="keyword">char</span> name2[Size];</span><br><span class="line"><span class="built_in">cin</span>.getline(name1, Size).getline(name2, Size);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; name1 &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">strlen</span>(name1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; name2 &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">strlen</span>(name2) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello world#输入</span><br><span class="line">hello#输入</span><br><span class="line">hello world 11</span><br><span class="line">hello 5</span><br></pre></td></tr></table></figure></li><li><p>当读取空行后将设置失效位 (<code>failbit</code>)。这意味着接下来的输入将被阻断，但可以用下面的命令来<code>cin.clear()</code>恢复输入，从上次结尾的地方继续读取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Size = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> name1[Size];</span><br><span class="line"><span class="keyword">char</span> name2[Size];</span><br><span class="line"><span class="built_in">cin</span>.getline(name1, Size);</span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">cin</span>.getline(name2, Size);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; name1 &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">strlen</span>(name1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; name2 &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">strlen</span>(name2) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ni hello world#输入</span><br><span class="line">ni h 4</span><br><span class="line">ello 4</span><br></pre></td></tr></table></figure></li></ol><p>如果手动设置字符数组指定位置为空字符，那么将导致字符串被截断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Size = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">char</span> name2[Size] = <span class="string">"Hello World!"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; name2 &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">strlen</span>(name2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">name2[<span class="number">4</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; name2 &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">strlen</span>(name2) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello World! 12</span><br><span class="line">Hell 4</span><br></pre></td></tr></table></figure><p>最后一种输入的异常是混合输入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Waht year was your house built?\n"</span>;</span><br><span class="line"><span class="keyword">int</span> year;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; year;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Wat is its street address?\n"</span>;</span><br><span class="line"><span class="keyword">char</span> address[<span class="number">80</span>];</span><br><span class="line"><span class="built_in">cin</span>.getline(address, <span class="number">80</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Year build: "</span> &lt;&lt; year &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Address: "</span> &lt;&lt; address &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Done! \n"</span>;</span><br></pre></td></tr></table></figure><p>运行结果是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Waht year was your house built?</span><br><span class="line">1966#输入</span><br><span class="line">Wat is its street address?</span><br><span class="line">Year build: 1966</span><br><span class="line">Address: </span><br><span class="line">Done!</span><br></pre></td></tr></table></figure><p>用户根本没有输入地址的机会。问题在于，当<code>cin</code>读取年份，将回车键生成的换行符留在了输入队列中。后面的<code>cin.getline( )</code>看到换行符后，将认为是一个空行，并将一个空字符串赋给<code>address</code>数组。</p><p>解决办法是，在读取地址之前先读取并丢弃换行符。可以通过 空参数的<code>cin.get()</code> 或者 cin.clear() 解决</p><p>数组的替代</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;typeName&gt; <span class="title">vt</span><span class="params">(n_elem)</span></span>;</span><br><span class="line"><span class="built_in">array</span>&lt;typeName, n_elem&gt; arr;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li>《C++ Primer Plus》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数组&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数组&quot;&gt;&lt;/a&gt; 数组&lt;/h3&gt;
&lt;p&gt;声明数组的通用格式如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储在每个元素中的值的类型&lt;/li&gt;
&lt;li&gt;数组名&lt;/li&gt;
&lt;li&gt;数组中的元素数&lt;/li
      
    
    </summary>
    
    
      <category term="C++" scheme="http://xboom.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://xboom.github.io/tags/C/"/>
    
      <category term="PrimerPlus" scheme="http://xboom.github.io/tags/PrimerPlus/"/>
    
  </entry>
  
  <entry>
    <title>CPP-02-数据处理</title>
    <link href="http://xboom.github.io/2023/07/26/C++/CPP-02-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <id>http://xboom.github.io/2023/07/26/C++/CPP-02-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</id>
    <published>2023-07-26T15:58:29.000Z</published>
    <updated>2023-07-25T16:32:46.101Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单变量"><a class="markdownIt-Anchor" href="#简单变量"></a> 简单变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">num = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>程序将找到一块能够存储整数的内存，将该内存单元标记为<code>num</code>，并将5复制到该内存单元中；然后，可在程序中使用<code>num</code>来访问该内存单元</p><p>C++还有另一种C语言没有的初始化语法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">num</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>这些变量都是声明了类型了，计算机如何知道没有声明类型的常量，比如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Year = "</span> &lt;&lt; <span class="number">1492</span> &lt;&lt; <span class="string">"\n"</span>;</span><br></pre></td></tr></table></figure><p>除非有理由存储为其他类型，否则 C++ 将整型常量存储为 int 类型，这里的其他理由是指</p><ul><li>使用了特殊的后缀来表示特定的类型</li><li>太大，不能存储为 <code>int</code></li></ul><h3 id="const"><a class="markdownIt-Anchor" href="#const"></a> const</h3><p>首先来看 <code>#define</code> 符号常量–预处理方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MAX 32767</span></span><br></pre></td></tr></table></figure><p>在C++编译过程中，首先将源代码传递给预处理器。在这里，<code>#define</code>和<code>#include</code>一样，是一个预处理器编译指令。告诉预处理器：在程序中查找<code>INT_MAX</code>，并将所有的 <code>INT_MAX</code>都替换为<code>32767</code></p><p><code>const</code>比 <code>#define</code> 好。</p><ol><li><code>const</code> 能够明确指定类型。</li><li>可以使用C++的作用域规则将定义限制在特定的函数或文件中</li><li>可以将<code>const</code>用于更复杂的类型，比如数组或者结构</li></ol><p><code>d.dddE+n</code>指的是将小数点向右移n位</p><p><code>d.dddE～n</code>指的是将小数点向左移n位，<code>8.33E～4</code> 表示<code>8.33/10^4</code>，即<code>0.000833</code></p><h3 id="类型转换"><a class="markdownIt-Anchor" href="#类型转换"></a> 类型转换</h3><table><thead><tr><th>转换</th><th>潜在的问题</th></tr></thead><tbody><tr><td>将较大的浮点类型转换为娇小的浮点类型，如将 <code>double</code> 转换为 <code>float</code></td><td>精度(有效数位)降低，值可能超出目标类型的 取值范围，在这种情况下，结果将是不确定的</td></tr><tr><td>将浮点类型转换为整型</td><td>小数部分丢失，原来的值可能超出目标类型的取 值范围，在这种情况下，结果将是不确定的</td></tr><tr><td>将较大的整型转换为较小的整 型，如将<code>long</code>转换为<code>short</code></td><td>原来的值可能超出目标类型的取值范围，通常只 复制右边的字节</td></tr></tbody></table><p>将 0 赋给<code>bool</code>变量时，将被转换为<code>false</code>；而非零值将被转换为<code>true</code>。</p><p>C++11制定了校验关系</p><ul><li>如果有一个操作数的类型是<code>long double</code>，则将另一个操作数转换为<code>long double</code></li><li>如果有一个操作数的类型是<code>long double</code>，则将另一个操作数转换为<code>long double</code></li><li>否则，如果有一个操作数的类型是<code>float</code>，则将另一个操作数转换为<code>float</code></li><li>否则，说明操作数都是整型，因此执行整型提升</li><li>在这种情况下，如果两个操作数都是有符号或无符号的，且其中一个操作数的级别比另一个低，则转换为级别高的类型。</li><li>如果一个操作数为有符号的，另一个操作数为无符号的，且 无符号操作数的级别比有符号操作数高，则将有符号操作数转换为无符 号操作数所属的类型</li><li>否则，如果有符号类型可表示无符号类型的所有可能取值， 则将无符号操作数转换为有符号操作数所属的类型。</li><li>否则，将两个操作数都转换为有符号类型的无符号版本。</li></ul><p>也可以<code>{ }</code>方式初始化时进行的转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ch</span><span class="params">(<span class="number">77</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> cm = &#123;<span class="number">78</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="string">" "</span>&lt;&lt; cm;<span class="comment">//77 78</span></span><br></pre></td></tr></table></figure><p>强制类型转换不会修改变量本身，而是创建一个新的、指定类型的值，可以在表达式中使用这个值，常见的转换表达式如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(typeName) var</span><br><span class="line">typeName (var)</span><br></pre></td></tr></table></figure><p>C++还引入了4个强制类型转换运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ch</span><span class="params">(<span class="number">77</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span> cm = (<span class="keyword">char</span>)ch;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="keyword">bool</span>(ch);</span><br><span class="line"><span class="keyword">bool</span> cf = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(ch);</span><br><span class="line">   </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="string">" "</span>&lt;&lt; cm &lt;&lt; <span class="string">" "</span> &lt;&lt; flag &lt;&lt; <span class="string">" "</span> &lt;&lt; cf; <span class="comment">//77 M 1 1</span></span><br></pre></td></tr></table></figure><h3 id="auto"><a class="markdownIt-Anchor" href="#auto"></a> auto</h3><p>C++11新增了一个工具，让编译器能够根据初始值的类型推断变量的类型。为此，它重新定义了auto的含义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">type_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> name = <span class="keyword">typeid</span>(T).name();</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line">  <span class="keyword">char</span> letter = <span class="string">'A'</span>;</span><br><span class="line">  <span class="keyword">bool</span> is_true = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">auto</span> name = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Type of num: "</span> &lt;&lt; type_name&lt;<span class="keyword">decltype</span>(num)&gt;() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Type of pi: "</span> &lt;&lt; type_name&lt;<span class="keyword">decltype</span>(pi)&gt;() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Type of letter: "</span> &lt;&lt; type_name&lt;<span class="keyword">decltype</span>(letter)&gt;() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Type of is_true: "</span> &lt;&lt; type_name&lt;<span class="keyword">decltype</span>(is_true)&gt;() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Type of name: "</span> &lt;&lt; type_name&lt;<span class="keyword">decltype</span>(name)&gt;() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Type of num: i</span><br><span class="line">Type of pi: d</span><br><span class="line">Type of letter: c</span><br><span class="line">Type of is_true: b</span><br><span class="line">Type of name: d</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>C++的基本类型分为两组：</p><ol><li><p>由存储为整数的值组成，整型之间通过存储值时使用的内存量及有无符号来区分，从最小到最大依次是：<code>bool</code>、<code>char</code>、<code>signed char</code>、 <code>unsigned char</code>、<code>short</code>、<code>unsigned short</code>、<code>int</code>、<code>unsigned int</code>、<code>long</code>、<code>unsigned long</code>以及</p></li><li><p>由存储为浮点格式的值组成。分别是<code>float</code>、<code>double</code>和<code>long double</code>。</p></li></ol><blockquote><p>C<ins>11新增了<code>long long</code>和<code>unsigned long long</code>，还有一种<code>wchar_t</code> 类型，它在这个序列中的位置取决于实现。C</ins>11新增了类型<code>char16_t</code> 和<code>char32_t</code>，分别存储16和32位的字符编码</p></blockquote><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li>《C++ Primer Plus》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简单变量&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简单变量&quot;&gt;&lt;/a&gt; 简单变量&lt;/h3&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa
      
    
    </summary>
    
    
      <category term="C++" scheme="http://xboom.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://xboom.github.io/tags/C/"/>
    
      <category term="PrimerPlus" scheme="http://xboom.github.io/tags/PrimerPlus/"/>
    
  </entry>
  
  <entry>
    <title>CPP-01-HelloWorld</title>
    <link href="http://xboom.github.io/2023/07/26/C++/CPP-01-HelloWorld/"/>
    <id>http://xboom.github.io/2023/07/26/C++/CPP-01-HelloWorld/</id>
    <published>2023-07-26T14:58:29.000Z</published>
    <updated>2023-07-25T16:34:27.148Z</updated>
    
    <content type="html"><![CDATA[<p>最近由于部门调整，需要改变编码语言，这里重新学习一下《C++ Primer Plus》，建立了一个 Demo 方便自己编译代码 <a href="https://github.com/XBoom/CPP-Learn.git" target="_blank" rel="noopener">https://github.com/XBoom/CPP-Learn.git</a></p><p>来看第一个 C++ Demo</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Come up and C++ me some time."</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"You won't regret it!"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="头文件"><a class="markdownIt-Anchor" href="#头文件"></a> 头文件</h3><p><code>#include</code> 编译指令让预处理器将 <code>iostream</code> 文件的内容添加到程序中，取代程序中的代码行 <code>#include &lt;iostream&gt;</code>。原始文件没有被修改，只是将源代码文件和<code>iostream</code>组合成一个复合文件。在编译后使用</p><table><thead><tr><th>头文件类型</th><th>约定</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>C++ 旧式风格</td><td>以.h结尾</td><td>iostream.h</td><td>c++程序可以使用</td></tr><tr><td>C 旧式风格</td><td>以.h结尾</td><td>math.h</td><td>c、c++程序可以使用</td></tr><tr><td>C++ 新式风格</td><td>没有拓展名</td><td>iostream</td><td>C++ 程序可以使用，使用 namespace std</td></tr><tr><td>转换后的 C</td><td>加上前缀c，没有扩展名</td><td>cmath</td><td>C++ 程序可以使用，可以使用不是C的特 性，如namespace std</td></tr></tbody></table><h3 id="命名空间"><a class="markdownIt-Anchor" href="#命名空间"></a> 命名空间</h3><p>如果使用<code>iostream</code>，而不是<code>iostream.h</code>，则应使用下面的名称空间编译指令来使<code>iostream</code>中的定义对程序可用，叫做 <strong>using编译指令</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><p>名称空间支持是一项C++特性，旨在让编写大型程序包含多个项目现有的代码组合起来的程序时更容易</p><p>但是如果多个项目包含相同的函数，那么就可以通过指定命名空间调用。</p><p>按照这种方式，类、函数和变量便是C++编译器的标准组件，它们都被放置在名称空间std中。仅当头文件没有扩展名h时，情况才是如此。在<code>iostream</code>中定义的用于输出的<code>cout</code>变量实际上是 <code>std::cout</code>，而<code>endl</code>实际上是<code>std::endl</code>。因此，可以省略编译指令using编码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Come up and C++ me some time."</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"You won't regret it!"</span>;</span><br></pre></td></tr></table></figure><p>而让程序能够访问命名空间的方法有很多中</p><ul><li>将 <code>using namespace std；</code>放在函数定义之前，文件中所有的函数都能够使用名称空间<code>std</code>中所有的元素</li><li>将 <code>using namespace std；</code>放在特定函数定义中，该函数能够使命名约定用名称空间<code>std</code>中的所有元素</li><li>在特定的函数中使用类似 <code>using std::cout;</code>这样的编译指令，而不是 <code>using namespace std;</code>，让该函数能够使用指定的元素，如<code>cout</code></li><li>完全不使用编译指令<code>using</code>，而在需要使用名称空间<code>std</code>中的元素 时，使用前缀<code>std::</code>，如下所示：</li></ul><h3 id="cout-cin"><a class="markdownIt-Anchor" href="#cout-cin"></a> cout &amp;&amp; cin</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Come up and C++ me some time."</span>;</span><br></pre></td></tr></table></figure><p><strong>&lt;&lt; 符号</strong>表示该语句将把这个字符串发送给 <code>cout</code>；该符号指出了信息流动的路径，是一个预定义的对象，知道如何显示字符串、数字和单个字符</p><blockquote><p>插入运算符 <code>&lt;&lt;</code> 看上去就像按位左移运算符 <code>&lt;&lt;</code> ，这是一个运算符重载的例子，通过重载，同一个运算符将有不同的含义</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num;</span><br></pre></td></tr></table></figure><p>输入时，<code>cin</code> 使用 <code>&gt;&gt;</code> 运算符从输入流中抽取字符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch;</span><br><span class="line">  <span class="keyword">char</span> cm = <span class="string">'M'</span>;</span><br><span class="line">  <span class="keyword">char</span> cn = <span class="number">77</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enteer a character: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">  <span class="built_in">cout</span>.<span class="built_in">put</span>(<span class="string">'!'</span>);</span><br><span class="line">  <span class="built_in">cout</span>.<span class="built_in">put</span>(<span class="string">'.'</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" ch "</span> &lt;&lt; ch &lt;&lt; <span class="string">" cm "</span> &lt;&lt; cm &lt;&lt;<span class="string">" cn "</span> &lt;&lt; cn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Enteer a character: </span><br><span class="line">M</span><br><span class="line">!. ch M cm M cn M</span><br></pre></td></tr></table></figure><p>其中 <code>cout.put(char c)</code>的作用是存放一个 <code>char</code> 变量</p><h3 id="函数原型"><a class="markdownIt-Anchor" href="#函数原型"></a> 函数原型</h3><p>函数原型之于函数就像变量声明之于变量 — 指出涉及的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span>)</span></span>;<span class="comment">//function prototype</span></span><br></pre></td></tr></table></figure><p>对于C<ins>库中 的每个函数，都在一个或多个头文件中提供了其原型，C 和 C</ins> 将库函数的这两项特性 (原型和定义)分开了。库文件中包含了函数的编译代码，而头文件中则包含了原型</p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li>《C++ Primer Plus》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近由于部门调整，需要改变编码语言，这里重新学习一下《C++ Primer Plus》，建立了一个 Demo 方便自己编译代码 &lt;a href=&quot;https://github.com/XBoom/CPP-Learn.git&quot; target=&quot;_blank&quot; rel=&quot;noo
      
    
    </summary>
    
    
      <category term="C++" scheme="http://xboom.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://xboom.github.io/tags/C/"/>
    
      <category term="PrimerPlus" scheme="http://xboom.github.io/tags/PrimerPlus/"/>
    
  </entry>
  
  <entry>
    <title>Go-27-SyncPool</title>
    <link href="http://xboom.github.io/2023/07/15/Go/Go-27-SyncPool/"/>
    <id>http://xboom.github.io/2023/07/15/Go/Go-27-SyncPool/</id>
    <published>2023-07-15T05:32:45.000Z</published>
    <updated>2023-07-15T05:38:19.201Z</updated>
    
    <content type="html"><![CDATA[<p>前面一篇讲解了<strong>Sync.Pool</strong>的底层数据结构 <a href="https://www.yuankang.top/2023/07/01/Go/Go%E5%85%A5%E9%97%A825-PoolDequeue/" target="_blank" rel="noopener">poolDequeue</a>，接着看看<code>Sync.Pool</code>的具体实现原理。如果想看看 <code>Sync.Pool</code> 的使用 可以看看我的 <a href="https://www.yuankang.top/2023/07/13/Go/Go%E5%85%A5%E9%97%A826-Issue/" target="_blank" rel="noopener">Go 入门 26-Issue</a>，使用的时候最好分配固定大小的对象否则注意清理</p><p>带着问题看世界</p><ol><li><code>Sync.Pool</code> 与  <code>Goroutine</code>  的关系</li><li><code>Sync.Pool</code> 是如何释放的(并没有主动释放接口)</li></ol><p>代码：<code>src/sync/pool.go</code>，1.20版本</p><p>首先来看内存池的说明，翻译过来就是就是：</p><ol><li>存放在<code>Pool</code> 中的元素任何时候都有可能在没有被其他引用的情况下释放掉</li><li><code>Pool</code> 是并发安全的</li><li>使用 <code>Pool</code> 之后不能再复制它。<em>假设缓存池对象 A 被对象 B 拷贝了，如果 A 被清空，B 的缓存对象指针指向的对象将会不可控</em></li></ol><p>先来看看整体的结构图</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/syncpools1.png" alt="syncpools1" /></p><h3 id="全局变量"><a class="markdownIt-Anchor" href="#全局变量"></a> 全局变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> poolRaceHash [<span class="number">128</span>]<span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">allPoolsMu Mutex<span class="comment">//互斥锁，用于更新 allPools，因为所有的 sync.pool 都存放在里面 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// allPools is the set of pools that have non-empty primary</span></span><br><span class="line"><span class="comment">// caches. Protected by either 1) allPoolsMu and pinning or 2)</span></span><br><span class="line"><span class="comment">// STW.</span></span><br><span class="line">allPools []*Pool</span><br><span class="line"></span><br><span class="line"><span class="comment">// oldPools is the set of pools that may have non-empty victim</span></span><br><span class="line"><span class="comment">// caches. Protected by STW.</span></span><br><span class="line">oldPools []*Pool</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>allPoolsMu</code>：用于对<code>allPools</code>的更新进行保护</li><li><code>allPools</code>: <code>[]*Pool</code>切片，存储具有非空私有缓存的对象池。可以被多个 <code>goroutine</code> 访问</li><li><code>oldPools</code>：<code>[]*Pool</code>类型的切片，用于存储可能具有非空受害者缓存的对象池，由于只有在 <code>STW</code> 时候才会更新，不会被并发访问</li></ul><h3 id="基本结构"><a class="markdownIt-Anchor" href="#基本结构"></a> 基本结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">  noCopy noCopy <span class="comment">// 提示不要复制</span></span><br><span class="line">  </span><br><span class="line">  local     unsafe.Pointer <span class="comment">// 指向每个 P(处理器) 的本地池的指针。它的类型是 [P]poolLocal，其中P是处理器数量</span></span><br><span class="line">  localSize <span class="keyword">uintptr</span>        <span class="comment">// 本地数组的大小</span></span><br><span class="line"></span><br><span class="line">  victim     unsafe.Pointer <span class="comment">// GC上一个周期中的本地池的指针。在当前周期中，这个本地池变成了受害者。它的类型是 unsafe.Pointer</span></span><br><span class="line">  victimSize <span class="keyword">uintptr</span>        <span class="comment">// 受害者缓存数组的大小，以字节为单位</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//可选地指定一个函数，当 Get 方法本来会返回 nil 时，可以用于生成一个值。</span></span><br><span class="line">  New <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">any</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>noCopy</code> 用于提示不要进行对象复制</p></li><li><p><code>local</code> 与 <code>victim</code> 的关系在后面 <strong>内存池清理</strong> 中说明</p></li><li><p><code>New</code> 则是自定义的分配对象函数</p></li></ul><h4 id="nocopy"><a class="markdownIt-Anchor" href="#nocopy"></a> noCopy</h4><p><code>noCopy</code> 支持 使用 <code>go vet</code> 检查对象是否被复制，它是一个内置的空结构体类型，当然也可以自行实现类似功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> noCopy <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n noCopy)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//TODO implement me</span></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"implement me"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n noCopy)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//TODO implement me</span></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"implement me"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ sync.Locker = (*noCopy)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">noCopy</span><br><span class="line">age    <span class="keyword">int</span></span><br><span class="line">height <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它第一次使用后不能被复制，其实代码是能够编译通过运行的，只是在 <code>go vet</code> 或者 <code>部分编辑器</code>会提示而已。可以看看没有成为标准的原因 <a href="https://golang.org/issues/8005#issuecomment-190753527" target="_blank" rel="noopener">https://golang.org/issues/8005#issuecomment-190753527</a></p><h4 id="poollocal"><a class="markdownIt-Anchor" href="#poollocal"></a> poolLocal</h4><p>每个处理器 <code>P</code> 都有一个 <code>poolLocal</code> 的本地池对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个 P 的本地对象池</span></span><br><span class="line"><span class="keyword">type</span> poolLocalInternal <span class="keyword">struct</span> &#123;</span><br><span class="line">private any       <span class="comment">// 仅能被当前 P 进行读写</span></span><br><span class="line">shared  poolChain <span class="comment">// 共享，当前 P 能对其进行 pushHead/popHead; 任何 P 都能执行popTail</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> poolLocal <span class="keyword">struct</span> &#123;</span><br><span class="line">poolLocalInternal</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prevents false sharing on widespread platforms with</span></span><br><span class="line"><span class="comment">// 128 mod (cache line size) = 0 .</span></span><br><span class="line">pad [<span class="number">128</span> - unsafe.Sizeof(poolLocalInternal&#123;&#125;)%<span class="number">128</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>private</code> 是一个仅用于当前 P 进行读写的字段(即没有并发读写的问题)</li><li><code>shared</code> 可以在多个 P 之间进行共享读写，是一个 <code>poolChain</code> 链式队列结构， 当前 P 上可以进行 <code>pushHead</code> 和 <code>popHead</code> 操作(队头读写)， 在所有 P 上都可以进行 <code>popTail</code> (队尾出队)操作</li><li><code>pad</code>  用于 <strong>伪共享</strong> 保证 <code>poolLocal</code> 的大小是 128 字节的倍数</li></ul><h4 id="runtime_procpin"><a class="markdownIt-Anchor" href="#runtime_procpin"></a> runtime_procPin</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">procPin</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">gp := getg()<span class="comment">//获取当前goroutine的指针</span></span><br><span class="line">mp := gp.m<span class="comment">//当前goroutine 对应的 协程代表</span></span><br><span class="line"></span><br><span class="line">  mp.locks++<span class="comment">//这个变量用于跟踪当前线程(m)持有的锁的数量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">int</span>(mp.p.ptr().id)<span class="comment">//代表当前线程(m)执行的处理器(p)的唯一标识符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">procUnpin</span><span class="params">()</span></span> &#123;</span><br><span class="line">gp := getg()</span><br><span class="line">gp.m.locks--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>locks</code>:通过增加锁的计数，表明当前线程被固定（pinned）在处理器上</li><li><code>mp.p</code>表示当前线程所绑定的处理器，<code>.ptr()</code>方法返回处理器的指针，<code>.id</code>表示处理器的唯一标识符</li></ul><h4 id="pinslow"><a class="markdownIt-Anchor" href="#pinslow"></a> pinSlow</h4><p>将当前的<code>goroutine</code>绑定到<code>Pool</code>中的一个<code>poolLocal</code>上，并返回该<code>poolLocal</code>及其索引</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">pinSlow</span><span class="params">()</span> <span class="params">(*poolLocal, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//1. 解除当前goroutine与之前绑定的poolLocal的绑定关系，使当前goroutine可以进行重新绑定</span></span><br><span class="line">  <span class="comment">//使用 mutex 时候 P 必须可抢占</span></span><br><span class="line">  runtime_procUnpin()</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//2. 获取池的全局锁 </span></span><br><span class="line">  allPoolsMu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> allPoolsMu.Unlock()</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//3. 将当前的goroutine绑定到一个poolLocal上，并返回其索引pid。</span></span><br><span class="line"><span class="comment">//再次固定 P 时 poolCleanup 不会被调用</span></span><br><span class="line">  pid := runtime_procPin()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//获取未越界返回poolLocal</span></span><br><span class="line">  s := p.localSize  </span><br><span class="line">  l := p.local</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">uintptr</span>(pid) &lt; s &#123;</span><br><span class="line">    <span class="keyword">return</span> indexLocal(l, pid), pid</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 如果数组为空，将其添加到 allPools，垃圾回收器从这里获取所有 Pool 实例</span></span><br><span class="line">  <span class="keyword">if</span> p.local == <span class="literal">nil</span> &#123;</span><br><span class="line">    allPools = <span class="built_in">append</span>(allPools, p)</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 根据 P 数量创建 slice，如果 GOMAXPROCS 在 GC 间发生变化</span></span><br><span class="line"><span class="comment">// 我们重新分配此数组并丢弃旧的</span></span><br><span class="line">size := runtime.GOMAXPROCS(<span class="number">0</span>)  <span class="comment">// 获取当前的GOMAXPROCS值，即当前系统的最大并发数</span></span><br><span class="line">local := <span class="built_in">make</span>([]poolLocal, size)    <span class="comment">//创建本地池</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将底层数组起始指针保存到 p.local，并设置 p.localSize</span></span><br><span class="line">atomic.StorePointer(&amp;p.local, unsafe.Pointer(&amp;local[<span class="number">0</span>]))</span><br><span class="line">runtime_StoreReluintptr(&amp;p.localSize, <span class="keyword">uintptr</span>(size))  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回所需的 pollLocal</span></span><br><span class="line"><span class="keyword">return</span> &amp;local[pid], pid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个逻辑的前提是当前 P 已经发生了动态调整，需要重新计算<code>localPool</code></p><ul><li>首先解除 <code>goroutine</code> 与 <code>Process</code> 的绑定，让 <code>goroutine</code> 可以重新绑定</li><li>获取 <code>allPools</code>的全局锁</li><li>将当前  <code>goroutine</code> 与 <code>Process</code> 重新绑定</li><li>如果<code>Process</code> 未发生变化，返回 <code>Process</code> 的 <code>localPool</code></li><li>如果没有变化则<ul><li>如果 <code>Pool.local</code>为空，则需要将 <code>Pool</code> 加入到 <code>allPools</code> 中，用于 GC 扫描回收</li><li>重新创建 <code>[p]poolLocal</code></li><li>重新将 <code>Pool.local</code> 指向 <code>[p]poolLocal</code></li></ul></li></ul><h4 id="pin"><a class="markdownIt-Anchor" href="#pin"></a> pin</h4><p>获取当前 <code>Process</code> 中的 <code>poolLocal</code>，将当前的<code>goroutine</code>绑定到一个特定的<code>Process</code>上，禁用抢占并返回<code>Process</code>的<code>poolLocal</code>本地池和<code>P</code>的标识</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">pin</span><span class="params">()</span> <span class="params">(*poolLocal, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1. 将当前的goroutine绑定到一个P上，并返回P的标识pid。</span></span><br><span class="line">pid := runtime_procPin()</span><br><span class="line">  </span><br><span class="line">s := runtime_LoadAcquintptr(&amp;p.localSize) <span class="comment">// load-acquire</span></span><br><span class="line">l := p.local    <span class="comment">// load-consume</span></span><br><span class="line">  <span class="comment">//可能存在动态的 P（运行时调整 P 的个数）procresize/GOMAXPROCS，如果 P.id 没有越界，则直接返回</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uintptr</span>(pid) &lt; s &#123;</span><br><span class="line"><span class="keyword">return</span> indexLocal(l, pid), pid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p.pinSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试通过加载<code>local</code>和<code>localSize</code>字段的方式来判断是否可以直接返回一个可用的<code>poolLocal</code>，如果不满足条件，则调用<code>pinSlow</code>方法来重新分配并返回一个新的<code>poolLocal</code>。调用者在使用完<code>poolLocal</code>之后，必须调用<code>runtime_procUnpin()</code>来解除与<code>P</code>的绑定关系。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexLocal</span><span class="params">(l unsafe.Pointer, i <span class="keyword">int</span>)</span> *<span class="title">poolLocal</span></span> &#123;</span><br><span class="line">lp := unsafe.Pointer(<span class="keyword">uintptr</span>(l) + <span class="keyword">uintptr</span>(i)*unsafe.Sizeof(poolLocal&#123;&#125;))</span><br><span class="line"><span class="keyword">return</span> (*poolLocal)(lp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存池清理"><a class="markdownIt-Anchor" href="#内存池清理"></a> 内存池清理</h3><p>在使用 init 仅执行了一个逻辑，就是注册内存池回收机制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">runtime_registerPoolCleanup(poolCleanup)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>poolCleanup</code> 用于实现内存池的清理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poolCleanup</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Because the world is stopped, no pool user can be in a</span></span><br><span class="line"><span class="comment">// pinned section (in effect, this has all Ps pinned).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Drop victim caches from all pools.</span></span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> oldPools &#123;</span><br><span class="line">p.victim = <span class="literal">nil</span></span><br><span class="line">p.victimSize = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Move primary cache to victim cache.</span></span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> allPools &#123;</span><br><span class="line">p.victim = p.local</span><br><span class="line">p.victimSize = p.localSize</span><br><span class="line">p.local = <span class="literal">nil</span></span><br><span class="line">p.localSize = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The pools with non-empty primary caches now have non-empty</span></span><br><span class="line"><span class="comment">// victim caches and no pools have primary caches.</span></span><br><span class="line">oldPools, allPools = allPools, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>垃圾回收的策略就是</p><ul><li>将 <code>oldPools</code> 中也就是所有<code>localPool</code>的 <code>victim</code> 对象丢弃</li><li>将 <code>allPools</code> 的 <code>local</code> 复制给<code>victim</code>，并 <code>local</code> 重置</li><li>最后将 <code>allPools</code> 复制给 <code>oldPools</code>，<code>allPools</code> 置空</li></ul><h3 id="get"><a class="markdownIt-Anchor" href="#get"></a> Get</h3><p>整体流程如下</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/syncpool4.png" alt="syncpool4" style="zoom:50%;" /><ol><li>首先获取当前 <code>Process</code> 的 <code>poolLocal</code>，<strong>也就是说当 Goroutine 在哪个 Process 运行的时候就会从哪个 Process 的 localPool中获取对象</strong></li><li>优先从 <code>private</code> 中选择对象，并将 <code>private = nil</code></li><li>若取不到，则尝试从 <code>shared</code> 队列的队头进行读取</li><li>若取不到，则尝试从其他的 <code>Process</code> 中进行偷取 <code>getSlow</code><strong>（跨 Process 读写）</strong></li><li>若还是取不到，则使用自定义的 <code>New</code> 方法新建对象</li></ol><p>获取对象代码如下操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">any</span></span> &#123;</span><br><span class="line">  <span class="comment">//...race</span></span><br><span class="line">  <span class="comment">//1. 获取一个poolLocal</span></span><br><span class="line">  l, pid := p.pin()</span><br><span class="line">  <span class="comment">//2. 先从private获取对象</span></span><br><span class="line">x := l.private</span><br><span class="line">l.private = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 尝试从 localPool 的 shared 队列队头读取</span></span><br><span class="line">x, _ = l.shared.popHead()</span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 如果取不到，则获取新的缓存对象</span></span><br><span class="line">x = p.getSlow(pid)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">runtime_procUnpin()</span><br><span class="line"><span class="comment">//...race</span></span><br><span class="line">  <span class="comment">// 如果 getSlow 还是获取不到，则 New 一个</span></span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &amp;&amp; p.New != <span class="literal">nil</span> &#123;</span><br><span class="line">x = p.New()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 <code>getSlow</code> 就是从 其他 <code>Process</code> 或者 <code>victim</code> 中获取</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">getSlow</span><span class="params">(pid <span class="keyword">int</span>)</span> <span class="title">any</span></span> &#123;</span><br><span class="line"><span class="comment">//1. 加载本地池</span></span><br><span class="line">size := runtime_LoadAcquintptr(&amp;p.localSize) <span class="comment">// load-acquire</span></span><br><span class="line">locals := p.local                            <span class="comment">// load-consume</span></span><br><span class="line"><span class="comment">// Try to steal one element from other procs.</span></span><br><span class="line">  <span class="comment">//2. 尝试从其他 process 偷取元素</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(size); i++ &#123;</span><br><span class="line">l := indexLocal(locals, (pid+i+<span class="number">1</span>)%<span class="keyword">int</span>(size))</span><br><span class="line"><span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3. 从其他 process 也没有偷到</span></span><br><span class="line">  <span class="comment">//那么判断是否 process数量发生了变化</span></span><br><span class="line">size = atomic.LoadUintptr(&amp;p.victimSize)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uintptr</span>(pid) &gt;= size &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//4. 从 victim 中获取</span></span><br><span class="line">locals = p.victim</span><br><span class="line">l := indexLocal(locals, pid)</span><br><span class="line"><span class="keyword">if</span> x := l.private; x != <span class="literal">nil</span> &#123;</span><br><span class="line">l.private = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(size); i++ &#123;</span><br><span class="line">l := indexLocal(locals, (pid+i)%<span class="keyword">int</span>(size))</span><br><span class="line"><span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//到这里说明没有了，那么就将 victimSize 设置为 0后续不会访问</span></span><br><span class="line">atomic.StoreUintptr(&amp;p.victimSize, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put"><a class="markdownIt-Anchor" href="#put"></a> Put</h3><p>Put 的操作如下</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/syncpool5.png" alt="syncpool5" style="zoom:50%;" /><p>存放策略是：</p><ol><li>如果存放 <code>nil</code> 直接返回</li><li>获取当前 <code>Process</code> 的 <code>poolLocal</code></li><li>如果 <code>private == nil</code> 则放到 <code>private</code> 中</li><li>如果<code>private != nil</code> 则将起放入到 链表头部</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Put</span><span class="params">(x any)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...race</span></span><br><span class="line">  <span class="comment">// 获得一个 localPool</span></span><br><span class="line">l, _ := p.pin()</span><br><span class="line">  <span class="comment">// 优先放入private</span></span><br><span class="line"><span class="keyword">if</span> l.private == <span class="literal">nil</span> &#123;</span><br><span class="line">l.private = x</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l.shared.pushHead(x)</span><br><span class="line">&#125;</span><br><span class="line">runtime_procUnpin()</span><br><span class="line"><span class="comment">//...race</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>Pool 本质是为了提高<strong>临时对象的复用率</strong>；</li><li>Pool 使用两层回收策略（local + victim）避免性能波动；</li><li>Pool 本质是一个杂货铺属性，啥都可以放，Pool 池本身不做限制；</li><li>Pool 池里面 cache 对象也是分层的，一层层的 cache，取用方式从最热的数据到最冷的数据递进；</li><li>Pool 是并发安全的，但是内部是无锁结构，原理是对每个 P 都分配 cache 数组（ <code>poolLocalInternal</code>  数组），这样 cache 结构就不会导致并发；</li><li>永远不要 copy 一个 Pool，明确禁止，不然会导致内存泄露和程序并发逻辑错误；</li><li>代码编译之前用 <code>go vet</code>  做静态检查，能减少非常多的问题；</li><li>每轮 GC 开始都会清理一把 Pool 里面 cache 的对象，注意流程是分两步，当前 Pool 池 local 数组里的元素交给 victim 数组句柄，victim 里面 cache 的元素全部清理。换句话说，引入 victim 机制之后，对象的缓存时间变成两个 GC 周期；</li><li>不要对 Pool 里面的对象做任何假定，有两种方案：要么就归还的时候 memset 对象之后，再调用 <code>Pool.Put</code> ，要么就 <code>Pool.Get</code> 取出来的时候 memset 之后再使用；</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://mp.weixin.qq.com/s/dLzWAqM9lCln83jhkvmtMw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dLzWAqM9lCln83jhkvmtMw</a></li><li><a href="https://geektutu.com/post/hpg-sync-pool.html" target="_blank" rel="noopener">https://geektutu.com/post/hpg-sync-pool.html</a></li><li><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/pool/" target="_blank" rel="noopener">https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/pool/</a></li><li><a href="https://xie.infoq.cn/article/55f28d278cccf0d8195459263" target="_blank" rel="noopener">https://xie.infoq.cn/article/55f28d278cccf0d8195459263</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面一篇讲解了&lt;strong&gt;Sync.Pool&lt;/strong&gt;的底层数据结构 &lt;a href=&quot;https://www.yuankang.top/2023/07/01/Go/Go%E5%85%A5%E9%97%A825-PoolDequeue/&quot; target=&quot;_bl
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go-26-Issue</title>
    <link href="http://xboom.github.io/2023/07/13/Go/Go-26-Issue/"/>
    <id>http://xboom.github.io/2023/07/13/Go/Go-26-Issue/</id>
    <published>2023-07-13T14:59:45.000Z</published>
    <updated>2023-07-19T15:34:46.967Z</updated>
    
    <content type="html"><![CDATA[<h3 id="issue-23199"><a class="markdownIt-Anchor" href="#issue-23199"></a> Issue-23199</h3><p>在阅读 <code>sync.Pool</code> 在 <code>fmt</code> 中的使用时候看到了这样一段代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pp)</span> <span class="title">free</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Proper usage of a sync.Pool requires each entry to have approximately</span></span><br><span class="line"><span class="comment">// the same memory cost. To obtain this property when the stored type</span></span><br><span class="line"><span class="comment">// contains a variably-sized buffer, we add a hard limit on the maximum</span></span><br><span class="line"><span class="comment">// buffer to place back in the pool. If the buffer is larger than the</span></span><br><span class="line"><span class="comment">// limit, we drop the buffer and recycle just the printer.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// See .https://golang.org/issue/23199</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span>(p.buf) &gt; <span class="number">64</span>*<span class="number">1024</span> &#123;</span><br><span class="line">p.buf = <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p.buf = p.buf[:<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//存入内存池</span></span><br><span class="line">ppFree.Put(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述英文解释的大致意思是</p><blockquote><p><code>sync.Pool</code>在使用的时候<strong>每个对象的内存消耗应该大致相同</strong>。当存储的类型包含可变大小的缓冲区时，需要对最大缓冲区设置一个硬限制，以确保如果缓冲区的大小超过限制，将丢弃缓冲区，并仅回收</p></blockquote><p>因为 <code>fmt</code> 使用内存池分配的对象大小不是固定的，如下 <code>buf</code> 其实是一个缓冲区</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ppFree = sync.Pool&#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">any</span></span> &#123; <span class="keyword">return</span> <span class="built_in">new</span>(pp) &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> pp <span class="keyword">struct</span> &#123;</span><br><span class="line">buf buffer</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> buffer []<span class="keyword">byte</span></span><br></pre></td></tr></table></figure><p>这里做一个测试就会明白这样的处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(a), <span class="built_in">len</span>(a))<span class="comment">//100 100</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(b), <span class="built_in">len</span>(b)) <span class="comment">//100 100</span></span><br><span class="line"></span><br><span class="line">a = <span class="literal">nil</span></span><br><span class="line">b = b[:<span class="number">0</span>]</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(a), <span class="built_in">len</span>(a))<span class="comment">//0 0</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(b), <span class="built_in">len</span>(b)) <span class="comment">///100 0</span></span><br></pre></td></tr></table></figure><p>使用 b[:0] 之后只是切片长度变化，容量并不会变，也就是内存仍然占用那么多</p><p>所以，如果内存池大小不固定的时候注意主动释放，防止额外占用空间而不被释放。再来看看它的测试结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">finalizer</span><span class="params">(buffer *bytes.Buffer)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"GC %d buffer \n"</span>, buffer.Cap())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> stats runtime.MemStats</span><br><span class="line">runtime.ReadMemStats(&amp;stats)</span><br><span class="line">fmt.Printf(<span class="string">"start %d B\n"</span>, stats.Alloc)</span><br><span class="line"></span><br><span class="line">pool := sync.Pool&#123;New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">runtime.SetFinalizer(buf, finalizer)</span><br><span class="line"><span class="keyword">return</span> buf</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line">processRequest := <span class="function"><span class="keyword">func</span><span class="params">(size <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">b := pool.Get().(*bytes.Buffer)</span><br><span class="line">time.Sleep(<span class="number">500</span> * time.Millisecond) <span class="comment">// Simulate processing time</span></span><br><span class="line">b.Grow(size)</span><br><span class="line">pool.Put(b)</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Millisecond) <span class="comment">// Simulate idle time</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟一组大规模写入</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">processRequest(<span class="number">1</span> &lt;&lt; <span class="number">20</span>) <span class="comment">// 256MiB</span></span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second) <span class="comment">// Let the initial set finish</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟小规模写入且不会停</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">processRequest(<span class="number">1</span> &lt;&lt; <span class="number">10</span>) <span class="comment">// 1KiB</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次GC之后查看分配的内存</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">runtime.ReadMemStats(&amp;stats)</span><br><span class="line">fmt.Printf(<span class="string">"Cycle %d: %dB\n"</span>, i, stats.Alloc)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">runtime.GC()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <a href="https://www.yuankang.top/2023/01/04/Go/Go-21-SetFinalizer/" target="_blank" rel="noopener">runtime.SetFinalizer</a> 大概说明对象的回收时间，会发现大对象并不是立即回收的，而是经过了一段时间，内存才趋于稳定。高并发场景下，比如处理网络请求的时候，可能导致大量内存的占用而没有及时释放</p><p><strong>解决办法</strong>: 就在在判断超过一定大小的时候直接丢弃</p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://golang.org/issue/23199" target="_blank" rel="noopener">https://golang.org/issue/23199</a></li><li><a href="https://go-review.googlesource.com/c/go/+/136035/1/src/encoding/json/encode.go" target="_blank" rel="noopener">https://go-review.googlesource.com/c/go/+/136035/1/src/encoding/json/encode.go</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;issue-23199&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#issue-23199&quot;&gt;&lt;/a&gt; Issue-23199&lt;/h3&gt;
&lt;p&gt;在阅读 &lt;code&gt;sync.Pool&lt;/code&gt; 在 &lt;code&gt;fmt&lt;/code&gt;
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go-25-PoolDequeue</title>
    <link href="http://xboom.github.io/2023/07/01/Go/Go-25-PoolDequeue/"/>
    <id>http://xboom.github.io/2023/07/01/Go/Go-25-PoolDequeue/</id>
    <published>2023-07-01T08:51:45.000Z</published>
    <updated>2023-07-15T05:38:08.054Z</updated>
    
    <content type="html"><![CDATA[<p>在学习Golang 中 的内存池 <code>Sync.Pool</code> 之前，底层是使用的 一个<strong>无锁</strong>的 <strong>动态扩容</strong> 的<strong>双端队列</strong>支持 <strong>单生产者</strong> <strong>多消费者</strong>  的 <code>Sync.Pool</code> 内存分配模式，它是一个私有结构体，所以外部无法访问它，这里来看看如何实现的</p><p><strong>代码：</strong><code>src/sync/poolqueue.go</code></p><p>带着问题看世界</p><ol><li>如何动态扩容的</li><li>为什么内存池要是用这样的 数组 + 链表</li></ol><h3 id="pooldequeue"><a class="markdownIt-Anchor" href="#pooldequeue"></a> poolDequeue</h3><p>首先看一下基本结构结构体，使用数组实现了一个 <code>ring buffer</code> 的结构</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/PoolDequeue1.png" alt="PoolDequeue1" style="zoom:50%;" /><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolDequeue <span class="keyword">struct</span> &#123;    </span><br><span class="line">  <span class="comment">// headTail 包含了 32bit的头部索引与32位尾部索引指向 vals</span></span><br><span class="line">  <span class="comment">// head 高 32 位, 指向下一个存放对象的索引</span></span><br><span class="line">  <span class="comment">// tail 低 32 位, 指向队列中最早(下一个读取)的对象索引</span></span><br><span class="line"><span class="comment">// 索引区间 tail &lt;= i &lt; head, 是消费者可以在该区间不断获取对象，直至获取到的对象为 nil</span></span><br><span class="line">headTail <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// vals 表示队列元素容器，大小必须为 2 的 N 次幂</span></span><br><span class="line"><span class="comment">// 容器会在初始化时指定容量，实现数据元素内存预初始化</span></span><br><span class="line"><span class="comment">// 队列会将未使用的槽位设置为nil</span></span><br><span class="line">vals []eface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么要将 <code>head</code> 和 <code>tail</code> 合并到一个变量里面？</strong></p><p>当队列中存在多个对象，两边同时操作貌似没什么问题，但为了防止队列中仅剩一个对象时，就需要锁住两个索引进行操作，所以利用了 <code>atomic</code> 包的提供的 <code>CAS</code> 操作，完成两个字段的 <code>lock free</code> 无锁编程</p><p>更新 <code>head</code> 和 <code>tail</code> 两个字段的时候，也是通过 <code>CAS + 位运算</code> 进行操作的。更新逻辑如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dequeueNil 是用于在 poolDequeue 中表示 interface&#123;&#125;(nil) 的类型。由于使用 nil 来表示空槽位，所以需要一个特殊值来表示 nil。</span></span><br><span class="line"><span class="keyword">type</span> dequeueNil *<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span> <span class="title">unpack</span><span class="params">(ptrs <span class="keyword">uint64</span>)</span> <span class="params">(head, tail <span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> mask = <span class="number">1</span>&lt;&lt;dequeueBits - <span class="number">1</span><span class="comment">//获取掩码</span></span><br><span class="line">head = <span class="keyword">uint32</span>((ptrs &gt;&gt; dequeueBits) &amp; mask)<span class="comment">//获取头部索引</span></span><br><span class="line">tail = <span class="keyword">uint32</span>(ptrs &amp; mask)<span class="comment">//获取尾部索引</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span> <span class="title">pack</span><span class="params">(head, tail <span class="keyword">uint32</span>)</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> mask = <span class="number">1</span>&lt;&lt;dequeueBits - <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">uint64</span>(head) &lt;&lt; dequeueBits) |</span><br><span class="line"><span class="keyword">uint64</span>(tail&amp;mask)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>unpack</code> 与 <code>pack</code> 实现了在 <code>poolDequeue</code> 结构中进行索引值的打包和解包操作。使得在 <code>poolDequeue</code> 结构中使用单个 64 位整数来同时存储头部索引和尾部索引</p><p>所以整体就如下图所示</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/PoolDequeue3.png" alt="PoolDequeue3" style="zoom:50%;" /><p>接着是对队列的操作，分为 <strong>头部写入</strong>、<strong>头部弹出</strong>、<strong>尾部弹出</strong></p><h4 id="pushhead"><a class="markdownIt-Anchor" href="#pushhead"></a> pushHead</h4><p>头部写入返回成功失败</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span> <span class="title">pushHead</span><span class="params">(val any)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="comment">//1. 原子操作获取索引</span></span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)</span><br><span class="line">  <span class="comment">//2. 解析头尾索引</span></span><br><span class="line">head, tail := d.unpack(ptrs)</span><br><span class="line">  <span class="comment">//3. (当尾部索引 + 队列长度)&amp; 掩码 == 头部索引，说明队列满了</span></span><br><span class="line"><span class="keyword">if</span> (tail+<span class="keyword">uint32</span>(<span class="built_in">len</span>(d.vals)))&amp;(<span class="number">1</span>&lt;&lt;dequeueBits<span class="number">-1</span>) == head &#123;</span><br><span class="line">  <span class="comment">// Queue is full.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//4. 没有满则获取头部位置</span></span><br><span class="line">slot := &amp;d.vals[head&amp;<span class="keyword">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 判断头部是否已经被释放</span></span><br><span class="line">typ := atomic.LoadPointer(&amp;slot.typ)</span><br><span class="line"><span class="keyword">if</span> typ != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Another goroutine is still cleaning up the tail, so</span></span><br><span class="line"><span class="comment">// the queue is actually still full.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The head slot is free, so we own it.</span></span><br><span class="line">    <span class="comment">//如果存放的是nil，那么使用 dequeueNil(nil) 表示存放的是一个nil类型</span></span><br><span class="line"><span class="keyword">if</span> val == <span class="literal">nil</span> &#123;</span><br><span class="line">val = dequeueNil(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">*(*any)(unsafe.Pointer(slot)) = val</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为头部索引是高32位，所以 增加 1&lt;&lt;dequeueBits，同理尾部索引是低32，直接减1</span></span><br><span class="line">atomic.AddUint64(&amp;d.headTail, <span class="number">1</span>&lt;&lt;dequeueBits)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>type == nil</code>，则表示 <code>slot</code> 已经被释放，如果 <code>value = dequeueNil(nil)</code> 表示存放的是一个 <code>nil</code> (但注意，<code>Sync.Pool</code> 的<code>Put(nil)</code> 会直接返回，而不会真的存放一个 <code>nil</code>)</p><h4 id="pophead"><a class="markdownIt-Anchor" href="#pophead"></a> popHead</h4><p>返回头部索引位置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span> <span class="title">popHead</span><span class="params">()</span> <span class="params">(any, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> slot *eface</span><br><span class="line">    <span class="comment">//使用 CAS 不断尝试获取头部值</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//加载并解析索引获取头部位置，判断是否为空</span></span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)</span><br><span class="line">head, tail := d.unpack(ptrs)</span><br><span class="line"><span class="keyword">if</span> tail == head &#123;</span><br><span class="line"><span class="comment">// Queue is empty.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算更新后的索引值</span></span><br><span class="line">head--</span><br><span class="line">ptrs2 := d.pack(head, tail)</span><br><span class="line">        <span class="comment">//CAS 更新</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;</span><br><span class="line"><span class="comment">//获取头部位置</span></span><br><span class="line">slot = &amp;d.vals[head&amp;<span class="keyword">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 如果 不是 ptrs 所以已经发生了变化那么重试</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val := *(*any)(unsafe.Pointer(slot))</span><br><span class="line"><span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;<span class="comment">//如果存放的是nil，那么返回nil</span></span><br><span class="line">val = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将槽置位 zero，为什么不会与pushHead冲突</span></span><br><span class="line">*slot = eface&#123;&#125; </span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>popTail</code> 与 <code>popHead</code>差不多，最后的赋值有区别</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slot.val = <span class="literal">nil</span><span class="comment">//直接赋值空值</span></span><br><span class="line">atomic.StorePointer(&amp;slot.typ, <span class="literal">nil</span>)<span class="comment">//表示为空</span></span><br></pre></td></tr></table></figure><p><strong>为什么 <code>popTail</code>  与 <code>popHead</code> 处理方式不一样</strong>，是因为设计的就是单个生产者与多个消费者，所以<code>popHead</code>并不会有竞争的问题，最后都是存放的 <code>slot{}</code></p><h3 id="poolchainelt"><a class="markdownIt-Anchor" href="#poolchainelt"></a> poolChainElt</h3><p><code>poolChainElt</code> 是一个双向链表的节点，包含林一个每个节点 <code>poolDequeue</code> 结构 以及 双向指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolChainElt <span class="keyword">struct</span> &#123;</span><br><span class="line">poolDequeue</span><br><span class="line">next, prev *poolChainElt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="poolchain"><a class="markdownIt-Anchor" href="#poolchain"></a> poolChain</h3><p>有了双向链表节点，那么就有双向链表 <code>poolChain</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolChain <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//由于只有生产者访问该字段，因此不需要同步操作</span></span><br><span class="line">head *poolChainElt</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于消费者访问该字段，因此读写必须是原子操作</span></span><br><span class="line">tail *poolChainElt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>poolChain</code> 是一个双向链表队列，其中每个 <code>poolDequeue</code> 的大小是前一个 <code>poolDequeue</code> 的两倍。一旦一个 <code>poolDequeue</code> 填满，就会分配一个新的 <code>poolDequeue</code>，并且只会将数据推入到最新的 <strong>poolDequeue</strong>。弹出操作发生在列表的另一端，当一个 <code>poolDequeue</code> 被耗尽后，它会从链表中移除。</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/PoolDequeue4.png" alt="PoolDequeue4" style="zoom:50%;" /><p>通过这种设计，<code>poolChain</code> 实现了一个可以动态增长的队列，以适应对象池中的元素数量变化。它能够高效地管理多个不同大小的队列，并提供生产者和消费者之间的并发访问。生产者将数据推入到最新的 <code>poolDequeue</code>，而消费者从链表的另一端弹出数据。这样可以避免竞争条件和锁等待，并提高并发性能</p><h4 id="pushhead-2"><a class="markdownIt-Anchor" href="#pushhead-2"></a> pushHead</h4><p>有了双向链表之后，再来看它是如何写入一个值的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span> <span class="title">pushHead</span><span class="params">(val any)</span></span> &#123;</span><br><span class="line">    <span class="comment">//1. 获取双向链表头部节点</span></span><br><span class="line">d := c.head</span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">//2. 如果头部节点是空的，说明整个链表都是空的，那么就需要初始化一个链表节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initSize = <span class="number">8</span> <span class="comment">// 默认大小是8，必须是2的倍数</span></span><br><span class="line">d = <span class="built_in">new</span>(poolChainElt)</span><br><span class="line">d.vals = <span class="built_in">make</span>([]eface, initSize)<span class="comment">//节点popDequeue的默认大小是8</span></span><br><span class="line">c.head = d<span class="comment">//双向链表的的头部指针指向这个节点</span></span><br><span class="line">        storePoolChainElt(&amp;c.tail, d) <span class="comment">//将节点追加到双向链表尾部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将值写入头部节点的内存池队列中，如果成功就结束</span></span><br><span class="line"><span class="keyword">if</span> d.pushHead(val) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果到这里，说明插入失败了，那么就会创建一个更大(2倍)的内存池队列 poolDequeue</span></span><br><span class="line">newSize := <span class="built_in">len</span>(d.vals) * <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> newSize &gt;= dequeueLimit &#123;<span class="comment">//最大不能超过 1 &lt;&lt; 32 / 4 = 1 &lt;&lt; 30</span></span><br><span class="line">newSize = dequeueLimit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">d2 := &amp;poolChainElt&#123;prev: d&#125;<span class="comment">//新建节点前驱是 d</span></span><br><span class="line">d2.vals = <span class="built_in">make</span>([]eface, newSize)<span class="comment">//构建指定大小的切片</span></span><br><span class="line">c.head = d2<span class="comment">//将d2设置为头部节点</span></span><br><span class="line">storePoolChainElt(&amp;d.next, d2) <span class="comment">//d的后继为d2</span></span><br><span class="line">d2.pushHead(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照效果如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">8</span>] -- [<span class="number">16</span>] -- [<span class="number">32</span>] -- head</span><br></pre></td></tr></table></figure><h4 id="pophead-2"><a class="markdownIt-Anchor" href="#pophead-2"></a> popHead</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span> <span class="title">popHead</span><span class="params">()</span> <span class="params">(any, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//获取头部节点</span></span><br><span class="line">d := c.head</span><br><span class="line"><span class="keyword">for</span> d != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">//获取队列头部节点</span></span><br><span class="line"><span class="keyword">if</span> val, ok := d.popHead(); ok &#123;</span><br><span class="line"><span class="keyword">return</span> val, ok</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 到这里是没有获取到，然后指向前驱继续获取</span></span><br><span class="line">d = loadPoolChainElt(&amp;d.prev)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="poptail"><a class="markdownIt-Anchor" href="#poptail"></a> popTail</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span> <span class="title">popTail</span><span class="params">()</span> <span class="params">(any, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//1. 加载尾部队列节点，如果没有表示链表为空则返回 false</span></span><br><span class="line">d := loadPoolChainElt(&amp;c.tail)</span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 记录尾部的后驱</span></span><br><span class="line">d2 := loadPoolChainElt(&amp;d.next)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出队列尾部值</span></span><br><span class="line"><span class="keyword">if</span> val, ok := d.popTail(); ok &#123;</span><br><span class="line"><span class="keyword">return</span> val, ok</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 d 没有了，d2 也为空，说明没有值</span></span><br><span class="line"><span class="keyword">if</span> d2 == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// CAS 尝试获取 d</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;c.tail)), unsafe.Pointer(d), unsafe.Pointer(d2)) &#123;</span><br><span class="line"><span class="comment">//如果获取到那么去掉前继</span></span><br><span class="line">storePoolChainElt(&amp;d2.prev, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//更新尾部指针</span></span><br><span class="line">d = d2</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>无锁的原因是队列形式，单个生产者在头部操作，消费者从队尾消费</li><li>并不是固定大小，而是作为双向链表节点的队列最大长度是 <code>1 &lt;&lt; 32/ 4</code>  ，并且用环形缓冲区 <code>ring buffer</code> 实现</li><li>Pool 底层 使用 数组 + 链表的形式的原因是由 Pool 的特性决定的，它需要频繁的内存分配，所以数组是一个好的选择。又为了解决扩容的问题，使用链表来连接数组</li></ul><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://mp.weixin.qq.com/s/dLzWAqM9lCln83jhkvmtMw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dLzWAqM9lCln83jhkvmtMw</a></li><li><a href="https://geektutu.com/post/hpg-sync-pool.html" target="_blank" rel="noopener">https://geektutu.com/post/hpg-sync-pool.html</a></li><li><a href="https://studygolang.com/articles/28386" target="_blank" rel="noopener">https://studygolang.com/articles/28386</a></li><li><a href="https://juejin.cn/post/7213257917255385149" target="_blank" rel="noopener">https://juejin.cn/post/7213257917255385149</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习Golang 中 的内存池 &lt;code&gt;Sync.Pool&lt;/code&gt; 之前，底层是使用的 一个&lt;strong&gt;无锁&lt;/strong&gt;的 &lt;strong&gt;动态扩容&lt;/strong&gt; 的&lt;strong&gt;双端队列&lt;/strong&gt;支持 &lt;strong&gt;单生产者&lt;/str
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>协议-03-Raft</title>
    <link href="http://xboom.github.io/2023/06/26/Protocol/%E5%8D%8F%E8%AE%AE-03-Raft/"/>
    <id>http://xboom.github.io/2023/06/26/Protocol/%E5%8D%8F%E8%AE%AE-03-Raft/</id>
    <published>2023-06-26T02:25:38.000Z</published>
    <updated>2023-06-26T10:29:53.701Z</updated>
    
    <content type="html"><![CDATA[<p>在学习分布式系统过程中，经常能碰到一致性算法，即使出现部分节点故障，网络延时等情况，也不影响整体可用性，进而提高系统的整体可用性。Raft协议是一种分布式一致性算法(共识算法)，共识就是多个节点对某一个事件达成一致的算法，常见的一致性协议有Raft、Paxos、ZAB，根据 《ETCD 技术内幕》 学习 Raft 协议</p><h3 id="基本定义"><a class="markdownIt-Anchor" href="#基本定义"></a> 基本定义</h3><p>Raft 为了实现共识，会选举出主从节点，任意节点都处于下面3类角色：</p><ul><li><strong>Leader(领袖)</strong>：领袖由群众投票选举得出，每次选举，只能选出一名领袖；</li><li><strong>Candidate(候选人)</strong>：当没有领袖时，某些群众可以成为候选人，然后去竞争领袖的位置；</li><li><strong>Follower(群众)</strong>：相对于 Leader 来说，在非选举过程中的其他节点就是 Follower，任何节点都可能通过 Candidate 成为 Leader</li></ul><p>在进行选举过程中，还有几个重要的概念：</p><ul><li><strong>Leader Election(领导人选举)</strong>：简称选举，就是指选出 Leader；</li><li><strong>Term(任期)</strong>：其实是一个单独递增的连续数字，每一次任期就会重新发起一次 Leader Election，每个节点都会记录当前的任期值</li><li><strong>Election Timeout(选举超时)</strong>：就是一个超时时间，当 Follower 超时未收到 Leader 的心跳时，会重新进行选举</li></ul><p><strong>任期(Term)</strong>：实际上是一个全局的、连续递增的整数。<strong>在raft中，每进行一次选举，任期就会+1</strong></p><p>节点存在三种状态分别是：</p><ul><li>Leader节点：可读可写、处理日志复制、保证⼀致性、维护⼼跳</li><li>Follower节点：可进行读操作，写操作需要路由到Leader处理；参与投票，<strong>⼀个term任期内只能投⼀次;</strong> 当触发 election timeout 时，晋升为 Candidate</li><li>Candidate节点：集群的候选者，会发起投票试图当选leader ; 通过 <code>RequestVote</code> 通知其他节点来投票;</li></ul><p>集群中任意一个节点都处于这三个状态之一</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220125000023.png" alt="image-20220125000018705" style="zoom:80%;" /><p>如上图所示</p><ol><li><p><strong>当 Etcd节点刚启动的时候，节点初始化状态为 Follower</strong></p></li><li><p>为了进行 Leader Election 有两个时间</p><ul><li><strong>选举超时时间(Election timeout)</strong>: 每个 Follower 节点在接收不到 Leader 节点的心跳消息之后，并不会立即发起新一轮选举，而是需要等待一段时间之后才切换成 Candidate 状态发起新一轮选举。<strong>是一个一定范围的随机数，为了保证各节点不是同时发起选举请求</strong></li><li><strong>心跳超时时间(Heartbeat timeout):</strong> Leader节点向集群中其他Follower节点发送心跳消息的时间间隔</li></ul></li><li><ul><li><ul><li></li></ul></li></ul></li></ol><h3 id="leader选举"><a class="markdownIt-Anchor" href="#leader选举"></a> Leader选举</h3><p>能成为 Leader 的条件有</p><ul><li>当前集群⽆可用 leader</li><li>触发 Election timeout</li><li>Term 任期最新</li><li>Log 日志最新</li><li>获取多数投票</li></ul><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312200222.png" alt="image-20220312200222021" /></p><p>流程可以查看：<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></p><p>需要注意的是：</p><ol><li>超过集群半数节点应答，才将日志写入WAL中，也是就如果没有等到半数应答就挂了，那么数据就丢了</li><li>Follower 收到 Leader 的 复制日志 则直接将日志写入 WAL 中</li><li>当Follower收到 Vote Request 也会重置 election timeout 定时器(降低同时出现两个候选人的概率)</li><li>Term 将持续直到某个节点因为心跳超时而从新发起选举</li><li>出现多个候选人都没有称为 Leader，那么选举失败，切换为Follower，等待下一个选举超时</li><li>Leader 宕机后，其他节点重新选出新 Leader。等到旧Leader 恢复，会因为收到新Leader心跳 而自己的 Term 落后，切换成 Follower，更新自己的Term，然后重新投出自己的选票</li></ol><h4 id="基本流程"><a class="markdownIt-Anchor" href="#基本流程"></a> 基本流程</h4><p>将设ETCD集群中有三个节点(A、B、C)</p><img src="/Users/xboom/Library/Application Support/typora-user-images/image-20230626161744828.png" alt="image-20230626161744828" style="zoom:50%;" /><ol><li>初始化，<strong>所有节点起初都是 Follower 状态</strong>(Term = 0， 得票数 = 0)</li><li>节点 A 由于长时间未收到 Leader 的心跳消息，就会切换成为 Candidate 状态并发起选举<ul><li>节点 A 的选举计时器 Election Timer 己被重置</li></ul></li><li>节点 A 首先会将自己的选票投给自己，并会向集群中其他节点发送选举请求 **Request Vote **以获取其选票，此时节点会有几种状态<ul><li>当前状态是 Leader(初始化的时候不会)</li><li>当前状态是 Candidate，当处于 Candidate 状态而收到 <code>Request Vote</code> 的时候，如果接收到 Term 值比自身记录的 Term 值大的请求时，节点会切换成 Follower 状态井更新自身记录的 Term 值</li><li>当前状态是 Follower，此时的节点 B 和节点 C 还都是处于 Term=0 的任期之中，且都是 Follower 状态，均未投出 Term=1 任期中的选票，所以节点 B 和节点 C 在接收到节点 A 的选举请求后会将选票投给节点 A，任期变为1</li></ul></li></ol><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220306235342.png" alt="image-20220306235342760" style="zoom:50%;"/><ol start="4"><li><p>在节点 A 收到节点 B、 C 的投票之后，其收到了集群中超过半数的选票，所以在 Term = 1 的任期中，该集群的 Leader 节点就是节点 A，其他节点将切换成 Follower 状态，</p><blockquote><p>节点除了记录当期任期号(CurrentTerm)，还记录在该任期中当前节点的投票结果(VoteFor)</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220307000505.png" alt="image-20220307000505928" style="zoom:50%;" /></li><li><p>成为 Term = 1 任期的 Leader 节点之后，节点 A 会定期向集群中的其他节点发送心跳消息，防止节点 B 和节点 C 中的选举计时器Election timer 超时而触发新一轮的选举(重置定时器)，此时当前节点的状态</p><ul><li>当前状态是 Follower，当节点 B 和节点 C (Follower) 收到节点 A 的心跳消息之后会重置选举计时器，更新 Term</li><li>当前状态是 Candidate， 当处于 Candidate 状态而收到 <code>Request Vote</code> 的时候，如果接收到 Term 值比自身记录的 Term 值大的请求时，节点会切换成 Follower 状态井更新自身记录的 Term 值</li></ul><blockquote><p>心跳超时时间（heartbeat timeout）需要远小于选举超时时间(election timeout)</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220307000654.png" alt="image-20220307000653976" style="zoom:50%;" /></li></ol><blockquote><p>Candidate 发起选举前,会先尝试连接集群中的其他节点。如果连接不上，放弃本次选举。这个状态称之为：<strong>Prevote</strong></p></blockquote><p>带着问题看世界</p><ol><li><p>如果Leader节点频繁宕机，或者选举反复进行，怎么办？</p><p>答：要求 心跳超时时间 &lt;&lt; 选举超时时间 &lt;&lt; 平均故障间隔时间</p><ul><li><p>心跳超时时间：节点直接发送心跳信息的完整返回时间 Hearthbeat timeout：0.5ms~50ms</p></li><li><p>选举超时时间：election timer：200ms~1s</p></li><li><p>故障间隔时间：两次故障的平均时间：1个月或更多(保证节点的不要经常出故障)</p></li></ul></li><li><p>是不是谁先发起了选举请求，谁就得到了Leader？</p><p>答：不是，除了看先后顺序，还取决于Candidate节点日志是不是最新最全的日志，否则拒绝投票，防止出现日志(即数据)丢失的情况</p></li><li><p>如果两个节点同时成为 Candidate 发起选举，刚好它们的日志 都是最新的是如何选举的</p><p>答：虽然每个节点的 Election Timer 都不同，但也是不能避免两个节点同时触发选举。比如有 4 个节点</p></li></ol><h4 id="异常情况"><a class="markdownIt-Anchor" href="#异常情况"></a> 异常情况</h4><p><strong>场景 1</strong>：假设A、B同时触发选举，A 的<code>Request Vote</code>先抵达节点 C ，B 的<code>Request Vote</code>先抵达节点 D，A、B 除了得到自身的选票之外，还分别得到了节点 C 和节点 D 的 <code>Vote</code>且票数相同没有超过半数</p><p>在这种情况下， Term = 4 这个任期会以选举失败结束，随着时间的流逝，当任意节点的 Election Timer 到期之后，会再次发起新一轮的选举。由于 <code>election timeout</code> 是在一个时间区间内取的随机数，所以在配置合理的时候，像上述情况多次出现的概率并不大</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230626165029693.png" alt="image-20230626165029693" style="zoom:50%;" /><p><strong>场景 2</strong>：假设选举已经完成， Leader 在运行过程中 Down 掉了</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230626170654713.png" alt="image-20230626170654713" style="zoom:50%;" /><p>当 A 恢复之后，会收到节点 D 发来的心跳消息，该<strong>消息中携带的任期号 Term=6 &gt; 节点 A 前记录的任期号 Term=5</strong> ，A 切换成 Follower</p><p>并更新自身的 Term，同时重置远举计时器</p><p>场景 3：当节点与其他节点断开连接(出现网络分区)，不断触发选举超时，在恢复的时候因为 Term 比较大又成了 Leader</p><p>为了防止选举超时而不断的增加 Term ，当恢复的时候因为 Term 而变成 Leader，所以采取了 Prevote 措施，变为 candidate 的条件</p><ul><li>询问其他节点是否有可用 leader</li><li>可连通绝⼤数节点</li></ul><h3 id="日志复制"><a class="markdownIt-Anchor" href="#日志复制"></a> 日志复制</h3><p>Leader 节点除了向 Follower 节点发送心跳消息，还会处理客户端的请求，并将客户端的写操作 以消息(Append Entries 消息)的形式发送到集群中所有Follower节点</p><p>步骤如下：</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312204541.png" alt="image-20220312204541060"  /><ol><li>Leader 节点接到 client 请求后 <code>set a=10</code>,将本请求计入本地log</li></ol><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312204707.png" alt="image-20220312204707596" /></p><ol start="2"><li>Leader 节点向 Follower1 和 Follower2 发送Append Entries消息 <code>set a=10</code></li><li>Follower1 和 Follower2 将此信息计入本地log，并返回给 Leader</li></ol><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312204848.png" alt="image-20220312204848066" /></p><ol start="4"><li>Leader 将日志信息置为 已提交(Commited),然后状态机处理。</li><li>响应 client 请求</li><li>向 Follower1 和 Follower2 发送消息，该信息已提交</li><li>Follower1 和 Follower2 接到消息后，修改日志状态，交给自己的状态机处理</li></ol><h4 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引</h4><p>集群中各个节点都会维护一个本地 Log 用于记录更新操作，还会维护 <code>commitlndex</code> 和<code>lastApplied</code> 两个值，它们是本地Log 的索引值</p><ul><li><code>commitlndex</code> 表示的是当前节点已知的、最大的、己提交的日志索引值</li><li><code>lastApplied</code> 表示的是当前节点最后一条被应用到状态机中的日志索引值。</li></ul><p>当节点中的 <code>commitlndex</code> 值大于 <code>lastApplied</code> 值时，会将 <code>lastApplied + 1</code> ，并将 <code>lastApplied</code> 对应的日志应用到其状态机中。</p><p>Leader 还需要了解集群中其他 Follower 节点的这些信息，而决定下次发送 Append Entries 消息中包含哪些日志记录。为此， Leader 节点会维护 <code>nextlndex[]</code>和 <code>matchlndex[]</code>两个数组，这两个数组中记录的都是日志索引值</p><ul><li><code>nextlndex[]</code> 记录了需要发送给 Follower 节点的下一条日志的索引值</li><li><code>matchlndex[]</code> 记录了己经复制给每个Follower 节点的最大的日志索引值</li></ul><blockquote><p>一个数组不就可以表达了吗？</p><p>答：不行，<code>nextIndex</code>用于指示Leader节点将要发送给Follower节点的下一个日志条目的位置，帮助Leader节点推进复制进度；<code>matchIndex</code>用于指示Leader节点已经复制到Follower节点上的最高日志条目的位置，帮助Leader节点确定已经<strong>被大多数节点确认的日志条目</strong>，可以进行提交</p></blockquote><p>Leader 节点中 <code>matchlndex</code> 大于等于该 Follower 节点对应的 <code>nextlndex</code> 值，那么通过 Append Entries 消息发送从<code>nextlndex</code> 开始的所有日志。之后，Leader节点会检测该 Follower 节点返回的相应响应，</p><ul><li>如果成功则更新相应该 Follower 节点对应的 <code>nextlndex</code> 值和<code>matchlndex</code> 值；</li><li>如果因为日志不一致而失败，则减少 <code>nextlndex</code> 值重试</li></ul><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230626172915420.png" alt="image-20230626172915420" style="zoom:50%;" /><p>A 作为 Leader 节点记录了 <code>nextlnde</code> 和 <code>matchlndex</code>，所以 A 应该知道向 B 、C 节点发送哪日志</p><p>Raft 协议采用批量发送的方式，当B、C 收到 Append Entries 消息后将日志记录到本地 Log 中，然后向 Leader 节点返回追加日志成功的响应，Leader 节点收到响应之后会递增节点对应的<code>nextlndex</code> 、<code>matchlnde</code> 这样，Leader 节点就知道下次发送日志的位置</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230626173725246.png" alt="image-20230626173725246" style="zoom:50%;" /><p>上面是 Leader 的情况，当 Leader 从 A 切换到 B，B 并不知道 Leader 节点记录 <code>nextlndex</code>、<code>matchlndex</code> 信息 ，所以新 Leader 节点<strong>会重置 nextlndex、matchlnd</strong> ，其中会将 <code>nextlndex</code> 全部重置为其自身 Log 的最后一条己提交日志的 Index，而 <code>matchlndex</code> 全部重置为 0</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230626173850377.png" alt="image-20230626173850377" style="zoom:50%;" /><p>新任期中的 Leader 节点向其他节点发送 Append Entrie 消息，拥有了当前 Leader 全部日志记录，会返回追加成功的响应并等后续的日志，而 C 没有 Index=2 Index=3 两条日志，所以追加日志失败的响应， Leader 节点会将 <code>nextindex</code> 前移</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230626174033113.png" alt="image-20230626174033113" style="zoom:50%;" /><p>然后新 Leader 会再次尝试发送 append entries 消息，循环往复，不断减小 nextlndex值，直至节点C 返回追加成功的响应，之后就进入了正常追加消息记录的流程</p><h4 id="日志判断"><a class="markdownIt-Anchor" href="#日志判断"></a> 日志判断</h4><p>那么又是如何判断两条日志是相同的呢，可能两个节点的 log index 相同但是内容并不相同</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312211352.png" alt="image-20220312211352566" style="zoom:50%;" /><p>raft 中的每个日志记录都带有 term 和 log index 来唯⼀标识，日志记录具有两个特性</p><ul><li>如果两条不同节点的某两个日志记录具有相同的 term 和 index 号，则两条记录⼀定是完全相同的 ;</li><li>如果两条不同节点的某两个日志记录具有相同的 term 和 index 号，则两条记录之前的所有记录也⼀定是完全相同的 ;</li></ul><p>以此来判断 leader与 follower 之间的日志是否相同</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312210348.png" alt="image-20220312210348704" style="zoom:50%;" /><ul><li>leader 从来不会覆盖，删除或者修改其日志 ;</li><li>若 follower 对比其前⼀条 log 不⼀致，则会拒绝 leader 发来的请求. 此时 leader 就将其在 <code>nextIndex[]</code> 中的对应值减⼀</li><li>leader 按照自身日志顺序将日志正常复制给 follower，并不断将 nextIndex[] 对应 值 +1，直到对应值 “追上” 自身日志的 index 为⽌;</li></ul><blockquote><p>问题 1：为什么要一个一个对比，而不直接找到对应的位置，批量复制？</p><p>答：通过数组存储的是索引，但是日志比较是通过 index 与 term</p></blockquote><p>所以，在选举过程中，Follower 节点还需要比较该 Candidate 节点的日志记录与自身的日志记录，拒绝那些日志没有自己新的 Candidat 节点发来的投票请求，确保将选票投给包含了全部己提交(Commited)日志记录的 Candidate 节点</p><p>Raft 协议通过较两节点日志中的最后一条日志记录的索引值和任期号，以决定谁的日志比较新</p><ul><li>首先比较最后一条日志记录的任期号，如果最后的日志记录的任期号不同，那么任期号大的日志记录比较新：</li><li>如果最后一条日志记录的任期号相同，那么日志索引较大的比较新</li></ul><h4 id="复制异常"><a class="markdownIt-Anchor" href="#复制异常"></a> 复制异常</h4><p><strong>场景1</strong>：两个Follower 节点不可用，Leader 如何处理请求</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312201120.png" alt="image-20220312201120077" style="zoom:50%;" /><ul><li><p>leader 通过⼼跳已知 follower 已挂, 则直接返回错误 ;</p></li><li><p>leader 不知节点已挂, 同步数据时得知异常; 触发异常触发超时</p></li></ul><p><strong>场景2</strong>： 提交给Leader后，发生了crash</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312201343.png" alt="image-20220312201343089" style="zoom:50%;" /><ul><li><p>leader 本地已记录已提交日志, 重启后强制同步新 leader 数据 ;</p></li><li><p>leader 还没记录未提交日志就crash, 丢了就丢了;</p></li></ul><p><strong>场景3</strong>：复制给 follower-1 后, leader就发⽣了 crash ?</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312202452.png" alt="image-20220312202452036" style="zoom:50%;" /><ul><li>leader 发⽣了重启，集群触发新的选举 ;</li><li>由于 follower-1 的数据较新, 那么该节点会晋升 leader ;</li><li>follower-1 会把 uncommited 的 v=3 同步给其他节点 ;</li><li>follower-1 收到其他节点接收确认后, 进⾏提交日志 ;</li></ul><p><strong>场景4</strong>：follower 返回确认消息时, leader 发⽣了 crash ?</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312202600.png" alt="image-20220312202600126" style="zoom:50%;" /><ul><li>三个节点的数据已经⼀致, 都为 uncommited v=3 ; 这时谁当 Leader 都可以 ; 新leader当选后, 需要进⾏同步提交通知 ;</li></ul><h3 id="脑裂问题"><a class="markdownIt-Anchor" href="#脑裂问题"></a> 脑裂问题</h3><p>脑裂问题是原本一个集群，被分成了两个集群，同时出现了两个“大脑”，这就是所谓的“脑裂”现象</p><p>出现脑裂的情况：</p><ol><li><p>两边都得到过半票数而选举出Leader的情况，不可能出现</p></li><li><p>两边都无法得到过半票数而无法选举出Leader的情况，则服务端会返回客户端集群不可用</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312195949.png" alt="image-20220312195949615" style="zoom:50%;" /></li><li><p>第三种情况：Leader 与 其他节点通信异常，导致其他节点重新选出 Leader</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230626175732437.png" alt="image-20230626175732437" style="zoom:50%;" /><p>由于 E 能收到超过半数的节点选举票 3 而成为新的 Leader，而 A 、B 会发起 PreVote 因为无法获取半数响应，所以不会触发选举</p><h3 id="客户端交互"><a class="markdownIt-Anchor" href="#客户端交互"></a> 客户端交互</h3><p>集群中只有 Leader 点可以处理客户端发来的请求，当  follower 节点收到客户端的请求时，也须将 Leader 信息告知客户端，然后由 Leader 点处理其请求，具体步骤如下：</p><ol><li>当客户端初次 接到集群时， 会随机挑选个服务器节点进行通信</li><li>如果客户端第一次挑选的节点不是 Leader 节点 ，那么该节点会拒绝客户端的请求，并且将它所知道的 Leader 节点的信息返回给客户端。</li><li>当客户端连接到 Leader 节点之后，即可发送消息进行交互</li><li>如果在交互过程中 Leader 节点宕机，那么客户端的请求会超时，客户端会再次随挑选集群中的节点，并从步骤2重新开始执行</li></ol><p><strong>异常 1</strong>：发生脑裂</p><p>与节点之间发生网络分区之后，客户端发往节点 A 请求将会超时，这是因为节点 A 无法将请求发送到集群中超过半数的节点 ，该请求相应的日志记录也就无法提交，从而导致无法给客户端返回相应的响应</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230626181508973.png" alt="image-20230626181508973" style="zoom:50%;" /><p><strong>异常 2</strong>：Leader 与其他节点通信异常</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/20220313111102.png" alt="image-20220313111102564" style="zoom:40%;" /><ul><li>由于 leader A ⽆法同步数据到多数节点, 造成 client 写请求失败 ;</li><li>⽹络分区后 follower c 长时间未收到⼼跳, 则触发选举且当选 ;</li><li>client 按照策略⼀直尝试跟可用的节点进⾏请求 ;</li><li>当⽹络恢复后, leader A B 将降为 follower, 并且强制同步 Leader C 的数据 ;</li></ul></li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li>《ETCD技术内幕》</li><li><a href="http://www.xuyasong.com/?p=1706" target="_blank" rel="noopener">http://www.xuyasong.com/?p=1706</a></li><li><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习分布式系统过程中，经常能碰到一致性算法，即使出现部分节点故障，网络延时等情况，也不影响整体可用性，进而提高系统的整体可用性。Raft协议是一种分布式一致性算法(共识算法)，共识就是多个节点对某一个事件达成一致的算法，常见的一致性协议有Raft、Paxos、ZAB，根据
      
    
    </summary>
    
    
      <category term="Protocol" scheme="http://xboom.github.io/categories/Protocol/"/>
    
    
      <category term="ETCD" scheme="http://xboom.github.io/tags/ETCD/"/>
    
      <category term="Distributed System" scheme="http://xboom.github.io/tags/Distributed-System/"/>
    
      <category term="Raft" scheme="http://xboom.github.io/tags/Raft/"/>
    
  </entry>
  
  <entry>
    <title>Go-15-SyncMap</title>
    <link href="http://xboom.github.io/2023/04/04/Go/Go-15-SyncMap/"/>
    <id>http://xboom.github.io/2023/04/04/Go/Go-15-SyncMap/</id>
    <published>2023-04-04T13:01:05.349Z</published>
    <updated>2023-07-15T05:37:13.807Z</updated>
    
    <content type="html"><![CDATA[<p>一开始以为 <code>Sync.Map</code> 仅仅是封装的了一层，后来在与同事的讨论中发现并不是这样，这里重新学习一下源码</p><h3 id="线程安全"><a class="markdownIt-Anchor" href="#线程安全"></a> 线程安全</h3><p>首先搞清楚一个问题，什么是并发安全。由于没有完整的解释，我找了一段Java中的表达</p><blockquote><p>当多个线程访问某个类时，不管运行环境采用何种调度方式或者这些进程将如何交替执行，并且在主调代码中不需要任何额外的协同或者同步，这个类都能表现出正确的行为，那么这个类是线程安全的</p></blockquote><p>大致抓住两点 <strong>无论如何交替执行</strong> <strong>表现出正确的行为</strong>，有点抽象，反过来问 <strong>什么情况会导致线程不安全</strong>？<strong>怎样才能保证线程安全？</strong></p><p><u>当前的一个操作可能不是原子的，执行过程中会被打断，其他线程有能力修改共享变量的值，同时存在线程修改的值不是立即对其他线程可见的，因为线程有自己的执行空间，另外一点就是存在程序可能存在乱序执行的情况，单线程没问题，但是多个线程同时执行，线程共享的数据会出现错乱</u>。那么保证线程安全的三个特征：</p><ul><li><strong>原子性</strong>：提供互斥访问、同一时刻只能有一个线程在操作</li><li><strong>可见性</strong>：一个线程对主内容的修改可以及时被其他线程看到</li><li><strong>有序性</strong>：程序在执行的时候，程序的代码执行顺序和语句的顺序是一致的有序性<ul><li>多个协程并发执行，那么<strong>几个协程之间是没有有序性的</strong>，但是协程里面的代码是有序的</li><li>什么情况下代码的执行顺序与语句顺序不一致？比如指令重排序，将多次访问主存合并到一起执行</li></ul></li></ul><p>这样就好理解为啥普通的map会存在并发安全问题了，因为一个协程的修改对于另外一个协程可能是不可见的。另外当map并发读写时候触发的panic是map内部实现的，结构体的并发读写只会报错不会panic。</p><h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3><p>普通的map并发处理实践</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="keyword">struct</span>&#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>sync.Map</code> 则可以</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter sync.Map</span><br></pre></td></tr></table></figure><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>源码：<code>src/sync/map.go</code></p><p>为了实现并发安全的Map，<code>Sync.Map</code>实现了一种读写分离的方式</p><ol><li>空间换时间。 通过冗余的两个数据结构(read、dirty),实现加锁对性能的影响。</li><li>动态调整，miss次数多了之后，将dirty数据提升为read。</li><li>double-checking，因为是判断与获取并不是原子操作，所以会出现 double-checking</li><li>延迟删除。 删除一个键值只是打标记，只有在提升dirty的时候才清理删除的数据。</li><li>优先从read读取、更新、删除，因为对read的读取不需要锁。</li></ol><p><strong>问题1</strong>：如何在并发情况下修改或删除已经存在的Key？</p><p>答：通过将 key 映射到 val 的地址，然后 val 指针指向真正的值，那么只需要保证 <code>address</code> 指针的原子操作，就能解决并发安全问题</p><blockquote><p>key -&gt; &amp;地址 --&gt; 真正的值</p></blockquote><p><strong>问题2</strong>：如何在写的同时保证读的准确性</p><p>答：读写指向的是同一个指针，首先在写时会通过互斥锁防止并发操作 <code>dirty</code>，其次就是用到了<code>atomic</code>原子操作<code>value</code>指针</p><p><strong>问题3</strong>：如果读写分离，如何将写入的数据同步到读中</p><p>答： 1. 第一种是当<code>misses == len(dirty)</code>的时候就会升级<code>dirty</code>到<code>read</code>中；第二种就是在遍历的如果<code>dirty</code>有<code>read</code>中没有的数据；</p><p>第三其实也不是读写分离，而是乐观锁，因为如果<code>read</code>中已经有key/val，也会尝试去更新<code>read</code>，发现已经删除，则去dirty中更新</p><p>最后的实现就变成了下面这个样子</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/20200505120255.png" alt="sync.map 整体结构" style="zoom:50%;" /><p><strong>问题4</strong>：指向的是同一个<code>entry</code>，不还是一样需要加锁吗？内部 的<code>mutex</code> 与 <code>atomic.pointer</code>的区别跟作用又是什么？</p><p><code>mutex</code> 与 <code>atomic</code> 的区别是：<code>mutex</code> 通过阻塞其他协程起到了原子操作的功能，是用来保护 dirty 的读写的。而<code>atomic</code>是通过CPU指令，来达到值操作的原子性，所以 <code>atomic</code>与<code>mutex</code>并不是一个层面的东西，<code>atomic</code>也比<code>mutex</code>更快。</p><p>所以才会出现 <code>mutex</code> 保护的是 <code>dirty</code>，而 <code>atomic</code> 保护的是 <code>entry</code> 具体值</p><h4 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h4><p>定义的 <code>Map</code> 中 除普通的map 与 互斥锁，还增加了两个字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">//当涉及到dirty的操作的时候，需要使用这个锁</span></span><br><span class="line">   mu Mutex</span><br><span class="line">  <span class="comment">// 一个只读结构(实际也会更新这个数据的entries，标记为未删除的unexpunger)</span></span><br><span class="line">   read atomic.Pointer[readOnly]</span><br><span class="line">  <span class="comment">// dirty包含最新的entries(包括read中未删除的数据,虽有冗余，但也提升dirty字段为read的时候非常快，不用一个一个的复制，而是直接将这个数据结构作为read字段的一部分),有些数据还可能没有移动到read字段中。</span></span><br><span class="line"><span class="comment">// 对于dirty的操作需要加锁，因为对它的操作可能会有读写竞争。</span></span><br><span class="line"><span class="comment">// 当dirty为空的时候， 比如初始化或者刚提升完，下一次的写操作会复制read字段中未删除的数据到这个数据中。</span></span><br><span class="line">   dirty <span class="keyword">map</span>[any]*entry</span><br><span class="line">  <span class="comment">// 当从Map中读取entry的时候，如果read中不包含这个entry,会尝试从dirty中读取，这个时候会将misses加一，</span></span><br><span class="line"><span class="comment">// 当misses累积到 dirty的长度的时候， 就会将dirty提升为read,避免从dirty中miss太多次。因为操作dirty需要加锁</span></span><br><span class="line">   misses <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中存在两个结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">m       <span class="keyword">map</span>[any]*entry</span><br><span class="line">amended <span class="keyword">bool</span> <span class="comment">// 为true 表示dirty中存在一些新增的键值对</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基本"><a class="markdownIt-Anchor" href="#基本"></a> 基本</h4><ol><li><code>read</code> 与 <code>dirty</code> 的转换</li><li><code>entry</code>的操作</li></ol><h5 id="entry"><a class="markdownIt-Anchor" href="#entry"></a> entry</h5><p><code>entry</code> 代表的是每个 key 在<code>Map</code>中对应的一个 <code>entry</code>，并且还记录了 <strong>其他信息</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">p atomic.Pointer[any]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> expunged = <span class="built_in">new</span>(any) <span class="comment">//</span></span><br></pre></td></tr></table></figure><p><code>p</code> 一共记录林 <code>entry</code> 的三种状态</p><ol><li><code>nil</code>: <code>entry</code>已被删除了，并且<code>m.dirty</code>为<code>nil</code></li><li><code>expunged</code>: <code>entry</code>已被删除了，并且<code>m.dirty</code>不为<code>nil</code>，而且这个<code>entry</code>不存在于<code>m.dirty</code>中</li><li>其它： <code>entry</code>是一个正常的值</li></ol><p>构建一个 <code>entry</code> 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newEntry</span><span class="params">(i any)</span> *<span class="title">entry</span></span> &#123;</span><br><span class="line">   e := &amp;entry&#123;&#125;</span><br><span class="line">   e.p.Store(&amp;i)</span><br><span class="line">   <span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">load</span><span class="params">()</span> <span class="params">(value any, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">p := e.p.Load()</span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;<span class="comment">//表示不存在</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *p, <span class="literal">true</span><span class="comment">//表示存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>entry</code> 使用 <code>atomic.Pointer[n]</code> 的作用在后面才体现出来, <code>atomic.Pointer</code> 原子地读取和存储指针类型的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">trySwap</span><span class="params">(i *any)</span> <span class="params">(*any, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      p := e.p.Load()</span><br><span class="line">      <span class="keyword">if</span> p == expunged &#123;<span class="comment">//如果已经被删除则返回false</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> e.p.CompareAndSwap(p, i) &#123;<span class="comment">//否则不断的CAS更新</span></span><br><span class="line">         <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h4><p>操作与正常的map类似，包含 存储、获取、删除、遍历。除此之外还增加的 交换、比较交换、比较删除</p><h5 id="获取"><a class="markdownIt-Anchor" href="#获取"></a> 获取</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Load</span><span class="params">(key any)</span> <span class="params">(value any, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1.首先从m.read中得到只读readOnly,从它的map中查找，不需要加锁</span></span><br><span class="line">  read := m.loadReadOnly()</span><br><span class="line">e, ok := read.m[key]</span><br><span class="line">  <span class="comment">//2. 如果没找到，并且m.dirty中有新数据，需要从m.dirty查找，这个时候需要加锁</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123; <span class="comment">// a 操作</span></span><br><span class="line">m.mu.Lock()  <span class="comment">//b 操作</span></span><br><span class="line">    <span class="comment">//双检查，避免加锁的时候m.dirty提升为m.read,这个时候m.read可能被替换了。</span></span><br><span class="line">read = m.loadReadOnly()</span><br><span class="line">e, ok = read.m[key]</span><br><span class="line">    <span class="comment">// 如果m.read中还是不存在，并且m.dirty中有新数据</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">      <span class="comment">// 从m.dirty查找</span></span><br><span class="line">e, ok = m.dirty[key]</span><br><span class="line">      <span class="comment">// 不管m.dirty中存不存在，都将misses计数加一</span></span><br><span class="line"><span class="comment">// missLocked()中满足条件后就会提升m.dirty</span></span><br><span class="line">m.missLocked()</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个注意事项</p><ol><li><p>出现double-check，是因为在执行 <code>if !ok &amp;&amp; read.amended</code> 的过程中，dirty可能升级为read，所以还是需要锁操作</p></li><li><p>不管 m.dirty中是否存在，都需要misses+1，表明 read中不存在才到 dirty中获取</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">missLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">m.misses++</span><br><span class="line"><span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">m.read.Store(&amp;readOnly&#123;m: m.dirty&#125;)<span class="comment">//直接将dirty升级到read中，然后</span></span><br><span class="line">m.dirty = <span class="literal">nil</span></span><br><span class="line">m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>什么时候讲dirty提升为 read，当 <code>misses &gt;= len(m.dirty)</code></p><h5 id="存储"><a class="markdownIt-Anchor" href="#存储"></a> 存储</h5><p>从接口实现可以看出，存储 k/v 内部使用的其实 Swap 接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Store</span><span class="params">(key, value any)</span></span> &#123;</span><br><span class="line">   _, _ = m.Swap(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接查看 <code>Swap</code> 的实现原理</p><p>根据描述，<code>Swap</code> 的作用是 将 <code>newValue</code> 更新入 <code>key</code> 所对应的 <code>value</code>中，并将 <code>oldValue</code> 返回。另外一个返回值<code>loaded</code>表示 <code>key</code> 是否存在</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Swap</span><span class="params">(key, value any)</span> <span class="params">(previous any, loaded <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 如果m.read存在这个键，并且这个entry没有被标记删除，尝试直接存储。</span></span><br><span class="line"><span class="comment">// 因为m.dirty也指向这个entry,所以m.dirty也保持最新的entry。</span></span><br><span class="line">   read := m.loadReadOnly()</span><br><span class="line">   <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;<span class="comment">//如果只读存在</span></span><br><span class="line">      <span class="keyword">if</span> v, ok := e.trySwap(&amp;value); ok &#123;<span class="comment">//尝试去更新value，如果未 标记删除</span></span><br><span class="line">         <span class="keyword">if</span> v == <span class="literal">nil</span> &#123;<span class="comment">//value为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> *v, <span class="literal">true</span><span class="comment">//更新成功 返回 true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   m.mu.Lock()<span class="comment">// 加锁，如果`m.read`不存在或者已经被标记删除</span></span><br><span class="line">   read = m.loadReadOnly()</span><br><span class="line">   <span class="keyword">if</span> e, ok := read.m[key]; ok &#123; <span class="comment">//只读存在</span></span><br><span class="line">     <span class="keyword">if</span> e.unexpungeLocked() &#123;<span class="comment">//如果未标记删除则删除read,然后存入dirty(写数据到dirty中)</span></span><br><span class="line">         m.dirty[key] = e<span class="comment">//存入 dirty</span></span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">if</span> v := e.swapLocked(&amp;value); v != <span class="literal">nil</span> &#123;<span class="comment">//未标记删除则直接更新read</span></span><br><span class="line">         loaded = <span class="literal">true</span></span><br><span class="line">         previous = *v</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;<span class="comment">//只读不存在但是dirty存在</span></span><br><span class="line">      <span class="keyword">if</span> v := e.swapLocked(&amp;value); v != <span class="literal">nil</span> &#123;</span><br><span class="line">         loaded = <span class="literal">true</span></span><br><span class="line">         previous = *v</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;<span class="comment">//都不存在</span></span><br><span class="line">      <span class="keyword">if</span> !read.amended &#123;<span class="comment">//dirty中没有新值</span></span><br><span class="line">         m.dirtyLocked()<span class="comment">//如果dirty为空，从 m.read中复制未删除的数据</span></span><br><span class="line">         m.read.Store(&amp;readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;) <span class="comment">//read中存储</span></span><br><span class="line">      &#125;</span><br><span class="line">      m.dirty[key] = newEntry(value)<span class="comment">//dirty 存储一个新的 value地址</span></span><br><span class="line">   &#125;</span><br><span class="line">   m.mu.Unlock()</span><br><span class="line">   <span class="keyword">return</span> previous, loaded</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>dirtyLocked的</code>作用是将未删除的复制到<code>dirty</code>中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">dirtyLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;<span class="comment">//如果不为空直接返回</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   read := m.loadReadOnly()</span><br><span class="line">   m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[any]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line">   <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">      <span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">         m.dirty[k] = e</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">tryExpungeLocked</span><span class="params">()</span> <span class="params">(isExpunged <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   p := e.p.Load()<span class="comment">//加载entry中的地址</span></span><br><span class="line">   <span class="keyword">for</span> p == <span class="literal">nil</span> &#123;<span class="comment">//如果为空</span></span><br><span class="line">      <span class="keyword">if</span> e.p.CompareAndSwap(<span class="literal">nil</span>, expunged) &#123;<span class="comment">//尝试使用 expunged更新状态</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      p = e.p.Load()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> p == expunged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Delete</span><span class="params">(key any)</span></span> &#123;</span><br><span class="line">m.LoadAndDelete(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">LoadAndDelete</span><span class="params">(key any)</span> <span class="params">(value any, loaded <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//先从read中加载</span></span><br><span class="line">read := m.loadReadOnly()</span><br><span class="line">e, ok := read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;<span class="comment">//read没有且dirty中有新数据</span></span><br><span class="line">    <span class="comment">//开启锁</span></span><br><span class="line">m.mu.Lock()</span><br><span class="line">read = m.loadReadOnly()</span><br><span class="line">e, ok = read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;<span class="comment">//如果read没有，则dirty中有新数据</span></span><br><span class="line">e, ok = m.dirty[key]</span><br><span class="line"><span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">      m.missLocked()<span class="comment">//当misses数量达到 len(m.dirty),dirty升级为read</span></span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">return</span> e.<span class="built_in">delete</span>()<span class="comment">//如果read存在则标记删除</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果read中存在，那么仅会标记删除</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">delete</span><span class="params">()</span> <span class="params">(value any, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      p := e.p.Load()</span><br><span class="line">      <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;<span class="comment">//如果为空或者标记删除，返回没有数据</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> e.p.CompareAndSwap(p, <span class="literal">nil</span>) &#123;<span class="comment">//标记为nil，并不会直接删除</span></span><br><span class="line">         <span class="keyword">return</span> *p, <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遍历"><a class="markdownIt-Anchor" href="#遍历"></a> 遍历</h5><p>因为是读写分离，所以在遍历的过程中</p><ol><li>如果dirty中没有新数据，那么就使用read遍历</li><li>如果dirty中有新数据，那么就将dirty升级为read，然后遍历read</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Range</span><span class="params">(f <span class="keyword">func</span>(key, value any)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">   <span class="comment">//判断dirty是否有新值</span></span><br><span class="line">   read := m.loadReadOnly()</span><br><span class="line">   <span class="keyword">if</span> read.amended &#123;</span><br><span class="line">      m.mu.Lock()<span class="comment">//开锁</span></span><br><span class="line">      read = m.loadReadOnly()</span><br><span class="line">      <span class="keyword">if</span> read.amended &#123;<span class="comment">//dirty是否有新值</span></span><br><span class="line">         read = readOnly&#123;m: m.dirty&#125;</span><br><span class="line">         m.read.Store(&amp;read)<span class="comment">//升级dirty为read</span></span><br><span class="line">         m.dirty = <span class="literal">nil</span></span><br><span class="line">         m.misses = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">      m.mu.Unlock()</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//遍历read</span></span><br><span class="line">   <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">      v, ok := e.load()</span><br><span class="line">      <span class="keyword">if</span> !ok &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> !f(k, v) &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3><ol><li><p>该map仅针对特定的场景</p><ul><li>Key 读多写少的情况，例如只增长的缓存</li><li>多个协程针对不同的key合集进行读写更新时候可以用</li><li>sync.Map 不能在第一次使用后复制</li></ul></li><li><p>由于dirty达到一定条件就需要升级为read，所以适用读多写少的场景</p></li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://www.cnblogs.com/qcrao-2018/p/12833787.html" target="_blank" rel="noopener">https://www.cnblogs.com/qcrao-2018/p/12833787.html</a></li><li><a href="https://colobu.com/2017/07/11/dive-into-sync-Map/#sync-Map%E7%9A%84%E6%80%A7%E8%83%BD" target="_blank" rel="noopener">https://colobu.com/2017/07/11/dive-into-sync-Map/#sync-Map的性能</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一开始以为 &lt;code&gt;Sync.Map&lt;/code&gt; 仅仅是封装的了一层，后来在与同事的讨论中发现并不是这样，这里重新学习一下源码&lt;/p&gt;
&lt;h3 id=&quot;线程安全&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线程安全&quot;&gt;&lt;/a&gt; 线程安全&lt;
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go-24-协程池问题</title>
    <link href="http://xboom.github.io/2023/03/05/Go/Go-24-%E5%8D%8F%E7%A8%8B%E6%B1%A0%E9%97%AE%E9%A2%98/"/>
    <id>http://xboom.github.io/2023/03/05/Go/Go-24-%E5%8D%8F%E7%A8%8B%E6%B1%A0%E9%97%AE%E9%A2%98/</id>
    <published>2023-03-05T06:46:45.000Z</published>
    <updated>2023-07-15T05:38:02.316Z</updated>
    
    <content type="html"><![CDATA[<p>之前在整理 <a href="https://www.yuankang.top/2022/07/06/GoZero/GoZero4-%E5%8D%8F%E7%A8%8B%E6%B1%A01/" target="_blank" rel="noopener">GoZero4-协程池</a>的过程中发现 <a href="https://github.com/bytedance/gopkg/tree/develop/util/gopool" target="_blank" rel="noopener">字节跳动开源的协程池</a>在使用中需要注意的地方：</p><p>​<strong>使用双向链表存储任务，表示它理论上支持无限个任务。后面的任务可能存在长时间等待的情况，并不存在任务过期处理逻辑</strong></p><p>没想到在实际应用中真的没注意踩了一遍，这里记录一下这个原因与后续的解决思路，排查过程就不赘述了。</p><p>伪代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Send</span><span class="params">(conn *grpc.ClientConn)</span></span> &#123;</span><br><span class="line">c := pb.NewGreeterClient(conn)</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">3</span>*time.Second)</span><br><span class="line"></span><br><span class="line">gopool.CtxGo(ctx, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="comment">//1. 通信消息自定义处理</span></span><br><span class="line">Handle(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 发送消息</span></span><br><span class="line">_, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: *name&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"could not greet: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="comment">//log.Printf("end success")</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">5</span>):</span><br><span class="line">log.Printf(<span class="string">"time out"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题原因</strong>：负责底层通信的 grpc-go(进行过二次开发) 使用了上述的协程池进行发送接口的超时控制。当突然大量的消息进入，消息接受速率 大于 消息发送-响应速率。导致过量的消息全部堆积到这个双向链表中，而本身消息是有超时时间的，就导致堆积的消息越来越多，消息等到发送的时候已经超时了，所以就出现了服务OOM，消息也无法发送出去。</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/%E5%8D%8F%E7%A8%8B%E6%B1%A0%E9%97%AE%E9%A2%982.png" alt="协程池问题2" style="zoom:50%;" /><p>类似上图所示，模拟客户端通过协程池的发送协程 <strong>work</strong> 实现超时控制消息任务 <strong>t</strong> 的发送</p><ul><li>第一阶段，发送协程 <strong>work</strong> 的消费速率 大于 消息任务 <strong>t</strong> 的生产速率，一切正常</li><li>第二阶段，发送协程 <strong>work</strong> 的消费速率 小于 消息任务 <strong>t</strong> 的生产速率的时候，消息开始在双向链表中堆积，出现内存快速增长</li><li>第三阶段，当 消息任务 <strong>t</strong> 的堆积 超过自定义超时时间的时候，所有消息都发送超时失败</li><li>第四阶段，当 双向链表中的任务堆积导致内存超时服务上限的时候，服务OOM</li></ul><p>这里产生了如下几个思考</p><ol><li>能否在任务双向链表中限制数量大小当发送超过限制的时候直接失败?</li><li>为什么不直接使用管道来代替底层的双向链表？</li><li>能否自动丢弃超时的消息并返回结果，注意这个时候是在协程里面运行的</li><li>如何像linux一样保存 pod因为OOM而产生的core方便后续分析</li></ol><p>第一个问题是可以解决的，协程池对象存在 taskCount 记录当前任务数量，也就是说可以增加协程池容量判断来达到限制目的</p><ul><li>增加协程池任务容量字段 <code>taskCap</code></li><li>增加接口，协程失败返回错误 error</li><li>添加协程池容量判断</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pool)</span> <span class="title">CtxGo2</span><span class="params">(ctx context.Context, f <span class="keyword">func</span>()</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">  cur := atomic.AddInt32(&amp;p.taskCount, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> cur &gt; p.taskCap &#123;<span class="comment">//当前任务容量判断</span></span><br><span class="line"><span class="keyword">return</span> errors.New</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个问题管道的缺点是管道数量是固定的，也就是达不到根据任务数量动态扩容 <code>work</code> 的功效</p><p>第三个问题由于任务放入协程中相当于异步处理，并不能直接将任务待执行超时的情况返回给客户端，可以通过自定义处理函数或者内部的panic处理任务超时的情况；但又能如何发现任务超时，时间轮貌似是个好东西</p><p>第四个问题找到<a href="https://juejin.cn/post/6844903792136159239" target="_blank" rel="noopener">一篇实践</a>，实操之后再单独记录</p><p>总结：</p><ol><li>我在使用过程中忽视了双向队列任务堆积的情况，令牌桶的使用也可能存在这样的情况(正常情况不会配置速率上千万的情况)，注意异常情况下的配置范围</li><li>上述需要改进与实操的部分尝试解决之后再来补充这边文章</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在整理 &lt;a href=&quot;https://www.yuankang.top/2022/07/06/GoZero/GoZero4-%E5%8D%8F%E7%A8%8B%E6%B1%A01/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GoZero4-协
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>算法-E10C-最大公约数</title>
    <link href="http://xboom.github.io/2023/02/02/Algorithms%20To%20Live%20By/%E7%AE%97%E6%B3%95-E10C-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"/>
    <id>http://xboom.github.io/2023/02/02/Algorithms%20To%20Live%20By/%E7%AE%97%E6%B3%95-E10C-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</id>
    <published>2023-02-02T12:25:25.494Z</published>
    <updated>2023-02-15T13:39:32.337Z</updated>
    
    <content type="html"><![CDATA[<p>今天碰到一道有意思的题目，学到了很多东西，所以记录一下</p><p><a href="https://leetcode.cn/problems/check-if-it-is-a-good-array/" target="_blank" rel="noopener">检查好数组</a></p><p>碰到之后完全不知道如何入手，最后通过看解答才弄明白，但是中间有很多知识点可以记录一下</p><p><strong>首先</strong> 需要知道裴蜀定理，又称贝祖定理，是一个最大公约数定理：设 a, b 是不全为零的整数，则存在整数 x , y , 使得</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ax + by = gcd(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span></p><ol><li><p>若任何一个等于0，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">gcd(a, b) == a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span></p></li><li><p>对任何整数a、b和它们的最大公约数d，关于未知数x和y的线性丢番图方程</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">ax + by = m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span></span></p><p>有解当前仅当 m 是 d 的倍数</p></li></ol><blockquote><p>这里有一个奇特的点 0 因为没有因数，所以 0 不与其他数存在最大公约数，等我看了 类欧几里德算法 再补充</p></blockquote><p>所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ax + by = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 有解，那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(a, b) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><p>其次 我们如何求一个两个数的最大公约数，经典的 <strong>辗转相除法</strong>(又称 <strong>欧几里德算法</strong>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以使用现有函数 gcd(a, b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b ? GCD(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>证明 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a, b) = gcd(b, a \% b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 过程如下</p><ol><li><p>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi><mi>k</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a = bk + c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>，所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">c = a \% b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span></span></span></span></p></li><li><p>设 d 是 a , b 的公约数</p></li><li><p>所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>=</mo><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>∗</mo><mi>k</mi><mo>+</mo><mi>c</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">a / d = b / d * k + c / d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span></p></li><li><p>因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">a / d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">b / d * k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 是整数，所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">c / d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span> 也是整数</p></li><li><p>将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">c = a \% b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span></span></span></span> 带入第3步得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>−</mo><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>∗</mo><mi>k</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">a / d - b / d * k = a \% b / d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span>，因为 左边是整数，所有等式右边也是整数</p></li><li><p>那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>+</mo><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">a / d = a \% b / d + b / d * k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，那么 d 也是  b, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">a \% b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span></span></span></span> 的约数，也是 a, b 的约数</p></li><li><p>尽然两式的公约数是相同的，那么最大公约数也会相同</p></li><li><p>所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a, b) = gcd(b, a mod b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p></li></ol><p>最后就是这个题目的解答</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b ? Gcd(b, a % b) : a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isGoodArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//1与任意正整数的最大公约数是1</span></span><br><span class="line">            v = Gcd(nums[i], v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://oi-wiki.org/math/number-theory/gcd/" target="_blank" rel="noopener">https://oi-wiki.org/math/number-theory/gcd/</a></li><li><a href="https://leetcode.cn/problems/check-if-it-is-a-good-array/" target="_blank" rel="noopener">https://leetcode.cn/problems/check-if-it-is-a-good-array/</a></li><li><a href="https://oi-wiki.org/math/number-theory/bezouts/" target="_blank" rel="noopener">https://oi-wiki.org/math/number-theory/bezouts/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天碰到一道有意思的题目，学到了很多东西，所以记录一下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/check-if-it-is-a-good-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;检查好
      
    
    </summary>
    
    
      <category term="Algorithms To Live By" scheme="http://xboom.github.io/categories/Algorithms-To-Live-By/"/>
    
    
      <category term="Algorithms To Live By" scheme="http://xboom.github.io/tags/Algorithms-To-Live-By/"/>
    
  </entry>
  
  <entry>
    <title>Go-23-arena</title>
    <link href="http://xboom.github.io/2023/01/10/Go/Go-23-arena/"/>
    <id>http://xboom.github.io/2023/01/10/Go/Go-23-arena/</id>
    <published>2023-01-10T08:00:20.000Z</published>
    <updated>2023-07-15T05:37:56.756Z</updated>
    
    <content type="html"><![CDATA[<p>最近 <code>Go1.20</code> 更新，中间讲到了一个特性 <code>arena</code> ，这里看看加入 <code>arena</code> 的作用</p><blockquote><p>在Go的内存管理中，<code>arena</code> 其实就是所谓的堆区，然后将这个区域分割成 <code>8KB</code> 大小的页，组合起来称为 <code>mspan</code>，<code>mspan</code>就是Go中内存管理的基本单元，是由一片连续的 8KB 的页组成的大块内存。其实 <code>mspan</code> 是一个包含起始地址、规格、页的数量等内容的双端链表</p></blockquote><p>虽然 Go 的垃圾回收机制能够正常的进行内存管理，但是存在以下问题</p><ol><li>垃圾回收机制需要花费大量CPU进行垃圾回收操作</li><li>垃圾回收机制有一定的延迟性，导致花费的内存比实际的内存要大</li></ol><p>而 <code>arena</code> 的优势 <strong>允许从连续的内存空间中分配对象并一次性进行释放</strong></p><p>注意：在 <a href="https://github.com/golang/go/issues/51317" target="_blank" rel="noopener">github arena 的话题</a>中，有一个最新的笔记提醒, 即处在测试阶段的 arena 功能随时可能被去除掉</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Note, 2023-01-17. This proposal is on hold indefinitely due to serious API concerns. The GOEXPERIMENT=arena code may be changed incompatibly or removed at any time, and we do not recommend its use in production.</span><br></pre></td></tr></table></figure><p>带着问题看世界：</p><ol><li>它跟内存池的区别</li><li>由于需要连续的内存空间，那么当需要分配的内存比较多，没有这么大的连续内存空间怎么办？</li><li>如果它分配的对象有一部分存在内存逃逸，那么该如何处理？</li><li>能支持并发吗</li></ol><h3 id="基础功能"><a class="markdownIt-Anchor" href="#基础功能"></a> 基础功能</h3><p>由于是实验功能，所以需要配置环境变量 <code>GOEXPERIMENT=arenas</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"arena"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;</span><br><span class="line">Foo <span class="keyword">string</span></span><br><span class="line">Bar [<span class="number">16</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processRequest</span><span class="params">(req *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// Create an arena in the beginning of the function.</span></span><br><span class="line">mem := arena.NewArena()</span><br><span class="line"><span class="comment">// Free the arena in the end.</span></span><br><span class="line"><span class="keyword">defer</span> mem.Free()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a bunch of objects from the arena.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">obj := arena.New[T](mem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or a slice with length and capacity.</span></span><br><span class="line">slice := arena.MakeSlice[T](mem, <span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想在arena释放时候继续使用它分配的对象，则可以通过 Clone 从堆中浅拷贝一个对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj1 := arena.New[T](mem) <span class="comment">// arena-allocated</span></span><br><span class="line">obj2 := arena.Clone(obj1) <span class="comment">// heap-allocated</span></span><br><span class="line">fmt.Println(obj2 == obj1) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">mem.Free()</span><br></pre></td></tr></table></figure><p>其他接口包括</p><ul><li><code>NewArena</code>：创建一个新的 arena 内存空间。</li><li><code>Free</code>：释放 arena 及其关联对象。</li><li><code>New</code>：基于 arena，创建新对象。</li><li><code>MakeSlice</code>：基于 arena，创建新切片。</li><li><code>Clone</code>：克隆一个 arena 的对象，并移动到内存堆上。<strong>只能是指针、slice或者字符串</strong></li></ul><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>代码路径：</p><ol><li><code>src/runtime/arena.go</code></li><li><code>src/arena/arena.go</code></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arena 表示多个Go一起分配与释放的内存集合，当其中的对象不在被引用那么将会自动释放</span></span><br><span class="line"><span class="keyword">type</span> Arena <span class="keyword">struct</span> &#123;</span><br><span class="line">a unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewArena allocates a new arena.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewArena</span><span class="params">()</span> *<span class="title">Arena</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Arena&#123;a: runtime_arena_newArena()&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据描述这里注意点有两个：</p><ol><li>arena 分配的对象需要及时释放</li><li>既然是自动释放，然后在使用中 <code>defer arena.Free()</code> 可以任务是，不用等到二次垃圾回收，直接将资源释放，并将可重复使用的mspan放入<code>reused</code>中</li></ol><p>查看Arena 内部结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> userArena <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 指向一个链表，表示一系列没有足够空闲内存的 mspan(内存段)。当该内存管理区域被释放时，这些 mspan 也会被释放</span></span><br><span class="line">fullList *mspan  <span class="comment">//内存组件 mspan</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向一个 mspan，表示未满的内存段。这个 mspan 中还有可用的内存可以分配</span></span><br><span class="line">active *mspan   </span><br><span class="line"></span><br><span class="line">  <span class="comment">//一个指向 unsafe.Pointer 类型的切片，用于引用当前内存管理区域的对象。这可以防止在仍然有引用对象时释放该内存管理区域</span></span><br><span class="line">refs []unsafe.Pointer</span><br><span class="line"></span><br><span class="line">  <span class="comment">//一个原子布尔类型的变量，用于标记内存管理区域是否已经被释放。如果为 true，表示该内存管理区域已经被释放，以避免重复释放</span></span><br><span class="line">defunct atomic.Bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Arena 如果重复释放也没有关系，判断释放过则直接结束</li></ul><p>**第一步：**分配一个 <code>Arena</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newUserArena creates a new userArena ready to be used.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newUserArena</span><span class="params">()</span> *<span class="title">userArena</span></span> &#123;</span><br><span class="line">a := <span class="built_in">new</span>(userArena)</span><br><span class="line">SetFinalizer(a, <span class="function"><span class="keyword">func</span><span class="params">(a *userArena)</span></span> &#123; <span class="comment">//g</span></span><br><span class="line"><span class="comment">// If arena handle is dropped without being freed, then call</span></span><br><span class="line"><span class="comment">// free on the arena, so the arena chunks are never reclaimed</span></span><br><span class="line"><span class="comment">// by the garbage collector.</span></span><br><span class="line">a.free()</span><br><span class="line">&#125;)</span><br><span class="line">a.refill()</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *userArena)</span> <span class="title">refill</span><span class="params">()</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line"><span class="comment">// If there's an active chunk, assume it's full.</span></span><br><span class="line">s := a.active</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the partially-used list.</span></span><br><span class="line">lock(&amp;userArenaState.lock)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(userArenaState.reuse) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">//当前存在可重用的就使用重用的</span></span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;userArenaState.lock)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Allocate a new one. 否则分配一个新的mspan</span></span><br><span class="line">x, s = newUserArenaChunk()</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"out of memory"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a.refs = <span class="built_in">append</span>(a.refs, x)<span class="comment">//记录mspan.base()，报活mspan</span></span><br><span class="line">a.active = s<span class="comment">//记录当前使用的mspan</span></span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>SetFinalizer</code> 函数可参考<a href="https://www.yuankang.top/2023/01/04/Go/Go%E5%85%A5%E9%97%A821-SetFinalizer/" target="_blank" rel="noopener">文章</a>，当gc检测到unreachable对象有关联的SetFinalizer函数时，会执行关联的SetFinalizer函数， 同时取消关联。 这样当下一次gc的时候，对象重新处于unreachable状态并且没有SetFinalizer关联， 就会被回收。</li></ul><p>**第二步：**从 arena 中分配具体类型的对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *userArena)</span> <span class="title">refill</span><span class="params">()</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line"><span class="comment">// If there's an active chunk, assume it's full.</span></span><br><span class="line">s := a.active<span class="comment">//上次分配了mspan</span></span><br><span class="line"><span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> s.userArenaChunkFree.size() &gt; userArenaChunkMaxAllocBytes &#123;</span><br><span class="line"><span class="comment">// It's difficult to tell when we're actually out of memory</span></span><br><span class="line"><span class="comment">// in a chunk because the allocation that failed may still leave</span></span><br><span class="line"><span class="comment">// some free space available. However, that amount of free space</span></span><br><span class="line"><span class="comment">// should never exceed the maximum allocation size.</span></span><br><span class="line">throw(<span class="string">"wasted too much memory in an arena chunk"</span>)</span><br><span class="line">&#125;</span><br><span class="line">s.next = a.fullList <span class="comment">//将这个mspan放到fullList的链表头部</span></span><br><span class="line">a.fullList = s</span><br><span class="line">a.active = <span class="literal">nil</span><span class="comment">//active置为空</span></span><br><span class="line">s = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the partially-used list.</span></span><br><span class="line">lock(&amp;userArenaState.lock)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(userArenaState.reuse) &gt; <span class="number">0</span> &#123;<span class="comment">//</span></span><br><span class="line"><span class="comment">//如果有可以重用的mspan则放到s中</span></span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;userArenaState.lock)</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Allocate a new one.</span></span><br><span class="line">x, s = newUserArenaChunk()<span class="comment">//否则新分配一个新的</span></span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"out of memory"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a.refs = <span class="built_in">append</span>(a.refs, x)</span><br><span class="line">a.active = s</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**第三步：**释放的核心是这块代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s := a.fullList<span class="comment">//获取这个mspan</span></span><br><span class="line">i := <span class="built_in">len</span>(a.refs) - <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> s != <span class="literal">nil</span> &#123;<span class="comment">//不为空</span></span><br><span class="line">  a.fullList = s.next<span class="comment">//指向下一个节点</span></span><br><span class="line">  s.next = <span class="literal">nil</span></span><br><span class="line">  freeUserArenaChunk(s, a.refs[i])<span class="comment">//释放这个mspan</span></span><br><span class="line">  s = a.fullList<span class="comment">//指向下一个节点</span></span><br><span class="line">  i--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>释放的时候仅仅是将fullList中所有的都释放掉了，而active中的则会进去到全局reuse对象中用于下次使用</li></ul><p>这个全局变量就是 <code>userArenaState</code> 用于存放可重复使用的mspan以及回收的mspan</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> userArenaState <span class="keyword">struct</span> &#123;</span><br><span class="line">lock mutex</span><br><span class="line"></span><br><span class="line">  <span class="comment">//可重复使用</span></span><br><span class="line">reuse []liveUserArenaChunk</span><br><span class="line"></span><br><span class="line">  <span class="comment">//回收释放的</span></span><br><span class="line">fault []liveUserArenaChunk</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对比syncpool"><a class="markdownIt-Anchor" href="#对比syncpool"></a> 对比Sync.Pool</h3><p>arena 与 Sync.Pool 同样都是为了解决频繁分配对象和大量对象GC带来的开销</p><p><code>Sync.Pool</code>相同类型的对象，使用完后暂时缓存不GC，下次再有相同的对象分配时直接用之前的缓存的对象，避免频繁创建大量对象。不承诺这些缓存对象的生命周期，GC时会释放之前的缓存，适合解决频繁创建相同对象带来的压力，短时间(两次GC之间)大量创建可能还是会有较大冲击，使用相对简单，但只能用于相同结构创建，不能创建slice等复杂结构</p><p><code>arena</code>手动管理连续内容并统一释放，对象的生命周期完全自己控制，使用相对复杂，支持slice等复杂结构，也不是一个真正意义的连续超大空间，而是通过管理不同的mspan实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"arena"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyObj <span class="keyword">struct</span> &#123;</span><br><span class="line">Index <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkCreateObj</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *MyObj</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++ &#123;</span><br><span class="line">p = <span class="built_in">new</span>(MyObj)</span><br><span class="line">p.Index = j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">objPool = sync.Pool&#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;MyObj&#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkCreateObj_SyncPool</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *MyObj</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++ &#123;</span><br><span class="line">p = objPool.Get().(*MyObj)</span><br><span class="line">p.Index = <span class="number">23</span></span><br><span class="line">objPool.Put(p)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkCreateObj_Arena</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *MyObj</span><br><span class="line"></span><br><span class="line">a := arena.NewArena()</span><br><span class="line"><span class="keyword">defer</span> a.Free()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++ &#123;</span><br><span class="line">p = arena.New[MyObj](a)</span><br><span class="line">p.Index = <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性能对比的结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cpu: Intel(R) Core(TM) i7-8559U CPU @ 2.70GHz</span><br><span class="line">BenchmarkCreateObj-8                      100518             11370 ns/op            8000 B/op       1000 allocs/op</span><br><span class="line">BenchmarkCreateObj_SyncPool-8             110017             11523 ns/op               0 B/op          0 allocs/op</span><br><span class="line">BenchmarkCreateObj_Arena-8                 80409             15340 ns/op            8032 B/op          0 allocs/op</span><br></pre></td></tr></table></figure><p><code>Sync.Pool</code> 不需要重复分配且每次操作时间短，而<code>Arena</code>执行时间会长一点且每次还是需要分配内存的，因为需要引入新的 <code>mspan</code></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li><code>Arena</code> 不支持并发，可以看出操作同一个 arena的时候并不存在锁操作</li><li>Arena 强制 Free()之后的对象无法继续使用</li><li>优点：<ul><li>一旦被释放但仍然被访问则会显示的导致程序错误</li><li>arena 地址空间除非没有指针指向，否则将不能被重用</li><li>arena 永远不会被垃圾回收机制回收(如果GC不可达它会执行 <code>SetFinalizer</code> 自己释放掉，那我们手动free的意义在哪里 --&gt; 也就是构建arena的目的，提前释放内存，降低GC扫描频率)</li></ul></li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://uptrace.dev/blog/golang-memory-arena.html" target="_blank" rel="noopener">https://uptrace.dev/blog/golang-memory-arena.html</a></li><li><a href="https://colobu.com/2022/10/17/a-first-look-at-arena/" target="_blank" rel="noopener">https://colobu.com/2022/10/17/a-first-look-at-arena/</a></li><li><a href="https://zhuanlan.zhihu.com/p/604686258" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/604686258</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近 &lt;code&gt;Go1.20&lt;/code&gt; 更新，中间讲到了一个特性 &lt;code&gt;arena&lt;/code&gt; ，这里看看加入 &lt;code&gt;arena&lt;/code&gt; 的作用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在Go的内存管理中，&lt;code&gt;arena&lt;/code&gt; 其实
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go-21-SetFinalizer</title>
    <link href="http://xboom.github.io/2023/01/04/Go/Go-21-SetFinalizer/"/>
    <id>http://xboom.github.io/2023/01/04/Go/Go-21-SetFinalizer/</id>
    <published>2023-01-04T13:45:13.344Z</published>
    <updated>2023-07-15T05:37:47.256Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读Go 1.20 新特性 arena 的时候，看到在构建 arena 对象的时候使用了 <code>SetFinalizer</code> 这样一个函数</p><p>带着问题看世界</p><ol><li>它有什么用</li><li>它怎么用</li><li>它有什么缺点导致不是随处可见这种用法</li></ol><p>这里来详细看看它的作用，备注如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SetFinalizer sets the finalizer associated with obj to the provided finalizer function. When the garbage collector finds an unreachable block with an associated finalizer, it clears the association and runs finalizer(obj) in a separate goroutine. This makes obj reachable again,</span><br><span class="line">but now without an associated finalizer. Assuming that SetFinalizer is not called again, the next time the garbage collector sees that obj is unreachable, it will free obj.</span><br></pre></td></tr></table></figure><p>大意是：<strong>为对象提供一个析构函数，当GC发现不可达对象带有析构函数的时候，会单独使用协程执行这个析构函数。这样对GC来说对象是可达但没有了析构函数，下次GC发现对象不可达就会释放掉对象</strong></p><p>有一些协程的生命周期是与整个服务一致的，比如定时清理机制，它的好处是自动处理一些业务而不需要人工调用，但如果是在一些与业务完全分离的场景。比如为业务提供一个缓存池，缓存池中为了清理过期的缓存而设计了一个常驻协程。是否可以使用 <code>SetFinalizer</code> 的过期删除机制</p><p>首先看一个栗子：</p><p>一般情况我们会提供对象一个 <code>Close()</code>函数用于业务在不需要的时候清理对象，这里就可以用到这个 <code>SetFinalizer</code>，如 <code>os.NewFile</code> 就注册了 <code>SetFinalizer</code>逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newFile</span><span class="params">(fd <span class="keyword">uintptr</span>, name <span class="keyword">string</span>, kind newFileKind)</span> *<span class="title">File</span></span> &#123;</span><br><span class="line">fdi := <span class="keyword">int</span>(fd)</span><br><span class="line"><span class="keyword">if</span> fdi &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">f := &amp;File&#123;&amp;file&#123;</span><br><span class="line">pfd: poll.FD&#123;</span><br><span class="line">Sysfd:         fdi,</span><br><span class="line">IsStream:      <span class="literal">true</span>,</span><br><span class="line">ZeroReadIsEOF: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line">name:        name,</span><br><span class="line">stdoutOrErr: fdi == <span class="number">1</span> || fdi == <span class="number">2</span>,</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">runtime.SetFinalizer(f.file, (*file).<span class="built_in">close</span>)</span><br><span class="line"><span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">num  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">finalizer</span><span class="params">(f *Foo)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"a finalizer has run for "</span>, f.name, f.num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeFoo</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(a_foo *Foo)</span></span> &#123;</span><br><span class="line">a_foo = &amp;Foo&#123;name, counter&#125;</span><br><span class="line">counter++</span><br><span class="line">runtime.SetFinalizer(a_foo, finalizer)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">f1 := MakeFoo(<span class="string">"one"</span>)</span><br><span class="line">f2 := MakeFoo(<span class="string">"two"</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"f1 is: "</span>, f1.name)</span><br><span class="line">fmt.Println(<span class="string">"f2 is: "</span>, f2.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">Bar()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">runtime.GC()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"done."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f1 is:  one</span><br><span class="line">f2 is:  two</span><br><span class="line">a finalizer has run <span class="keyword">for</span>  two <span class="number">1</span></span><br><span class="line">a finalizer has run <span class="keyword">for</span>  one <span class="number">0</span></span><br><span class="line">f1 is:  one</span><br><span class="line">f2 is:  two</span><br><span class="line">a finalizer has run <span class="keyword">for</span>  two <span class="number">3</span></span><br><span class="line">a finalizer has run <span class="keyword">for</span>  one <span class="number">2</span></span><br><span class="line">f1 is:  one</span><br><span class="line">f2 is:  two</span><br><span class="line">a finalizer has run <span class="keyword">for</span>  two <span class="number">5</span></span><br><span class="line">a finalizer has run <span class="keyword">for</span>  one <span class="number">4</span></span><br><span class="line">done.</span><br></pre></td></tr></table></figure><p>注意事项</p><ol><li>obj 必须是指针</li><li><code>SetFinalizer</code> 执行顺序按照类似对象的出栈顺序</li><li>可以通过 <code>SetFinalizer(obj, nil)</code> 清理对象的析构器</li></ol><p>栗子2，它的实际效果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"runtime/debug"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">debug.SetGCPercent(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ms runtime.MemStats</span><br><span class="line">runtime.ReadMemStats(&amp;ms)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Allocation: %f Mb, Number of allocation: %d\n"</span>, <span class="keyword">float32</span>(ms.HeapAlloc)/<span class="keyword">float32</span>(<span class="number">1024</span>*<span class="number">1024</span>), ms.HeapObjects)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</span><br><span class="line">f := NewFoo(i)</span><br><span class="line">_ = fmt.Sprintf(<span class="string">"%d"</span>, f.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runtime.ReadMemStats(&amp;ms)</span><br><span class="line">fmt.Printf(<span class="string">"Allocation: %f Mb, Number of allocation: %d\n"</span>, <span class="keyword">float32</span>(ms.HeapAlloc)/<span class="keyword">float32</span>(<span class="number">1024</span>*<span class="number">1024</span>), ms.HeapObjects)</span><br><span class="line"></span><br><span class="line">runtime.GC()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">runtime.ReadMemStats(&amp;ms)</span><br><span class="line">fmt.Printf(<span class="string">"Allocation: %f Mb, Number of allocation: %d\n"</span>, <span class="keyword">float32</span>(ms.HeapAlloc)/<span class="keyword">float32</span>(<span class="number">1024</span>*<span class="number">1024</span>), ms.HeapObjects)</span><br><span class="line"></span><br><span class="line">runtime.GC()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">runtime.ReadMemStats(&amp;ms)</span><br><span class="line">fmt.Printf(<span class="string">"Allocation: %f Mb, Number of allocation: %d\n"</span>, <span class="keyword">float32</span>(ms.HeapAlloc)/<span class="keyword">float32</span>(<span class="number">1024</span>*<span class="number">1024</span>), ms.HeapObjects)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFoo</span><span class="params">(i <span class="keyword">int</span>)</span> *<span class="title">Foo</span></span> &#123;</span><br><span class="line">f := &amp;Foo&#123;a: rand.Intn(<span class="number">50</span>)&#125;</span><br><span class="line">runtime.SetFinalizer(f, <span class="function"><span class="keyword">func</span><span class="params">(f *Foo)</span></span> &#123;</span><br><span class="line">_ = fmt.Sprintf(<span class="string">"foo "</span> + strconv.Itoa(i) + <span class="string">" has been garbage collected"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Allocation: <span class="number">0.121063</span> Mb, Number of allocation: <span class="number">140</span></span><br><span class="line">Allocation: <span class="number">29.111671</span> Mb, Number of allocation: <span class="number">1899990</span></span><br><span class="line">Allocation: <span class="number">128.025635</span> Mb, Number of allocation: <span class="number">4382420</span></span><br><span class="line">Allocation: <span class="number">0.122147</span> Mb, Number of allocation: <span class="number">155</span></span><br></pre></td></tr></table></figure><p>可以看出，正如它功能说的一样，在第二次GC之后，分配的内存被释放</p><p>它也有缺点：</p><ol><li><code>SetFinalizer</code> 最大的问题是延长了对象生命周期。在第一次回收时执行 Finalizer 函数，且目标对象重新变成可达状态，直到第二次才真正 “销毁”。这对于有大量对象分配的高并发算法，可能会造成很大麻烦</li><li>指针构成的 “循环引⽤” 加上 <code>runtime.SetFinalizer</code> 会导致内存泄露</li><li><code>SetFinalizer</code>只在GC 发现对象不可达之后的任意时间执行，所以如果程序正常结束或者发生错误，而对象还没有被GC选中那么 <code>SetFinalizer</code> 也不会执行。</li></ol><p>所以保险起见还是提供了 <code>Close()</code> 逻辑供业务调用</p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/76504936" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/76504936</a></li><li><a href="https://go.dev/play/p/jWhRSPNvxJ" target="_blank" rel="noopener">https://go.dev/play/p/jWhRSPNvxJ</a></li><li><a href="https://medium.com/a-journey-with-go/go-finalizers-786df8e17687" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-finalizers-786df8e17687</a></li><li><code>runtime/mfinal.go</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在阅读Go 1.20 新特性 arena 的时候，看到在构建 arena 对象的时候使用了 &lt;code&gt;SetFinalizer&lt;/code&gt; 这样一个函数&lt;/p&gt;
&lt;p&gt;带着问题看世界&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它有什么用&lt;/li&gt;
&lt;li&gt;它怎么用&lt;/li&gt;
&lt;li&gt;它
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>算法之美-八数码问题</title>
    <link href="http://xboom.github.io/2022/12/11/Algorithms%20To%20Live%20By/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>http://xboom.github.io/2022/12/11/Algorithms%20To%20Live%20By/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/</id>
    <published>2022-12-11T09:47:28.000Z</published>
    <updated>2022-12-11T09:47:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>八数码问题也称为九宫问题。在3×3的棋盘，摆有八个棋子，每个棋子上标有1至8的某一数字，不同棋子上标的数字不相同。棋盘上还有一个空格，与空格相邻的棋子可以移到空格中。要求解决的问题是：给出一个初始状态和一个目标状态，找出一种从初始转变成目标状态的移动棋子步数最少的移动步骤</p><blockquote><p>所谓一个状态就是棋子在棋盘上的一种摆法。棋子移动后，状态就会发生改变。实际上就是找出从初始状态到达目标状态所经过的一系列中间过渡状态</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-11-03_23-53-25_bashuma_1.png" alt="Snipaste_2022-11-03_23-53-25_bashuma_1" style="zoom:67%;" /><p>首先这个九宫格的状态数量是 9!，那么存在问题</p><ol><li><p>是否存在从一个状态转移到另外一个状态无解的情况？</p></li><li><p>如何计算或者衡量从一个转移到另外一个状态的需要走多少步？</p></li></ol><h3 id="排列的性质"><a class="markdownIt-Anchor" href="#排列的性质"></a> 排列的性质</h3><p>为了搞清楚上述问题，需要知道几个基本定义与引理</p><ol><li><p>把n个不同的元素按一定的顺序排列成一行，成为这n个元素的一个<strong>排列</strong>。n个不同元素的排列共有 <strong>n!</strong> 种</p></li><li><p>对于n个自然数的一个排列，如果一个大数排在一个小数之前，就称这两个数构成一个<strong>逆序</strong>。一个排列的逆序总和称为该排列的<strong>逆序对</strong>，记为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi><mo stretchy="false">(</mo><mi>j</mi><mn>1</mn><mi>j</mi><mn>2</mn><mo>⋯</mo><mi>j</mi><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>τ</mi><mo>∗</mo><mo stretchy="false">(</mo><mo>∗</mo><mi>j</mi><mo>∗</mo><mn>1</mn><mo>∗</mo><mi>j</mi><mo>∗</mo><mn>2</mn><mo>⋯</mo><mo>∗</mo><mi>j</mi><mo>∗</mo><mo>∗</mo><mi>n</mi><mo>∗</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">τ(j1j2⋯jn)*τ*(*j*1*j*2⋯*j**n*)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">∗</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∗</span><span class="mord mathdefault">n</span><span class="mord">∗</span><span class="mclose">)</span></span></span></span></p><blockquote><p>如5阶排列31542的逆序是(3,1),(3,2),(5,4),(5,2),(4,2),故 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi><mo stretchy="false">(</mo><mn>31542</mn><mo stretchy="false">)</mo><mo>=</mo><mn>5</mn><mo>∗</mo><mi>τ</mi><mo>∗</mo><mo stretchy="false">(</mo><mn>31542</mn><mo stretchy="false">)</mo><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">τ(31542)=5*τ*(31542)=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mopen">(</span><span class="mord">3</span><span class="mord">1</span><span class="mord">5</span><span class="mord">4</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mord">1</span><span class="mord">5</span><span class="mord">4</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span></p></blockquote></li><li><p>逆序对为奇数的排列称为<strong>奇排列</strong>。逆序对为偶数的排列称为<strong>偶排列</strong>。<strong>自然排列</strong> 123⋯<em>n</em>的逆序对为0，故它是偶排列</p></li><li><p>在一个排列中，把某两个数的位置互换（其他数不动）变成另一个排列的变动称为一个<strong>对换</strong>，将相邻的两个数对换称为<strong>相邻对换</strong></p></li></ol><h3 id="性质的证明"><a class="markdownIt-Anchor" href="#性质的证明"></a> 性质的证明</h3><p><strong>性质1</strong>：<strong>一个排列中的任意两个数对换后，排列改变奇偶性。即经过一次对换，奇排列变成偶排列，偶排列变成奇排列</strong></p><p>证明：</p><ol><li><p>先证明相邻对换的情形</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-11-05_23-25-04-bashuma2.png" alt="Snipaste_2022-11-05_23-25-04-bashuma2" style="zoom:50%;" /><ul><li><p>设排列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>s</mi></msub><mi>a</mi><mi>b</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 ... a_s a b b_1 b_2 ... b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，对换a 与 b 的排列变为  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>s</mi></msub><mi>b</mi><mi>a</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 ... a_s b a b_1 b_2 ... b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p></li><li><p>a 与 b 的 对换不影响  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 ... a_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">b_1 b_2 ... b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 与 其他数的关系</p></li><li><p>但a与b的序关系变为：</p><ul><li><p>当 a &lt; b 时，在新排列中 a 、b 构成逆序</p></li><li><p>当 a &gt; b 时，在新排列中 a、b 不构成逆序</p></li></ul></li><li><p>因此 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>s</mi></msub><mi>a</mi><mi>b</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 ... a_s a b b_1 b_2 ... b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 比  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>s</mi></msub><mi>b</mi><mi>a</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 ... a_s b a b_1 b_2 ... b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的逆序多1或者少1</p></li></ul></li><li><p>再证一般对换情形</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-11-05_23-30-29-bashuma3.png" alt="Snipaste_2022-11-05_23-30-29-bashuma3" style="zoom:50%;" /><ul><li>设存在排列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>s</mi></msub><mi>a</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>…</mo><msub><mi>b</mi><mi>m</mi></msub><mi>b</mi><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>…</mo><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 … a_s a b_1 b_2 … b_m b c_1 c_2 … c_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>将 b 做 m 次相邻对换变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>s</mi></msub><mi>a</mi><mi>b</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>…</mo><msub><mi>b</mi><mi>m</mi></msub><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>…</mo><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 … a_s a b b_1 b_2 … b_m c_1 c_2 … c_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>再将 a 做 (m + 1) 次相邻对换变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>s</mi></msub><mi>b</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>…</mo><msub><mi>b</mi><mi>m</mi></msub><mi>a</mi><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>…</mo><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 … a_s b b_1 b_2 … b_m a c_1 c_2 … c_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>所以 经过 (2m + 1) 次相邻兑换，可以把排列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>s</mi></msub><mi>a</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>…</mo><msub><mi>b</mi><mi>m</mi></msub><mi>b</mi><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>…</mo><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 … a_s a b_1 b_2 … b_m b c_1 c_2 … c_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>转变成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>s</mi></msub><mi>b</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>…</mo><msub><mi>b</mi><mi>m</mi></msub><mi>a</mi><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>…</mo><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 … a_s b b_1 b_2 … b_m a c_1 c_2 … c_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，这两个排列的奇偶性相反</li></ul></li></ol><p><strong>性质2：在全部的 n(n≥2)阶排列中，奇偶排列各占一半，各有 n!/2 个</strong></p><p>证明：</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-11-06_09-56-51-bashuma4.png" alt="Snipaste_2022-11-06_09-56-51-bashuma4" style="zoom:50%;" /><ul><li><p>假设在全部n级排列中共有t个奇排列，s个偶排列</p></li><li><p>将t个奇排列中的前两个数字对换，得到t个互不相同的偶排列。因此 t≤s</p></li><li><p>同理可证 s≤t</p></li><li><p>于是 s=t，即奇、偶排列的总数相等，各有 n!/2个</p></li></ul><p><strong>性质3：任意一个n阶排列都可以经过一系列对换变成自然排列，并且所作对换的次数与这个排列有相同的奇偶性</strong></p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-11-06_13-10-01-bashuma5.png" alt="Snipaste_2022-11-06_13-10-01-bashuma5" style="zoom:50%;" /><p>证明(归纳法)：</p><ul><li>1阶排列只有一个，结论显然成立</li><li>假设对n-1阶排列已经成立，证对n阶排列的情形结论也成立<ul><li>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mn>1</mn></msub><msub><mi>j</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>j</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">j_1 j_2 ... j_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是一个n阶排列<ul><li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mi>n</mi></msub><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">j_n=n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> ，假设n-1级排列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mn>1</mn></msub><msub><mi>j</mi><mn>2</mn></msub><mo>…</mo><msub><mi>j</mi><mi>n</mi></msub><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">j_1 j_2 … j_n−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 可以经过一系列变换变成自然序列，即 1 2 … n−1，于是这一系列对换也就把 j1j2⋯jn 变成 12⋯n 这种自然序列的形式。</li><li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mi>n</mi><mi mathvariant="normal">≠</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">jn≠n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，那么对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mn>1</mn></msub><msub><mi>j</mi><mn>2</mn></msub><mo>…</mo><msub><mi>j</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">j_1 j_2 … j_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">j_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 n 的对换，它就变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mn>1</mn></msub><msub><mi>j</mi><mn>2</mn></msub><mo>…</mo><msub><mi>j</mi><mi>n</mi></msub><mi mathvariant="normal">−</mi><mn>1</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">j_1 j_2 … j_n−1 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">−</span><span class="mord">1</span><span class="mord mathdefault">n</span></span></span></span> ，这就归结成上面的情形，因此</li></ul></li></ul></li></ul><p><strong>性质4：奇偶性与可达性关系与证明</strong></p><blockquote><p>必要性证明：排列的奇偶性不同则对应在八数码问题中不可达</p></blockquote><p>在满足上述约定的八数码问题中，空格与相邻棋子的交换不会改变棋局中棋子数列的逆序对的奇偶性</p><ul><li><p>空格与左右棋子交换：是不改变棋子数列的逆序对的(因为数列并没有改变)</p></li><li><p>空格与上下棋子交换：也是不改变棋子数列的逆序对的</p><ul><li>假设交换棋子为c[i]=X</li><li>原数列p=c[1]… X c[i+1]c[i+2]…c[8]将变为新数列q=c[1]…c[i+1]c[i+2]X …c[8]（注意：在棋盘中，上下相邻的两棋格之间隔有两个棋格）。可以解释为用X与c[i+1]、 c[i+2]先后进行两次相邻交换而完成状态转变。</li><li>由p状态到q状态并不会改变改变棋子数列的逆序对的奇偶性。同理可证空格与下方棋子交换也不会改变棋子数列的逆序对的奇偶性。所以，空格与相邻棋子的交换不会改变棋局中棋子数列的逆序对的奇偶性</li></ul></li></ul><p>得出 <strong>定理1：对于任意两个状态映射的序列，如果这两个状态等价，那么它们的逆序数相同</strong></p><blockquote><p>充分性证明：<strong>排列的奇偶性相同则对应在八数码问题中也可达</strong></p></blockquote><p>首先明确几个定义：</p><ul><li><p><strong>状态</strong>(<strong>state</strong>)：八数码中8个数字与0的排列被定义为八数码的<strong>状态</strong>，比如：</p></li><li><p><strong>状态空间</strong>(<strong>state space</strong>)：八数码所有状态的合集被称为<strong>状态空间</strong></p></li><li><p><strong>完全态</strong>(<strong>completeness</strong>)：当状态空间的子集中任何两个状态都能通过一定步骤得到，那么称这个状态空间的子集是<strong>完全态</strong></p></li><li><p><strong>状态映射</strong>(<strong>a sequence mapped by a state</strong>)：一个状态{}可以映射(忽略0)成一个排序，那么这个排列就称为这个<strong>状态的映射</strong></p></li><li><p><strong>标准格式(a standard form)</strong>：如果 0 在正中间，那么称这个状态为<strong>标准格式</strong></p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20221211150738067.png" alt="image-20221211150738067" style="zoom:50%;" /></li><li><p><strong>区域(field)</strong>：对于任意状态(state)，4个位置中任意两个都相邻，那么称之为 <strong>区域</strong>，特别的，当两个区域有相同的两个位置，则称为 <strong>同边区域</strong></p></li><li><p><strong>转圈(circle moving)</strong>：0在一个区域内移动称 <strong>转圈</strong></p></li></ul><p><strong>引理1：对于标准格式中的任意区域，转圈可以得到两个等价的区域</strong></p><p>考虑到 <strong>标准格式</strong> 的对称性，只需要考虑一个区域的的变化</p><p>第一种情况(顺时针方向部分先后): a b d</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121101.png" alt="bashuma-121101" style="zoom:50%;" /><p>第二种情况(顺时针方向不分先后): a d b</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121102.png" alt="bashuma-121102" /></p><p>接着考虑在一个标准格式中，在两个具有相同边的区域交换数据，由于标准格式的对称性，所以只考虑上半部分</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121103.png" alt="bashuma-121103" style="zoom:50%;" /><blockquote><p>这个图形转换根据上述原则手动绘制交换流程更容易理解</p></blockquote><p>得出的<strong>规律1</strong>: m 属于 {a ,d}，n 属于 {c, e}，p 属于 {a, d} 但 p != m，q 属于 {c, e}但 q != n，那么交换 m n，则 n 来到 m 之前的位置，而 m 来到 q 之前的位置，q 来到 n 之前的位置</p><p>得出的<strong>规律2</strong>：abc 可以经过转换编程 cab 或者 bac，不影响其他行且逆序对不变</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121104.png" alt="bashuma-121104" style="zoom:80%;" /><p>对于标准格式，如果它们的逆序对的奇偶性相同，那么它们是等价的</p><p>证明：</p><p>首先，将九宫格分为A、B、C、D分为四个区域</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121106.png" alt="bashuma-121106" style="zoom:50%;" /><p>第一步，将 h 移动到位置 位置 9，这是肯定可以的</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121107.png" alt="bashuma-121107" style="zoom:50%;" /><p>第二步，将 g、e 移动到区域D</p><blockquote><p>为什么不考虑g、e的顺序，因为可以在不影响h的情况下 g 在 位置 6 与 位置8 任意切换</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121112.png" alt="bashuma-121112" style="zoom:50%;" /><ul><li><p>2.1 如果 g、e 已经在区域D，那么不需要移动</p></li><li><p>2.2 如果其中 g 在 区域D，而e 在其他区域</p><ul><li><p>2.2.1 e 在区域A</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121109.png" alt="bashuma-121109" style="zoom:50%;" /></li><li><p>2.2.2 e 在区域B</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-12-11_16-55-10.png" alt="Snipaste_2022-12-11_16-55-10" style="zoom:50%;" /></li><li><p>2.2.3 e 在区域C</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121111.png" alt="bashuma-121111" style="zoom:50%;" /></li></ul><p>第三步，将 b、c 移动到 B区域</p><ul><li><p>3.1 如果 b、c 都在区域 B，那么不需要移动</p></li><li><p>3.2 如果 b、c 有一个在区域B，那么</p><blockquote><p>b 、c 的位置也同样可以忽略，如果b、c是正常顺序，那么也可以在不影响 g e h 位置的情况下调整 b c 的顺序</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-1211-13.png" alt="bashuma-1211-13" style="zoom:50%;" /><ul><li><p>3.1.1 如果在位置3</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma121110.png" alt="bashuma121110" style="zoom:50%;" /></li><li><p>3.1.2 如果在位置2，那么先将c移动位置3再执行上述步骤</p></li></ul></li><li><p>如果 b、c 都不在区域B，同理将c 移动到位置3，然后在执行上述3.1.1 步骤</p></li></ul></li></ul><p>第四步，在不影响bcehg的情况下调整adf的顺序</p><ul><li>规律二在 此场景下仍然适用，所以首先将防止到位置7</li><li>根据定理1，如果两者等价，那么它们的逆序对是相同的。而如果位置1与位置3交换其他位置不变，那边整个序列的逆序对是变化的。所以a一定在位置1，d在位置4</li></ul><p>所以，如果奇偶性相同，那么两个状态都能转换成一个相同的标准状态，那么两个状态之间是可达的</p><p>得出结论：<strong>两个排列的逆序对奇偶性相同，那么在八数码中必可达</strong></p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://blog.csdn.net/u011008379/article/details/40144147" target="_blank" rel="noopener">https://blog.csdn.net/u011008379/article/details/40144147</a></li><li><a href="https://chengfeng96.com/blog/2018/05/26/%E5%88%A9%E7%94%A8BFS%EF%BC%8CDFS%EF%BC%8CA-%E8%A7%A3%E5%86%B3%E5%85%AB%E6%95%B0%E7%A0%81%E9%9A%BE%E9%A2%98/" target="_blank" rel="noopener">https://chengfeng96.com/blog/2018/05/26/利用BFS，DFS，A-解决八数码难题/</a></li><li><a href="http://www.huaying1988.com/blogs/8_Puzzle_StrictProof_SolutionAlgorithm_AndOthers/detail.html" target="_blank" rel="noopener">http://www.huaying1988.com/blogs/8_Puzzle_StrictProof_SolutionAlgorithm_AndOthers/detail.html</a></li><li>《A constructive proof for the subsets completeness of 8-Puzzle state space》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;八数码问题也称为九宫问题。在3×3的棋盘，摆有八个棋子，每个棋子上标有1至8的某一数字，不同棋子上标的数字不相同。棋盘上还有一个空格，与空格相邻的棋子可以移到空格中。要求解决的问题是：给出一个初始状态和一个目标状态，找出一种从初始转变成目标状态的移动棋子步数最少的移动步骤&lt;
      
    
    </summary>
    
    
      <category term="Algorithms To Live By" scheme="http://xboom.github.io/categories/Algorithms-To-Live-By/"/>
    
    
      <category term="Algorithms To Live By" scheme="http://xboom.github.io/tags/Algorithms-To-Live-By/"/>
    
  </entry>
  
  <entry>
    <title>Go-22-Goland激活</title>
    <link href="http://xboom.github.io/2022/12/09/Go/Go-22-Goland%E6%BF%80%E6%B4%BB/"/>
    <id>http://xboom.github.io/2022/12/09/Go/Go-22-Goland%E6%BF%80%E6%B4%BB/</id>
    <published>2022-12-09T08:00:20.000Z</published>
    <updated>2023-07-15T05:37:52.316Z</updated>
    
    <content type="html"><![CDATA[<p>Goland好用但是激活太贵，网上找了一个使用激活服务器的办法， Goland 2022.2.2 激活成功</p><blockquote><p>最好支持正版！！！</p></blockquote><p>第一步：首先打开网址 <a href="https://search.censys.io" target="_blank" rel="noopener">https://search.censys.io</a></p><p>第二步：搜索信息 <code>services.http.response.headers.location: account.jetbrains.com/fls-auth</code></p><p>第三步：点击搜索到的网址信息</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/goland-acitve-1.png" alt="goland-acitve-1" /></p><p>第四步：找到状态为302的信息网址信息，如果没有找到请重复第三步</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/goland-acitve-302.png" alt="goland-acitve-302" /></p><p>第五步：复制上一步信息中的Details信息，这里是 <code>https://188.210.42.106</code></p><p>第六步：将地址信息填入 goland 中的 Licence Service 并点击 Acitve 激活</p><p>第七步：如果激活成功将出现下图所示，否则重复第三步</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/goland-acitve-success.png" alt="goland-acitve-success" /></p><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://dushusir.com/jetbrains/" target="_blank" rel="noopener">https://dushusir.com/jetbrains/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Goland好用但是激活太贵，网上找了一个使用激活服务器的办法， Goland 2022.2.2 激活成功&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最好支持正版！！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一步：首先打开网址 &lt;a href=&quot;https://sear
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-14-健康检查</title>
    <link href="http://xboom.github.io/2022/11/04/Grpc/Grpc-14-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/"/>
    <id>http://xboom.github.io/2022/11/04/Grpc/Grpc-14-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/</id>
    <published>2022-11-04T14:58:29.000Z</published>
    <updated>2023-05-27T10:56:13.039Z</updated>
    
    <content type="html"><![CDATA[<p>前面学习了保持链接，这里看一下健康检查</p><p>带着问题看世界</p><ol><li>健康检查的作用</li><li>健康检查的原理</li><li>保持链接与健康检查的区别</li></ol><p>首先看一下源码例子中的ReadMe说明，gRPC提供了一个健康检查库，用于向客户端通报系统的健康状况。它通过使用health/v1 API提供服务定义。通过使用健康检查库，客户端可以在遇到问题时优雅地避免使用服务器。大多数语言都提供了现成的实现，这使得它在不同系统之间可以互操作。内置健康检查的优势</p><ul><li>健康检查的格式与普通的RPC一样</li><li>重用现有的配额等机制，内部对健康检查有完全的控制权</li></ul><h3 id="基本使用"><a class="markdownIt-Anchor" href="#基本使用"></a> 基本使用</h3><p>内部定义了健康检查的 proto</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> grpc.health.v1;</span><br><span class="line"></span><br><span class="line">message HealthCheckRequest &#123;</span><br><span class="line">  <span class="keyword">string</span> service = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HealthCheckResponse &#123;</span><br><span class="line">  enum ServingStatus &#123;</span><br><span class="line">    UNKNOWN = <span class="number">0</span>;</span><br><span class="line">    SERVING = <span class="number">1</span>;</span><br><span class="line">    NOT_SERVING = <span class="number">2</span>;</span><br><span class="line">    SERVICE_UNKNOWN = <span class="number">3</span>;  <span class="comment">// Used only by the Watch method.</span></span><br><span class="line">  &#125;</span><br><span class="line">  ServingStatus status = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service Health &#123;</span><br><span class="line">  rpc Check(HealthCheckRequest) returns (HealthCheckResponse);</span><br><span class="line"></span><br><span class="line">  rpc Watch(HealthCheckRequest) returns (stream HealthCheckResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共有两种方式进行健康检查</p><ul><li><code>Check</code> 探测服务器的健康状态</li><li><code>Watch</code> 观察服务端变化，这里注意 是一个<code>服务端流</code>，也就是客户端不断会收到服务端的状态更新</li></ul><p>一般，客户端不需要手动执行 <code>Check</code>操作，而是通过配置 <code>healthCheckConfig</code> ，它会在内部自动执行 <code>Watch</code>操作</p><h4 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import grpc/health to enable transparent client side checking </span></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">"google.golang.org/grpc/health"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set up appropriate service config</span></span><br><span class="line">serviceConfig := grpc.WithDefaultServiceConfig(<span class="string">`&#123;</span></span><br><span class="line"><span class="string">  "loadBalancingPolicy": "round_robin",</span></span><br><span class="line"><span class="string">  "healthCheckConfig": &#123;</span></span><br><span class="line"><span class="string">    "serviceName": ""</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;`</span>)</span><br><span class="line"></span><br><span class="line">conn, err := grpc.Dial(..., serviceConfig)</span><br></pre></td></tr></table></figure><h4 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h4><p>启动一个协程，来模拟服务端状态变化，核心逻辑就是设置服务的状态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">port  = flag.Int(<span class="string">"port"</span>, <span class="number">50051</span>, <span class="string">"the port to serve on"</span>)</span><br><span class="line">sleep = flag.Duration(<span class="string">"sleep"</span>, time.Second*<span class="number">5</span>, <span class="string">"duration between changes in health"</span>)</span><br><span class="line"></span><br><span class="line">system = <span class="string">""</span> <span class="comment">// empty string represents the health of the system</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line">lis, err := net.Listen(<span class="string">"tcp"</span>, fmt.Sprintf(<span class="string">":%d"</span>, *port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to listen: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s := grpc.NewServer()</span><br><span class="line">healthcheck := health.NewServer()</span><br><span class="line">healthpb.RegisterHealthServer(s, healthcheck)<span class="comment">//健康检查</span></span><br><span class="line">pb.RegisterEchoServer(s, &amp;echoServer&#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//健康状态更新</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// asynchronously inspect dependencies and toggle serving status as needed</span></span><br><span class="line">next := healthpb.HealthCheckResponse_SERVING</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">healthcheck.SetServingStatus(system, next)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> next == healthpb.HealthCheckResponse_SERVING &#123;</span><br><span class="line">next = healthpb.HealthCheckResponse_NOT_SERVING</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">next = healthpb.HealthCheckResponse_SERVING</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(*sleep)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to serve: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>健康服务器可以返回四种状态：<code>UNKNOWN</code>、<code>SERVING</code>、<code>NOT_SERVING</code>和<code>SERVICE_UNKNOWN</code>。</p><ul><li><p><code>UNKNOWN</code> 表示当前状态尚未知晓。在服务器实例启动时经常会看到这种状态。</p></li><li><p><code>SERVING</code> 表示系统健康，准备好提供服务请求。</p></li><li><p><code>NOT_SERVING</code> 表示系统当前无法处理请求。</p></li><li><p><code>SERVICE_UNKNOWN</code> 表示客户端请求的服务名未被服务器所知。此状态仅由 <code>Watch()</code> 调用报告</p></li></ul><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><h4 id="客户端-2"><a class="markdownIt-Anchor" href="#客户端-2"></a> 客户端</h4><p>客户端默认初始化<code>Watch</code>函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">   internal.HealthCheckFunc = clientHealthCheck</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> healthCheckMethod = <span class="string">"/grpc.health.v1.Health/Watch"</span><span class="comment">//指定健康检查方法名称</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clientHealthCheck</span><span class="params">(ctx context.Context, newStream <span class="keyword">func</span>(<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>, <span class="title">setConnectivityState</span> <span class="title">func</span><span class="params">(connectivity.State, error)</span>, <span class="title">service</span> <span class="title">string</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">   tryCnt := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">retryConnection:</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">//退避重试</span></span><br><span class="line">      <span class="keyword">if</span> tryCnt &gt; <span class="number">0</span> &amp;&amp; !backoffFunc(ctx, tryCnt<span class="number">-1</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">      tryCnt++</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ctx.Err() != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">      setConnectivityState(connectivity.Connecting, <span class="literal">nil</span>)<span class="comment">//设置状态</span></span><br><span class="line">      rawS, err := newStream(healthCheckMethod)<span class="comment">//构建流链接</span></span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">continue</span> retryConnection</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      s, ok := rawS.(grpc.ClientStream)</span><br><span class="line">      <span class="keyword">if</span> !ok &#123;</span><br><span class="line">         setConnectivityState(connectivity.Ready, <span class="literal">nil</span>)<span class="comment">//服务端健康</span></span><br><span class="line">         <span class="keyword">return</span> fmt.Errorf(<span class="string">"newStream returned %v (type %T); want grpc.ClientStream"</span>, rawS, rawS)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> err = s.SendMsg(&amp;healthpb.HealthCheckRequest&#123;Service: service&#125;); err != <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123;</span><br><span class="line">         <span class="comment">// Stream should have been closed, so we can safely continue to create a new stream.</span></span><br><span class="line">         <span class="keyword">continue</span> retryConnection</span><br><span class="line">      &#125;</span><br><span class="line">      s.CloseSend()</span><br><span class="line"></span><br><span class="line">      resp := <span class="built_in">new</span>(healthpb.HealthCheckResponse)</span><br><span class="line">      <span class="keyword">for</span> &#123;<span class="comment">//不断接收服务端响应</span></span><br><span class="line">         err = s.RecvMsg(resp)</span><br><span class="line"></span><br><span class="line">         <span class="comment">// </span></span><br><span class="line">         <span class="keyword">if</span> status.Code(err) == codes.Unimplemented &#123;<span class="comment">//表示服务端未支持健康检查</span></span><br><span class="line">            setConnectivityState(connectivity.Ready, <span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 其他错误</span></span><br><span class="line">         <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            setConnectivityState(connectivity.TransientFailure, fmt.Errorf(<span class="string">"connection active but received health check RPC error: %v"</span>, err))</span><br><span class="line">            <span class="keyword">continue</span> retryConnection</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//收到消息那么</span></span><br><span class="line">         tryCnt = <span class="number">0</span></span><br><span class="line">         <span class="keyword">if</span> resp.Status == healthpb.HealthCheckResponse_SERVING &#123;</span><br><span class="line">            setConnectivityState(connectivity.Ready, <span class="literal">nil</span>)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setConnectivityState(connectivity.TransientFailure, fmt.Errorf(<span class="string">"connection active but health check failed. status=%s"</span>, resp.Status))</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据策略启动健康检查，<strong>针对的是同一个域名对应的多个子地址</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启健康检查</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ac *addrConn)</span> <span class="title">startHealthCheck</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> healthcheckManagingState <span class="keyword">bool</span></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> !healthcheckManagingState &#123;</span><br><span class="line">         ac.updateConnectivityState(connectivity.Ready, <span class="literal">nil</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="comment">//... 判断健康检查是否开启</span></span><br><span class="line">   currentTr := ac.transport</span><br><span class="line">   newStream := <span class="function"><span class="keyword">func</span><span class="params">(method <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">      ac.mu.Lock()</span><br><span class="line">      <span class="keyword">if</span> ac.transport != currentTr &#123;</span><br><span class="line">         ac.mu.Unlock()</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.Canceled, <span class="string">"the provided transport is no longer valid to use"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      ac.mu.Unlock()</span><br><span class="line">      <span class="keyword">return</span> newNonRetryClientStream(ctx, &amp;StreamDesc&#123;ServerStreams: <span class="literal">true</span>&#125;, method, currentTr, ac)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//更新连接状态</span></span><br><span class="line">   setConnectivityState := <span class="function"><span class="keyword">func</span><span class="params">(s connectivity.State, lastErr error)</span></span> &#123;</span><br><span class="line">      ac.mu.Lock()</span><br><span class="line">      <span class="keyword">defer</span> ac.mu.Unlock()</span><br><span class="line">      <span class="keyword">if</span> ac.transport != currentTr &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      ac.updateConnectivityState(s, lastErr)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 独立协程去检查健康状态</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      err := ac.cc.dopts.healthCheckFunc(ctx, newStream, setConnectivityState, healthCheckConfig.ServiceName)</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">   &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以通过健康检查更新连接状态，但不是唯一更新连接状态的方式</p><h4 id="服务端-2"><a class="markdownIt-Anchor" href="#服务端-2"></a> 服务端</h4><h5 id="维护"><a class="markdownIt-Anchor" href="#维护"></a> 维护</h5><p>首先需要明白服务端是如何维护状态的 <code>SetServingStatus</code> 其实还是需要用户自定义状态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">SetServingStatus</span><span class="params">(service <span class="keyword">string</span>, servingStatus healthpb.HealthCheckResponse_ServingStatus)</span></span> &#123;</span><br><span class="line">   <span class="comment">//....</span></span><br><span class="line">   s.setServingStatusLocked(service, servingStatus)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">setServingStatusLocked</span><span class="params">(service <span class="keyword">string</span>, servingStatus healthpb.HealthCheckResponse_ServingStatus)</span></span> &#123;</span><br><span class="line">   s.statusMap[service] = servingStatus</span><br><span class="line">   <span class="keyword">for</span> _, update := <span class="keyword">range</span> s.updates[service] &#123;</span><br><span class="line">      <span class="comment">// Clears previous updates, that are not sent to the client, from the channel.</span></span><br><span class="line">      <span class="comment">// This can happen if the client is not reading and the server gets flow control limited.</span></span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-update:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Puts the most recent update to the channel.</span></span><br><span class="line">      update &lt;- servingStatus</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">statusMap <span class="keyword">map</span>[<span class="keyword">string</span>]healthpb.HealthCheckResponse_ServingStatus</span><br><span class="line">updates   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[healthgrpc.Health_WatchServer]<span class="keyword">chan</span> healthpb.HealthCheckResponse_ServingStatus</span><br></pre></td></tr></table></figure><p>这里的状态更新有两种</p><ol><li>更新 <code>statusMap[service]</code> 对应的服务状态</li><li>将状态写入到服务对应的隧道中，隧道中的状态则是通过<code>Watch</code>函数不断地通知客户端(不同的状态才会通知)</li></ol><p>这里有两种特殊的情况可以直接使用内置函数，就是服务恢复正常与停止服务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Shutdown</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s.mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line">   s.shutdown = <span class="literal">true</span></span><br><span class="line">   <span class="keyword">for</span> service := <span class="keyword">range</span> s.statusMap &#123;</span><br><span class="line">      s.setServingStatusLocked(service, healthpb.HealthCheckResponse_NOT_SERVING)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Resume</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s.mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line">   s.shutdown = <span class="literal">false</span></span><br><span class="line">   <span class="keyword">for</span> service := <span class="keyword">range</span> s.statusMap &#123;</span><br><span class="line">      s.setServingStatusLocked(service, healthpb.HealthCheckResponse_SERVING)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会统一更新服务的状态，而不需要单独设置某个服务的状态更新，一般用于服务启动与恢复。</p><p>接着就是接收客户端的健康检查请求</p><h5 id="check"><a class="markdownIt-Anchor" href="#check"></a> Check</h5><p>当客户端请求服务状态的时候，直接从状态服务中返回结果  <code>statusMap[in.Service]</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Check</span><span class="params">(ctx context.Context, in *healthpb.HealthCheckRequest)</span> <span class="params">(*healthpb.HealthCheckResponse, error)</span></span> &#123;</span><br><span class="line">   s.mu.RLock()</span><br><span class="line">   <span class="keyword">defer</span> s.mu.RUnlock()</span><br><span class="line">   <span class="keyword">if</span> servingStatus, ok := s.statusMap[in.Service]; ok &#123;</span><br><span class="line">      <span class="keyword">return</span> &amp;healthpb.HealthCheckResponse&#123;</span><br><span class="line">         Status: servingStatus,</span><br><span class="line">      &#125;, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.NotFound, <span class="string">"unknown service"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="watch"><a class="markdownIt-Anchor" href="#watch"></a> Watch</h5><p><code>watch</code> 其实就是服务端不断地将状态的变化通知给客户端</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Watch implements `service Health`.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Watch</span><span class="params">(in *healthpb.HealthCheckRequest, stream healthgrpc.Health_WatchServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   service := in.Service</span><br><span class="line">   <span class="comment">// update channel is used for getting service status updates.</span></span><br><span class="line">   update := <span class="built_in">make</span>(<span class="keyword">chan</span> healthpb.HealthCheckResponse_ServingStatus, <span class="number">1</span>)</span><br><span class="line">   s.mu.Lock()</span><br><span class="line">   <span class="comment">// Puts the initial status to the channel.</span></span><br><span class="line">   <span class="keyword">if</span> servingStatus, ok := s.statusMap[service]; ok &#123;</span><br><span class="line">      update &lt;- servingStatus<span class="comment">//如果服务状态存在，那么写入隧道中</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果不存在，则更新未知</span></span><br><span class="line">      update &lt;- healthpb.HealthCheckResponse_SERVICE_UNKNOWN</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注册状态</span></span><br><span class="line">   <span class="keyword">if</span> _, ok := s.updates[service]; !ok &#123;</span><br><span class="line">      s.updates[service] = <span class="built_in">make</span>(<span class="keyword">map</span>[healthgrpc.Health_WatchServer]<span class="keyword">chan</span> healthpb.HealthCheckResponse_ServingStatus)</span><br><span class="line">   &#125;</span><br><span class="line">   s.updates[service][stream] = update</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      s.mu.Lock()</span><br><span class="line">      <span class="built_in">delete</span>(s.updates[service], stream)</span><br><span class="line">      s.mu.Unlock()</span><br><span class="line">   &#125;()</span><br><span class="line">   s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> lastSentStatus healthpb.HealthCheckResponse_ServingStatus = <span class="number">-1</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">     </span><br><span class="line">      <span class="keyword">case</span> servingStatus := &lt;-update:<span class="comment">//监听 update</span></span><br><span class="line">         <span class="keyword">if</span> lastSentStatus == servingStatus &#123;<span class="comment">//与上一次的状态相同，那么就不会响应</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//否则发送状态</span></span><br><span class="line">         lastSentStatus = servingStatus</span><br><span class="line">         err := stream.Send(&amp;healthpb.HealthCheckResponse&#123;Status: servingStatus&#125;)</span><br><span class="line">         <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> status.Error(codes.Canceled, <span class="string">"Stream has ended."</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> &lt;-stream.Context().Done():</span><br><span class="line">         <span class="keyword">return</span> status.Error(codes.Canceled, <span class="string">"Stream has ended."</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li><p>心跳检查是为了客户端可以根据服务端状态进行自定义操作</p></li><li><p>心跳检查启动的时候启动了退避算法，gRPC默认的退避算法是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultConfig = Config&#123;</span><br><span class="line">BaseDelay:  <span class="number">1.0</span> * time.Second,</span><br><span class="line">Multiplier: <span class="number">1.6</span>,</span><br><span class="line">Jitter:     <span class="number">0.2</span>,</span><br><span class="line">MaxDelay:   <span class="number">120</span> * time.Second,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>Watch</code>中如果与上一次的状态没有变化，则不会通知客户端</p></li><li><p>健康检查针对的是具有相同地址的多个服务，一个服务异常整体连接在不会断开，而是更新连接状态</p><ul><li>针对不能提供服务的服务器端，客户端会将链接状态更新为<code>TransientFailure</code>，但是链接不会断的；当该连接的状态重新更新为<code>Ready</code>时，还可以继续创建流，传输数据。</li><li>针对可以对外提供服务的服务器端，客户端会将链接状态更新为<code>Ready</code>，生成<code>Picker</code>，即将此链接缓存到平衡器里，并且将链接状态更新为<code>Ready</code>，接下来，就可以创建流，传输数据了</li></ul></li><li><p>健康检查可以应用会更新连接状态，且不能自定义 <code>withHealthCheckFunc</code></p></li><li><p>如果在传输过程中收到服务端通知，由于数据发送存在重试机制，所以还是可以从平衡器中选择 <code>Ready</code> 的连接重新传输数据</p></li><li><p>健康检查与保持链接的区别</p><ol><li><code>keepalive</code>和<code>healthcheck</code>都是用于确保通信的可用性和健康状态的机制。</li><li><code>keepalive</code>是一种保持连接活动的机制，用于检测连接是否处于空闲状态，并在需要时发送ping帧以防止连接关闭。<code>keepalive</code>机制确保长时间的空闲连接不会被关闭，以避免重新建立连接的开销</li><li><code>healthcheck</code>是一种检查服务可用性的机制，用于检测服务器是否可用，以及在服务器不可用时采取相应的措施。<code>healthcheck</code>机制通过发送特定的RPC请求来检查服务器的可用性，并根据响应的状态码和错误信息来确定服务器的状态。</li></ol></li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://github.com/grpc/grpc/blob/master/doc/health-checking.md" target="_blank" rel="noopener">https://github.com/grpc/grpc/blob/master/doc/health-checking.md</a></li><li><a href="https://blog.csdn.net/u011582922/article/details/120052706" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/120052706</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面学习了保持链接，这里看一下健康检查&lt;/p&gt;
&lt;p&gt;带着问题看世界&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;健康检查的作用&lt;/li&gt;
&lt;li&gt;健康检查的原理&lt;/li&gt;
&lt;li&gt;保持链接与健康检查的区别&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先看一下源码例子中的ReadMe说明，gRPC提供了一
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-13-保持链接</title>
    <link href="http://xboom.github.io/2022/10/31/Grpc/Grpc-13-%E4%BF%9D%E6%8C%81%E9%93%BE%E6%8E%A5/"/>
    <id>http://xboom.github.io/2022/10/31/Grpc/Grpc-13-%E4%BF%9D%E6%8C%81%E9%93%BE%E6%8E%A5/</id>
    <published>2022-10-31T14:58:29.000Z</published>
    <updated>2023-05-27T10:56:04.414Z</updated>
    
    <content type="html"><![CDATA[<p>在学习的过程中看到了grpc-go中的两个概念 <strong>保持链接</strong> 和 <strong>心跳检查</strong>，这里先学习一下<strong>保持链接</strong></p><p>带着问题看世界</p><ol><li>保持链接的作用</li><li>保持链接的原理</li><li>它与TCP的 <code>keepalive</code> 有什么区别</li></ol><p>首先来看一下<a href="https://github.com/grpc/grpc-go/blob/master/Documentation/keepalive.md" target="_blank" rel="noopener">官方的介绍</a>，</p><ul><li><p>保持连接功能可以检测TCP层面的连接故障。在某些情况下，TCP连接会丢失数据包(包括FIN)，需要等待系统TCP超时时间(可能为30分钟)才能检测到故障。使用保持连接功能可以让gRPC更早地检测到这种故障</p></li><li><p>另外是保持连接活动，比如在L4代理中配置为关闭“空闲连接”的情况下，发送包活消息可以是连接不处于“空闲”状态</p></li></ul><p>这里补充一下TCP的 keepalive 的原理：</p><p>当一方发送一个数据包后，如果对方没有回应，那么TCP协议会按照指数退避的算法重新发送数据包，最多会重发12次。如果在这12次内仍然没有收到对方的响应，则会将连接标记为“超时”，并关闭连接。这个过程通常需要30分钟左右</p><blockquote><p>可以手动修改TCP默认的超时时间</p><p>sudo sysctl -w net.ipv4.tcp_keepalive_time=300</p></blockquote><h3 id="基本使用"><a class="markdownIt-Anchor" href="#基本使用"></a> 基本使用</h3><h4 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kacp = keepalive.ClientParameters&#123;</span><br><span class="line">   Time:                <span class="number">10</span> * time.Second, <span class="comment">// send pings every 10 seconds if there is no activity</span></span><br><span class="line">   Timeout:             time.Second,      <span class="comment">// wait 1 second for ping ack before considering the connection dead</span></span><br><span class="line">   PermitWithoutStream: <span class="literal">true</span>,             <span class="comment">// send pings even without active streams</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithKeepaliveParams(kacp))</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端的保持心跳参数一共有三个</p><ol><li><code>Time</code>：在没有活动的情况下，发送 ping 的时间间隔(<strong>不能少于10s</strong>)</li><li><code>Timeout</code>：等待ping确认的超时时间</li><li><code>PermitWithoutStream</code>：及时没有活动的流也要发送<code>ping</code>请求</li></ol><h4 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kaep = keepalive.EnforcementPolicy&#123;</span><br><span class="line">   MinTime:             <span class="number">5</span> * time.Second, <span class="comment">// If a client pings more than once every 5 seconds, terminate the connection</span></span><br><span class="line">   PermitWithoutStream: <span class="literal">true</span>,            <span class="comment">// Allow pings even when there are no active streams</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kasp = keepalive.ServerParameters&#123;</span><br><span class="line">   MaxConnectionIdle:     <span class="number">15</span> * time.Second, <span class="comment">// If a client is idle for 15 seconds, send a GOAWAY</span></span><br><span class="line">   MaxConnectionAge:      <span class="number">30</span> * time.Second, <span class="comment">// If any connection is alive for more than 30 seconds, send a GOAWAY</span></span><br><span class="line">   MaxConnectionAgeGrace: <span class="number">5</span> * time.Second,  <span class="comment">// Allow 5 seconds for pending RPCs to complete before forcibly closing connections</span></span><br><span class="line">   Time:                  <span class="number">5</span> * time.Second,  <span class="comment">// Ping the client if it is idle for 5 seconds to ensure the connection is still active</span></span><br><span class="line">   Timeout:               <span class="number">1</span> * time.Second,  <span class="comment">// Wait 1 second for the ping ack before assuming the connection is dead</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := grpc.NewServer(grpc.KeepaliveEnforcementPolicy(kaep), grpc.KeepaliveParams(kasp))</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一共有两个保活配置 <code>EnforcementPolicy</code> 与 <code>ServerParameters</code></p><p><code>EnforcementPolicy</code> 定义了服务端如何执行保活策略</p><ul><li><code>MinTime</code>：如果客户端每隔不到5秒就发送一个ping请求，服务器就终止连接</li><li><code>PermitWithoutStream</code>：表示即使没有活动的流，也允许ping请求</li></ul><p>ServerParameters 定义了保活</p><ul><li><code>MaxConnectionIdle</code>：如果客户端闲置超过 15 秒，则发送 <code>GOAWAY</code></li><li><code>MaxConnectionAge</code>： 如果任何连接存在时间超过 30 秒，则发送 <code>GOAWAY</code></li><li><code>MaxConnectionAgeGrace</code>：允许在强制关闭连接之前等待 5 秒钟以完成待处理的 <code>RPC</code></li><li><code>Time</code>：如果客户端闲置超过 5 秒钟，则发送 <code>ping</code> 以确保连接仍处于活动状态</li><li><code>Timeout</code>：等待 1 秒钟以获取 <code>ping</code> 的响应，在此之后假定连接已断开</li></ul><p><code>MaxConnectionAge</code>是指整个连接（connection）的最长存在时间，不是单个流(stream)的最长存在时间。当一个连接的时间超过了 <code>MaxConnectionAge</code> 指定的时间，服务器会发送一个 <code>GOAWAY</code> 帧，表示不再接受来自该连接的新流。任何新的流的创建请求都会被拒绝，并且服务器会等待 <code>MaxConnectionAgeGrace</code> 指定的一段时间，让尚未完成的 RPC 请求完成。在这段时间内，服务器不会发送任何新的数据帧，但仍会响应已有的流。</p><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><h4 id="客户端-2"><a class="markdownIt-Anchor" href="#客户端-2"></a> 客户端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newHTTP2Client</span><span class="params">(connectCtx, ctx context.Context, addr resolver.Address, opts ConnectOptions, onPrefaceReceipt <span class="keyword">func</span>()</span>, <span class="title">onGoAway</span> <span class="title">func</span><span class="params">(GoAwayReason)</span>, <span class="title">onClose</span> <span class="title">func</span><span class="params">()</span>) <span class="params">(_ *http2Client, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">kp := opts.KeepaliveParams</span><br><span class="line"><span class="comment">// Validate keepalive parameters.</span></span><br><span class="line"><span class="keyword">if</span> kp.Time == <span class="number">0</span> &#123;</span><br><span class="line">kp.Time = defaultClientKeepaliveTime</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> kp.Timeout == <span class="number">0</span> &#123;</span><br><span class="line">kp.Timeout = defaultClientKeepaliveTimeout</span><br><span class="line">&#125;</span><br><span class="line">keepaliveEnabled := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> kp.Time != infinity &#123;</span><br><span class="line"><span class="keyword">if</span> err = syscall.SetTCPUserTimeout(conn, kp.Timeout); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, connectionErrorf(<span class="literal">false</span>, err, <span class="string">"transport: failed to set TCP_USER_TIMEOUT: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">keepaliveEnabled = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//... </span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> t.keepaliveEnabled &#123;<span class="comment">//如果开启包活</span></span><br><span class="line">t.kpDormancyCond = sync.NewCond(&amp;t.mu)</span><br><span class="line"><span class="keyword">go</span> t.keepalive()</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是在构建链接的时候设置的超时时间 <code>SetTCPUserTimeout</code>，指定发送数据后多久没有收到确认信号就会超时。</p><ul><li>这是设置是设置网络层的，并不会影响gRPC应用层，因为gRPC超时会重试</li><li>并不是所有的操作系统都支持 <code>syscall.SetTCPUserTimeout</code>(可能老的操作系统不支持，Linux、Windows、MacOS都支持)</li></ul><p>如果开启保活，通过开启独立协程发送ping帧确保链接是活的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *http2Client)</span> <span class="title">keepalive</span><span class="params">()</span></span> &#123;</span><br><span class="line">   p := &amp;ping&#123;data: [<span class="number">8</span>]<span class="keyword">byte</span>&#123;&#125;&#125;</span><br><span class="line">   outstandingPing := <span class="literal">false</span> <span class="comment">//是否有等待响应的ping帧</span></span><br><span class="line">   timeoutLeft := time.Duration(<span class="number">0</span>)<span class="comment">//记录发送ping之后剩余时间</span></span><br><span class="line">   prevNano := time.Now().UnixNano() <span class="comment">//记录活动时间</span></span><br><span class="line">   timer := time.NewTimer(t.kp.Time)<span class="comment">//开启定时器</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">         lastRead := atomic.LoadInt64(&amp;t.lastRead)</span><br><span class="line">         <span class="keyword">if</span> lastRead &gt; prevNano &#123;<span class="comment">//自从上次定时器已经读取过了</span></span><br><span class="line">            outstandingPing = <span class="literal">false</span></span><br><span class="line">            <span class="comment">// Next timer should fire at kp.Time seconds from lastRead time.</span></span><br><span class="line">           <span class="comment">//重新计算下次触发定时器时间(从上次读取时间开始算)</span></span><br><span class="line">            timer.Reset(time.Duration(lastRead) + t.kp.Time - time.Duration(time.Now().UnixNano()))</span><br><span class="line">            prevNano = lastRead</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//outstandingPing  有等待响应的ping帧，且已经超时。表示链接超时关闭</span></span><br><span class="line">         <span class="keyword">if</span> outstandingPing &amp;&amp; timeoutLeft &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            t.Close(connectionErrorf(<span class="literal">true</span>, <span class="literal">nil</span>, <span class="string">"keepalive ping failed to receive ACK within timeout"</span>))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         t.mu.Lock()</span><br><span class="line">         <span class="keyword">if</span> t.state == closing &#123;<span class="comment">//如果链接的状态是关闭中，那么也退出</span></span><br><span class="line">            t.mu.Unlock()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//如果没有活动流，且没有活动流不允许发送ping帧</span></span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">len</span>(t.activeStreams) &lt; <span class="number">1</span> &amp;&amp; !t.kp.PermitWithoutStream &#123;</span><br><span class="line">            outstandingPing = <span class="literal">false</span></span><br><span class="line">            t.kpDormant = <span class="literal">true</span></span><br><span class="line">            t.kpDormancyCond.Wait() <span class="comment">//在初始化流或者关闭客户端的时候 会触发 t.kpDormancyCond.Signal()</span></span><br><span class="line">         &#125;</span><br><span class="line">         t.kpDormant = <span class="literal">false</span></span><br><span class="line">         t.mu.Unlock()</span><br><span class="line"></span><br><span class="line">         <span class="comment">//没有等待响应的ping帧，就发送ping帧</span></span><br><span class="line">         <span class="keyword">if</span> !outstandingPing &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            t.controlBuf.put(p)<span class="comment">//发送ping帧</span></span><br><span class="line">            timeoutLeft = t.kp.Timeout</span><br><span class="line">            outstandingPing = <span class="literal">true</span></span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         sleepDuration := minTime(t.kp.Time, timeoutLeft)</span><br><span class="line">         timeoutLeft -= sleepDuration</span><br><span class="line">         timer.Reset(sleepDuration)<span class="comment">//计算定时器下一次触发时间</span></span><br><span class="line">      <span class="keyword">case</span> &lt;-t.ctx.Done():</span><br><span class="line">         <span class="keyword">if</span> !timer.Stop() &#123;</span><br><span class="line">            &lt;-timer.C</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是根据 ping帧的状态以及链接是否有活动来计算发送ping帧时间。</p><p>有几个注意点</p><ol><li><p>如何判断有ping帧响应的</p><p>其实它并没有判断是有有相应帧，而是是否在指定时间内是否读取到消息即可</p></li><li><p>如果没有活动流又不允许非活动流发送ping，那么它是如何处理的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果没有活动流，且没有活动流不允许发送ping帧</span></span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">len</span>(t.activeStreams) &lt; <span class="number">1</span> &amp;&amp; !t.kp.PermitWithoutStream &#123;</span><br><span class="line">    outstandingPing = <span class="literal">false</span></span><br><span class="line">    t.kpDormant = <span class="literal">true</span></span><br><span class="line">    t.kpDormancyCond.Wait() <span class="comment">//在初始化流或者关闭客户端的时候 会触发 t.kpDormancyCond.Signal()</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>而出发 <code>kpDormancyCond.Signal()</code>的位置是 构建流或者关闭连接</p></li></ol><h4 id="服务端-2"><a class="markdownIt-Anchor" href="#服务端-2"></a> 服务端</h4><p>服务端同样也是使用独立协程来运行保活逻辑</p><ol><li>超过 最长闲置时间 <code>MaxConnectionIdle</code> 优雅的关闭连接</li><li>超过 最大连接时间 MaxConnectionAge 优雅的关闭连接</li><li>等待 <code>MaxConnectionAgeGrace</code> 后强制关闭连接。</li><li>以 <code>Time</code> 的频率发送 <code>ping</code> 确保连接存活，并在 <code>Timeout</code> 的额外时间内关闭无响应的连接</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *http2Server)</span> <span class="title">keepalive</span><span class="params">()</span></span> &#123;</span><br><span class="line">   p := &amp;ping&#123;&#125;</span><br><span class="line">   outstandingPing := <span class="literal">false</span> <span class="comment">//是否有等待响应帧</span></span><br><span class="line">   kpTimeoutLeft := time.Duration(<span class="number">0</span>)</span><br><span class="line">   prevNano := time.Now().UnixNano()</span><br><span class="line">   <span class="comment">// Initialize the different timers to their default values.</span></span><br><span class="line">   idleTimer := time.NewTimer(t.kp.MaxConnectionIdle)</span><br><span class="line">   ageTimer := time.NewTimer(t.kp.MaxConnectionAge)</span><br><span class="line">   kpTimer := time.NewTimer(t.kp.Time)</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      idleTimer.Stop()</span><br><span class="line">      ageTimer.Stop()</span><br><span class="line">      kpTimer.Stop()</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-idleTimer.C:<span class="comment">//闲置定时器</span></span><br><span class="line">         t.mu.Lock()</span><br><span class="line">         idle := t.idle</span><br><span class="line">         <span class="keyword">if</span> idle.IsZero() &#123; <span class="comment">//未闲置则重置最大闲置时间</span></span><br><span class="line">            t.mu.Unlock()</span><br><span class="line">            idleTimer.Reset(t.kp.MaxConnectionIdle)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         val := t.kp.MaxConnectionIdle - time.Since(idle)</span><br><span class="line">         t.mu.Unlock()</span><br><span class="line">         <span class="keyword">if</span> val &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            t.Drain()<span class="comment">//优雅关闭连接</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         idleTimer.Reset(val)<span class="comment">//重置闲置连接</span></span><br><span class="line">      <span class="keyword">case</span> &lt;-ageTimer.C:<span class="comment">//最长连接</span></span><br><span class="line">         t.Drain()</span><br><span class="line">         ageTimer.Reset(t.kp.MaxConnectionAgeGrace)</span><br><span class="line">         <span class="keyword">select</span> &#123;</span><br><span class="line">         <span class="keyword">case</span> &lt;-ageTimer.C:</span><br><span class="line">            <span class="comment">// Close the connection after grace period.</span></span><br><span class="line">            <span class="keyword">if</span> logger.V(logLevel) &#123;</span><br><span class="line">               logger.Infof(<span class="string">"transport: closing server transport due to maximum connection age."</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            t.Close()</span><br><span class="line">         <span class="keyword">case</span> &lt;-t.done:</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">case</span> &lt;-kpTimer.C:<span class="comment">//保活定时器</span></span><br><span class="line">         lastRead := atomic.LoadInt64(&amp;t.lastRead)</span><br><span class="line">         <span class="keyword">if</span> lastRead &gt; prevNano &#123;</span><br><span class="line">            <span class="comment">// There has been read activity since the last time we were</span></span><br><span class="line">            <span class="comment">// here. Setup the timer to fire at kp.Time seconds from</span></span><br><span class="line">            <span class="comment">// lastRead time and continue.</span></span><br><span class="line">            outstandingPing = <span class="literal">false</span></span><br><span class="line">            kpTimer.Reset(time.Duration(lastRead) + t.kp.Time - time.Duration(time.Now().UnixNano()))</span><br><span class="line">            prevNano = lastRead</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> outstandingPing &amp;&amp; kpTimeoutLeft &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> logger.V(logLevel) &#123;</span><br><span class="line">               logger.Infof(<span class="string">"transport: closing server transport due to idleness."</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            t.Close()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> !outstandingPing &#123;<span class="comment">//如果没有等待保活则发送保活帧</span></span><br><span class="line">            <span class="keyword">if</span> channelz.IsOn() &#123;</span><br><span class="line">               atomic.AddInt64(&amp;t.czData.kpCount, <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            t.controlBuf.put(p)</span><br><span class="line">            kpTimeoutLeft = t.kp.Timeout</span><br><span class="line">            outstandingPing = <span class="literal">true</span></span><br><span class="line">         &#125;</span><br><span class="line">         sleepDuration := minTime(t.kp.Time, kpTimeoutLeft)</span><br><span class="line">         kpTimeoutLeft -= sleepDuration</span><br><span class="line">         kpTimer.Reset(sleepDuration)</span><br><span class="line">      <span class="keyword">case</span> &lt;-t.done:</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：</p><ol><li><p>连接什么时候闲置的?</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(t.activeStreams) == <span class="number">1</span> &#123;</span><br><span class="line">  t.idle = time.Time&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在处理头帧的时候(构建了一个活跃流)，如果 <code>len(t.activeStreams) == 1</code> ，表示刚新建一个流且仅有一个活跃流，那么这个时候连接是闲置的</p></li><li><p>服务端也会主动发送ping帧</p></li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li><p>TCP与gRPC的区别</p><p>TCP的Keepalive是一种机制，它允许在网络连接空闲时发送探测包（keepalive包）来维护连接的状态。这些探测包不包含有效负载，只是一个空的TCP报文段，主要用于检测连接是否仍然活着。</p><p>当TCP连接上没有传输数据时会进入空闲状态，即使连接已经中断或不可用，导致不必要的延迟和资源浪费。Keepalive机制可以在连接空闲时周期性地发送探测包，以检测连接是否仍然活着。如果远程端点没有响应这些探测包，则可以视为连接已经断开，并且可以关闭连接。</p><p>在gRPC中，使用Keepalive可以检测底层TCP连接是否失效，并在检测到连接问题时及时重新建立连接，从而提高网络连接的可靠性和性能。</p></li><li><p>客户端与服务端都会根据配置向对端发送ping帧，只要在指定时间内读取到帧，那么就不会主动发送ping帧</p></li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://blog.csdn.net/u011582922/article/details/120279303" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/120279303</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习的过程中看到了grpc-go中的两个概念 &lt;strong&gt;保持链接&lt;/strong&gt; 和 &lt;strong&gt;心跳检查&lt;/strong&gt;，这里先学习一下&lt;strong&gt;保持链接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;带着问题看世界&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;保持链接的作用&lt;/l
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-02-平衡器</title>
    <link href="http://xboom.github.io/2022/10/28/Grpc/Grpc-12-%E5%B9%B3%E8%A1%A1%E5%99%A8/"/>
    <id>http://xboom.github.io/2022/10/28/Grpc/Grpc-12-%E5%B9%B3%E8%A1%A1%E5%99%A8/</id>
    <published>2022-10-28T14:58:29.000Z</published>
    <updated>2023-05-27T10:55:56.060Z</updated>
    
    <content type="html"><![CDATA[<p>平衡器的核心目的就是用于向服务端发起链接，主要包括</p><ul><li>子链接的维护，每个 target 可能对应多个地址(类似一个服务有多个副本)，进行子链接的新增与删除</li><li>当平衡器状态发生变化，更新 <code>ClientConn</code> 的状态，自定义选择器，从而让客户端选择具体子链接进行发送</li><li>在满足一定条件的情况下，执行解析器操作。如解析器由阻塞状态 --&gt; 非阻塞状态</li></ul><h4 id="整体流程"><a class="markdownIt-Anchor" href="#整体流程"></a> 整体流程</h4><h4 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h4><p>代码路径:<code>/balancer/balancer.go</code>，在这个文件中一共定义了五个接口</p><ul><li><strong>Builder 接口</strong>，主要用来创建平衡器</li><li><strong>SubConn 接</strong>口，主要用来负责具体的链接(<strong>这里的链接指的是一对实际建立链接的客户端与服务器</strong>)</li><li><strong>Picker 接口</strong>，主要是从众多 <code>SubConn</code>中按照某个策略选择一个链接进行数据传输，也就是 <strong>选择器</strong></li><li><strong>Balancer 接口</strong>，主要是更新 <code>ClientConn</code> 的状态，更新<code>SubConn</code>状态</li><li><strong>ClientConn 接口</strong>，主要是负责链路的维护，包括创建、移除、更新一个子链路，更新 <code>ClientConn</code> 状态</li></ul><p>所以平衡器也跟解析器一样，由两部分组成平衡器构建器与平衡器，内部在封装到一个结构体实现平衡器功能</p><h4 id="平衡器构建器注册"><a class="markdownIt-Anchor" href="#平衡器构建器注册"></a> 平衡器构建器注册</h4><p>平衡器构建器通过注册的方式将自己平衡器的构建方法存入全局变量中，当需要使用的时候则直接根据名称获取</p><ol><li><p>使用一个全局的 map  <code>var m = make(map[string]Builder)</code>进行平衡器构建器 <code>Builder</code> 的存储。k/v 分别对应的是构建 构建器的名称以及构建器的实现方法。</p></li><li><p>平衡器构建器可以通过 <code>Register</code> 函数存储到这个 map 中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Register 注册平衡器构建器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Register</span><span class="params">(b Builder)</span></span> &#123;</span><br><span class="line">m[strings.ToLower(b.Name())] = b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Get 获取平衡器构建器，如果找不到则返回nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Builder</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> b, ok := m[strings.ToLower(name)]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>有了存储与添加，它还增加了一个删除操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//仅做测试使用，去掉某一个平衡器解析器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unregisterForTesting</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(m, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">internal.BalancerUnregister = unregisterForTesting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除操作则是利用 <code>init</code> 给 <code>BalancerUnregister</code> 复制一个 删除函数 <code>unregisterForTesting</code></p></li><li><p>而一个普通的平衡器构建器(已轮询平衡器构建器为例<code>rrPickerBuilder</code>)，则是利用 init 函数直接初始化到这个全局map中，那么就可以在需要使用的时候，直接从全局map 中获取</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Name = <span class="string">"round_robin"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个平衡器构建器对洗那个</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newBuilder</span><span class="params">()</span> <span class="title">balancer</span>.<span class="title">Builder</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> base.NewBalancerBuilder(Name, &amp;rrPickerBuilder&#123;&#125;, base.Config&#123;HealthCheck: <span class="literal">true</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化将 round_robin平衡器构建器存入全局 map 中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">balancer.Register(newBuilder())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="构建平衡器"><a class="markdownIt-Anchor" href="#构建平衡器"></a> 构建平衡器</h4><p>有了平衡器构建器之后，通过选定的平衡器构建器进行平衡器的构建</p><ol><li><p>设置通过哪个平衡器构建器获取平衡器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serviceConfig = <span class="string">`&#123;</span></span><br><span class="line"><span class="string">"loadBalancingConfig": [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">"grpclb": &#123;</span></span><br><span class="line"><span class="string">"childPolicy": [</span></span><br><span class="line"><span class="string">&#123;"round_robin": ""&#125;,</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line">grpc.WithDefaultServiceConfig(serviceConfig)</span><br></pre></td></tr></table></figure><p>如果不设置负载均衡构建器名称，那么grpc-go 会默认使用 <code>round_robin</code> 构建平衡器</p></li><li><p>指定了构建器之后就会在构建链接过程中调用构建函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialContext</span><span class="params">(ctx context.Context, target <span class="keyword">string</span>, opts ...DialOption)</span> <span class="params">(conn *ClientConn, err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//...                                                                                                      </span></span><br><span class="line">    cc.balancerWrapper = newCCBalancerWrapper(cc, balancer.BuildOptions&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在建立连接的过程中，通过</p></li></ol><h4 id="构建链接"><a class="markdownIt-Anchor" href="#构建链接"></a> 构建链接</h4><h4 id="存储链接"><a class="markdownIt-Anchor" href="#存储链接"></a> 存储链接</h4><h4 id="实际应用"><a class="markdownIt-Anchor" href="#实际应用"></a> 实际应用</h4><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://blog.csdn.net/u011582922/article/details/117547171" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/117547171</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平衡器的核心目的就是用于向服务端发起链接，主要包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子链接的维护，每个 target 可能对应多个地址(类似一个服务有多个副本)，进行子链接的新增与删除&lt;/li&gt;
&lt;li&gt;当平衡器状态发生变化，更新 &lt;code&gt;ClientConn&lt;/code&gt; 
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
</feed>
