<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XBoom Dove</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xboom.github.io/"/>
  <updated>2023-06-24T05:27:48.780Z</updated>
  <id>http://xboom.github.io/</id>
  
  <author>
    <name>XBoom Dove</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式事务-05-SAGA</title>
    <link href="http://xboom.github.io/2023/06/21/Distributed%20Transaction/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-05-SAGA/"/>
    <id>http://xboom.github.io/2023/06/21/Distributed%20Transaction/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-05-SAGA/</id>
    <published>2023-06-21T15:27:38.013Z</published>
    <updated>2023-06-24T05:27:48.780Z</updated>
    
    <content type="html"><![CDATA[<p>SAGE核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作</p><blockquote><ol><li>如何实现补偿(提前准备回滚语句)</li><li>dtm 的SAGA模式与Seata的SAGA在设计理念上是不一样的</li></ol></blockquote><h3 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h3><p>已跨行转账的业务为例，转出(<code>TransOut</code>)和转入(<code>TransIn</code>)分别在不同的微服务里，一个成功完成的SAGA事务典型的时序图如下</p><h4 id="成功"><a class="markdownIt-Anchor" href="#成功"></a> 成功</h4><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/saga_normal.a2849672.jpg" alt="saga_normal" style="zoom:50%;" /><h4 id="失败"><a class="markdownIt-Anchor" href="#失败"></a> 失败</h4><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/saga_rollback.8da8593f.jpg" alt="saga_rollback" style="zoom:50%;" /><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">req := &amp;gin.H&#123;<span class="string">"amount"</span>: <span class="number">30</span>&#125; <span class="comment">// 微服务的请求Body</span></span><br><span class="line">saga := dtmcli.NewSaga(DtmServer, shortuuid.New()).</span><br><span class="line">  Add(qsBusi+<span class="string">"/TransOut"</span>, qsBusi+<span class="string">"/TransOutCompensate"</span>, req).</span><br><span class="line">  Add(qsBusi+<span class="string">"/TransIn"</span>, qsBusi+<span class="string">"/TransInCompensate"</span>, req)</span><br><span class="line">err := saga.Submit()</span><br></pre></td></tr></table></figure><ul><li>构建了事务的请求Body</li><li>构建一个事务包含了<ul><li><code>DtmServer</code>为DTM服务的地址</li><li><code>shortuuid.New()</code> 事务请求ID</li><li>添加一个<code>TransOut</code>的子事务，每个事务都包含了<strong>正向操作</strong>与<strong>补偿操作</strong>(逆向操作)<ul><li>正向操作为url: <code>qsBusi+&quot;/TransOut&quot;</code>，</li><li>逆向操作为url: <code>qsBusi+&quot;/TransOutCompensate&quot;</code></li></ul></li><li>添加一个<code>TransIn</code>的子事务<ul><li>正向操作为url: <code>qsBusi+&quot;/TransIn&quot;</code></li><li>逆向操作为url: <code>qsBusi+&quot;/TransInCompensate&quot;</code></li></ul></li></ul></li><li>提交saga事务</li></ul><blockquote><p>问题1：是如何进行补偿的</p><p>问题2：补偿失败是如何处理的</p><p>答：在补偿操作遇见失败时，会不断进行重试，直到成功。(TM重启了怎么办)</p><p>问题3：sage事务是同步返回结果还是异步任务处理的</p><p>问题4：当RM1执行成功，RM2执行失败的同时RM1崩溃了，TM会如何处理</p><p>问题5：当服务崩溃大量事务堆积在TM上，TM如何支持短时间大量事务重试</p></blockquote><h3 id="补偿"><a class="markdownIt-Anchor" href="#补偿"></a> 补偿</h3><p>补偿的情况有几种</p><ol><li>第一种情况，子事务 A - B - C 中 C 失败，需要对 A - B 进行补偿操作，如何保存处理单个分布式事务的子事务顺序补偿问题 B 先回滚，然后是A</li><li>第二种情况，子事务 A - B - C 在执行过程中 A1 - B1 - C1 也在执行，A - B - C 中 C失败，A1 - B1 - C1 中 B1 失败，那么如何处理</li><li>单个服务的补偿分为 已执行 、未执行、执行中(结果未知)，那么补偿又是如何处理的</li></ol><p>补偿执行顺序</p><blockquote><p>DTM 的SAGA事务在1.10.0及之前，补偿操作是并发执行的，1.10.1之后，是根据用户指定的分支顺序，进行回滚的。</p></blockquote><ul><li><p>普通SAGA，未打开并发选项，那么SAGA事务的补偿分支是完全按照正向分支的反向顺序进行补偿的。</p></li><li><p>并发SAGA，补偿分支也会并发执行，补偿分支的执行顺序与指定的正向分支顺序相反。假如并发SAGA指定A分支之后才能执行B，那么进行并发补偿时，DTM保证A的补偿操作在B的补偿操作之后执行</p></li></ul><h3 id="demo"><a class="markdownIt-Anchor" href="#demo"></a> Demo</h3><p>一个用户出行旅游的应用，收到一个用户出行计划，需要预定去三亚的机票，三亚的酒店，返程的机票。要求：</p><ol><li>两张机票和酒店要么都预定成功，要么都回滚（酒店和航空公司提供了相关的回滚接口）</li><li>预订机票和酒店是并发的，避免串行的情况下，因为某一个预定最后确认时间晚，导致其他的预定错过时间</li><li>预定结果的<strong>确认时间可能从1分钟到1天不等</strong></li></ol><p>首先，根据<strong>要求1</strong>创建一个saga事务，这个saga包含三个分支，<code>预定去三亚机票</code>，<code>预定酒店</code>，<code>预定返程机票</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">saga := dtmcli.NewSaga(DtmServer, gid).</span><br><span class="line">Add(Busi+<span class="string">"/BookTicket"</span>, Busi+<span class="string">"/BookTicketRevert"</span>, bookTicketInfo1).</span><br><span class="line">Add(Busi+<span class="string">"/BookHotel"</span>, Busi+<span class="string">"/BookHotelRevert"</span>, bookHotelInfo2).</span><br><span class="line">Add(Busi+<span class="string">"/BookTicket"</span>, Busi+<span class="string">"/BookTicketRevert"</span>, bookTicketBackInfo3)</span><br></pre></td></tr></table></figure><p>接着，根据<strong>要求2</strong>，让saga并发执行（默认是顺序执行）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">saga.EnableConcurrent()</span><br></pre></td></tr></table></figure><p>最后，根据要求3，由于不是即时响应，所以不能够让预定操作等待第三方的结果，而是提交预定请求后，就立即返回状态-进行中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">saga.RetryInterval = <span class="number">60</span></span><br><span class="line">saga.Submit()</span><br><span class="line"><span class="comment">// ........</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bookTicket</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">order := loadOrder()</span><br><span class="line"><span class="keyword">if</span> order == <span class="literal">nil</span> &#123; <span class="comment">// 尚未下单，进行第三方下单操作</span></span><br><span class="line">order = submitTicketOrder()</span><br><span class="line">order.save()</span><br><span class="line">&#125;</span><br><span class="line">order.Query() <span class="comment">// 查询第三方订单状态</span></span><br><span class="line"><span class="keyword">return</span> order.Status <span class="comment">// 成功-SUCCESS 失败-FAILURE 进行中-ONGOING</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>分支事务未完成，dtm会重试我们的事务分支，把重试间隔指定为1分钟，这里订票结果不应当采用指数退避算法重试，否则最终用户不能及时收到通知。在<code>bookTicket</code>中，返回结果ONGOING，当dtm收到这个结果时，会采用固定间隔重试，这样能及时通知到用户</p></blockquote><h4 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h4><p>并发SAGA通过<code>EnableConcurrent()</code>打开，当saga提交后，多个事务分支之间是并发执行。DTM也支持指定事务分支之间的依赖关系，可以指定特定任务A执行完成之后才能够执行任务B</p><p>并发SAGA如果出现回滚，那么所有回滚的补偿操作会全部并发执行，不再考虑前面的任务依赖。</p><p>由于并发SAGA的正向操作和补偿操作都是并发执行的，因此更容易出现空补偿和悬挂情况，需要参考DTM的子事务屏障环节妥善处理</p><h4 id="部分无法回滚"><a class="markdownIt-Anchor" href="#部分无法回滚"></a> 部分无法回滚</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">saga := dtmcli.NewSaga(DtmServer, shortuuid.New()).</span><br><span class="line">Add(Busi+<span class="string">"/CanRollback1"</span>, Busi+<span class="string">"/CanRollback1Revert"</span>, req).</span><br><span class="line">Add(Busi+<span class="string">"/CanRollback2"</span>, Busi+<span class="string">"/CanRollback2Revert"</span>, req).</span><br><span class="line">Add(Busi+<span class="string">"/UnRollback1"</span>, <span class="string">""</span>, req).</span><br><span class="line">Add(Busi+<span class="string">"/UnRollback2"</span>, <span class="string">""</span>, req).</span><br><span class="line">EnableConcurrent().</span><br><span class="line">AddBranchOrder(<span class="number">2</span>, []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;). <span class="comment">// 指定step 2，需要在0，1完成后执行</span></span><br><span class="line">AddBranchOrder(<span class="number">3</span>, []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;) <span class="comment">// 指定step 3，需要在0，1完成后执行</span></span><br></pre></td></tr></table></figure><p>指定Step 2，3 中的 UnRollback 操作，必须在Step 0，1 完成后执行</p><p>这样也能处理 <strong>第一个事务输出是第二个事务的输入怎么办</strong>的问题</p><h4 id="超时回滚"><a class="markdownIt-Anchor" href="#超时回滚"></a> 超时回滚</h4><p>saga属于长事务，因此持续的时间跨度很大，可能是100ms到1天，因此saga没有默认的超时时间。</p><p>dtm支持saga事务单独指定超时时间，到了超时时间，全局事务就会回滚。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">saga.TimeoutToFail = <span class="number">1800</span></span><br></pre></td></tr></table></figure><p>在saga事务中，设置超时时间一定要注意，这类事务里不能够包含无法回滚的事务分支，因为超时回滚时，已执行的无法回滚的分支，数据就是错的</p><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://dtm.pub/practice/saga.html" target="_blank" rel="noopener">https://dtm.pub/practice/saga.html</a></li><li><a href="https://dtm.pub/deploy/maintain.html" target="_blank" rel="noopener">https://dtm.pub/deploy/maintain.html</a></li><li><a href="https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf" target="_blank" rel="noopener">https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SAGE核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;如何实现补偿(提前准备回滚语句)&lt;/li&gt;
&lt;li&gt;dtm 的SAGA模
      
    
    </summary>
    
    
      <category term="Distributed Transaction" scheme="http://xboom.github.io/categories/Distributed-Transaction/"/>
    
    
      <category term="Distributed Transaction" scheme="http://xboom.github.io/tags/Distributed-Transaction/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务-00-前言</title>
    <link href="http://xboom.github.io/2023/06/21/Distributed%20Transaction/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-01-%E5%89%8D%E8%A8%80/"/>
    <id>http://xboom.github.io/2023/06/21/Distributed%20Transaction/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-01-%E5%89%8D%E8%A8%80/</id>
    <published>2023-06-21T15:27:38.012Z</published>
    <updated>2023-06-25T14:26:00.190Z</updated>
    
    <content type="html"><![CDATA[<p>这里开一个新坑就是分布式事务，为了学这一块内容准备这样做</p><ol><li>学习分布式事务前的基本知识</li><li>围绕这些解决方案的实现原理是什么</li><li>不同的解决方案与不同的实现原理进行对比</li><li>看看都有哪些解决方案，以及它们的优缺点</li></ol><h4 id="cap"><a class="markdownIt-Anchor" href="#cap"></a> CAP</h4><p>分布式系统最多只能同时满足<strong>一致性（Consistency）</strong>、<strong>可用性（Availability）<strong>和</strong>分区容错性（Partition tolerance）<strong>这三项中的两项。这被称为</strong>CAP理论</strong></p><ul><li><p><strong>C 一致性(Consistency)</strong>：要求分布式系统中的所有副本或节点在任何时刻都具有相同的数据值。当系统接收到更新请求后，所有节点必须保证在一定时间内达到一致的状态(<strong>强一致性</strong>)</p></li><li><p><strong>A 可用性(Availability)</strong>：要求分布式系统在任何时刻都能够响应用户的请求并提供正常的服务。即使在节点故障或网络分区等情况下，系统仍然能够继续运行并提供服务</p></li><li><p><strong>P 分区容错性(Partition tolerance)</strong>：指系统能够继续运行并保持一致性和可用性，即使在不可避免的网络分区(分布式系统中的消息丢失或延迟)发生时</p></li></ul><p>根据上面三者可以组合的情况有</p><ol><li><strong>CA(一致性和可用性)</strong>：系统追求强一致性和高可用性，但在发生网络分区时，系统会停止对外服务，直到分区问题解决。关系型数据库通常采用这种方案。</li><li><strong>AP(可用性和分区容错性)</strong>：系统追求高可用性和分区容错性，即使发生网络分区，系统仍然可以继续运行，但可能导致数据的一致性问题。例如，大规模分布式系统如互联网应用中的NoSQL数据库常采用这种方案。</li><li><strong>CP(一致性和分区容错性)</strong>：在这种方案中，系统追求强一致性和分区容错性，但在发生网络分区时，可能会牺牲可用性。这意味着系统可能在网络分区期间无法提供服务。例如，一些分布式数据库系统采用这种方案。</li></ol><blockquote><ol><li>CAP的一致性指的是<strong>强一致性</strong></li><li>CAP中分布式事务的一致性是多个节点状态的一致性，而ACID中事务的一致性指的是DB的约束定义的前后一致性</li><li>根据 CAP 各个的描述可以得出系统三者不可能同时满足，需要在系统设计时根据情况舍弃</li></ol></blockquote><h4 id="base"><a class="markdownIt-Anchor" href="#base"></a> BASE</h4><p>BASE是<strong>Basically Available（基本可用）</strong>、**Soft state（软状态）<strong>和</strong>Eventually consistent（最终一致性）**三个短语的简写，BASE是基于CAP定理逐步演化而来，对CAP中一致性和可用性权衡的结果，核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性(Eventual consistency)</p><ul><li><strong>Basically Available(基本可用):</strong> 指分布式系统在出现不可预知故障的时候，允许损失部分可用性(系统仍然可用)</li><li><strong>Soft state(软状态):</strong> 弱状态也称为软状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</li><li><strong>Eventually consistent(最终一致性):</strong> 强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性</li></ul><p>BASE理论提出通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。</p><p>分布式的理论基础是CAP，分布式系统中，P(分区容错)是必选项，所以只能在AP或者CP中选择。</p><ul><li><p><strong>分布式理论的CP</strong> -&gt; 刚性事务，遵循ACID，对数据要求强一致性</p></li><li><p><strong>分布式理论的AP+BASE</strong> -&gt; 柔性事务，遵循BASE，允许一定时间内不同节点的数据不一致，但要求最终一致</p></li></ul><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/arch-z-transection-1.png" alt="img" style="zoom:67%;" /><p><strong>刚性事务</strong>基于分布式理论的CP，遵循ACID，对数据要求强一致性。包括 2PC、3PC</p><p><strong>柔性事务</strong>基于分布式理论的AP，遵循BASE，允许一定时间内不同节点的数据不一致，但要求最终一致。它们又可以分为两种</p><ol><li>基于补偿的有 TCC 与 SAGA</li><li>基于最终一致性的有 本地消息、事务消息、尽最大努力通知</li></ol><p>整体分布式事务实现原理根据资源在分布式事务的角色可以分为：</p><ol><li><p><strong>AP 应用程序处理器</strong>，一般是发起分布式事务的一方</p></li><li><p><strong>RM 资源管理器</strong>，负责管理和控制分布式系统中的特定资源或数据库。资源管理器协调事务的执行，包括处理事务的提交和回滚，以及确保数据的一致性和完整性。</p></li><li><p><strong>TM 事务管理器</strong>，负责协调和管理分布式事务的执行。事务管理器协调不同资源管理器的操作，以确保所有参与的资源在事务提交或回滚时保持一致性，并提供事务的ACID</p></li><li><p><strong>TC 事务协调者</strong>，维护全局和分支事务的状态，驱动全局事务提交或回滚(Seata 引入)</p></li></ol><p>根据分布式事务的组成分为</p><ul><li><p><strong>事务分支</strong>：每个服务管理的事务组成部分，称为事务分支，<code>RM</code> 服务会在全局事务上，注册一个事务分支</p></li><li><p><strong>分支操作</strong>：对于<code>RM</code>服务，在<code>TCC</code>事务模式下，会实现<code>Try/Confirm/Cancel</code>三个操作，多个分支操作配合完成一个分支事务</p></li><li><p><strong>本地事务</strong>：<code>RM</code> 服务可能访问一个数据库，创建一个本地事务，也可能访问多个数据库，创建多个本地事务</p></li></ul><p>找了一下分布式事务的实现方案，发现两种 DTM 与 SEATA</p><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">DTM</th><th style="text-align:center">SEATA</th></tr></thead><tbody><tr><td style="text-align:center">语言</td><td style="text-align:center">Go、Java、python、php、c#…</td><td style="text-align:center">Java、Go、Python</td></tr><tr><td style="text-align:center">异常处理</td><td style="text-align:center">子事务屏障自动处理</td><td style="text-align:center">手动处理</td></tr><tr><td style="text-align:center">TCC事务</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center">XA事务</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center">AT事务</td><td style="text-align:center">建议使用XA</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center">SAGA事务</td><td style="text-align:center">支持并发</td><td style="text-align:center">状态机模式</td></tr><tr><td style="text-align:center">二阶段消息</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center">单服务多数据源</td><td style="text-align:center">✓</td><td style="text-align:center">✗</td></tr><tr><td style="text-align:center">通信协议</td><td style="text-align:center">HTTP、gRPC</td><td style="text-align:center">dubbo、gRPC</td></tr><tr><td style="text-align:center">仓库</td><td style="text-align:center"><a href="https://github.com/dtm-labs/dtm.git" target="_blank" rel="noopener">https://github.com/dtm-labs/dtm.git</a></td><td style="text-align:center"><a href="https://github.com/seata/seata.git" target="_blank" rel="noopener">https://github.com/seata/seata.git</a></td></tr></tbody></table><p>接下来异常介绍几种分布式事务的实现原理、优缺点以及适用场景</p><ol><li>二阶段提交</li><li>三阶段提交</li><li>TCC</li><li>SAGA</li><li>AT</li><li>通知型事务</li><li>二阶段消息(DTM)</li><li>异常处理优化(DTM)</li><li>Percolator</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://dtm.pub/guide/theory.html#%E4%BA%8B%E5%8A%A1" target="_blank" rel="noopener">https://dtm.pub/guide/theory.html#事务</a></li><li><a href="https://blog.csdn.net/yeyazhishang/article/details/80758354" target="_blank" rel="noopener">https://blog.csdn.net/yeyazhishang/article/details/80758354</a></li><li><a href="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/" target="_blank" rel="noopener">https://xiaomi-info.github.io/2020/01/02/distributed-transaction/</a></li><li><a href="https://segmentfault.com/a/1190000040321750" target="_blank" rel="noopener">https://segmentfault.com/a/1190000040321750</a></li><li><a href="http://seata.io/zh-cn/docs/overview/what-is-seata.html" target="_blank" rel="noopener">http://seata.io/zh-cn/docs/overview/what-is-seata.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里开一个新坑就是分布式事务，为了学这一块内容准备这样做&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;学习分布式事务前的基本知识&lt;/li&gt;
&lt;li&gt;围绕这些解决方案的实现原理是什么&lt;/li&gt;
&lt;li&gt;不同的解决方案与不同的实现原理进行对比&lt;/li&gt;
&lt;li&gt;看看都有哪些解决方案，以及它们的优
      
    
    </summary>
    
    
      <category term="Distributed Transaction" scheme="http://xboom.github.io/categories/Distributed-Transaction/"/>
    
    
      <category term="Distributed Transaction" scheme="http://xboom.github.io/tags/Distributed-Transaction/"/>
    
  </entry>
  
  <entry>
    <title>Go入门15-SyncMap</title>
    <link href="http://xboom.github.io/2023/04/04/Go/Go%E5%85%A5%E9%97%A815-SyncMap/"/>
    <id>http://xboom.github.io/2023/04/04/Go/Go%E5%85%A5%E9%97%A815-SyncMap/</id>
    <published>2023-04-04T13:01:05.349Z</published>
    <updated>2023-05-31T16:01:10.769Z</updated>
    
    <content type="html"><![CDATA[<p>一开始以为 <code>Sync.Map</code> 仅仅是封装的了一层，后来在与同事的讨论中发现并不是这样，这里重新学习一下源码</p><h3 id="线程安全"><a class="markdownIt-Anchor" href="#线程安全"></a> 线程安全</h3><p>首先搞清楚一个问题，什么是并发安全。由于没有完整的解释，我找了一段Java中的表达</p><blockquote><p>当多个线程访问某个类时，不管运行环境采用何种调度方式或者这些进程将如何交替执行，并且在主调代码中不需要任何额外的协同或者同步，这个类都能表现出正确的行为，那么这个类是线程安全的</p></blockquote><p>大致抓住两点 <strong>无论如何交替执行</strong> <strong>表现出正确的行为</strong>，有点抽象，反过来问 <strong>什么情况会导致线程不安全</strong>？<strong>怎样才能保证线程安全？</strong></p><p><u>当前的一个操作可能不是原子的，执行过程中会被打断，其他线程有能力修改共享变量的值，同时存在线程修改的值不是立即对其他线程可见的，因为线程有自己的执行空间，另外一点就是存在程序可能存在乱序执行的情况，单线程没问题，但是多个线程同时执行，线程共享的数据会出现错乱</u>。那么保证线程安全的三个特征：</p><ul><li><strong>原子性</strong>：提供互斥访问、同一时刻只能有一个线程在操作</li><li><strong>可见性</strong>：一个线程对主内容的修改可以及时被其他线程看到</li><li><strong>有序性</strong>：程序在执行的时候，程序的代码执行顺序和语句的顺序是一致的有序性<ul><li>多个协程并发执行，那么<strong>几个协程之间是没有有序性的</strong>，但是协程里面的代码是有序的</li><li>什么情况下代码的执行顺序与语句顺序不一致？比如指令重排序，将多次访问主存合并到一起执行</li></ul></li></ul><p>这样就好理解为啥普通的map会存在并发安全问题了，因为一个协程的修改对于另外一个协程可能是不可见的。另外当map并发读写时候触发的panic是map内部实现的，结构体的并发读写只会报错不会panic。</p><h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3><p>普通的map并发处理实践</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="keyword">struct</span>&#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>sync.Map</code> 则可以</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter sync.Map</span><br></pre></td></tr></table></figure><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>源码：<code>src/sync/map.go</code></p><p>为了实现并发安全的Map，<code>Sync.Map</code>实现了一种读写分离的方式</p><ol><li>空间换时间。 通过冗余的两个数据结构(read、dirty),实现加锁对性能的影响。</li><li>动态调整，miss次数多了之后，将dirty数据提升为read。</li><li>double-checking，因为是判断与获取并不是原子操作，所以会出现 double-checking</li><li>延迟删除。 删除一个键值只是打标记，只有在提升dirty的时候才清理删除的数据。</li><li>优先从read读取、更新、删除，因为对read的读取不需要锁。</li></ol><p><strong>问题1</strong>：如何在并发情况下修改或删除已经存在的Key？</p><p>答：通过将 key 映射到 val 的地址，然后 val 指针指向真正的值，那么只需要保证 <code>address</code> 指针的原子操作，就能解决并发安全问题</p><blockquote><p>key -&gt; &amp;地址 --&gt; 真正的值</p></blockquote><p><strong>问题2</strong>：如何在写的同时保证读的准确性</p><p>答：读写指向的是同一个指针，首先在写时会通过互斥锁防止并发操作 <code>dirty</code>，其次就是用到了<code>atomic</code>原子操作<code>value</code>指针</p><p><strong>问题3</strong>：如果读写分离，如何将写入的数据同步到读中</p><p>答： 1. 第一种是当<code>misses == len(dirty)</code>的时候就会升级<code>dirty</code>到<code>read</code>中；第二种就是在遍历的如果<code>dirty</code>有<code>read</code>中没有的数据；</p><p>第三其实也不是读写分离，而是乐观锁，因为如果<code>read</code>中已经有key/val，也会尝试去更新<code>read</code>，发现已经删除，则去dirty中更新</p><p>最后的实现就变成了下面这个样子</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/20200505120255.png" alt="sync.map 整体结构" style="zoom:50%;" /><p><strong>问题4</strong>：指向的是同一个<code>entry</code>，不还是一样需要加锁吗？内部 的<code>mutex</code> 与 <code>atomic.pointer</code>的区别跟作用又是什么？</p><p><code>mutex</code> 与 <code>atomic</code> 的区别是：<code>mutex</code> 通过阻塞其他协程起到了原子操作的功能，是用来保护 dirty 的读写的。而<code>atomic</code>是通过CPU指令，来达到值操作的原子性，所以 <code>atomic</code>与<code>mutex</code>并不是一个层面的东西，<code>atomic</code>也比<code>mutex</code>更快。</p><p>所以才会出现 <code>mutex</code> 保护的是 <code>dirty</code>，而 <code>atomic</code> 保护的是 <code>entry</code> 具体值</p><h4 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h4><p>定义的 <code>Map</code> 中 除普通的map 与 互斥锁，还增加了两个字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">//当涉及到dirty的操作的时候，需要使用这个锁</span></span><br><span class="line">   mu Mutex</span><br><span class="line">  <span class="comment">// 一个只读结构(实际也会更新这个数据的entries，标记为未删除的unexpunger)</span></span><br><span class="line">   read atomic.Pointer[readOnly]</span><br><span class="line">  <span class="comment">// dirty包含最新的entries(包括read中未删除的数据,虽有冗余，但也提升dirty字段为read的时候非常快，不用一个一个的复制，而是直接将这个数据结构作为read字段的一部分),有些数据还可能没有移动到read字段中。</span></span><br><span class="line"><span class="comment">// 对于dirty的操作需要加锁，因为对它的操作可能会有读写竞争。</span></span><br><span class="line"><span class="comment">// 当dirty为空的时候， 比如初始化或者刚提升完，下一次的写操作会复制read字段中未删除的数据到这个数据中。</span></span><br><span class="line">   dirty <span class="keyword">map</span>[any]*entry</span><br><span class="line">  <span class="comment">// 当从Map中读取entry的时候，如果read中不包含这个entry,会尝试从dirty中读取，这个时候会将misses加一，</span></span><br><span class="line"><span class="comment">// 当misses累积到 dirty的长度的时候， 就会将dirty提升为read,避免从dirty中miss太多次。因为操作dirty需要加锁</span></span><br><span class="line">   misses <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中存在两个结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">m       <span class="keyword">map</span>[any]*entry</span><br><span class="line">amended <span class="keyword">bool</span> <span class="comment">// 为true 表示dirty中存在一些新增的键值对</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基本"><a class="markdownIt-Anchor" href="#基本"></a> 基本</h4><ol><li><code>read</code> 与 <code>dirty</code> 的转换</li><li><code>entry</code>的操作</li></ol><h5 id="entry"><a class="markdownIt-Anchor" href="#entry"></a> entry</h5><p><code>entry</code> 代表的是每个 key 在<code>Map</code>中对应的一个 <code>entry</code>，并且还记录了 <strong>其他信息</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">p atomic.Pointer[any]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> expunged = <span class="built_in">new</span>(any) <span class="comment">//</span></span><br></pre></td></tr></table></figure><p><code>p</code> 一共记录林 <code>entry</code> 的三种状态</p><ol><li><code>nil</code>: <code>entry</code>已被删除了，并且<code>m.dirty</code>为<code>nil</code></li><li><code>expunged</code>: <code>entry</code>已被删除了，并且<code>m.dirty</code>不为<code>nil</code>，而且这个<code>entry</code>不存在于<code>m.dirty</code>中</li><li>其它： <code>entry</code>是一个正常的值</li></ol><p>构建一个 <code>entry</code> 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newEntry</span><span class="params">(i any)</span> *<span class="title">entry</span></span> &#123;</span><br><span class="line">   e := &amp;entry&#123;&#125;</span><br><span class="line">   e.p.Store(&amp;i)</span><br><span class="line">   <span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">load</span><span class="params">()</span> <span class="params">(value any, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">p := e.p.Load()</span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;<span class="comment">//表示不存在</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *p, <span class="literal">true</span><span class="comment">//表示存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>entry</code> 使用 <code>atomic.Pointer[n]</code> 的作用在后面才体现出来, <code>atomic.Pointer</code> 原子地读取和存储指针类型的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">trySwap</span><span class="params">(i *any)</span> <span class="params">(*any, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      p := e.p.Load()</span><br><span class="line">      <span class="keyword">if</span> p == expunged &#123;<span class="comment">//如果已经被删除则返回false</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> e.p.CompareAndSwap(p, i) &#123;<span class="comment">//否则不断的CAS更新</span></span><br><span class="line">         <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h4><p>操作与正常的map类似，包含 存储、获取、删除、遍历。除此之外还增加的 交换、比较交换、比较删除</p><h5 id="获取"><a class="markdownIt-Anchor" href="#获取"></a> 获取</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Load</span><span class="params">(key any)</span> <span class="params">(value any, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1.首先从m.read中得到只读readOnly,从它的map中查找，不需要加锁</span></span><br><span class="line">  read := m.loadReadOnly()</span><br><span class="line">e, ok := read.m[key]</span><br><span class="line">  <span class="comment">//2. 如果没找到，并且m.dirty中有新数据，需要从m.dirty查找，这个时候需要加锁</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123; <span class="comment">// a 操作</span></span><br><span class="line">m.mu.Lock()  <span class="comment">//b 操作</span></span><br><span class="line">    <span class="comment">//双检查，避免加锁的时候m.dirty提升为m.read,这个时候m.read可能被替换了。</span></span><br><span class="line">read = m.loadReadOnly()</span><br><span class="line">e, ok = read.m[key]</span><br><span class="line">    <span class="comment">// 如果m.read中还是不存在，并且m.dirty中有新数据</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">      <span class="comment">// 从m.dirty查找</span></span><br><span class="line">e, ok = m.dirty[key]</span><br><span class="line">      <span class="comment">// 不管m.dirty中存不存在，都将misses计数加一</span></span><br><span class="line"><span class="comment">// missLocked()中满足条件后就会提升m.dirty</span></span><br><span class="line">m.missLocked()</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个注意事项</p><ol><li><p>出现double-check，是因为在执行 <code>if !ok &amp;&amp; read.amended</code> 的过程中，dirty可能升级为read，所以还是需要锁操作</p></li><li><p>不管 m.dirty中是否存在，都需要misses+1，表明 read中不存在才到 dirty中获取</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">missLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">m.misses++</span><br><span class="line"><span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">m.read.Store(&amp;readOnly&#123;m: m.dirty&#125;)<span class="comment">//直接将dirty升级到read中，然后</span></span><br><span class="line">m.dirty = <span class="literal">nil</span></span><br><span class="line">m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>什么时候讲dirty提升为 read，当 <code>misses &gt;= len(m.dirty)</code></p><h5 id="存储"><a class="markdownIt-Anchor" href="#存储"></a> 存储</h5><p>从接口实现可以看出，存储 k/v 内部使用的其实 Swap 接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Store</span><span class="params">(key, value any)</span></span> &#123;</span><br><span class="line">   _, _ = m.Swap(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接查看 <code>Swap</code> 的实现原理</p><p>根据描述，<code>Swap</code> 的作用是 将 <code>newValue</code> 更新入 <code>key</code> 所对应的 <code>value</code>中，并将 <code>oldValue</code> 返回。另外一个返回值<code>loaded</code>表示 <code>key</code> 是否存在</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Swap</span><span class="params">(key, value any)</span> <span class="params">(previous any, loaded <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 如果m.read存在这个键，并且这个entry没有被标记删除，尝试直接存储。</span></span><br><span class="line"><span class="comment">// 因为m.dirty也指向这个entry,所以m.dirty也保持最新的entry。</span></span><br><span class="line">   read := m.loadReadOnly()</span><br><span class="line">   <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;<span class="comment">//如果只读存在</span></span><br><span class="line">      <span class="keyword">if</span> v, ok := e.trySwap(&amp;value); ok &#123;<span class="comment">//尝试去更新value，如果未 标记删除</span></span><br><span class="line">         <span class="keyword">if</span> v == <span class="literal">nil</span> &#123;<span class="comment">//value为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> *v, <span class="literal">true</span><span class="comment">//更新成功 返回 true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   m.mu.Lock()<span class="comment">// 加锁，如果`m.read`不存在或者已经被标记删除</span></span><br><span class="line">   read = m.loadReadOnly()</span><br><span class="line">   <span class="keyword">if</span> e, ok := read.m[key]; ok &#123; <span class="comment">//只读存在</span></span><br><span class="line">     <span class="keyword">if</span> e.unexpungeLocked() &#123;<span class="comment">//如果未标记删除则删除read,然后存入dirty(写数据到dirty中)</span></span><br><span class="line">         m.dirty[key] = e<span class="comment">//存入 dirty</span></span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">if</span> v := e.swapLocked(&amp;value); v != <span class="literal">nil</span> &#123;<span class="comment">//未标记删除则直接更新read</span></span><br><span class="line">         loaded = <span class="literal">true</span></span><br><span class="line">         previous = *v</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;<span class="comment">//只读不存在但是dirty存在</span></span><br><span class="line">      <span class="keyword">if</span> v := e.swapLocked(&amp;value); v != <span class="literal">nil</span> &#123;</span><br><span class="line">         loaded = <span class="literal">true</span></span><br><span class="line">         previous = *v</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;<span class="comment">//都不存在</span></span><br><span class="line">      <span class="keyword">if</span> !read.amended &#123;<span class="comment">//dirty中没有新值</span></span><br><span class="line">         m.dirtyLocked()<span class="comment">//如果dirty为空，从 m.read中复制未删除的数据</span></span><br><span class="line">         m.read.Store(&amp;readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;) <span class="comment">//read中存储</span></span><br><span class="line">      &#125;</span><br><span class="line">      m.dirty[key] = newEntry(value)<span class="comment">//dirty 存储一个新的 value地址</span></span><br><span class="line">   &#125;</span><br><span class="line">   m.mu.Unlock()</span><br><span class="line">   <span class="keyword">return</span> previous, loaded</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>dirtyLocked的</code>作用是将未删除的复制到<code>dirty</code>中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">dirtyLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;<span class="comment">//如果不为空直接返回</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   read := m.loadReadOnly()</span><br><span class="line">   m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[any]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line">   <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">      <span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">         m.dirty[k] = e</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">tryExpungeLocked</span><span class="params">()</span> <span class="params">(isExpunged <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   p := e.p.Load()<span class="comment">//加载entry中的地址</span></span><br><span class="line">   <span class="keyword">for</span> p == <span class="literal">nil</span> &#123;<span class="comment">//如果为空</span></span><br><span class="line">      <span class="keyword">if</span> e.p.CompareAndSwap(<span class="literal">nil</span>, expunged) &#123;<span class="comment">//尝试使用 expunged更新状态</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      p = e.p.Load()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> p == expunged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Delete</span><span class="params">(key any)</span></span> &#123;</span><br><span class="line">m.LoadAndDelete(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">LoadAndDelete</span><span class="params">(key any)</span> <span class="params">(value any, loaded <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//先从read中加载</span></span><br><span class="line">read := m.loadReadOnly()</span><br><span class="line">e, ok := read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;<span class="comment">//read没有且dirty中有新数据</span></span><br><span class="line">    <span class="comment">//开启锁</span></span><br><span class="line">m.mu.Lock()</span><br><span class="line">read = m.loadReadOnly()</span><br><span class="line">e, ok = read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;<span class="comment">//如果read没有，则dirty中有新数据</span></span><br><span class="line">e, ok = m.dirty[key]</span><br><span class="line"><span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">      m.missLocked()<span class="comment">//当misses数量达到 len(m.dirty),dirty升级为read</span></span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">return</span> e.<span class="built_in">delete</span>()<span class="comment">//如果read存在则标记删除</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果read中存在，那么仅会标记删除</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">delete</span><span class="params">()</span> <span class="params">(value any, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      p := e.p.Load()</span><br><span class="line">      <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;<span class="comment">//如果为空或者标记删除，返回没有数据</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> e.p.CompareAndSwap(p, <span class="literal">nil</span>) &#123;<span class="comment">//标记为nil，并不会直接删除</span></span><br><span class="line">         <span class="keyword">return</span> *p, <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遍历"><a class="markdownIt-Anchor" href="#遍历"></a> 遍历</h5><p>因为是读写分离，所以在遍历的过程中</p><ol><li>如果dirty中没有新数据，那么就使用read遍历</li><li>如果dirty中有新数据，那么就将dirty升级为read，然后遍历read</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Range</span><span class="params">(f <span class="keyword">func</span>(key, value any)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">   <span class="comment">//判断dirty是否有新值</span></span><br><span class="line">   read := m.loadReadOnly()</span><br><span class="line">   <span class="keyword">if</span> read.amended &#123;</span><br><span class="line">      m.mu.Lock()<span class="comment">//开锁</span></span><br><span class="line">      read = m.loadReadOnly()</span><br><span class="line">      <span class="keyword">if</span> read.amended &#123;<span class="comment">//dirty是否有新值</span></span><br><span class="line">         read = readOnly&#123;m: m.dirty&#125;</span><br><span class="line">         m.read.Store(&amp;read)<span class="comment">//升级dirty为read</span></span><br><span class="line">         m.dirty = <span class="literal">nil</span></span><br><span class="line">         m.misses = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">      m.mu.Unlock()</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//遍历read</span></span><br><span class="line">   <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">      v, ok := e.load()</span><br><span class="line">      <span class="keyword">if</span> !ok &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> !f(k, v) &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3><ol><li><p>该map仅针对特定的场景</p><ul><li>Key 读多写少的情况，例如只增长的缓存</li><li>多个协程针对不同的key合集进行读写更新时候可以用</li><li>sync.Map 不能在第一次使用后复制</li></ul></li><li><p>由于dirty达到一定条件就需要升级为read，所以适用读多写少的场景</p></li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://www.cnblogs.com/qcrao-2018/p/12833787.html" target="_blank" rel="noopener">https://www.cnblogs.com/qcrao-2018/p/12833787.html</a></li><li><a href="https://colobu.com/2017/07/11/dive-into-sync-Map/#sync-Map%E7%9A%84%E6%80%A7%E8%83%BD" target="_blank" rel="noopener">https://colobu.com/2017/07/11/dive-into-sync-Map/#sync-Map的性能</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一开始以为 &lt;code&gt;Sync.Map&lt;/code&gt; 仅仅是封装的了一层，后来在与同事的讨论中发现并不是这样，这里重新学习一下源码&lt;/p&gt;
&lt;h3 id=&quot;线程安全&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线程安全&quot;&gt;&lt;/a&gt; 线程安全&lt;
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go入门24-协程池问题</title>
    <link href="http://xboom.github.io/2023/03/05/Go/Go%E5%85%A5%E9%97%A824-%E5%8D%8F%E7%A8%8B%E6%B1%A0%E9%97%AE%E9%A2%98/"/>
    <id>http://xboom.github.io/2023/03/05/Go/Go%E5%85%A5%E9%97%A824-%E5%8D%8F%E7%A8%8B%E6%B1%A0%E9%97%AE%E9%A2%98/</id>
    <published>2023-03-05T06:46:45.000Z</published>
    <updated>2023-04-05T04:17:47.389Z</updated>
    
    <content type="html"><![CDATA[<p>之前在整理 <a href="https://www.yuankang.top/2022/07/06/GoZero/GoZero4-%E5%8D%8F%E7%A8%8B%E6%B1%A01/" target="_blank" rel="noopener">GoZero4-协程池</a>的过程中发现 <a href="https://github.com/bytedance/gopkg/tree/develop/util/gopool" target="_blank" rel="noopener">字节跳动开源的协程池</a>在使用中需要注意的地方：</p><p>​<strong>使用双向链表存储任务，表示它理论上支持无限个任务。后面的任务可能存在长时间等待的情况，并不存在任务过期处理逻辑</strong></p><p>没想到在实际应用中真的没注意踩了一遍，这里记录一下这个原因与后续的解决思路，排查过程就不赘述了。</p><p>伪代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Send</span><span class="params">(conn *grpc.ClientConn)</span></span> &#123;</span><br><span class="line">c := pb.NewGreeterClient(conn)</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">3</span>*time.Second)</span><br><span class="line"></span><br><span class="line">gopool.CtxGo(ctx, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="comment">//1. 通信消息自定义处理</span></span><br><span class="line">Handle(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 发送消息</span></span><br><span class="line">_, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: *name&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"could not greet: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="comment">//log.Printf("end success")</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">5</span>):</span><br><span class="line">log.Printf(<span class="string">"time out"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题原因</strong>：负责底层通信的 grpc-go(进行过二次开发) 使用了上述的协程池进行发送接口的超时控制。当突然大量的消息进入，消息接受速率 大于 消息发送-响应速率。导致过量的消息全部堆积到这个双向链表中，而本身消息是有超时时间的，就导致堆积的消息越来越多，消息等到发送的时候已经超时了，所以就出现了服务OOM，消息也无法发送出去。</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/%E5%8D%8F%E7%A8%8B%E6%B1%A0%E9%97%AE%E9%A2%982.png" alt="协程池问题2" style="zoom:50%;" /><p>类似上图所示，模拟客户端通过协程池的发送协程 <strong>work</strong> 实现超时控制消息任务 <strong>t</strong> 的发送</p><ul><li>第一阶段，发送协程 <strong>work</strong> 的消费速率 大于 消息任务 <strong>t</strong> 的生产速率，一切正常</li><li>第二阶段，发送协程 <strong>work</strong> 的消费速率 小于 消息任务 <strong>t</strong> 的生产速率的时候，消息开始在双向链表中堆积，出现内存快速增长</li><li>第三阶段，当 消息任务 <strong>t</strong> 的堆积 超过自定义超时时间的时候，所有消息都发送超时失败</li><li>第四阶段，当 双向链表中的任务堆积导致内存超时服务上限的时候，服务OOM</li></ul><p>这里产生了如下几个思考</p><ol><li>能否在任务双向链表中限制数量大小当发送超过限制的时候直接失败?</li><li>为什么不直接使用管道来代替底层的双向链表？</li><li>能否自动丢弃超时的消息并返回结果，注意这个时候是在协程里面运行的</li><li>如何像linux一样保存 pod因为OOM而产生的core方便后续分析</li></ol><p>第一个问题是可以解决的，协程池对象存在 taskCount 记录当前任务数量，也就是说可以增加协程池容量判断来达到限制目的</p><ul><li>增加协程池任务容量字段 <code>taskCap</code></li><li>增加接口，协程失败返回错误 error</li><li>添加协程池容量判断</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pool)</span> <span class="title">CtxGo2</span><span class="params">(ctx context.Context, f <span class="keyword">func</span>()</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">  cur := atomic.AddInt32(&amp;p.taskCount, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> cur &gt; p.taskCap &#123;<span class="comment">//当前任务容量判断</span></span><br><span class="line"><span class="keyword">return</span> errors.New</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个问题管道的缺点是管道数量是固定的，也就是达不到根据任务数量动态扩容 <code>work</code> 的功效</p><p>第三个问题由于任务放入协程中相当于异步处理，并不能直接将任务待执行超时的情况返回给客户端，可以通过自定义处理函数或者内部的panic处理任务超时的情况；但又能如何发现任务超时，时间轮貌似是个好东西</p><p>第四个问题找到<a href="https://juejin.cn/post/6844903792136159239" target="_blank" rel="noopener">一篇实践</a>，实操之后再单独记录</p><p>总结：</p><ol><li>我在使用过程中忽视了双向队列任务堆积的情况，令牌桶的使用也可能存在这样的情况(正常情况不会配置速率上千万的情况)，注意异常情况下的配置范围</li><li>上述需要改进与实操的部分尝试解决之后再来补充这边文章</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在整理 &lt;a href=&quot;https://www.yuankang.top/2022/07/06/GoZero/GoZero4-%E5%8D%8F%E7%A8%8B%E6%B1%A01/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GoZero4-协
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>算法-E10C-最大公约数</title>
    <link href="http://xboom.github.io/2023/02/02/Algorithms%20To%20Live%20By/%E7%AE%97%E6%B3%95-E10C-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"/>
    <id>http://xboom.github.io/2023/02/02/Algorithms%20To%20Live%20By/%E7%AE%97%E6%B3%95-E10C-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</id>
    <published>2023-02-02T12:25:25.494Z</published>
    <updated>2023-02-15T13:39:32.337Z</updated>
    
    <content type="html"><![CDATA[<p>今天碰到一道有意思的题目，学到了很多东西，所以记录一下</p><p><a href="https://leetcode.cn/problems/check-if-it-is-a-good-array/" target="_blank" rel="noopener">检查好数组</a></p><p>碰到之后完全不知道如何入手，最后通过看解答才弄明白，但是中间有很多知识点可以记录一下</p><p><strong>首先</strong> 需要知道裴蜀定理，又称贝祖定理，是一个最大公约数定理：设 a, b 是不全为零的整数，则存在整数 x , y , 使得</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ax + by = gcd(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span></p><ol><li><p>若任何一个等于0，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">gcd(a, b) == a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span></p></li><li><p>对任何整数a、b和它们的最大公约数d，关于未知数x和y的线性丢番图方程</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">ax + by = m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span></span></p><p>有解当前仅当 m 是 d 的倍数</p></li></ol><blockquote><p>这里有一个奇特的点 0 因为没有因数，所以 0 不与其他数存在最大公约数，等我看了 类欧几里德算法 再补充</p></blockquote><p>所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ax + by = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 有解，那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(a, b) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><p>其次 我们如何求一个两个数的最大公约数，经典的 <strong>辗转相除法</strong>(又称 <strong>欧几里德算法</strong>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以使用现有函数 gcd(a, b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b ? GCD(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>证明 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a, b) = gcd(b, a \% b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 过程如下</p><ol><li><p>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi><mi>k</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a = bk + c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>，所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">c = a \% b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span></span></span></span></p></li><li><p>设 d 是 a , b 的公约数</p></li><li><p>所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>=</mo><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>∗</mo><mi>k</mi><mo>+</mo><mi>c</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">a / d = b / d * k + c / d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span></p></li><li><p>因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">a / d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">b / d * k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 是整数，所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">c / d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span> 也是整数</p></li><li><p>将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">c = a \% b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span></span></span></span> 带入第3步得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>−</mo><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>∗</mo><mi>k</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">a / d - b / d * k = a \% b / d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span>，因为 左边是整数，所有等式右边也是整数</p></li><li><p>那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>+</mo><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">a / d = a \% b / d + b / d * k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，那么 d 也是  b, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">a \% b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span></span></span></span> 的约数，也是 a, b 的约数</p></li><li><p>尽然两式的公约数是相同的，那么最大公约数也会相同</p></li><li><p>所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a, b) = gcd(b, a mod b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p></li></ol><p>最后就是这个题目的解答</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b ? Gcd(b, a % b) : a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isGoodArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//1与任意正整数的最大公约数是1</span></span><br><span class="line">            v = Gcd(nums[i], v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://oi-wiki.org/math/number-theory/gcd/" target="_blank" rel="noopener">https://oi-wiki.org/math/number-theory/gcd/</a></li><li><a href="https://leetcode.cn/problems/check-if-it-is-a-good-array/" target="_blank" rel="noopener">https://leetcode.cn/problems/check-if-it-is-a-good-array/</a></li><li><a href="https://oi-wiki.org/math/number-theory/bezouts/" target="_blank" rel="noopener">https://oi-wiki.org/math/number-theory/bezouts/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天碰到一道有意思的题目，学到了很多东西，所以记录一下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/check-if-it-is-a-good-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;检查好
      
    
    </summary>
    
    
      <category term="Algorithms To Live By" scheme="http://xboom.github.io/categories/Algorithms-To-Live-By/"/>
    
    
      <category term="Algorithms To Live By" scheme="http://xboom.github.io/tags/Algorithms-To-Live-By/"/>
    
  </entry>
  
  <entry>
    <title>Go入门23-arena</title>
    <link href="http://xboom.github.io/2023/01/10/Go/Go%E5%85%A5%E9%97%A823-arena/"/>
    <id>http://xboom.github.io/2023/01/10/Go/Go%E5%85%A5%E9%97%A823-arena/</id>
    <published>2023-01-10T08:00:20.000Z</published>
    <updated>2023-06-02T08:42:51.246Z</updated>
    
    <content type="html"><![CDATA[<p>最近 <code>Go1.20</code> 更新，中间讲到了一个特性 <code>arena</code> ，这里看看加入 <code>arena</code> 的作用</p><blockquote><p>在Go的内存管理中，<code>arena</code> 其实就是所谓的堆区，然后将这个区域分割成 <code>8KB</code> 大小的页，组合起来称为 <code>mspan</code>，<code>mspan</code>就是Go中内存管理的基本单元，是由一片连续的 8KB 的页组成的大块内存。其实 <code>mspan</code> 是一个包含起始地址、规格、页的数量等内容的双端链表</p></blockquote><p>虽然 Go 的垃圾回收机制能够正常的进行内存管理，但是存在以下问题</p><ol><li>垃圾回收机制需要花费大量CPU进行垃圾回收操作</li><li>垃圾回收机制有一定的延迟性，导致花费的内存比实际的内存要大</li></ol><p>而 <code>arena</code> 的优势 <strong>允许从连续的内存空间中分配对象并一次性进行释放</strong></p><p>注意：在 <a href="https://github.com/golang/go/issues/51317" target="_blank" rel="noopener">github arena 的话题</a>中，有一个最新的笔记提醒, 即处在测试阶段的 arena 功能随时可能被去除掉</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Note, 2023-01-17. This proposal is on hold indefinitely due to serious API concerns. The GOEXPERIMENT=arena code may be changed incompatibly or removed at any time, and we do not recommend its use in production.</span><br></pre></td></tr></table></figure><p>带着问题看世界：</p><ol><li>它跟内存池的区别</li><li>由于需要连续的内存空间，那么当需要分配的内存比较多，没有这么大的连续内存空间怎么办？</li><li>如果它分配的对象有一部分存在内存逃逸，那么该如何处理？</li><li>能支持并发吗</li></ol><h3 id="基础功能"><a class="markdownIt-Anchor" href="#基础功能"></a> 基础功能</h3><p>由于是实验功能，所以需要配置环境变量 <code>GOEXPERIMENT=arenas</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"arena"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;</span><br><span class="line">Foo <span class="keyword">string</span></span><br><span class="line">Bar [<span class="number">16</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processRequest</span><span class="params">(req *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// Create an arena in the beginning of the function.</span></span><br><span class="line">mem := arena.NewArena()</span><br><span class="line"><span class="comment">// Free the arena in the end.</span></span><br><span class="line"><span class="keyword">defer</span> mem.Free()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a bunch of objects from the arena.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">obj := arena.New[T](mem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or a slice with length and capacity.</span></span><br><span class="line">slice := arena.MakeSlice[T](mem, <span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想在arena释放时候继续使用它分配的对象，则可以通过 Clone 从堆中浅拷贝一个对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj1 := arena.New[T](mem) <span class="comment">// arena-allocated</span></span><br><span class="line">obj2 := arena.Clone(obj1) <span class="comment">// heap-allocated</span></span><br><span class="line">fmt.Println(obj2 == obj1) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">mem.Free()</span><br></pre></td></tr></table></figure><p>其他接口包括</p><ul><li><code>NewArena</code>：创建一个新的 arena 内存空间。</li><li><code>Free</code>：释放 arena 及其关联对象。</li><li><code>New</code>：基于 arena，创建新对象。</li><li><code>MakeSlice</code>：基于 arena，创建新切片。</li><li><code>Clone</code>：克隆一个 arena 的对象，并移动到内存堆上。<strong>只能是指针、slice或者字符串</strong></li></ul><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>代码路径：</p><ol><li><code>src/runtime/arena.go</code></li><li><code>src/arena/arena.go</code></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arena 表示多个Go一起分配与释放的内存集合，当其中的对象不在被引用那么将会自动释放</span></span><br><span class="line"><span class="keyword">type</span> Arena <span class="keyword">struct</span> &#123;</span><br><span class="line">a unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewArena allocates a new arena.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewArena</span><span class="params">()</span> *<span class="title">Arena</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Arena&#123;a: runtime_arena_newArena()&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据描述这里注意点有两个：</p><ol><li>arena 分配的对象需要及时释放</li><li>既然是自动释放，然后在使用中 <code>defer arena.Free()</code> 可以任务是，不用等到二次垃圾回收，直接将资源释放，并将可重复使用的mspan放入<code>reused</code>中</li></ol><p>查看Arena 内部结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> userArena <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 指向一个链表，表示一系列没有足够空闲内存的 mspan(内存段)。当该内存管理区域被释放时，这些 mspan 也会被释放</span></span><br><span class="line">fullList *mspan  <span class="comment">//内存组件 mspan</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向一个 mspan，表示未满的内存段。这个 mspan 中还有可用的内存可以分配</span></span><br><span class="line">active *mspan   </span><br><span class="line"></span><br><span class="line">  <span class="comment">//一个指向 unsafe.Pointer 类型的切片，用于引用当前内存管理区域的对象。这可以防止在仍然有引用对象时释放该内存管理区域</span></span><br><span class="line">refs []unsafe.Pointer</span><br><span class="line"></span><br><span class="line">  <span class="comment">//一个原子布尔类型的变量，用于标记内存管理区域是否已经被释放。如果为 true，表示该内存管理区域已经被释放，以避免重复释放</span></span><br><span class="line">defunct atomic.Bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Arena 如果重复释放也没有关系，判断释放过则直接结束</li></ul><p>**第一步：**分配一个 <code>Arena</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newUserArena creates a new userArena ready to be used.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newUserArena</span><span class="params">()</span> *<span class="title">userArena</span></span> &#123;</span><br><span class="line">a := <span class="built_in">new</span>(userArena)</span><br><span class="line">SetFinalizer(a, <span class="function"><span class="keyword">func</span><span class="params">(a *userArena)</span></span> &#123; <span class="comment">//g</span></span><br><span class="line"><span class="comment">// If arena handle is dropped without being freed, then call</span></span><br><span class="line"><span class="comment">// free on the arena, so the arena chunks are never reclaimed</span></span><br><span class="line"><span class="comment">// by the garbage collector.</span></span><br><span class="line">a.free()</span><br><span class="line">&#125;)</span><br><span class="line">a.refill()</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *userArena)</span> <span class="title">refill</span><span class="params">()</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line"><span class="comment">// If there's an active chunk, assume it's full.</span></span><br><span class="line">s := a.active</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the partially-used list.</span></span><br><span class="line">lock(&amp;userArenaState.lock)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(userArenaState.reuse) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">//当前存在可重用的就使用重用的</span></span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;userArenaState.lock)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Allocate a new one. 否则分配一个新的mspan</span></span><br><span class="line">x, s = newUserArenaChunk()</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"out of memory"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a.refs = <span class="built_in">append</span>(a.refs, x)<span class="comment">//记录mspan.base()，报活mspan</span></span><br><span class="line">a.active = s<span class="comment">//记录当前使用的mspan</span></span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>SetFinalizer</code> 函数可参考<a href="https://www.yuankang.top/2023/01/04/Go/Go%E5%85%A5%E9%97%A821-SetFinalizer/" target="_blank" rel="noopener">文章</a>，当gc检测到unreachable对象有关联的SetFinalizer函数时，会执行关联的SetFinalizer函数， 同时取消关联。 这样当下一次gc的时候，对象重新处于unreachable状态并且没有SetFinalizer关联， 就会被回收。</li></ul><p>**第二步：**从 arena 中分配具体类型的对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *userArena)</span> <span class="title">refill</span><span class="params">()</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line"><span class="comment">// If there's an active chunk, assume it's full.</span></span><br><span class="line">s := a.active<span class="comment">//上次分配了mspan</span></span><br><span class="line"><span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> s.userArenaChunkFree.size() &gt; userArenaChunkMaxAllocBytes &#123;</span><br><span class="line"><span class="comment">// It's difficult to tell when we're actually out of memory</span></span><br><span class="line"><span class="comment">// in a chunk because the allocation that failed may still leave</span></span><br><span class="line"><span class="comment">// some free space available. However, that amount of free space</span></span><br><span class="line"><span class="comment">// should never exceed the maximum allocation size.</span></span><br><span class="line">throw(<span class="string">"wasted too much memory in an arena chunk"</span>)</span><br><span class="line">&#125;</span><br><span class="line">s.next = a.fullList <span class="comment">//将这个mspan放到fullList的链表头部</span></span><br><span class="line">a.fullList = s</span><br><span class="line">a.active = <span class="literal">nil</span><span class="comment">//active置为空</span></span><br><span class="line">s = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the partially-used list.</span></span><br><span class="line">lock(&amp;userArenaState.lock)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(userArenaState.reuse) &gt; <span class="number">0</span> &#123;<span class="comment">//</span></span><br><span class="line"><span class="comment">//如果有可以重用的mspan则放到s中</span></span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;userArenaState.lock)</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Allocate a new one.</span></span><br><span class="line">x, s = newUserArenaChunk()<span class="comment">//否则新分配一个新的</span></span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"out of memory"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a.refs = <span class="built_in">append</span>(a.refs, x)</span><br><span class="line">a.active = s</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**第三步：**释放的核心是这块代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s := a.fullList<span class="comment">//获取这个mspan</span></span><br><span class="line">i := <span class="built_in">len</span>(a.refs) - <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> s != <span class="literal">nil</span> &#123;<span class="comment">//不为空</span></span><br><span class="line">  a.fullList = s.next<span class="comment">//指向下一个节点</span></span><br><span class="line">  s.next = <span class="literal">nil</span></span><br><span class="line">  freeUserArenaChunk(s, a.refs[i])<span class="comment">//释放这个mspan</span></span><br><span class="line">  s = a.fullList<span class="comment">//指向下一个节点</span></span><br><span class="line">  i--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>释放的时候仅仅是将fullList中所有的都释放掉了，而active中的则会进去到全局reuse对象中用于下次使用</li></ul><p>这个全局变量就是 <code>userArenaState</code> 用于存放可重复使用的mspan以及回收的mspan</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> userArenaState <span class="keyword">struct</span> &#123;</span><br><span class="line">lock mutex</span><br><span class="line"></span><br><span class="line">  <span class="comment">//可重复使用</span></span><br><span class="line">reuse []liveUserArenaChunk</span><br><span class="line"></span><br><span class="line">  <span class="comment">//回收释放的</span></span><br><span class="line">fault []liveUserArenaChunk</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对比syncpool"><a class="markdownIt-Anchor" href="#对比syncpool"></a> 对比Sync.Pool</h3><p>arena 与 Sync.Pool 同样都是为了解决频繁分配对象和大量对象GC带来的开销</p><p><code>Sync.Pool</code>相同类型的对象，使用完后暂时缓存不GC，下次再有相同的对象分配时直接用之前的缓存的对象，避免频繁创建大量对象。不承诺这些缓存对象的生命周期，GC时会释放之前的缓存，适合解决频繁创建相同对象带来的压力，短时间(两次GC之间)大量创建可能还是会有较大冲击，使用相对简单，但只能用于相同结构创建，不能创建slice等复杂结构</p><p><code>arena</code>手动管理连续内容并统一释放，对象的生命周期完全自己控制，使用相对复杂，支持slice等复杂结构，也不是一个真正意义的连续超大空间，而是通过管理不同的mspan实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"arena"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyObj <span class="keyword">struct</span> &#123;</span><br><span class="line">Index <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkCreateObj</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *MyObj</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++ &#123;</span><br><span class="line">p = <span class="built_in">new</span>(MyObj)</span><br><span class="line">p.Index = j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">objPool = sync.Pool&#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;MyObj&#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkCreateObj_SyncPool</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *MyObj</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++ &#123;</span><br><span class="line">p = objPool.Get().(*MyObj)</span><br><span class="line">p.Index = <span class="number">23</span></span><br><span class="line">objPool.Put(p)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkCreateObj_Arena</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *MyObj</span><br><span class="line"></span><br><span class="line">a := arena.NewArena()</span><br><span class="line"><span class="keyword">defer</span> a.Free()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++ &#123;</span><br><span class="line">p = arena.New[MyObj](a)</span><br><span class="line">p.Index = <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性能对比的结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cpu: Intel(R) Core(TM) i7-8559U CPU @ 2.70GHz</span><br><span class="line">BenchmarkCreateObj-8                      100518             11370 ns/op            8000 B/op       1000 allocs/op</span><br><span class="line">BenchmarkCreateObj_SyncPool-8             110017             11523 ns/op               0 B/op          0 allocs/op</span><br><span class="line">BenchmarkCreateObj_Arena-8                 80409             15340 ns/op            8032 B/op          0 allocs/op</span><br></pre></td></tr></table></figure><p><code>Sync.Pool</code> 不需要重复分配且每次操作时间短，而<code>Arena</code>执行时间会长一点且每次还是需要分配内存的，因为需要引入新的 <code>mspan</code></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li><code>Arena</code> 不支持并发，可以看出操作同一个 arena的时候并不存在锁操作</li><li>Arena 强制 Free()之后的对象无法继续使用</li><li>优点：<ul><li>一旦被释放但仍然被访问则会显示的导致程序错误</li><li>arena 地址空间除非没有指针指向，否则将不能被重用</li><li>arena 永远不会被垃圾回收机制回收(如果GC不可达它会执行 <code>SetFinalizer</code> 自己释放掉，那我们手动free的意义在哪里 --&gt; 也就是构建arena的目的，提前释放内存，降低GC扫描频率)</li></ul></li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://uptrace.dev/blog/golang-memory-arena.html" target="_blank" rel="noopener">https://uptrace.dev/blog/golang-memory-arena.html</a></li><li><a href="https://colobu.com/2022/10/17/a-first-look-at-arena/" target="_blank" rel="noopener">https://colobu.com/2022/10/17/a-first-look-at-arena/</a></li><li><a href="https://zhuanlan.zhihu.com/p/604686258" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/604686258</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近 &lt;code&gt;Go1.20&lt;/code&gt; 更新，中间讲到了一个特性 &lt;code&gt;arena&lt;/code&gt; ，这里看看加入 &lt;code&gt;arena&lt;/code&gt; 的作用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在Go的内存管理中，&lt;code&gt;arena&lt;/code&gt; 其实
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务-02-两阶段提交</title>
    <link href="http://xboom.github.io/2023/01/04/Distributed%20Transaction/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-02-%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/"/>
    <id>http://xboom.github.io/2023/01/04/Distributed%20Transaction/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-02-%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/</id>
    <published>2023-01-04T13:45:13.442Z</published>
    <updated>2023-06-25T15:08:18.258Z</updated>
    
    <content type="html"><![CDATA[<p>理解两阶段提交，需要首先了解 XA 协议。</p><p>XA定义：XA是由X/Open组织提出的分布式事务的规范。主要定义了**(全局)事务管理器TM<strong>和</strong>(局部)资源管理器(RM)**之间的接口，主流的关系型 数据库产品都是实现了XA接口的</p><p>两阶段提交(Two-phase Commit Protocol，简称 2PC)针对的是刚性事务，将一个分布式的事务过程拆分成两个阶段： <strong>投票</strong> 和 <strong>事务提交</strong> ，是一个非常经典的<code>强一致、中心化的原子提交协议</code></p><h3 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h3><p>AP 向 TM 提交请求，发起分布式事务</p><h4 id="第一阶段-准备阶段prepare-phase"><a class="markdownIt-Anchor" href="#第一阶段-准备阶段prepare-phase"></a> 第一阶段 准备阶段（Prepare Phase）</h4><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/1090617-20190710222443794-591603727.jpg" alt="img" style="zoom:50%;" /><p>准备阶段，主要目的在于打探数据库集群中的各个 RM 是否能够正常的执行事务，具体步骤如下：</p><ol><li>TM 向所有的 RM 发送事务预处理请求 <code>REQUEST-TO-PREPARE</code>，并等待 RM 反馈事务执行结果(准备结果)</li><li>RM 收到请求之后，执行询问发起为止的所有事务操作，并将 Undo 信息和 Redo 信息写入日志</li><li>RM 响应 TM 发起的询问。如果 RM 第二步 执行成功，则返回<code>PREPARED</code>；否则返回 <code>NO</code>。同时阻塞等待 TM 的后续指令</li></ol><blockquote><p>第一阶段准备阶段也被称作<strong>投票阶段</strong>，即各 RM 投票是否要继续接下来的提交操作</p></blockquote><p>这里就会存在一些问题：</p><ol><li><p>TM 发送请求部分 RM 没有收到</p><p>答：RM 会阻塞等待，而 TM 也会因为收不到回复而阻塞等待。解决方案，提供超时机制， TM超时回滚或咨询事务执行结果逻辑</p></li><li><p>RM 收到请求是如何准备的</p><p>答：特殊处理机制，看下面的 MySQL 执行 XA 命令</p></li><li><p>RM 收到请求之后执行了准备操作但是没有响应</p><p>答：TM 会阻塞，解决方案，提供超时机制， TM超时回滚或咨询事务执行结果逻辑</p></li><li><p>TM 等待响应部分或全部超时如何处理</p><p>答：TM 会阻塞，解决方案，提供超时机制， TM超时回滚或咨询事务执行结果逻辑</p></li></ol><p><strong>可惜的是，当 TM 无法收到所有 RM 的回复的时候，TM 会陷入阻塞！！需要超时逻辑进行下一步处理</strong></p><p>在具体应用中超时/失败场景可以根据实际的系统需要而进行方案设计，这里的协议仅仅做了流程上的考量</p><ul><li><strong>超时重试</strong>：TM 可以尝试重新发送准备请求给失败的 RM，设定一个合理的超时时间。如果在超时时间内收到了 RM 的准备就绪通知，那么可以继续进行提交阶段。如果超时后仍未收到响应，可以将 RM 标记为失败，并回滚事务。</li><li><strong>回滚事务</strong>：如果准备请求发送失败，可以将事务标记为回滚，并通知所有 RM 回滚事务。这样可以确保所有 RM 处于一致的状态，即使其中一部分 RM 未能接收到准备请求。</li><li><strong>异常处理</strong>：如果准备请求的发送失败是由于网络故障、RM 崩溃或其他不可预见的错误引起的，可以捕获异常并进行相应的处理。可以根据具体的系统需求，选择适当的策略，如重试、回滚或者向管理员报告问题</li></ul><p>RM 支持 XA 协议，在收到 TM 请求之后，可以根据 MySQL 命令看看 RM 是如何处理的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 第一阶段</span><br><span class="line">// 1.1 通过 XA <span class="keyword">START</span> 和 XA <span class="keyword">END</span> 来包裹 用户业务<span class="keyword">SQL</span></span><br><span class="line">mysql&gt; XA <span class="keyword">START</span> <span class="string">'transfer_money'</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET money = money -100 where id = 1 ;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; XA END 'transfer_money';</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">// 1.2 通过 XA <span class="keyword">PREPARE</span> 通知 RM 一阶段就绪</span><br><span class="line">mysql&gt; XA <span class="keyword">PREPARE</span> <span class="string">'transfer_money'</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">// 第二阶段，通过 XA <span class="keyword">COMMIT</span> 完成二阶段的提交</span><br><span class="line">mysql&gt;</span><br><span class="line">mysql&gt; XA <span class="keyword">COMMIT</span> <span class="string">'transfer_money'</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="第二阶段-提交阶段commit-phase"><a class="markdownIt-Anchor" href="#第二阶段-提交阶段commit-phase"></a> 第二阶段 提交阶段（Commit Phase）</h4><p>在第一阶段 TM 收到所有 RM 返回成功的情况下，流程如下所示</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/1090617-20190710222454275-1462865655.jpg" alt="img" style="zoom:50%;" /><ul><li><p>如果所有的 RM 都回复的是<code>PREPARED</code>， 那么 TM 向所有 RM 发送<code>COMMIT</code> 消息；</p></li><li><p>否则 TM 向所有回复<code>PREPARED</code>的 RM 发送<code>ABORT</code>消息；</p></li><li><p>RM 如果收到 TM 发来的<code>COMMIT</code>消息则提交，<code>ABORT</code>消息则回滚，并向 TM 发送<code>DONE</code>消息以确认</p></li></ul><p>不懂就问：</p><ol><li><p>部分 RM 并没有收到 TM 的提交或者回滚、</p><p>答：数据可能出现不一致。解决方案，可以引入咨询机制查看事务是否正常，阻塞时间更长</p></li><li><p>TM 等待 RM 的提交响应超时如何处理。</p><p>答：TM 无法知道执行结果，可能出现不一致，解决方案，可以引入咨询机制查看事务是否正常，阻塞时间更长</p></li><li><p>TM 作为事务协调者，是否存在单点故障以及性能瓶颈。</p><p>答：可以通过协商选举一个出来(如果能保存未提交事务让备TM 继续咨询协调更好)</p></li></ol><p>当TM 等待响应部分超时或者失败，TM 均认为 RM 无法成功执行事务，为了整个集群数据的一致性，向各个 RM 发送事务回滚通知：</p><ol><li>TM 向各个 RM 发送事务 <code>rollback</code> 通知，请求回滚事务</li><li>RM 收到事务回滚通知之后执行 <code>rollback</code> 操作，然后释放占有的资源</li><li>RM 向 TM 返回事务 <code>rollback</code> 结果信息(发送也可能失败)</li></ol><p>不懂就问：</p><ol><li><p>部分RM 并没有收到回滚通知怎么办？</p><p>答：所有处于执行了操作但是未提交状态的 RM 都会陷入阻塞情况.</p></li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>优点：</p><ol><li>两阶段提交支持不同数据库的分布式事务，比如一个是 MySQL，另外一个是 Oracle</li><li>业务无侵入：XA 模式将是业务无侵入的，不给应用设计和开发带来额外负担</li><li>数据库的支持广泛：XA 协议被主流关系型数据库广泛支持，不需要额外的适配即可使用</li></ol><p>缺点：</p><ol><li><strong>同步阻塞</strong>，无论是在第一阶段的过程中,还是在第二阶段,<strong>所有 RM 资源和 TM 资源都是被锁住的</strong>,只有当所有 RM 准备完毕，TM 才会通知进行全局提交，<strong>RM</strong> 进行本地事务提交后才会释放资源。这样的<strong>过程会比较漫长，对性能影响比较大</strong>。</li><li><strong>单点故障</strong>，一旦 TM 发生故障。RM 会一直阻塞下去。尤其在第二阶段，TM 发生故障，那么所有的 RM 还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是 TM 挂掉，可以重新选举一个TM ，但是无法解决因为 TM 宕机导致的 RM 处于阻塞状态的问题）</li><li><strong>数据不一致</strong>。当只有部分 RM 收到commit请求，会导致整个分布式系统便出现了数据部一致性的现象。</li><li><strong>脑裂</strong>，当 TM 发出 <code>commit</code> 消息之后宕机，而接收到这条消息的 RM 同时也宕机了。那么即使 TM 通过选举协议产生了新的TM ，这条事务的状态也是不确定的，没人知道事务是否被已经提交</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://pdai.tech/md/arch/arch-z-transection.html#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%A1%88%E4%B9%8B%E5%88%9A%E6%80%A7%E4%BA%8B%E5%8A%A1" target="_blank" rel="noopener">https://pdai.tech/md/arch/arch-z-transection.html#分布式事务方案之刚性事务</a></li><li><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/二阶段提交</a></li><li><a href="https://blog.51cto.com/u_15287666/2989395" target="_blank" rel="noopener">https://blog.51cto.com/u_15287666/2989395</a></li><li><a href="https://www.cnblogs.com/qdhxhz/p/11167025.html" target="_blank" rel="noopener">https://www.cnblogs.com/qdhxhz/p/11167025.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;理解两阶段提交，需要首先了解 XA 协议。&lt;/p&gt;
&lt;p&gt;XA定义：XA是由X/Open组织提出的分布式事务的规范。主要定义了**(全局)事务管理器TM&lt;strong&gt;和&lt;/strong&gt;(局部)资源管理器(RM)**之间的接口，主流的关系型 数据库产品都是实现了XA接口的
      
    
    </summary>
    
    
      <category term="Distributed Transaction" scheme="http://xboom.github.io/categories/Distributed-Transaction/"/>
    
    
      <category term="Distributed Transaction" scheme="http://xboom.github.io/tags/Distributed-Transaction/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务-03-三阶段提交</title>
    <link href="http://xboom.github.io/2023/01/04/Distributed%20Transaction/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-03-%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/"/>
    <id>http://xboom.github.io/2023/01/04/Distributed%20Transaction/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-03-%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/</id>
    <published>2023-01-04T13:45:13.442Z</published>
    <updated>2023-06-25T15:39:58.539Z</updated>
    
    <content type="html"><![CDATA[<p>针对两阶段提交存在的问题，三阶段提交协议通过引入一个 <strong>预询盘</strong> 阶段，以及超时策略来减少整个集群的阻塞时间，提升系统性能？</p><p>为啥加一个流程就能减少阻塞时间，接着往下看</p><p>针对2PC存在的问题 3PC 做了如下改变</p><ol><li>引入超时机制。同时在 TM 和 RM 中都引入超时机制。</li><li>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</li></ol><p><strong>超时机制：</strong></p><ul><li><p>对于 TM 来说如果在指定时间内没有收到所有 RM 的应答，则可以自动退出 <code>WAIT</code> 状态，并向所有参与者发送 <code>rollback</code> 通知。</p></li><li><p>对于 RM 来说如果位于 READY 状态，但是在指定时间内没有收到TM的第二阶段通知，则不能武断地执行 rollback 操作，因为TM 可能发送的是 commit 通知，这个时候执行 rollback 就会导致数据不一致。</p></li></ul><p><strong>互询机制</strong>，让 RM A 去询问其他 RM B 的执行情况。</p><ul><li>如果 B 执行了 rollback 或 commit 操作，则 A 可以大胆的与 B 执行相同的操作；</li><li>如果 B 此时还没有到达 READY 状态，则可以推断出 TM 发出的肯定是 rollback 通知；</li><li>如果 B 同样位于 READY 状态，则 A 可以继续询问另外的参与者。</li><li>只有当所有的 RM 都位于 READY 状态时，此时两阶段提交协议无法处理，将陷入长时间的阻塞状态(TM 可能崩溃了)</li></ul><p><strong>3PC把2PC的准备阶段再次一分为二</strong>：<strong>预询盘(can_commit)</strong>、<strong>预提交(pre_commit)<strong>以及</strong>事务提交(do_commit)</strong></p><h3 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h3><h4 id="第一阶段-预询盘"><a class="markdownIt-Anchor" href="#第一阶段-预询盘"></a> 第一阶段 预询盘</h4><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/1090617-20190710222512291-462809105.jpeg" alt="img" style="zoom:50%;" /><ul><li>TM 向各 RM 发送 <code>CanCommit</code> 的请求，询问是否可以执行事务提交操作，并开始等待各 RM 的响应</li><li>RM 收到 <code>CanCommit</code> 请求后，正常情况下，如果自身认为可以顺利执行事务，那么会反馈 Yes 响应，并进入预备状态，否则反馈 No</li></ul><p>异常情况：</p><ul><li>部分 RM 收到 <code>canCommit</code> 指令后，直接反馈不能开始事务，TM 向所有参与者发送 abort 请求。</li><li>TM 等待反馈超时，向所有 RM 发送 abort 请求。</li><li>RM 预检没问题，但一直无法接收到下一步的的指令(反馈 <code>can commit</code> 超时 或接收RM 的下一步指令超时)，自省中断事务的中断</li><li>RM 收到来自 TM 的 <code>abort</code> 请求之后执行事务中断</li></ul><h4 id="第二阶段-预提交"><a class="markdownIt-Anchor" href="#第二阶段-预提交"></a> 第二阶段 预提交</h4><p>这个阶段类似2PC 的第一阶段，这个环节根据阶段 1 的参与者的反馈不同，而执行不同的逻辑：</p><p>1）如果任意一个 RM 在阶段 1 向 TM 反馈了 No 响应，或者 TM 等待 RM 反馈超时，那么就会中断事务，<strong>中断执行逻辑</strong>如下：</p><ol><li>TM 向所有 RM 发送 abort 请求</li><li>RM 无论是收到来自 TM 的 abort 请求，还是等待超时，都执行事务中断</li></ol><p>2）另一种情况，如果 TM  接收到各RM 反馈都是 Yes，那么才执行事务预提交，执行逻辑如下：</p><ol><li>TM 向各RM 发送 <code>preCommit</code> 请求，并进入 <code>prepared</code> 阶段</li><li>各 RM 接收到 <code>preCommit</code> 请求后执行事务操作，并将 Undo 和 Redo 信息记录到事务日记中，但事务不提交</li><li>如果各 RM 都成功执行了事务操作，那么反馈给TM Ack 响应，同时等待最终指令，提交 <code>commit</code> 或者终止 <code>abort</code></li></ol><h4 id="第三阶段-事务提交"><a class="markdownIt-Anchor" href="#第三阶段-事务提交"></a> 第三阶段 事务提交</h4><p>这个阶段类似 2PC 的第二个阶段，这个环节根据阶段2 RM 不同反馈，而执行不同的逻辑：</p><p>1）假设 TM 正常工作，并且有任意一个 RM 在阶段 2 反馈 No，或者在等待RM 的反馈超时后，都会主动中断事务</p><ul><li>TM 向所有RM 节点发送 abort 请求</li><li>RM 接收到 abort 请求后，利用 undo 日志执行事务回滚，并在完成事务回滚后释放占用的资源后，向 TM 发送 ack 信息，反馈事务回滚结果</li><li>TM 接收到所有 RM 反馈的 ACK 消息之后，完成事务的中断</li></ul><p>2）假设 TM 正常工作，接收到了所有 RM 的 ack 响应，那么它将从预提交阶段进入提交状态</p><ul><li>TM 向所有 RM 发送 <code>doCommit</code> 请求</li><li>RM 收到 <code>doCommit</code> 请求后，正式提交事务，并在完成事务提交后释放占用的资源，向 TM 发送 ACK 信息，反馈事务提交结果</li><li>TM 接收到所有参与者 ack 信息，整个事务完成</li></ul><p>异常情况：</p><ul><li>RM 收到 <code>PreCommit</code> 指令并正常执行事务，给 TM 反馈 <code>preCommit</code> 完成后，如果未能等到下一步的 <code>doCommit</code> 指令超时了，会自主提交事务。因为询问阶段是一致通过的，执行到这个阶段整个事务成功的概率已经很高了</li><li>部分 RM 执行 <code>preCommit</code> 异常，部分参与者执行 <code>preCommit</code> 正常，但此时 TM 挂了，那么通过 RM 的超时自醒机制，就出现部分参与者提交，部分参与者回滚，出现数据不一致。</li><li>TM 发送了 abort 指令，RM 超时未收到指令就提交了事务，其他 RM 收到了协调者发送的 abort 指令后执行了回滚，也会出现数据不一致。</li></ul><blockquote><p>Keidar 和 Dolev (1998) 建议使用增强型三阶段提交 (E3PC) 协议来消除此问题。E3PC 协议需要至少三个往返才能完成，这将有很长的延迟才能完成每笔交易。</p></blockquote><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>相较于2PC，3PC引入超时机制与质询机制，增加了额外的通信开销，增加了系统网络负载与延迟</li><li>异常情况仍然无法避免数据不一致的情况</li><li>依赖于时间同步，3PC的正确执行依赖于系统中所有 RM 和 TM 的时间同步。如果时间同步不准确，可能导致超时机制失效或误判，影响事务的最终一致性。</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://pdai.tech/md/arch/arch-z-transection.html#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%A1%88%E4%B9%8B%E5%88%9A%E6%80%A7%E4%BA%8B%E5%8A%A1" target="_blank" rel="noopener">https://pdai.tech/md/arch/arch-z-transection.html#分布式事务方案之刚性事务</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;针对两阶段提交存在的问题，三阶段提交协议通过引入一个 &lt;strong&gt;预询盘&lt;/strong&gt; 阶段，以及超时策略来减少整个集群的阻塞时间，提升系统性能？&lt;/p&gt;
&lt;p&gt;为啥加一个流程就能减少阻塞时间，接着往下看&lt;/p&gt;
&lt;p&gt;针对2PC存在的问题 3PC 做了如下改变&lt;/
      
    
    </summary>
    
    
      <category term="Distributed Transaction" scheme="http://xboom.github.io/categories/Distributed-Transaction/"/>
    
    
      <category term="Distributed Transaction" scheme="http://xboom.github.io/tags/Distributed-Transaction/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务-04-TCC</title>
    <link href="http://xboom.github.io/2023/01/04/Distributed%20Transaction/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-04-TCC/"/>
    <id>http://xboom.github.io/2023/01/04/Distributed%20Transaction/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-04-TCC/</id>
    <published>2023-01-04T13:45:13.442Z</published>
    <updated>2023-06-25T15:47:19.066Z</updated>
    
    <content type="html"><![CDATA[<p>TCC是<strong>Try</strong>、<strong>Confirm</strong>、<strong>Cancel</strong>三个词语的缩写，TCC分为3个阶段</p><ul><li>Try 阶段：尝试执行，完成所有业务检查（一致性）, 预留必须业务资源（准隔离性）</li><li>Confirm 阶段：如果所有分支的Try都成功了，则走到Confirm阶段。Confirm真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源</li><li>Cancel 阶段：如果所有分支的Try有一个失败了，则走到Cancel阶段。Cancel释放 Try 阶段预留的业务资源</li></ul><h3 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h3><h4 id="成功"><a class="markdownIt-Anchor" href="#成功"></a> 成功</h4><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/tcc_normal.dea14fb3.jpg" alt="tcc_normal" style="zoom:50%;" /><h4 id="失败"><a class="markdownIt-Anchor" href="#失败"></a> 失败</h4><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/tcc_rollback.f28601d7.jpg" alt="tcc_rollback" style="zoom:50%;" /><p>假如<code>Confirm/Cancel</code>操作遇见失败会怎么样？按照Tcc模式的协议，<code>Confirm/Cancel</code>操作是要求最终成功的，遇见失败的情况，都是由于临时故障或者程序bug。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>优点：</p><ol><li>TCC 只适合短事务</li><li>允许开发人员根据业务需求灵活定义每个阶段的操作逻辑。可使TCC模式适用于各种复杂的分布式事务场景。</li><li>TCC模式通过将事务拆分为Try、Confirm和Cancel三个阶段，避免了传统的锁机制带来的并发性能问题</li><li>由于无锁设计和阶段化的执行，TCC模式具有良好的并发性能。各个参与者可以并行执行Try和Confirm阶段的操作，减少了事务冲突和等待时间。</li><li>TCC模式对于 RM  的故障和系统崩溃有一定的容错性。在Confirm阶段，事务的确认操作将确保事务的最终提交；而在Cancel阶段，事务的撤销操作将恢复资源到事务之前的状态，保证了系统的可靠性和故障恢复能力。</li></ol><p>缺点：</p><ol><li>相对于传统的ACID事务模型，TCC模式的实现相对复杂。需要开发人员仔细设计和实现每个阶段的操作逻辑</li><li>由于TCC模式的阶段执行方式，可能存在部分阶段执行成功而后续阶段失败的情况。这可能导致数据的不一致性，需要通过应用程序层面的补偿机制或人工干预来解决。</li><li>不同 RM 之间需要进行额外的网络通信来协调事务的执行。这可能增加系统的网络开销和延迟。</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://dtm.pub/guide/theory.html#%E4%BA%8B%E5%8A%A1" target="_blank" rel="noopener">https://dtm.pub/guide/theory.html#事务</a></li><li><a href="https://blog.csdn.net/yeyazhishang/article/details/80758354" target="_blank" rel="noopener">https://blog.csdn.net/yeyazhishang/article/details/80758354</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TCC是&lt;strong&gt;Try&lt;/strong&gt;、&lt;strong&gt;Confirm&lt;/strong&gt;、&lt;strong&gt;Cancel&lt;/strong&gt;三个词语的缩写，TCC分为3个阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Try 阶段：尝试执行，完成所有业务检查（一致性）, 预留必须业务
      
    
    </summary>
    
    
      <category term="Distributed Transaction" scheme="http://xboom.github.io/categories/Distributed-Transaction/"/>
    
    
      <category term="Distributed Transaction" scheme="http://xboom.github.io/tags/Distributed-Transaction/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务-06-AT</title>
    <link href="http://xboom.github.io/2023/01/04/Distributed%20Transaction/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-06-AT/"/>
    <id>http://xboom.github.io/2023/01/04/Distributed%20Transaction/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-06-AT/</id>
    <published>2023-01-04T13:45:13.442Z</published>
    <updated>2023-06-25T15:53:15.895Z</updated>
    
    <content type="html"><![CDATA[<p>AT模式是Seata最主推的分布式事务且基于XA演进而来的解决方案，是一种改进的二阶段提交，主要有三个角色：TM、RM和TC，<strong>其中TM和RM作为Seata的客户端和业务集成，TC作为Seata服务器独立部署</strong></p><p>在AT模式下，数据库资源被当做RM，<strong>访问RM时，Seata会对请求进行拦截；每个本地事务提交时，RM会向TC(Transaction Coordinator，事务协调器)注册一个分支事务</strong>，用户只需关注自己的 <strong>业务SQL</strong> ，用户的  <strong>业务SQL</strong> 作为一阶段，Seata 框架会自动生成事务的二阶段提交和回滚操作</p><h3 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h3><h4 id="第一阶段"><a class="markdownIt-Anchor" href="#第一阶段"></a> 第一阶段</h4><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/1352849-20210623235541565-1026038020.png" alt="img" style="zoom:90%;" /><ol><li>当访问 RM 的时候，会拦截解析 SQL 语句，保存 “before image”</li><li>执行 SQL 更新业务数据</li><li>接着保存操作后的 “after image”</li><li>插入回滚日志 undo_log</li><li>向TC注册分支事务，申请全局锁，并将其纳入到该XID对应的全局事务范围。</li><li>提交本地事务</li><li>向 TC 汇报本地事务结果</li></ol><h4 id="第二阶段"><a class="markdownIt-Anchor" href="#第二阶段"></a> 第二阶段</h4><h5 id="事务提交"><a class="markdownIt-Anchor" href="#事务提交"></a> 事务提交</h5><p>如果在第一阶段所有的分支事务已经提交，则TC决定全局事务提交，此时只需要清理UNDO_LOG日志即可，相比较XA模式，不需要TC触发所有分支事务的提交</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/1352849-20210624000205985-1441189903.png" alt="img" style="zoom:80%;" /><p>具体的流程为：</p><ol><li><p>分支事务收到TC的提交请求之后放入异步队列中，马上返回提交成功的结果</p><blockquote><p>这里不需要同步返回的原因是：TC不需要知道分支事务的结果，因为仅仅只是一步删除<code>UNDO_LOG</code>记录的操作，即使不成功也不会结果造成影响，所以采用异步是有效的方式</p></blockquote></li><li><p>从异步队列中执行分支提交请求，清理undo_log日志，这里并不需要分支事务的提交了，因为第一阶段中已经提交过了</p></li></ol><p>理解起来就是：<strong>AT模式下的全局事务的提交只需要清理UNDO_LOG记录就行，不需要管分支(本地)事务的提交结果！</strong></p><h5 id="事务回滚"><a class="markdownIt-Anchor" href="#事务回滚"></a> 事务回滚</h5><p>在第一阶段的分支事务中任何一个分支事务执行失败，都会进入全局事务回滚流程，回滚主要是依赖<code>UNDO_LOG</code>中的记录进行补偿的</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/1352849-20210624001241995-2087665567.png" alt="img" style="zoom:80%;" /><p>具体的流程如下：</p><p>接收到TC的回滚请求后，开启本地事务用来执行回滚操作</p><ol><li><p>本地事务分支开始进行对查找<code>UNDO_LOG</code>记录，通过<code>XID+branch ID</code>查到<code>UNDO_LOG</code>记录；</p></li><li><p>数据校验(对比更新后镜像数据与当前数据)，拿到<code>rollback_for</code>中<code>afterImage</code>镜像数据与当前业务表中数据比较，不同的话，比如<code>afterImage</code>镜像数据拿出的amount理论上为99，但是实际上amount=98，则说明已经被当前全局事务外的某个操作做了修改(实际上由于全局锁的存在，并不会存在其他全局事务对业务数据进行更新)，那么事务不进行回滚。</p></li><li><p>第二步中对比结果是相等的话，就采用<code>beforeImage</code>和SQL的相关信息进行回滚，即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE rep SET acoumt&#x3D;100 WHERE id&#x3D;1</span><br></pre></td></tr></table></figure></li><li><p>删除<code>UNDO_LOG</code>记录</p></li><li><p>提交本地事务</p></li><li><p>将本地事务的回滚执行结果报告给TC</p></li></ol><h3 id="隔离性保证"><a class="markdownIt-Anchor" href="#隔离性保证"></a> 隔离性保证</h3><p>在AT模式下，多个全局事务操作同一张表时，它的事务隔离性保证是基于全局锁来实现的</p><ol><li><p>写隔离，<strong>在第一阶段本地事务提交之前，必须确保拿到全局锁</strong>，如果拿不到全局锁则一直等待尝试，超出最大尝试次数则放弃全局锁的获取，并回滚释放本地锁（在本地事务开始之前就获到本地锁，这里的本地锁概念是数据库锁，比如对某行记录的行锁）</p></li><li><p>读隔离，Seata AT事务模式的默认全局隔离级别是Read Uncommit，在这种隔离级别下，所有事务都可以看到其它未提交事物的执行结果产生脏读，这在最终一致性的事务模型是被允许的，并且大部分是分布式事务是接受脏读的。</p></li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/1352849-20210623233710656-104557209.png" alt="img" style="zoom:80%;" /><p>优点：</p><ol><li>原子性，AT协议保证了分布式事务的原子性，要么所有 RM 都成功提交事务，要么所有 RM 都回滚事务。</li><li>数据一致性，AT协议确保了分布式事务的一致性，所有 RM 在提交阶段只有在所有其他 RM 也准备好提交时才会提交事务。</li><li>灵活性，AT协议可以适应各种分布式环境和参与者的异构性，因为它没有对具体的数据库或资源管理器实施特定要求。</li></ol><p>缺点：</p><ol><li>同步阻塞，AT协议在准备和提交阶段都需要等待 RM 的响应，因此可能会引入同步阻塞，影响事务的性能和吞吐量。</li><li>单点故障，在AT协议中，TC 是关键的中心节点，如果 TC 发生故障，整个分布式事务的执行将受到影响。</li><li>数据不一致风险，在AT协议中，即使在准备阶段所有参与者都准备就绪，但在提交阶段仍然存在参与者无法提交成功的情况，这可能导致数据的不一致。</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://seata.io/zh-cn/blog/seata-at-tcc-saga.html" target="_blank" rel="noopener">https://seata.io/zh-cn/blog/seata-at-tcc-saga.html</a></li><li><a href="https://www.cnblogs.com/jian0110/p/14925087.html" target="_blank" rel="noopener">https://www.cnblogs.com/jian0110/p/14925087.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/78599954" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/78599954</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AT模式是Seata最主推的分布式事务且基于XA演进而来的解决方案，是一种改进的二阶段提交，主要有三个角色：TM、RM和TC，&lt;strong&gt;其中TM和RM作为Seata的客户端和业务集成，TC作为Seata服务器独立部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在AT模式下，数据
      
    
    </summary>
    
    
      <category term="Distributed Transaction" scheme="http://xboom.github.io/categories/Distributed-Transaction/"/>
    
    
      <category term="Distributed Transaction" scheme="http://xboom.github.io/tags/Distributed-Transaction/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务-07-通知型事务</title>
    <link href="http://xboom.github.io/2023/01/04/Distributed%20Transaction/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-07-%E9%80%9A%E7%9F%A5%E5%9E%8B%E4%BA%8B%E5%8A%A1/"/>
    <id>http://xboom.github.io/2023/01/04/Distributed%20Transaction/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-07-%E9%80%9A%E7%9F%A5%E5%9E%8B%E4%BA%8B%E5%8A%A1/</id>
    <published>2023-01-04T13:45:13.442Z</published>
    <updated>2023-06-23T12:41:07.706Z</updated>
    
    <content type="html"><![CDATA[<p>刚性事务属于 CAP 理论中的 CP 组合，会有性能上限，无法满足高并发场景的需求。基于 BASE 理论，柔性事务方案被提出用于保证事务数据的最终一致性。柔性事务本质是对 XA 协议的妥协，它通过降低强一致性要求，从而降低数据库资源锁定时间，提升可用性，允许有中间状态，要求最终一致性，也就是 AP 组合。柔性事务分为通知型和补偿型：</p><ul><li>通知型事务都是异步的，包含有：可靠消息、最大努力通知两种</li><li>补偿型事务都是同步的，包含有：AT、TCC、Saga</li></ul><h3 id="可靠消息"><a class="markdownIt-Anchor" href="#可靠消息"></a> 可靠消息</h3><p>可靠消息方案是指当事务发起方(消息发送者)执行完成本地事务后并发出一条消息，事务参与方(消息接收者)一定能够接收消息并处理事务成功</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/7df25b5310d14fdbb59db28b300f3bbe~tplv-k3u1fbpfcp-zoom-1.png" alt="img" /></p><p>此方案强调的是一旦消息发给事务参与方，则最终事务要达到一致。这其中有两个关键问题：</p><ol><li><strong>本地事务与消息发送的原子性问题</strong>：若事务发起方在本地事务执行成功，则消息必须发出(可以是立即发送，也可以是异步发送)，否则就无消息</li><li>事务参与方接收消息的可靠性问题<ul><li>参与方必须能够从 MQ 接收到消息，如果接收消息失败可以重复接收消息</li><li>参与方要解决消息重复消费的问题(消费处理的幂等性)</li></ul></li></ol><p>可靠消息方案适合执行周期长且实时性要求不高的场景。引入消息机制后，原先同步的事务操作变为基于消息写/读的异步操作，避免了同步阻塞，也实现了服务间的解耦。一般有基于<strong>本地消息表</strong>和基于<strong>消息中间件</strong>这两种实现式</p><h4 id="本地消息表"><a class="markdownIt-Anchor" href="#本地消息表"></a> 本地消息表</h4><p>本地消息表核心思路是：将分布式事务拆分成本地事务进行处理</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/c14cb3cd99e04114895723d27a2c176c~tplv-k3u1fbpfcp-zoom-1.png" alt="img" style="zoom:67%;" /><p>**优点：**从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对 MQ 中间件特性的依赖，方案轻量，容易实现。</p><p>**缺点：**需设计 DB 消息表，同时还需要一个后台任务，不断扫描本地消息。导致消息的处理和业务逻辑耦合额外增加业务方的负担</p><h4 id="事务消息"><a class="markdownIt-Anchor" href="#事务消息"></a> 事务消息</h4><p>为了解决本地消息表与业务耦合的问题，利用消息队列的事务消息的能力，可理解为将本地消息表移动到了 MQ 内部</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/70b4280f7cfe4ef79496621475c49de8~tplv-k3u1fbpfcp-zoom-1.png" alt="img" style="zoom:80%;" /><p>事务消息发送步骤如下：</p><ol><li>发送方将半事务消息发送至 RocketMQ</li><li>MQ 将消息持久化成功之后，向发送方返回 ACK 确认消息已经发送成功，此时消息为半事务消息</li><li>发送方开始执行本地事务逻辑</li><li>发送方根据本地事务执行结果向服务端提交二次确认（Commit 或是 Rollback），服务端收到 Commit 状态则将半事务消息标记为可投递，订阅方最终将收到该消息；服务端收到 Rollback 状态则删除半事务消息，订阅方将不会接受该消息</li></ol><p>事务消息回查步骤如下：</p><ol><li>在断网或者是应用重启的特殊情况下，上述发送步骤的步骤 4 提交的二次确认最终未到达服务端，经过固定时间后服务端将对该消息发起消息回查</li><li>发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果</li><li>发送方根据检查得到的本地事务的最终状态再次提交二次确认，服务端仍按照发送步骤的步骤 4 对半事务消息进行操作</li></ol><h3 id="最大努力通知"><a class="markdownIt-Anchor" href="#最大努力通知"></a> 最大努力通知</h3><p>最大努力通知型的目标是 <strong>事务发起方尽量将业务处理结果通知到参与方</strong>。适用于一些最终一致性时间敏感度低，且参与方的处理结果不影响发起方的处理结果的这类通知类的业务场景。如短信供应商的回执通知：</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/6c0d5c48079649a0a9ee54f6598c95e4~tplv-k3u1fbpfcp-zoom-1.png" alt="短信供应商回执通知(图片来自网络).png" style="zoom:80%;" /><p>最大努力通知型的实现方案，一般符合以下两个特点：</p><ol><li>消息重复通知，在业务活动发起方完成业务处理之后，向参与方发送消息，参与方可能没有接收到通知，此时要发起方有一定的机制对消息重复通知（通常是发起方调用参与方的 http 接口，而且会协商一个 N 次 通知的上限）</li><li>定期校对，事务发起方提供消息校对的接口，如果事务参与方没有接收到发起方发送的消息，可以调用事务发起方提供的接口主动获取消息</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li><p>可靠性的保障方不同</p><ul><li>可靠消息方案中，发起方需要保证将消息发出去，并且将消息发到参与方，消息的可靠性关键由发起方来保证</li><li>最大努力通知方案中，发起方尽最大努力将业务处理结果通知给参与方，但参与者是可能接收不到消息，此时需要接收通知方主动调用发起通知方的接口查询业务处理结果，消息通知的可靠性关键在参与方</li></ul></li><li><p>两者的业务应用场景不同</p><ul><li>可靠消息方案 关注的是整体业务处理的事务一致，以异步的方式完成整个业务处理，通常是内部系统之间的调用</li><li>最大努力通知 关注的是业务处理后的通知事务，即将业务处理结果可靠的通知出去</li></ul></li><li><p>技术解决方向不同</p><ul><li>可靠消息方案 要解决消息从发出到接收的一致性，即消息发出并且被接收到</li><li>最大努力通知方案 无法保证消息从发出到接收的一致性，只提供消息接收的可靠性机制。可靠机制是，尽最大努力将消息通知给参与方，当消息无法被参与方接收时，由参与方主动查询消息（业务处理结果）</li></ul></li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://developer.aliyun.com/article/1192549#slide-22" target="_blank" rel="noopener">https://developer.aliyun.com/article/1192549#slide-22</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚性事务属于 CAP 理论中的 CP 组合，会有性能上限，无法满足高并发场景的需求。基于 BASE 理论，柔性事务方案被提出用于保证事务数据的最终一致性。柔性事务本质是对 XA 协议的妥协，它通过降低强一致性要求，从而降低数据库资源锁定时间，提升可用性，允许有中间状态，要求
      
    
    </summary>
    
    
      <category term="Distributed Transaction" scheme="http://xboom.github.io/categories/Distributed-Transaction/"/>
    
    
      <category term="Distributed Transaction" scheme="http://xboom.github.io/tags/Distributed-Transaction/"/>
    
  </entry>
  
  <entry>
    <title>Go入门21-SetFinalizer</title>
    <link href="http://xboom.github.io/2023/01/04/Go/Go%E5%85%A5%E9%97%A821-SetFinalizer/"/>
    <id>http://xboom.github.io/2023/01/04/Go/Go%E5%85%A5%E9%97%A821-SetFinalizer/</id>
    <published>2023-01-04T13:45:13.344Z</published>
    <updated>2023-06-02T08:49:46.059Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读Go 1.20 新特性 arena 的时候，看到在构建 arena 对象的时候使用了 <code>SetFinalizer</code> 这样一个函数</p><p>带着问题看世界</p><ol><li>它有什么用</li><li>它怎么用</li><li>它有什么缺点导致不是随处可见这种用法</li></ol><p>这里来详细看看它的作用，备注如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SetFinalizer sets the finalizer associated with obj to the provided finalizer function. When the garbage collector finds an unreachable block with an associated finalizer, it clears the association and runs finalizer(obj) in a separate goroutine. This makes obj reachable again,</span><br><span class="line">but now without an associated finalizer. Assuming that SetFinalizer is not called again, the next time the garbage collector sees that obj is unreachable, it will free obj.</span><br></pre></td></tr></table></figure><p>大意是：<strong>为对象提供一个析构函数，当GC发现不可达对象带有析构函数的时候，会单独使用协程执行这个析构函数。这样对GC来说对象是可达但没有了析构函数，下次GC发现对象不可达就会释放掉对象</strong></p><p>有一些协程的生命周期是与整个服务一致的，比如定时清理机制，它的好处是自动处理一些业务而不需要人工调用，但如果是在一些与业务完全分离的场景。比如为业务提供一个缓存池，缓存池中为了清理过期的缓存而设计了一个常驻协程。是否可以使用 <code>SetFinalizer</code> 的过期删除机制</p><p>首先看一个栗子：</p><p>一般情况我们会提供对象一个 <code>Close()</code>函数用于业务在不需要的时候清理对象，这里就可以用到这个 <code>SetFinalizer</code>，如 <code>os.NewFile</code> 就注册了 <code>SetFinalizer</code>逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newFile</span><span class="params">(fd <span class="keyword">uintptr</span>, name <span class="keyword">string</span>, kind newFileKind)</span> *<span class="title">File</span></span> &#123;</span><br><span class="line">fdi := <span class="keyword">int</span>(fd)</span><br><span class="line"><span class="keyword">if</span> fdi &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">f := &amp;File&#123;&amp;file&#123;</span><br><span class="line">pfd: poll.FD&#123;</span><br><span class="line">Sysfd:         fdi,</span><br><span class="line">IsStream:      <span class="literal">true</span>,</span><br><span class="line">ZeroReadIsEOF: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line">name:        name,</span><br><span class="line">stdoutOrErr: fdi == <span class="number">1</span> || fdi == <span class="number">2</span>,</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">runtime.SetFinalizer(f.file, (*file).<span class="built_in">close</span>)</span><br><span class="line"><span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">num  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">finalizer</span><span class="params">(f *Foo)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"a finalizer has run for "</span>, f.name, f.num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeFoo</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(a_foo *Foo)</span></span> &#123;</span><br><span class="line">a_foo = &amp;Foo&#123;name, counter&#125;</span><br><span class="line">counter++</span><br><span class="line">runtime.SetFinalizer(a_foo, finalizer)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">f1 := MakeFoo(<span class="string">"one"</span>)</span><br><span class="line">f2 := MakeFoo(<span class="string">"two"</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"f1 is: "</span>, f1.name)</span><br><span class="line">fmt.Println(<span class="string">"f2 is: "</span>, f2.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">Bar()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">runtime.GC()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"done."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f1 is:  one</span><br><span class="line">f2 is:  two</span><br><span class="line">a finalizer has run <span class="keyword">for</span>  two <span class="number">1</span></span><br><span class="line">a finalizer has run <span class="keyword">for</span>  one <span class="number">0</span></span><br><span class="line">f1 is:  one</span><br><span class="line">f2 is:  two</span><br><span class="line">a finalizer has run <span class="keyword">for</span>  two <span class="number">3</span></span><br><span class="line">a finalizer has run <span class="keyword">for</span>  one <span class="number">2</span></span><br><span class="line">f1 is:  one</span><br><span class="line">f2 is:  two</span><br><span class="line">a finalizer has run <span class="keyword">for</span>  two <span class="number">5</span></span><br><span class="line">a finalizer has run <span class="keyword">for</span>  one <span class="number">4</span></span><br><span class="line">done.</span><br></pre></td></tr></table></figure><p>注意事项</p><ol><li>obj 必须是指针</li><li><code>SetFinalizer</code> 执行顺序按照类似对象的出栈顺序</li><li>可以通过 <code>SetFinalizer(obj, nil)</code> 清理对象的析构器</li></ol><p>栗子2，它的实际效果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"runtime/debug"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">debug.SetGCPercent(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ms runtime.MemStats</span><br><span class="line">runtime.ReadMemStats(&amp;ms)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Allocation: %f Mb, Number of allocation: %d\n"</span>, <span class="keyword">float32</span>(ms.HeapAlloc)/<span class="keyword">float32</span>(<span class="number">1024</span>*<span class="number">1024</span>), ms.HeapObjects)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</span><br><span class="line">f := NewFoo(i)</span><br><span class="line">_ = fmt.Sprintf(<span class="string">"%d"</span>, f.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runtime.ReadMemStats(&amp;ms)</span><br><span class="line">fmt.Printf(<span class="string">"Allocation: %f Mb, Number of allocation: %d\n"</span>, <span class="keyword">float32</span>(ms.HeapAlloc)/<span class="keyword">float32</span>(<span class="number">1024</span>*<span class="number">1024</span>), ms.HeapObjects)</span><br><span class="line"></span><br><span class="line">runtime.GC()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">runtime.ReadMemStats(&amp;ms)</span><br><span class="line">fmt.Printf(<span class="string">"Allocation: %f Mb, Number of allocation: %d\n"</span>, <span class="keyword">float32</span>(ms.HeapAlloc)/<span class="keyword">float32</span>(<span class="number">1024</span>*<span class="number">1024</span>), ms.HeapObjects)</span><br><span class="line"></span><br><span class="line">runtime.GC()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">runtime.ReadMemStats(&amp;ms)</span><br><span class="line">fmt.Printf(<span class="string">"Allocation: %f Mb, Number of allocation: %d\n"</span>, <span class="keyword">float32</span>(ms.HeapAlloc)/<span class="keyword">float32</span>(<span class="number">1024</span>*<span class="number">1024</span>), ms.HeapObjects)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFoo</span><span class="params">(i <span class="keyword">int</span>)</span> *<span class="title">Foo</span></span> &#123;</span><br><span class="line">f := &amp;Foo&#123;a: rand.Intn(<span class="number">50</span>)&#125;</span><br><span class="line">runtime.SetFinalizer(f, <span class="function"><span class="keyword">func</span><span class="params">(f *Foo)</span></span> &#123;</span><br><span class="line">_ = fmt.Sprintf(<span class="string">"foo "</span> + strconv.Itoa(i) + <span class="string">" has been garbage collected"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Allocation: <span class="number">0.121063</span> Mb, Number of allocation: <span class="number">140</span></span><br><span class="line">Allocation: <span class="number">29.111671</span> Mb, Number of allocation: <span class="number">1899990</span></span><br><span class="line">Allocation: <span class="number">128.025635</span> Mb, Number of allocation: <span class="number">4382420</span></span><br><span class="line">Allocation: <span class="number">0.122147</span> Mb, Number of allocation: <span class="number">155</span></span><br></pre></td></tr></table></figure><p>可以看出，正如它功能说的一样，在第二次GC之后，分配的内存被释放</p><p>它也有缺点：</p><ol><li><code>SetFinalizer</code> 最大的问题是延长了对象生命周期。在第一次回收时执行 Finalizer 函数，且目标对象重新变成可达状态，直到第二次才真正 “销毁”。这对于有大量对象分配的高并发算法，可能会造成很大麻烦</li><li>指针构成的 “循环引⽤” 加上 <code>runtime.SetFinalizer</code> 会导致内存泄露</li><li><code>SetFinalizer</code>只在GC 发现对象不可达之后的任意时间执行，所以如果程序正常结束或者发生错误，而对象还没有被GC选中那么 <code>SetFinalizer</code> 也不会执行。</li></ol><p>所以保险起见还是提供了 <code>Close()</code> 逻辑供业务调用</p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/76504936" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/76504936</a></li><li><a href="https://go.dev/play/p/jWhRSPNvxJ" target="_blank" rel="noopener">https://go.dev/play/p/jWhRSPNvxJ</a></li><li><a href="https://medium.com/a-journey-with-go/go-finalizers-786df8e17687" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-finalizers-786df8e17687</a></li><li><code>runtime/mfinal.go</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在阅读Go 1.20 新特性 arena 的时候，看到在构建 arena 对象的时候使用了 &lt;code&gt;SetFinalizer&lt;/code&gt; 这样一个函数&lt;/p&gt;
&lt;p&gt;带着问题看世界&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它有什么用&lt;/li&gt;
&lt;li&gt;它怎么用&lt;/li&gt;
&lt;li&gt;它
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>算法之美-八数码问题</title>
    <link href="http://xboom.github.io/2022/12/11/Algorithms%20To%20Live%20By/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>http://xboom.github.io/2022/12/11/Algorithms%20To%20Live%20By/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/</id>
    <published>2022-12-11T09:47:28.000Z</published>
    <updated>2022-12-11T09:47:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>八数码问题也称为九宫问题。在3×3的棋盘，摆有八个棋子，每个棋子上标有1至8的某一数字，不同棋子上标的数字不相同。棋盘上还有一个空格，与空格相邻的棋子可以移到空格中。要求解决的问题是：给出一个初始状态和一个目标状态，找出一种从初始转变成目标状态的移动棋子步数最少的移动步骤</p><blockquote><p>所谓一个状态就是棋子在棋盘上的一种摆法。棋子移动后，状态就会发生改变。实际上就是找出从初始状态到达目标状态所经过的一系列中间过渡状态</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-11-03_23-53-25_bashuma_1.png" alt="Snipaste_2022-11-03_23-53-25_bashuma_1" style="zoom:67%;" /><p>首先这个九宫格的状态数量是 9!，那么存在问题</p><ol><li><p>是否存在从一个状态转移到另外一个状态无解的情况？</p></li><li><p>如何计算或者衡量从一个转移到另外一个状态的需要走多少步？</p></li></ol><h3 id="排列的性质"><a class="markdownIt-Anchor" href="#排列的性质"></a> 排列的性质</h3><p>为了搞清楚上述问题，需要知道几个基本定义与引理</p><ol><li><p>把n个不同的元素按一定的顺序排列成一行，成为这n个元素的一个<strong>排列</strong>。n个不同元素的排列共有 <strong>n!</strong> 种</p></li><li><p>对于n个自然数的一个排列，如果一个大数排在一个小数之前，就称这两个数构成一个<strong>逆序</strong>。一个排列的逆序总和称为该排列的<strong>逆序对</strong>，记为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi><mo stretchy="false">(</mo><mi>j</mi><mn>1</mn><mi>j</mi><mn>2</mn><mo>⋯</mo><mi>j</mi><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>τ</mi><mo>∗</mo><mo stretchy="false">(</mo><mo>∗</mo><mi>j</mi><mo>∗</mo><mn>1</mn><mo>∗</mo><mi>j</mi><mo>∗</mo><mn>2</mn><mo>⋯</mo><mo>∗</mo><mi>j</mi><mo>∗</mo><mo>∗</mo><mi>n</mi><mo>∗</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">τ(j1j2⋯jn)*τ*(*j*1*j*2⋯*j**n*)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">∗</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∗</span><span class="mord mathdefault">n</span><span class="mord">∗</span><span class="mclose">)</span></span></span></span></p><blockquote><p>如5阶排列31542的逆序是(3,1),(3,2),(5,4),(5,2),(4,2),故 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi><mo stretchy="false">(</mo><mn>31542</mn><mo stretchy="false">)</mo><mo>=</mo><mn>5</mn><mo>∗</mo><mi>τ</mi><mo>∗</mo><mo stretchy="false">(</mo><mn>31542</mn><mo stretchy="false">)</mo><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">τ(31542)=5*τ*(31542)=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mopen">(</span><span class="mord">3</span><span class="mord">1</span><span class="mord">5</span><span class="mord">4</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mord">1</span><span class="mord">5</span><span class="mord">4</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span></p></blockquote></li><li><p>逆序对为奇数的排列称为<strong>奇排列</strong>。逆序对为偶数的排列称为<strong>偶排列</strong>。<strong>自然排列</strong> 123⋯<em>n</em>的逆序对为0，故它是偶排列</p></li><li><p>在一个排列中，把某两个数的位置互换（其他数不动）变成另一个排列的变动称为一个<strong>对换</strong>，将相邻的两个数对换称为<strong>相邻对换</strong></p></li></ol><h3 id="性质的证明"><a class="markdownIt-Anchor" href="#性质的证明"></a> 性质的证明</h3><p><strong>性质1</strong>：<strong>一个排列中的任意两个数对换后，排列改变奇偶性。即经过一次对换，奇排列变成偶排列，偶排列变成奇排列</strong></p><p>证明：</p><ol><li><p>先证明相邻对换的情形</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-11-05_23-25-04-bashuma2.png" alt="Snipaste_2022-11-05_23-25-04-bashuma2" style="zoom:50%;" /><ul><li><p>设排列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>s</mi></msub><mi>a</mi><mi>b</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 ... a_s a b b_1 b_2 ... b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，对换a 与 b 的排列变为  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>s</mi></msub><mi>b</mi><mi>a</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 ... a_s b a b_1 b_2 ... b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p></li><li><p>a 与 b 的 对换不影响  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 ... a_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">b_1 b_2 ... b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 与 其他数的关系</p></li><li><p>但a与b的序关系变为：</p><ul><li><p>当 a &lt; b 时，在新排列中 a 、b 构成逆序</p></li><li><p>当 a &gt; b 时，在新排列中 a、b 不构成逆序</p></li></ul></li><li><p>因此 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>s</mi></msub><mi>a</mi><mi>b</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 ... a_s a b b_1 b_2 ... b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 比  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>s</mi></msub><mi>b</mi><mi>a</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 ... a_s b a b_1 b_2 ... b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的逆序多1或者少1</p></li></ul></li><li><p>再证一般对换情形</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-11-05_23-30-29-bashuma3.png" alt="Snipaste_2022-11-05_23-30-29-bashuma3" style="zoom:50%;" /><ul><li>设存在排列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>s</mi></msub><mi>a</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>…</mo><msub><mi>b</mi><mi>m</mi></msub><mi>b</mi><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>…</mo><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 … a_s a b_1 b_2 … b_m b c_1 c_2 … c_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>将 b 做 m 次相邻对换变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>s</mi></msub><mi>a</mi><mi>b</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>…</mo><msub><mi>b</mi><mi>m</mi></msub><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>…</mo><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 … a_s a b b_1 b_2 … b_m c_1 c_2 … c_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>再将 a 做 (m + 1) 次相邻对换变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>s</mi></msub><mi>b</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>…</mo><msub><mi>b</mi><mi>m</mi></msub><mi>a</mi><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>…</mo><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 … a_s b b_1 b_2 … b_m a c_1 c_2 … c_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>所以 经过 (2m + 1) 次相邻兑换，可以把排列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>s</mi></msub><mi>a</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>…</mo><msub><mi>b</mi><mi>m</mi></msub><mi>b</mi><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>…</mo><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 … a_s a b_1 b_2 … b_m b c_1 c_2 … c_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>转变成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>s</mi></msub><mi>b</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>…</mo><msub><mi>b</mi><mi>m</mi></msub><mi>a</mi><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>…</mo><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 … a_s b b_1 b_2 … b_m a c_1 c_2 … c_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，这两个排列的奇偶性相反</li></ul></li></ol><p><strong>性质2：在全部的 n(n≥2)阶排列中，奇偶排列各占一半，各有 n!/2 个</strong></p><p>证明：</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-11-06_09-56-51-bashuma4.png" alt="Snipaste_2022-11-06_09-56-51-bashuma4" style="zoom:50%;" /><ul><li><p>假设在全部n级排列中共有t个奇排列，s个偶排列</p></li><li><p>将t个奇排列中的前两个数字对换，得到t个互不相同的偶排列。因此 t≤s</p></li><li><p>同理可证 s≤t</p></li><li><p>于是 s=t，即奇、偶排列的总数相等，各有 n!/2个</p></li></ul><p><strong>性质3：任意一个n阶排列都可以经过一系列对换变成自然排列，并且所作对换的次数与这个排列有相同的奇偶性</strong></p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-11-06_13-10-01-bashuma5.png" alt="Snipaste_2022-11-06_13-10-01-bashuma5" style="zoom:50%;" /><p>证明(归纳法)：</p><ul><li>1阶排列只有一个，结论显然成立</li><li>假设对n-1阶排列已经成立，证对n阶排列的情形结论也成立<ul><li>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mn>1</mn></msub><msub><mi>j</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>j</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">j_1 j_2 ... j_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是一个n阶排列<ul><li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mi>n</mi></msub><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">j_n=n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> ，假设n-1级排列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mn>1</mn></msub><msub><mi>j</mi><mn>2</mn></msub><mo>…</mo><msub><mi>j</mi><mi>n</mi></msub><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">j_1 j_2 … j_n−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 可以经过一系列变换变成自然序列，即 1 2 … n−1，于是这一系列对换也就把 j1j2⋯jn 变成 12⋯n 这种自然序列的形式。</li><li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mi>n</mi><mi mathvariant="normal">≠</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">jn≠n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，那么对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mn>1</mn></msub><msub><mi>j</mi><mn>2</mn></msub><mo>…</mo><msub><mi>j</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">j_1 j_2 … j_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">j_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 n 的对换，它就变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mn>1</mn></msub><msub><mi>j</mi><mn>2</mn></msub><mo>…</mo><msub><mi>j</mi><mi>n</mi></msub><mi mathvariant="normal">−</mi><mn>1</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">j_1 j_2 … j_n−1 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">−</span><span class="mord">1</span><span class="mord mathdefault">n</span></span></span></span> ，这就归结成上面的情形，因此</li></ul></li></ul></li></ul><p><strong>性质4：奇偶性与可达性关系与证明</strong></p><blockquote><p>必要性证明：排列的奇偶性不同则对应在八数码问题中不可达</p></blockquote><p>在满足上述约定的八数码问题中，空格与相邻棋子的交换不会改变棋局中棋子数列的逆序对的奇偶性</p><ul><li><p>空格与左右棋子交换：是不改变棋子数列的逆序对的(因为数列并没有改变)</p></li><li><p>空格与上下棋子交换：也是不改变棋子数列的逆序对的</p><ul><li>假设交换棋子为c[i]=X</li><li>原数列p=c[1]… X c[i+1]c[i+2]…c[8]将变为新数列q=c[1]…c[i+1]c[i+2]X …c[8]（注意：在棋盘中，上下相邻的两棋格之间隔有两个棋格）。可以解释为用X与c[i+1]、 c[i+2]先后进行两次相邻交换而完成状态转变。</li><li>由p状态到q状态并不会改变改变棋子数列的逆序对的奇偶性。同理可证空格与下方棋子交换也不会改变棋子数列的逆序对的奇偶性。所以，空格与相邻棋子的交换不会改变棋局中棋子数列的逆序对的奇偶性</li></ul></li></ul><p>得出 <strong>定理1：对于任意两个状态映射的序列，如果这两个状态等价，那么它们的逆序数相同</strong></p><blockquote><p>充分性证明：<strong>排列的奇偶性相同则对应在八数码问题中也可达</strong></p></blockquote><p>首先明确几个定义：</p><ul><li><p><strong>状态</strong>(<strong>state</strong>)：八数码中8个数字与0的排列被定义为八数码的<strong>状态</strong>，比如：</p></li><li><p><strong>状态空间</strong>(<strong>state space</strong>)：八数码所有状态的合集被称为<strong>状态空间</strong></p></li><li><p><strong>完全态</strong>(<strong>completeness</strong>)：当状态空间的子集中任何两个状态都能通过一定步骤得到，那么称这个状态空间的子集是<strong>完全态</strong></p></li><li><p><strong>状态映射</strong>(<strong>a sequence mapped by a state</strong>)：一个状态{}可以映射(忽略0)成一个排序，那么这个排列就称为这个<strong>状态的映射</strong></p></li><li><p><strong>标准格式(a standard form)</strong>：如果 0 在正中间，那么称这个状态为<strong>标准格式</strong></p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20221211150738067.png" alt="image-20221211150738067" style="zoom:50%;" /></li><li><p><strong>区域(field)</strong>：对于任意状态(state)，4个位置中任意两个都相邻，那么称之为 <strong>区域</strong>，特别的，当两个区域有相同的两个位置，则称为 <strong>同边区域</strong></p></li><li><p><strong>转圈(circle moving)</strong>：0在一个区域内移动称 <strong>转圈</strong></p></li></ul><p><strong>引理1：对于标准格式中的任意区域，转圈可以得到两个等价的区域</strong></p><p>考虑到 <strong>标准格式</strong> 的对称性，只需要考虑一个区域的的变化</p><p>第一种情况(顺时针方向部分先后): a b d</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121101.png" alt="bashuma-121101" style="zoom:50%;" /><p>第二种情况(顺时针方向不分先后): a d b</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121102.png" alt="bashuma-121102" /></p><p>接着考虑在一个标准格式中，在两个具有相同边的区域交换数据，由于标准格式的对称性，所以只考虑上半部分</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121103.png" alt="bashuma-121103" style="zoom:50%;" /><blockquote><p>这个图形转换根据上述原则手动绘制交换流程更容易理解</p></blockquote><p>得出的<strong>规律1</strong>: m 属于 {a ,d}，n 属于 {c, e}，p 属于 {a, d} 但 p != m，q 属于 {c, e}但 q != n，那么交换 m n，则 n 来到 m 之前的位置，而 m 来到 q 之前的位置，q 来到 n 之前的位置</p><p>得出的<strong>规律2</strong>：abc 可以经过转换编程 cab 或者 bac，不影响其他行且逆序对不变</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121104.png" alt="bashuma-121104" style="zoom:80%;" /><p>对于标准格式，如果它们的逆序对的奇偶性相同，那么它们是等价的</p><p>证明：</p><p>首先，将九宫格分为A、B、C、D分为四个区域</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121106.png" alt="bashuma-121106" style="zoom:50%;" /><p>第一步，将 h 移动到位置 位置 9，这是肯定可以的</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121107.png" alt="bashuma-121107" style="zoom:50%;" /><p>第二步，将 g、e 移动到区域D</p><blockquote><p>为什么不考虑g、e的顺序，因为可以在不影响h的情况下 g 在 位置 6 与 位置8 任意切换</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121112.png" alt="bashuma-121112" style="zoom:50%;" /><ul><li><p>2.1 如果 g、e 已经在区域D，那么不需要移动</p></li><li><p>2.2 如果其中 g 在 区域D，而e 在其他区域</p><ul><li><p>2.2.1 e 在区域A</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121109.png" alt="bashuma-121109" style="zoom:50%;" /></li><li><p>2.2.2 e 在区域B</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-12-11_16-55-10.png" alt="Snipaste_2022-12-11_16-55-10" style="zoom:50%;" /></li><li><p>2.2.3 e 在区域C</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121111.png" alt="bashuma-121111" style="zoom:50%;" /></li></ul><p>第三步，将 b、c 移动到 B区域</p><ul><li><p>3.1 如果 b、c 都在区域 B，那么不需要移动</p></li><li><p>3.2 如果 b、c 有一个在区域B，那么</p><blockquote><p>b 、c 的位置也同样可以忽略，如果b、c是正常顺序，那么也可以在不影响 g e h 位置的情况下调整 b c 的顺序</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-1211-13.png" alt="bashuma-1211-13" style="zoom:50%;" /><ul><li><p>3.1.1 如果在位置3</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma121110.png" alt="bashuma121110" style="zoom:50%;" /></li><li><p>3.1.2 如果在位置2，那么先将c移动位置3再执行上述步骤</p></li></ul></li><li><p>如果 b、c 都不在区域B，同理将c 移动到位置3，然后在执行上述3.1.1 步骤</p></li></ul></li></ul><p>第四步，在不影响bcehg的情况下调整adf的顺序</p><ul><li>规律二在 此场景下仍然适用，所以首先将防止到位置7</li><li>根据定理1，如果两者等价，那么它们的逆序对是相同的。而如果位置1与位置3交换其他位置不变，那边整个序列的逆序对是变化的。所以a一定在位置1，d在位置4</li></ul><p>所以，如果奇偶性相同，那么两个状态都能转换成一个相同的标准状态，那么两个状态之间是可达的</p><p>得出结论：<strong>两个排列的逆序对奇偶性相同，那么在八数码中必可达</strong></p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://blog.csdn.net/u011008379/article/details/40144147" target="_blank" rel="noopener">https://blog.csdn.net/u011008379/article/details/40144147</a></li><li><a href="https://chengfeng96.com/blog/2018/05/26/%E5%88%A9%E7%94%A8BFS%EF%BC%8CDFS%EF%BC%8CA-%E8%A7%A3%E5%86%B3%E5%85%AB%E6%95%B0%E7%A0%81%E9%9A%BE%E9%A2%98/" target="_blank" rel="noopener">https://chengfeng96.com/blog/2018/05/26/利用BFS，DFS，A-解决八数码难题/</a></li><li><a href="http://www.huaying1988.com/blogs/8_Puzzle_StrictProof_SolutionAlgorithm_AndOthers/detail.html" target="_blank" rel="noopener">http://www.huaying1988.com/blogs/8_Puzzle_StrictProof_SolutionAlgorithm_AndOthers/detail.html</a></li><li>《A constructive proof for the subsets completeness of 8-Puzzle state space》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;八数码问题也称为九宫问题。在3×3的棋盘，摆有八个棋子，每个棋子上标有1至8的某一数字，不同棋子上标的数字不相同。棋盘上还有一个空格，与空格相邻的棋子可以移到空格中。要求解决的问题是：给出一个初始状态和一个目标状态，找出一种从初始转变成目标状态的移动棋子步数最少的移动步骤&lt;
      
    
    </summary>
    
    
      <category term="Algorithms To Live By" scheme="http://xboom.github.io/categories/Algorithms-To-Live-By/"/>
    
    
      <category term="Algorithms To Live By" scheme="http://xboom.github.io/tags/Algorithms-To-Live-By/"/>
    
  </entry>
  
  <entry>
    <title>Go入门22-Goland激活</title>
    <link href="http://xboom.github.io/2022/12/09/Go/Go%E5%85%A5%E9%97%A822-Goland%E6%BF%80%E6%B4%BB/"/>
    <id>http://xboom.github.io/2022/12/09/Go/Go%E5%85%A5%E9%97%A822-Goland%E6%BF%80%E6%B4%BB/</id>
    <published>2022-12-09T08:00:20.000Z</published>
    <updated>2023-05-28T01:52:00.096Z</updated>
    
    <content type="html"><![CDATA[<p>Goland好用但是激活太贵，网上找了一个使用激活服务器的办法， Goland 2022.2.2 激活成功</p><blockquote><p>最好支持正版！！！</p></blockquote><p>第一步：首先打开网址 <a href="https://search.censys.io" target="_blank" rel="noopener">https://search.censys.io</a></p><p>第二步：搜索信息 <code>services.http.response.headers.location: account.jetbrains.com/fls-auth</code></p><p>第三步：点击搜索到的网址信息</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/goland-acitve-1.png" alt="goland-acitve-1" /></p><p>第四步：找到状态为302的信息网址信息，如果没有找到请重复第三步</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/goland-acitve-302.png" alt="goland-acitve-302" /></p><p>第五步：复制上一步信息中的Details信息，这里是 <code>https://188.210.42.106</code></p><p>第六步：将地址信息填入 goland 中的 Licence Service 并点击 Acitve 激活</p><p>第七步：如果激活成功将出现下图所示，否则重复第三步</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/goland-acitve-success.png" alt="goland-acitve-success" /></p><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://dushusir.com/jetbrains/" target="_blank" rel="noopener">https://dushusir.com/jetbrains/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Goland好用但是激活太贵，网上找了一个使用激活服务器的办法， Goland 2022.2.2 激活成功&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最好支持正版！！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一步：首先打开网址 &lt;a href=&quot;https://sear
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-14-健康检查</title>
    <link href="http://xboom.github.io/2022/11/04/Grpc/Grpc-14-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/"/>
    <id>http://xboom.github.io/2022/11/04/Grpc/Grpc-14-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/</id>
    <published>2022-11-04T14:58:29.000Z</published>
    <updated>2023-05-27T10:56:13.039Z</updated>
    
    <content type="html"><![CDATA[<p>前面学习了保持链接，这里看一下健康检查</p><p>带着问题看世界</p><ol><li>健康检查的作用</li><li>健康检查的原理</li><li>保持链接与健康检查的区别</li></ol><p>首先看一下源码例子中的ReadMe说明，gRPC提供了一个健康检查库，用于向客户端通报系统的健康状况。它通过使用health/v1 API提供服务定义。通过使用健康检查库，客户端可以在遇到问题时优雅地避免使用服务器。大多数语言都提供了现成的实现，这使得它在不同系统之间可以互操作。内置健康检查的优势</p><ul><li>健康检查的格式与普通的RPC一样</li><li>重用现有的配额等机制，内部对健康检查有完全的控制权</li></ul><h3 id="基本使用"><a class="markdownIt-Anchor" href="#基本使用"></a> 基本使用</h3><p>内部定义了健康检查的 proto</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> grpc.health.v1;</span><br><span class="line"></span><br><span class="line">message HealthCheckRequest &#123;</span><br><span class="line">  <span class="keyword">string</span> service = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HealthCheckResponse &#123;</span><br><span class="line">  enum ServingStatus &#123;</span><br><span class="line">    UNKNOWN = <span class="number">0</span>;</span><br><span class="line">    SERVING = <span class="number">1</span>;</span><br><span class="line">    NOT_SERVING = <span class="number">2</span>;</span><br><span class="line">    SERVICE_UNKNOWN = <span class="number">3</span>;  <span class="comment">// Used only by the Watch method.</span></span><br><span class="line">  &#125;</span><br><span class="line">  ServingStatus status = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service Health &#123;</span><br><span class="line">  rpc Check(HealthCheckRequest) returns (HealthCheckResponse);</span><br><span class="line"></span><br><span class="line">  rpc Watch(HealthCheckRequest) returns (stream HealthCheckResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共有两种方式进行健康检查</p><ul><li><code>Check</code> 探测服务器的健康状态</li><li><code>Watch</code> 观察服务端变化，这里注意 是一个<code>服务端流</code>，也就是客户端不断会收到服务端的状态更新</li></ul><p>一般，客户端不需要手动执行 <code>Check</code>操作，而是通过配置 <code>healthCheckConfig</code> ，它会在内部自动执行 <code>Watch</code>操作</p><h4 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import grpc/health to enable transparent client side checking </span></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">"google.golang.org/grpc/health"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set up appropriate service config</span></span><br><span class="line">serviceConfig := grpc.WithDefaultServiceConfig(<span class="string">`&#123;</span></span><br><span class="line"><span class="string">  "loadBalancingPolicy": "round_robin",</span></span><br><span class="line"><span class="string">  "healthCheckConfig": &#123;</span></span><br><span class="line"><span class="string">    "serviceName": ""</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;`</span>)</span><br><span class="line"></span><br><span class="line">conn, err := grpc.Dial(..., serviceConfig)</span><br></pre></td></tr></table></figure><h4 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h4><p>启动一个协程，来模拟服务端状态变化，核心逻辑就是设置服务的状态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">port  = flag.Int(<span class="string">"port"</span>, <span class="number">50051</span>, <span class="string">"the port to serve on"</span>)</span><br><span class="line">sleep = flag.Duration(<span class="string">"sleep"</span>, time.Second*<span class="number">5</span>, <span class="string">"duration between changes in health"</span>)</span><br><span class="line"></span><br><span class="line">system = <span class="string">""</span> <span class="comment">// empty string represents the health of the system</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line">lis, err := net.Listen(<span class="string">"tcp"</span>, fmt.Sprintf(<span class="string">":%d"</span>, *port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to listen: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s := grpc.NewServer()</span><br><span class="line">healthcheck := health.NewServer()</span><br><span class="line">healthpb.RegisterHealthServer(s, healthcheck)<span class="comment">//健康检查</span></span><br><span class="line">pb.RegisterEchoServer(s, &amp;echoServer&#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//健康状态更新</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// asynchronously inspect dependencies and toggle serving status as needed</span></span><br><span class="line">next := healthpb.HealthCheckResponse_SERVING</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">healthcheck.SetServingStatus(system, next)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> next == healthpb.HealthCheckResponse_SERVING &#123;</span><br><span class="line">next = healthpb.HealthCheckResponse_NOT_SERVING</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">next = healthpb.HealthCheckResponse_SERVING</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(*sleep)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to serve: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>健康服务器可以返回四种状态：<code>UNKNOWN</code>、<code>SERVING</code>、<code>NOT_SERVING</code>和<code>SERVICE_UNKNOWN</code>。</p><ul><li><p><code>UNKNOWN</code> 表示当前状态尚未知晓。在服务器实例启动时经常会看到这种状态。</p></li><li><p><code>SERVING</code> 表示系统健康，准备好提供服务请求。</p></li><li><p><code>NOT_SERVING</code> 表示系统当前无法处理请求。</p></li><li><p><code>SERVICE_UNKNOWN</code> 表示客户端请求的服务名未被服务器所知。此状态仅由 <code>Watch()</code> 调用报告</p></li></ul><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><h4 id="客户端-2"><a class="markdownIt-Anchor" href="#客户端-2"></a> 客户端</h4><p>客户端默认初始化<code>Watch</code>函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">   internal.HealthCheckFunc = clientHealthCheck</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> healthCheckMethod = <span class="string">"/grpc.health.v1.Health/Watch"</span><span class="comment">//指定健康检查方法名称</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clientHealthCheck</span><span class="params">(ctx context.Context, newStream <span class="keyword">func</span>(<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>, <span class="title">setConnectivityState</span> <span class="title">func</span><span class="params">(connectivity.State, error)</span>, <span class="title">service</span> <span class="title">string</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">   tryCnt := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">retryConnection:</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">//退避重试</span></span><br><span class="line">      <span class="keyword">if</span> tryCnt &gt; <span class="number">0</span> &amp;&amp; !backoffFunc(ctx, tryCnt<span class="number">-1</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">      tryCnt++</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ctx.Err() != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">      setConnectivityState(connectivity.Connecting, <span class="literal">nil</span>)<span class="comment">//设置状态</span></span><br><span class="line">      rawS, err := newStream(healthCheckMethod)<span class="comment">//构建流链接</span></span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">continue</span> retryConnection</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      s, ok := rawS.(grpc.ClientStream)</span><br><span class="line">      <span class="keyword">if</span> !ok &#123;</span><br><span class="line">         setConnectivityState(connectivity.Ready, <span class="literal">nil</span>)<span class="comment">//服务端健康</span></span><br><span class="line">         <span class="keyword">return</span> fmt.Errorf(<span class="string">"newStream returned %v (type %T); want grpc.ClientStream"</span>, rawS, rawS)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> err = s.SendMsg(&amp;healthpb.HealthCheckRequest&#123;Service: service&#125;); err != <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123;</span><br><span class="line">         <span class="comment">// Stream should have been closed, so we can safely continue to create a new stream.</span></span><br><span class="line">         <span class="keyword">continue</span> retryConnection</span><br><span class="line">      &#125;</span><br><span class="line">      s.CloseSend()</span><br><span class="line"></span><br><span class="line">      resp := <span class="built_in">new</span>(healthpb.HealthCheckResponse)</span><br><span class="line">      <span class="keyword">for</span> &#123;<span class="comment">//不断接收服务端响应</span></span><br><span class="line">         err = s.RecvMsg(resp)</span><br><span class="line"></span><br><span class="line">         <span class="comment">// </span></span><br><span class="line">         <span class="keyword">if</span> status.Code(err) == codes.Unimplemented &#123;<span class="comment">//表示服务端未支持健康检查</span></span><br><span class="line">            setConnectivityState(connectivity.Ready, <span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 其他错误</span></span><br><span class="line">         <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            setConnectivityState(connectivity.TransientFailure, fmt.Errorf(<span class="string">"connection active but received health check RPC error: %v"</span>, err))</span><br><span class="line">            <span class="keyword">continue</span> retryConnection</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//收到消息那么</span></span><br><span class="line">         tryCnt = <span class="number">0</span></span><br><span class="line">         <span class="keyword">if</span> resp.Status == healthpb.HealthCheckResponse_SERVING &#123;</span><br><span class="line">            setConnectivityState(connectivity.Ready, <span class="literal">nil</span>)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setConnectivityState(connectivity.TransientFailure, fmt.Errorf(<span class="string">"connection active but health check failed. status=%s"</span>, resp.Status))</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据策略启动健康检查，<strong>针对的是同一个域名对应的多个子地址</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启健康检查</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ac *addrConn)</span> <span class="title">startHealthCheck</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> healthcheckManagingState <span class="keyword">bool</span></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> !healthcheckManagingState &#123;</span><br><span class="line">         ac.updateConnectivityState(connectivity.Ready, <span class="literal">nil</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="comment">//... 判断健康检查是否开启</span></span><br><span class="line">   currentTr := ac.transport</span><br><span class="line">   newStream := <span class="function"><span class="keyword">func</span><span class="params">(method <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">      ac.mu.Lock()</span><br><span class="line">      <span class="keyword">if</span> ac.transport != currentTr &#123;</span><br><span class="line">         ac.mu.Unlock()</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.Canceled, <span class="string">"the provided transport is no longer valid to use"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      ac.mu.Unlock()</span><br><span class="line">      <span class="keyword">return</span> newNonRetryClientStream(ctx, &amp;StreamDesc&#123;ServerStreams: <span class="literal">true</span>&#125;, method, currentTr, ac)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//更新连接状态</span></span><br><span class="line">   setConnectivityState := <span class="function"><span class="keyword">func</span><span class="params">(s connectivity.State, lastErr error)</span></span> &#123;</span><br><span class="line">      ac.mu.Lock()</span><br><span class="line">      <span class="keyword">defer</span> ac.mu.Unlock()</span><br><span class="line">      <span class="keyword">if</span> ac.transport != currentTr &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      ac.updateConnectivityState(s, lastErr)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 独立协程去检查健康状态</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      err := ac.cc.dopts.healthCheckFunc(ctx, newStream, setConnectivityState, healthCheckConfig.ServiceName)</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">   &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以通过健康检查更新连接状态，但不是唯一更新连接状态的方式</p><h4 id="服务端-2"><a class="markdownIt-Anchor" href="#服务端-2"></a> 服务端</h4><h5 id="维护"><a class="markdownIt-Anchor" href="#维护"></a> 维护</h5><p>首先需要明白服务端是如何维护状态的 <code>SetServingStatus</code> 其实还是需要用户自定义状态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">SetServingStatus</span><span class="params">(service <span class="keyword">string</span>, servingStatus healthpb.HealthCheckResponse_ServingStatus)</span></span> &#123;</span><br><span class="line">   <span class="comment">//....</span></span><br><span class="line">   s.setServingStatusLocked(service, servingStatus)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">setServingStatusLocked</span><span class="params">(service <span class="keyword">string</span>, servingStatus healthpb.HealthCheckResponse_ServingStatus)</span></span> &#123;</span><br><span class="line">   s.statusMap[service] = servingStatus</span><br><span class="line">   <span class="keyword">for</span> _, update := <span class="keyword">range</span> s.updates[service] &#123;</span><br><span class="line">      <span class="comment">// Clears previous updates, that are not sent to the client, from the channel.</span></span><br><span class="line">      <span class="comment">// This can happen if the client is not reading and the server gets flow control limited.</span></span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-update:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Puts the most recent update to the channel.</span></span><br><span class="line">      update &lt;- servingStatus</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">statusMap <span class="keyword">map</span>[<span class="keyword">string</span>]healthpb.HealthCheckResponse_ServingStatus</span><br><span class="line">updates   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[healthgrpc.Health_WatchServer]<span class="keyword">chan</span> healthpb.HealthCheckResponse_ServingStatus</span><br></pre></td></tr></table></figure><p>这里的状态更新有两种</p><ol><li>更新 <code>statusMap[service]</code> 对应的服务状态</li><li>将状态写入到服务对应的隧道中，隧道中的状态则是通过<code>Watch</code>函数不断地通知客户端(不同的状态才会通知)</li></ol><p>这里有两种特殊的情况可以直接使用内置函数，就是服务恢复正常与停止服务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Shutdown</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s.mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line">   s.shutdown = <span class="literal">true</span></span><br><span class="line">   <span class="keyword">for</span> service := <span class="keyword">range</span> s.statusMap &#123;</span><br><span class="line">      s.setServingStatusLocked(service, healthpb.HealthCheckResponse_NOT_SERVING)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Resume</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s.mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line">   s.shutdown = <span class="literal">false</span></span><br><span class="line">   <span class="keyword">for</span> service := <span class="keyword">range</span> s.statusMap &#123;</span><br><span class="line">      s.setServingStatusLocked(service, healthpb.HealthCheckResponse_SERVING)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会统一更新服务的状态，而不需要单独设置某个服务的状态更新，一般用于服务启动与恢复。</p><p>接着就是接收客户端的健康检查请求</p><h5 id="check"><a class="markdownIt-Anchor" href="#check"></a> Check</h5><p>当客户端请求服务状态的时候，直接从状态服务中返回结果  <code>statusMap[in.Service]</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Check</span><span class="params">(ctx context.Context, in *healthpb.HealthCheckRequest)</span> <span class="params">(*healthpb.HealthCheckResponse, error)</span></span> &#123;</span><br><span class="line">   s.mu.RLock()</span><br><span class="line">   <span class="keyword">defer</span> s.mu.RUnlock()</span><br><span class="line">   <span class="keyword">if</span> servingStatus, ok := s.statusMap[in.Service]; ok &#123;</span><br><span class="line">      <span class="keyword">return</span> &amp;healthpb.HealthCheckResponse&#123;</span><br><span class="line">         Status: servingStatus,</span><br><span class="line">      &#125;, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.NotFound, <span class="string">"unknown service"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="watch"><a class="markdownIt-Anchor" href="#watch"></a> Watch</h5><p><code>watch</code> 其实就是服务端不断地将状态的变化通知给客户端</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Watch implements `service Health`.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Watch</span><span class="params">(in *healthpb.HealthCheckRequest, stream healthgrpc.Health_WatchServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   service := in.Service</span><br><span class="line">   <span class="comment">// update channel is used for getting service status updates.</span></span><br><span class="line">   update := <span class="built_in">make</span>(<span class="keyword">chan</span> healthpb.HealthCheckResponse_ServingStatus, <span class="number">1</span>)</span><br><span class="line">   s.mu.Lock()</span><br><span class="line">   <span class="comment">// Puts the initial status to the channel.</span></span><br><span class="line">   <span class="keyword">if</span> servingStatus, ok := s.statusMap[service]; ok &#123;</span><br><span class="line">      update &lt;- servingStatus<span class="comment">//如果服务状态存在，那么写入隧道中</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果不存在，则更新未知</span></span><br><span class="line">      update &lt;- healthpb.HealthCheckResponse_SERVICE_UNKNOWN</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注册状态</span></span><br><span class="line">   <span class="keyword">if</span> _, ok := s.updates[service]; !ok &#123;</span><br><span class="line">      s.updates[service] = <span class="built_in">make</span>(<span class="keyword">map</span>[healthgrpc.Health_WatchServer]<span class="keyword">chan</span> healthpb.HealthCheckResponse_ServingStatus)</span><br><span class="line">   &#125;</span><br><span class="line">   s.updates[service][stream] = update</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      s.mu.Lock()</span><br><span class="line">      <span class="built_in">delete</span>(s.updates[service], stream)</span><br><span class="line">      s.mu.Unlock()</span><br><span class="line">   &#125;()</span><br><span class="line">   s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> lastSentStatus healthpb.HealthCheckResponse_ServingStatus = <span class="number">-1</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">     </span><br><span class="line">      <span class="keyword">case</span> servingStatus := &lt;-update:<span class="comment">//监听 update</span></span><br><span class="line">         <span class="keyword">if</span> lastSentStatus == servingStatus &#123;<span class="comment">//与上一次的状态相同，那么就不会响应</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//否则发送状态</span></span><br><span class="line">         lastSentStatus = servingStatus</span><br><span class="line">         err := stream.Send(&amp;healthpb.HealthCheckResponse&#123;Status: servingStatus&#125;)</span><br><span class="line">         <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> status.Error(codes.Canceled, <span class="string">"Stream has ended."</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> &lt;-stream.Context().Done():</span><br><span class="line">         <span class="keyword">return</span> status.Error(codes.Canceled, <span class="string">"Stream has ended."</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li><p>心跳检查是为了客户端可以根据服务端状态进行自定义操作</p></li><li><p>心跳检查启动的时候启动了退避算法，gRPC默认的退避算法是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultConfig = Config&#123;</span><br><span class="line">BaseDelay:  <span class="number">1.0</span> * time.Second,</span><br><span class="line">Multiplier: <span class="number">1.6</span>,</span><br><span class="line">Jitter:     <span class="number">0.2</span>,</span><br><span class="line">MaxDelay:   <span class="number">120</span> * time.Second,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>Watch</code>中如果与上一次的状态没有变化，则不会通知客户端</p></li><li><p>健康检查针对的是具有相同地址的多个服务，一个服务异常整体连接在不会断开，而是更新连接状态</p><ul><li>针对不能提供服务的服务器端，客户端会将链接状态更新为<code>TransientFailure</code>，但是链接不会断的；当该连接的状态重新更新为<code>Ready</code>时，还可以继续创建流，传输数据。</li><li>针对可以对外提供服务的服务器端，客户端会将链接状态更新为<code>Ready</code>，生成<code>Picker</code>，即将此链接缓存到平衡器里，并且将链接状态更新为<code>Ready</code>，接下来，就可以创建流，传输数据了</li></ul></li><li><p>健康检查可以应用会更新连接状态，且不能自定义 <code>withHealthCheckFunc</code></p></li><li><p>如果在传输过程中收到服务端通知，由于数据发送存在重试机制，所以还是可以从平衡器中选择 <code>Ready</code> 的连接重新传输数据</p></li><li><p>健康检查与保持链接的区别</p><ol><li><code>keepalive</code>和<code>healthcheck</code>都是用于确保通信的可用性和健康状态的机制。</li><li><code>keepalive</code>是一种保持连接活动的机制，用于检测连接是否处于空闲状态，并在需要时发送ping帧以防止连接关闭。<code>keepalive</code>机制确保长时间的空闲连接不会被关闭，以避免重新建立连接的开销</li><li><code>healthcheck</code>是一种检查服务可用性的机制，用于检测服务器是否可用，以及在服务器不可用时采取相应的措施。<code>healthcheck</code>机制通过发送特定的RPC请求来检查服务器的可用性，并根据响应的状态码和错误信息来确定服务器的状态。</li></ol></li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://github.com/grpc/grpc/blob/master/doc/health-checking.md" target="_blank" rel="noopener">https://github.com/grpc/grpc/blob/master/doc/health-checking.md</a></li><li><a href="https://blog.csdn.net/u011582922/article/details/120052706" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/120052706</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面学习了保持链接，这里看一下健康检查&lt;/p&gt;
&lt;p&gt;带着问题看世界&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;健康检查的作用&lt;/li&gt;
&lt;li&gt;健康检查的原理&lt;/li&gt;
&lt;li&gt;保持链接与健康检查的区别&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先看一下源码例子中的ReadMe说明，gRPC提供了一
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-13-保持链接</title>
    <link href="http://xboom.github.io/2022/10/31/Grpc/Grpc-13-%E4%BF%9D%E6%8C%81%E9%93%BE%E6%8E%A5/"/>
    <id>http://xboom.github.io/2022/10/31/Grpc/Grpc-13-%E4%BF%9D%E6%8C%81%E9%93%BE%E6%8E%A5/</id>
    <published>2022-10-31T14:58:29.000Z</published>
    <updated>2023-05-27T10:56:04.414Z</updated>
    
    <content type="html"><![CDATA[<p>在学习的过程中看到了grpc-go中的两个概念 <strong>保持链接</strong> 和 <strong>心跳检查</strong>，这里先学习一下<strong>保持链接</strong></p><p>带着问题看世界</p><ol><li>保持链接的作用</li><li>保持链接的原理</li><li>它与TCP的 <code>keepalive</code> 有什么区别</li></ol><p>首先来看一下<a href="https://github.com/grpc/grpc-go/blob/master/Documentation/keepalive.md" target="_blank" rel="noopener">官方的介绍</a>，</p><ul><li><p>保持连接功能可以检测TCP层面的连接故障。在某些情况下，TCP连接会丢失数据包(包括FIN)，需要等待系统TCP超时时间(可能为30分钟)才能检测到故障。使用保持连接功能可以让gRPC更早地检测到这种故障</p></li><li><p>另外是保持连接活动，比如在L4代理中配置为关闭“空闲连接”的情况下，发送包活消息可以是连接不处于“空闲”状态</p></li></ul><p>这里补充一下TCP的 keepalive 的原理：</p><p>当一方发送一个数据包后，如果对方没有回应，那么TCP协议会按照指数退避的算法重新发送数据包，最多会重发12次。如果在这12次内仍然没有收到对方的响应，则会将连接标记为“超时”，并关闭连接。这个过程通常需要30分钟左右</p><blockquote><p>可以手动修改TCP默认的超时时间</p><p>sudo sysctl -w net.ipv4.tcp_keepalive_time=300</p></blockquote><h3 id="基本使用"><a class="markdownIt-Anchor" href="#基本使用"></a> 基本使用</h3><h4 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kacp = keepalive.ClientParameters&#123;</span><br><span class="line">   Time:                <span class="number">10</span> * time.Second, <span class="comment">// send pings every 10 seconds if there is no activity</span></span><br><span class="line">   Timeout:             time.Second,      <span class="comment">// wait 1 second for ping ack before considering the connection dead</span></span><br><span class="line">   PermitWithoutStream: <span class="literal">true</span>,             <span class="comment">// send pings even without active streams</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithKeepaliveParams(kacp))</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端的保持心跳参数一共有三个</p><ol><li><code>Time</code>：在没有活动的情况下，发送 ping 的时间间隔(<strong>不能少于10s</strong>)</li><li><code>Timeout</code>：等待ping确认的超时时间</li><li><code>PermitWithoutStream</code>：及时没有活动的流也要发送<code>ping</code>请求</li></ol><h4 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kaep = keepalive.EnforcementPolicy&#123;</span><br><span class="line">   MinTime:             <span class="number">5</span> * time.Second, <span class="comment">// If a client pings more than once every 5 seconds, terminate the connection</span></span><br><span class="line">   PermitWithoutStream: <span class="literal">true</span>,            <span class="comment">// Allow pings even when there are no active streams</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kasp = keepalive.ServerParameters&#123;</span><br><span class="line">   MaxConnectionIdle:     <span class="number">15</span> * time.Second, <span class="comment">// If a client is idle for 15 seconds, send a GOAWAY</span></span><br><span class="line">   MaxConnectionAge:      <span class="number">30</span> * time.Second, <span class="comment">// If any connection is alive for more than 30 seconds, send a GOAWAY</span></span><br><span class="line">   MaxConnectionAgeGrace: <span class="number">5</span> * time.Second,  <span class="comment">// Allow 5 seconds for pending RPCs to complete before forcibly closing connections</span></span><br><span class="line">   Time:                  <span class="number">5</span> * time.Second,  <span class="comment">// Ping the client if it is idle for 5 seconds to ensure the connection is still active</span></span><br><span class="line">   Timeout:               <span class="number">1</span> * time.Second,  <span class="comment">// Wait 1 second for the ping ack before assuming the connection is dead</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := grpc.NewServer(grpc.KeepaliveEnforcementPolicy(kaep), grpc.KeepaliveParams(kasp))</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一共有两个保活配置 <code>EnforcementPolicy</code> 与 <code>ServerParameters</code></p><p><code>EnforcementPolicy</code> 定义了服务端如何执行保活策略</p><ul><li><code>MinTime</code>：如果客户端每隔不到5秒就发送一个ping请求，服务器就终止连接</li><li><code>PermitWithoutStream</code>：表示即使没有活动的流，也允许ping请求</li></ul><p>ServerParameters 定义了保活</p><ul><li><code>MaxConnectionIdle</code>：如果客户端闲置超过 15 秒，则发送 <code>GOAWAY</code></li><li><code>MaxConnectionAge</code>： 如果任何连接存在时间超过 30 秒，则发送 <code>GOAWAY</code></li><li><code>MaxConnectionAgeGrace</code>：允许在强制关闭连接之前等待 5 秒钟以完成待处理的 <code>RPC</code></li><li><code>Time</code>：如果客户端闲置超过 5 秒钟，则发送 <code>ping</code> 以确保连接仍处于活动状态</li><li><code>Timeout</code>：等待 1 秒钟以获取 <code>ping</code> 的响应，在此之后假定连接已断开</li></ul><p><code>MaxConnectionAge</code>是指整个连接（connection）的最长存在时间，不是单个流(stream)的最长存在时间。当一个连接的时间超过了 <code>MaxConnectionAge</code> 指定的时间，服务器会发送一个 <code>GOAWAY</code> 帧，表示不再接受来自该连接的新流。任何新的流的创建请求都会被拒绝，并且服务器会等待 <code>MaxConnectionAgeGrace</code> 指定的一段时间，让尚未完成的 RPC 请求完成。在这段时间内，服务器不会发送任何新的数据帧，但仍会响应已有的流。</p><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><h4 id="客户端-2"><a class="markdownIt-Anchor" href="#客户端-2"></a> 客户端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newHTTP2Client</span><span class="params">(connectCtx, ctx context.Context, addr resolver.Address, opts ConnectOptions, onPrefaceReceipt <span class="keyword">func</span>()</span>, <span class="title">onGoAway</span> <span class="title">func</span><span class="params">(GoAwayReason)</span>, <span class="title">onClose</span> <span class="title">func</span><span class="params">()</span>) <span class="params">(_ *http2Client, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">kp := opts.KeepaliveParams</span><br><span class="line"><span class="comment">// Validate keepalive parameters.</span></span><br><span class="line"><span class="keyword">if</span> kp.Time == <span class="number">0</span> &#123;</span><br><span class="line">kp.Time = defaultClientKeepaliveTime</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> kp.Timeout == <span class="number">0</span> &#123;</span><br><span class="line">kp.Timeout = defaultClientKeepaliveTimeout</span><br><span class="line">&#125;</span><br><span class="line">keepaliveEnabled := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> kp.Time != infinity &#123;</span><br><span class="line"><span class="keyword">if</span> err = syscall.SetTCPUserTimeout(conn, kp.Timeout); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, connectionErrorf(<span class="literal">false</span>, err, <span class="string">"transport: failed to set TCP_USER_TIMEOUT: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">keepaliveEnabled = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//... </span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> t.keepaliveEnabled &#123;<span class="comment">//如果开启包活</span></span><br><span class="line">t.kpDormancyCond = sync.NewCond(&amp;t.mu)</span><br><span class="line"><span class="keyword">go</span> t.keepalive()</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是在构建链接的时候设置的超时时间 <code>SetTCPUserTimeout</code>，指定发送数据后多久没有收到确认信号就会超时。</p><ul><li>这是设置是设置网络层的，并不会影响gRPC应用层，因为gRPC超时会重试</li><li>并不是所有的操作系统都支持 <code>syscall.SetTCPUserTimeout</code>(可能老的操作系统不支持，Linux、Windows、MacOS都支持)</li></ul><p>如果开启保活，通过开启独立协程发送ping帧确保链接是活的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *http2Client)</span> <span class="title">keepalive</span><span class="params">()</span></span> &#123;</span><br><span class="line">   p := &amp;ping&#123;data: [<span class="number">8</span>]<span class="keyword">byte</span>&#123;&#125;&#125;</span><br><span class="line">   outstandingPing := <span class="literal">false</span> <span class="comment">//是否有等待响应的ping帧</span></span><br><span class="line">   timeoutLeft := time.Duration(<span class="number">0</span>)<span class="comment">//记录发送ping之后剩余时间</span></span><br><span class="line">   prevNano := time.Now().UnixNano() <span class="comment">//记录活动时间</span></span><br><span class="line">   timer := time.NewTimer(t.kp.Time)<span class="comment">//开启定时器</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">         lastRead := atomic.LoadInt64(&amp;t.lastRead)</span><br><span class="line">         <span class="keyword">if</span> lastRead &gt; prevNano &#123;<span class="comment">//自从上次定时器已经读取过了</span></span><br><span class="line">            outstandingPing = <span class="literal">false</span></span><br><span class="line">            <span class="comment">// Next timer should fire at kp.Time seconds from lastRead time.</span></span><br><span class="line">           <span class="comment">//重新计算下次触发定时器时间(从上次读取时间开始算)</span></span><br><span class="line">            timer.Reset(time.Duration(lastRead) + t.kp.Time - time.Duration(time.Now().UnixNano()))</span><br><span class="line">            prevNano = lastRead</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//outstandingPing  有等待响应的ping帧，且已经超时。表示链接超时关闭</span></span><br><span class="line">         <span class="keyword">if</span> outstandingPing &amp;&amp; timeoutLeft &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            t.Close(connectionErrorf(<span class="literal">true</span>, <span class="literal">nil</span>, <span class="string">"keepalive ping failed to receive ACK within timeout"</span>))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         t.mu.Lock()</span><br><span class="line">         <span class="keyword">if</span> t.state == closing &#123;<span class="comment">//如果链接的状态是关闭中，那么也退出</span></span><br><span class="line">            t.mu.Unlock()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//如果没有活动流，且没有活动流不允许发送ping帧</span></span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">len</span>(t.activeStreams) &lt; <span class="number">1</span> &amp;&amp; !t.kp.PermitWithoutStream &#123;</span><br><span class="line">            outstandingPing = <span class="literal">false</span></span><br><span class="line">            t.kpDormant = <span class="literal">true</span></span><br><span class="line">            t.kpDormancyCond.Wait() <span class="comment">//在初始化流或者关闭客户端的时候 会触发 t.kpDormancyCond.Signal()</span></span><br><span class="line">         &#125;</span><br><span class="line">         t.kpDormant = <span class="literal">false</span></span><br><span class="line">         t.mu.Unlock()</span><br><span class="line"></span><br><span class="line">         <span class="comment">//没有等待响应的ping帧，就发送ping帧</span></span><br><span class="line">         <span class="keyword">if</span> !outstandingPing &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            t.controlBuf.put(p)<span class="comment">//发送ping帧</span></span><br><span class="line">            timeoutLeft = t.kp.Timeout</span><br><span class="line">            outstandingPing = <span class="literal">true</span></span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         sleepDuration := minTime(t.kp.Time, timeoutLeft)</span><br><span class="line">         timeoutLeft -= sleepDuration</span><br><span class="line">         timer.Reset(sleepDuration)<span class="comment">//计算定时器下一次触发时间</span></span><br><span class="line">      <span class="keyword">case</span> &lt;-t.ctx.Done():</span><br><span class="line">         <span class="keyword">if</span> !timer.Stop() &#123;</span><br><span class="line">            &lt;-timer.C</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是根据 ping帧的状态以及链接是否有活动来计算发送ping帧时间。</p><p>有几个注意点</p><ol><li><p>如何判断有ping帧响应的</p><p>其实它并没有判断是有有相应帧，而是是否在指定时间内是否读取到消息即可</p></li><li><p>如果没有活动流又不允许非活动流发送ping，那么它是如何处理的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果没有活动流，且没有活动流不允许发送ping帧</span></span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">len</span>(t.activeStreams) &lt; <span class="number">1</span> &amp;&amp; !t.kp.PermitWithoutStream &#123;</span><br><span class="line">    outstandingPing = <span class="literal">false</span></span><br><span class="line">    t.kpDormant = <span class="literal">true</span></span><br><span class="line">    t.kpDormancyCond.Wait() <span class="comment">//在初始化流或者关闭客户端的时候 会触发 t.kpDormancyCond.Signal()</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>而出发 <code>kpDormancyCond.Signal()</code>的位置是 构建流或者关闭连接</p></li></ol><h4 id="服务端-2"><a class="markdownIt-Anchor" href="#服务端-2"></a> 服务端</h4><p>服务端同样也是使用独立协程来运行保活逻辑</p><ol><li>超过 最长闲置时间 <code>MaxConnectionIdle</code> 优雅的关闭连接</li><li>超过 最大连接时间 MaxConnectionAge 优雅的关闭连接</li><li>等待 <code>MaxConnectionAgeGrace</code> 后强制关闭连接。</li><li>以 <code>Time</code> 的频率发送 <code>ping</code> 确保连接存活，并在 <code>Timeout</code> 的额外时间内关闭无响应的连接</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *http2Server)</span> <span class="title">keepalive</span><span class="params">()</span></span> &#123;</span><br><span class="line">   p := &amp;ping&#123;&#125;</span><br><span class="line">   outstandingPing := <span class="literal">false</span> <span class="comment">//是否有等待响应帧</span></span><br><span class="line">   kpTimeoutLeft := time.Duration(<span class="number">0</span>)</span><br><span class="line">   prevNano := time.Now().UnixNano()</span><br><span class="line">   <span class="comment">// Initialize the different timers to their default values.</span></span><br><span class="line">   idleTimer := time.NewTimer(t.kp.MaxConnectionIdle)</span><br><span class="line">   ageTimer := time.NewTimer(t.kp.MaxConnectionAge)</span><br><span class="line">   kpTimer := time.NewTimer(t.kp.Time)</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      idleTimer.Stop()</span><br><span class="line">      ageTimer.Stop()</span><br><span class="line">      kpTimer.Stop()</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-idleTimer.C:<span class="comment">//闲置定时器</span></span><br><span class="line">         t.mu.Lock()</span><br><span class="line">         idle := t.idle</span><br><span class="line">         <span class="keyword">if</span> idle.IsZero() &#123; <span class="comment">//未闲置则重置最大闲置时间</span></span><br><span class="line">            t.mu.Unlock()</span><br><span class="line">            idleTimer.Reset(t.kp.MaxConnectionIdle)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         val := t.kp.MaxConnectionIdle - time.Since(idle)</span><br><span class="line">         t.mu.Unlock()</span><br><span class="line">         <span class="keyword">if</span> val &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            t.Drain()<span class="comment">//优雅关闭连接</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         idleTimer.Reset(val)<span class="comment">//重置闲置连接</span></span><br><span class="line">      <span class="keyword">case</span> &lt;-ageTimer.C:<span class="comment">//最长连接</span></span><br><span class="line">         t.Drain()</span><br><span class="line">         ageTimer.Reset(t.kp.MaxConnectionAgeGrace)</span><br><span class="line">         <span class="keyword">select</span> &#123;</span><br><span class="line">         <span class="keyword">case</span> &lt;-ageTimer.C:</span><br><span class="line">            <span class="comment">// Close the connection after grace period.</span></span><br><span class="line">            <span class="keyword">if</span> logger.V(logLevel) &#123;</span><br><span class="line">               logger.Infof(<span class="string">"transport: closing server transport due to maximum connection age."</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            t.Close()</span><br><span class="line">         <span class="keyword">case</span> &lt;-t.done:</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">case</span> &lt;-kpTimer.C:<span class="comment">//保活定时器</span></span><br><span class="line">         lastRead := atomic.LoadInt64(&amp;t.lastRead)</span><br><span class="line">         <span class="keyword">if</span> lastRead &gt; prevNano &#123;</span><br><span class="line">            <span class="comment">// There has been read activity since the last time we were</span></span><br><span class="line">            <span class="comment">// here. Setup the timer to fire at kp.Time seconds from</span></span><br><span class="line">            <span class="comment">// lastRead time and continue.</span></span><br><span class="line">            outstandingPing = <span class="literal">false</span></span><br><span class="line">            kpTimer.Reset(time.Duration(lastRead) + t.kp.Time - time.Duration(time.Now().UnixNano()))</span><br><span class="line">            prevNano = lastRead</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> outstandingPing &amp;&amp; kpTimeoutLeft &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> logger.V(logLevel) &#123;</span><br><span class="line">               logger.Infof(<span class="string">"transport: closing server transport due to idleness."</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            t.Close()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> !outstandingPing &#123;<span class="comment">//如果没有等待保活则发送保活帧</span></span><br><span class="line">            <span class="keyword">if</span> channelz.IsOn() &#123;</span><br><span class="line">               atomic.AddInt64(&amp;t.czData.kpCount, <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            t.controlBuf.put(p)</span><br><span class="line">            kpTimeoutLeft = t.kp.Timeout</span><br><span class="line">            outstandingPing = <span class="literal">true</span></span><br><span class="line">         &#125;</span><br><span class="line">         sleepDuration := minTime(t.kp.Time, kpTimeoutLeft)</span><br><span class="line">         kpTimeoutLeft -= sleepDuration</span><br><span class="line">         kpTimer.Reset(sleepDuration)</span><br><span class="line">      <span class="keyword">case</span> &lt;-t.done:</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：</p><ol><li><p>连接什么时候闲置的?</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(t.activeStreams) == <span class="number">1</span> &#123;</span><br><span class="line">  t.idle = time.Time&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在处理头帧的时候(构建了一个活跃流)，如果 <code>len(t.activeStreams) == 1</code> ，表示刚新建一个流且仅有一个活跃流，那么这个时候连接是闲置的</p></li><li><p>服务端也会主动发送ping帧</p></li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li><p>TCP与gRPC的区别</p><p>TCP的Keepalive是一种机制，它允许在网络连接空闲时发送探测包（keepalive包）来维护连接的状态。这些探测包不包含有效负载，只是一个空的TCP报文段，主要用于检测连接是否仍然活着。</p><p>当TCP连接上没有传输数据时会进入空闲状态，即使连接已经中断或不可用，导致不必要的延迟和资源浪费。Keepalive机制可以在连接空闲时周期性地发送探测包，以检测连接是否仍然活着。如果远程端点没有响应这些探测包，则可以视为连接已经断开，并且可以关闭连接。</p><p>在gRPC中，使用Keepalive可以检测底层TCP连接是否失效，并在检测到连接问题时及时重新建立连接，从而提高网络连接的可靠性和性能。</p></li><li><p>客户端与服务端都会根据配置向对端发送ping帧，只要在指定时间内读取到帧，那么就不会主动发送ping帧</p></li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://blog.csdn.net/u011582922/article/details/120279303" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/120279303</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习的过程中看到了grpc-go中的两个概念 &lt;strong&gt;保持链接&lt;/strong&gt; 和 &lt;strong&gt;心跳检查&lt;/strong&gt;，这里先学习一下&lt;strong&gt;保持链接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;带着问题看世界&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;保持链接的作用&lt;/l
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-02-平衡器</title>
    <link href="http://xboom.github.io/2022/10/28/Grpc/Grpc-12-%E5%B9%B3%E8%A1%A1%E5%99%A8/"/>
    <id>http://xboom.github.io/2022/10/28/Grpc/Grpc-12-%E5%B9%B3%E8%A1%A1%E5%99%A8/</id>
    <published>2022-10-28T14:58:29.000Z</published>
    <updated>2023-05-27T10:55:56.060Z</updated>
    
    <content type="html"><![CDATA[<p>平衡器的核心目的就是用于向服务端发起链接，主要包括</p><ul><li>子链接的维护，每个 target 可能对应多个地址(类似一个服务有多个副本)，进行子链接的新增与删除</li><li>当平衡器状态发生变化，更新 <code>ClientConn</code> 的状态，自定义选择器，从而让客户端选择具体子链接进行发送</li><li>在满足一定条件的情况下，执行解析器操作。如解析器由阻塞状态 --&gt; 非阻塞状态</li></ul><h4 id="整体流程"><a class="markdownIt-Anchor" href="#整体流程"></a> 整体流程</h4><h4 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h4><p>代码路径:<code>/balancer/balancer.go</code>，在这个文件中一共定义了五个接口</p><ul><li><strong>Builder 接口</strong>，主要用来创建平衡器</li><li><strong>SubConn 接</strong>口，主要用来负责具体的链接(<strong>这里的链接指的是一对实际建立链接的客户端与服务器</strong>)</li><li><strong>Picker 接口</strong>，主要是从众多 <code>SubConn</code>中按照某个策略选择一个链接进行数据传输，也就是 <strong>选择器</strong></li><li><strong>Balancer 接口</strong>，主要是更新 <code>ClientConn</code> 的状态，更新<code>SubConn</code>状态</li><li><strong>ClientConn 接口</strong>，主要是负责链路的维护，包括创建、移除、更新一个子链路，更新 <code>ClientConn</code> 状态</li></ul><p>所以平衡器也跟解析器一样，由两部分组成平衡器构建器与平衡器，内部在封装到一个结构体实现平衡器功能</p><h4 id="平衡器构建器注册"><a class="markdownIt-Anchor" href="#平衡器构建器注册"></a> 平衡器构建器注册</h4><p>平衡器构建器通过注册的方式将自己平衡器的构建方法存入全局变量中，当需要使用的时候则直接根据名称获取</p><ol><li><p>使用一个全局的 map  <code>var m = make(map[string]Builder)</code>进行平衡器构建器 <code>Builder</code> 的存储。k/v 分别对应的是构建 构建器的名称以及构建器的实现方法。</p></li><li><p>平衡器构建器可以通过 <code>Register</code> 函数存储到这个 map 中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Register 注册平衡器构建器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Register</span><span class="params">(b Builder)</span></span> &#123;</span><br><span class="line">m[strings.ToLower(b.Name())] = b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Get 获取平衡器构建器，如果找不到则返回nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Builder</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> b, ok := m[strings.ToLower(name)]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>有了存储与添加，它还增加了一个删除操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//仅做测试使用，去掉某一个平衡器解析器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unregisterForTesting</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(m, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">internal.BalancerUnregister = unregisterForTesting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除操作则是利用 <code>init</code> 给 <code>BalancerUnregister</code> 复制一个 删除函数 <code>unregisterForTesting</code></p></li><li><p>而一个普通的平衡器构建器(已轮询平衡器构建器为例<code>rrPickerBuilder</code>)，则是利用 init 函数直接初始化到这个全局map中，那么就可以在需要使用的时候，直接从全局map 中获取</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Name = <span class="string">"round_robin"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个平衡器构建器对洗那个</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newBuilder</span><span class="params">()</span> <span class="title">balancer</span>.<span class="title">Builder</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> base.NewBalancerBuilder(Name, &amp;rrPickerBuilder&#123;&#125;, base.Config&#123;HealthCheck: <span class="literal">true</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化将 round_robin平衡器构建器存入全局 map 中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">balancer.Register(newBuilder())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="构建平衡器"><a class="markdownIt-Anchor" href="#构建平衡器"></a> 构建平衡器</h4><p>有了平衡器构建器之后，通过选定的平衡器构建器进行平衡器的构建</p><ol><li><p>设置通过哪个平衡器构建器获取平衡器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serviceConfig = <span class="string">`&#123;</span></span><br><span class="line"><span class="string">"loadBalancingConfig": [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">"grpclb": &#123;</span></span><br><span class="line"><span class="string">"childPolicy": [</span></span><br><span class="line"><span class="string">&#123;"round_robin": ""&#125;,</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line">grpc.WithDefaultServiceConfig(serviceConfig)</span><br></pre></td></tr></table></figure><p>如果不设置负载均衡构建器名称，那么grpc-go 会默认使用 <code>round_robin</code> 构建平衡器</p></li><li><p>指定了构建器之后就会在构建链接过程中调用构建函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialContext</span><span class="params">(ctx context.Context, target <span class="keyword">string</span>, opts ...DialOption)</span> <span class="params">(conn *ClientConn, err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//...                                                                                                      </span></span><br><span class="line">    cc.balancerWrapper = newCCBalancerWrapper(cc, balancer.BuildOptions&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在建立连接的过程中，通过</p></li></ol><h4 id="构建链接"><a class="markdownIt-Anchor" href="#构建链接"></a> 构建链接</h4><h4 id="存储链接"><a class="markdownIt-Anchor" href="#存储链接"></a> 存储链接</h4><h4 id="实际应用"><a class="markdownIt-Anchor" href="#实际应用"></a> 实际应用</h4><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://blog.csdn.net/u011582922/article/details/117547171" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/117547171</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平衡器的核心目的就是用于向服务端发起链接，主要包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子链接的维护，每个 target 可能对应多个地址(类似一个服务有多个副本)，进行子链接的新增与删除&lt;/li&gt;
&lt;li&gt;当平衡器状态发生变化，更新 &lt;code&gt;ClientConn&lt;/code&gt; 
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-03-选择器</title>
    <link href="http://xboom.github.io/2022/10/25/Grpc/Grpc-11-%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <id>http://xboom.github.io/2022/10/25/Grpc/Grpc-11-%E9%80%89%E6%8B%A9%E5%99%A8/</id>
    <published>2022-10-25T14:58:29.000Z</published>
    <updated>2023-05-27T10:55:51.743Z</updated>
    
    <content type="html"><![CDATA[<ol><li>什么是Grpc</li><li>为什么我们要使用grpc</li><li>优点有哪些</li></ol><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/20210605094836494.jpg" alt="resolver、balancer、picker之间的关系" /></p><p>从图中可以看出 grpc 客户端与服务端的通信主要有两个阶段</p><ol><li>建立链接阶段</li><li>帧传输阶段</li></ol><p>这其中存在三个主要的功能接口</p><ul><li><p>解析器 resolver 负责根据域名解析地址</p></li><li><p>平衡器 balancer 负责根据地址构建对应连接</p></li><li><p>选择器 picker 负责在发送的时候选择合适的连接</p></li></ul><p>在第一阶段建立链接的过程中，主要通过 解析器与平衡器构建链接；在第二阶段发送过程中通过选择器从准备好的连接中选择合适的连接进行帧的传输</p><p>根据负载均衡器的位置不同，可以分为</p><ul><li>根据作用的位置可以分为客户端负载均衡器、服务端负载均衡器</li><li>根据部署的方式可以分为 <strong>集中式LB(Proxy Model)</strong>、进程内LB(Balancing-aware Client)、<strong>独立LB进程(External Load Balancing Service)</strong></li></ul><blockquote><p>独立LB与集中式LB的区别是，独立LB不在进程内部，但是是伴随着进程的，类似SideCar模式。</p></blockquote><p>在 <code>grpc-go</code> 的中的负载均衡器(选择器)，其实是一种 <strong>进程内LB</strong>，它的核心功能就是：<strong>根据规则选择合适的子链接进行消息发送</strong></p><h3 id="整体流程"><a class="markdownIt-Anchor" href="#整体流程"></a> 整体流程</h3><h3 id="实际应用"><a class="markdownIt-Anchor" href="#实际应用"></a> 实际应用</h3><p>代码路径：<code>balancer\balancer.go</code></p><p>选择器定义了一个 <code>Picker</code> 的接口，按照备注</p><ol><li><code>Pick</code> 函数用于发送RPC消息的连接以及相关信息</li><li><code>Pick</code> 函数不应该被阻塞，如果有任何I/O、阻塞、一定时间开销的操作，那么应该返回 <code>ErrNoSubConnAvailable</code>的内部错误，那么它将重复调用(注意：它会一致重复！)直到Picker更新 <code>ClientConn.UpdateState</code></li><li>如果返回了其他错误<ul><li>如果返回一个状态错误来源于 <code>status\status.go</code>，那么 rpc将停止并返回这个错误</li><li>如果是其他错误，那么等待的rpc调用将继续调用，不需要等待的rpc调用将立即停止并返回这个错误以及 状态 Code 为 <code>Unavailable</code></li></ul></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Picker <span class="keyword">interface</span> &#123;</span><br><span class="line">Pick(info PickInfo) (PickResult, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择器执行失败的逻辑处理，代码路径：<code>picker_wrapper.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">pickResult, err := p.Pick(info)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == balancer.ErrNoSubConnAvailable &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, ok := status.FromError(err); ok &#123;</span><br><span class="line"><span class="comment">// Status error: end the RPC unconditionally with this status.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, dropError&#123;error: err&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// For all other errors, wait for ready RPCs should block and other</span></span><br><span class="line"><span class="comment">// RPCs should fail with unavailable.</span></span><br><span class="line"><span class="keyword">if</span> !failfast &#123;</span><br><span class="line">lastPickErr = err</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, status.Error(codes.Unavailable, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 failfast 是通过 <code>serviceconfig.MethodConfig</code> 中的 <code>WaitForReady</code> 控制，可在初始化连接配置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grpc.WithDefaultServiceConfig(<span class="string">`&#123;"methodConfig": [&#123;"waitForReady": true&#125;]&#125;`</span>)</span><br></pre></td></tr></table></figure><h3 id="实际应用-2"><a class="markdownIt-Anchor" href="#实际应用-2"></a> 实际应用</h3><h4 id="pickfirst"><a class="markdownIt-Anchor" href="#pickfirst"></a> PickFirst</h4><p>pickFirst 是 grpc-go 内置的选择器，它的作用是从链接中选择第一个已经建立好的链接给流使用</p><p>代码路径：<code>pickfirst.go</code></p><p>首先，看下选择器 <code>pickfirstBalancer</code> 结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pickfirstBalancer <span class="keyword">struct</span> &#123;</span><br><span class="line">state connectivity.State</span><br><span class="line">cc    balancer.ClientConn</span><br><span class="line">sc    balancer.SubConn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>connectivity.State 表示选择器的状态</li><li>balancer.ClientConn 负责子链接 SubConn 的创建、移除。更新客户端链接 ClientConn 的状态。由 <code>ccBalancerWrapper</code>结构实现</li><li>balancer.SubConn 主要负责向 grpc 服务发起链接</li></ul><p>其次，<code>pickfirstBalancer</code> 其实实现了平衡器构建接口，也就是说，通过 <code>pickfirstBalancer</code> 可以构建一个平衡器</p><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/377860784" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/377860784</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;什么是Grpc&lt;/li&gt;
&lt;li&gt;为什么我们要使用grpc&lt;/li&gt;
&lt;li&gt;优点有哪些&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-10-连接</title>
    <link href="http://xboom.github.io/2022/10/22/Grpc/Grpc-10-%E8%BF%9E%E6%8E%A5/"/>
    <id>http://xboom.github.io/2022/10/22/Grpc/Grpc-10-%E8%BF%9E%E6%8E%A5/</id>
    <published>2022-10-22T14:58:29.000Z</published>
    <updated>2023-05-27T10:55:43.898Z</updated>
    
    <content type="html"><![CDATA[<h3 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h3><ol><li><p>构建链接阶段设置超时时间</p><p>构建链接阶段有单独的超时控制，也就是链接的超时控制与发送请求的超时控制是分开的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conn, err := grpc.DialContext(context.Background(), *addr, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatalf(<span class="string">"did not connect: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br></pre></td></tr></table></figure><p>在构建链接的过程中，通过强制等待</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialContext</span><span class="params">(ctx context.Context, target <span class="keyword">string</span>, opts ...DialOption)</span> <span class="params">(conn *ClientConn, err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//等待最后的结果，要么ctx.Done()结束</span></span><br><span class="line">     <span class="keyword">select</span> &#123;</span><br><span class="line">     <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> ctx.Err() == err:<span class="comment">//失败错误</span></span><br><span class="line">           conn = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> err == <span class="literal">nil</span> || !cc.dopts.returnLastError:<span class="comment">//将服务端的错误与错误信息一起返回给客户端而不是仅仅一个错误码</span></span><br><span class="line">           conn, err = <span class="literal">nil</span>, ctx.Err()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">           conn, err = <span class="literal">nil</span>, fmt.Errorf(<span class="string">"%v: %v"</span>, ctx.Err(), err)<span class="comment">//返回其他错误</span></span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span> cc.dopts.block &#123;<span class="comment">//如果是阻塞模式</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">cc.Connect()</span><br><span class="line">s := cc.GetState()</span><br><span class="line"><span class="keyword">if</span> s == connectivity.Ready &#123;<span class="comment">//连接状态，健康检查的时候也会更新</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> cc.dopts.copts.FailOnNonTempDialError &amp;&amp; s == connectivity.TransientFailure &#123;</span><br><span class="line"><span class="keyword">if</span> err = cc.connectionError(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">terr, ok := err.(<span class="keyword">interface</span> &#123;</span><br><span class="line">Temporary() <span class="keyword">bool</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> ok &amp;&amp; !terr.Temporary() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !cc.WaitForStateChange(ctx, s) &#123;<span class="comment">//为什么是等待状态变化，因为构建链接的时候是每个都使用一个协程进行建立连接</span></span><br><span class="line"><span class="comment">// ctx got timeout or canceled.</span></span><br><span class="line"><span class="keyword">if</span> err = cc.connectionError(); err != <span class="literal">nil</span> &amp;&amp; cc.dopts.returnLastError &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ctx.Err()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> cc, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等待连接的状态其实就是等待结果后者超时的过程，通过隧道通知</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *ClientConn)</span> <span class="title">WaitForStateChange</span><span class="params">(ctx context.Context, sourceState connectivity.State)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   ch := cc.csMgr.getNotifyChan()</span><br><span class="line">   <span class="keyword">if</span> cc.csMgr.getState() != sourceState &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Dfasdf</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;客户端&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#客户端&quot;&gt;&lt;/a&gt; 客户端&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;构建链接阶段设置超时时间&lt;/p&gt;
&lt;p&gt;构建链接阶段有单独的超时控制，也就是链接的超时控制与发送请求的超时控制是分开的
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-05-重试机制</title>
    <link href="http://xboom.github.io/2022/10/19/Grpc/Grpc-09-%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/"/>
    <id>http://xboom.github.io/2022/10/19/Grpc/Grpc-09-%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/</id>
    <published>2022-10-19T14:58:29.000Z</published>
    <updated>2023-05-27T10:55:34.640Z</updated>
    
    <content type="html"><![CDATA[<p>重试机制是为了在短暂异常情况下能够正常恢复，也能防止长时间异常而不退出。这里看一下grpc-go 中的重试机制以及使用方法</p><p>带着问题看世界：</p><ol><li>grpc-go 的重试策略的使用</li><li>grpc-go 的重试机制是怎样的</li><li>grpc-go 的重试机制都应用在哪些地方</li></ol><h3 id="基本使用"><a class="markdownIt-Anchor" href="#基本使用"></a> 基本使用</h3><p>通过 <code>Dial</code> 可选参数设置自定义重试策略</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   addr = flag.String(<span class="string">"addr"</span>, <span class="string">"localhost:50052"</span>, <span class="string">"the address to connect to"</span>)</span><br><span class="line">   <span class="comment">// see https://github.com/grpc/grpc/blob/master/doc/service_config.md to know more about service config</span></span><br><span class="line">   retryPolicy = <span class="string">`&#123;</span></span><br><span class="line"><span class="string">      "methodConfig": [&#123;</span></span><br><span class="line"><span class="string">        "name": [&#123;"service": "grpc.examples.echo.Echo"&#125;],</span></span><br><span class="line"><span class="string">        "waitForReady": true,</span></span><br><span class="line"><span class="string">        "retryPolicy": &#123;</span></span><br><span class="line"><span class="string">           "MaxAttempts": 4,</span></span><br><span class="line"><span class="string">           "InitialBackoff": ".01s",</span></span><br><span class="line"><span class="string">           "MaxBackoff": ".01s",</span></span><br><span class="line"><span class="string">           "BackoffMultiplier": 1.0,</span></span><br><span class="line"><span class="string">           "RetryableStatusCodes": [ "UNAVAILABLE" ]</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        "hedgingPolicy": &#123;</span></span><br><span class="line"><span class="string">        "MaxAttempts": "",</span></span><br><span class="line"><span class="string">        "HedgingDelay": "",</span></span><br><span class="line"><span class="string">        "NonFatalStatusCodes": [""]</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;]&#125;`</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// use grpc.WithDefaultServiceConfig() to set service config</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retryDial</span><span class="params">()</span> <span class="params">(*grpc.ClientConn, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithDefaultServiceConfig(retryPolicy))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，这里有两种重试策略 <code>hedgingPolicy</code> (<strong>重试</strong>) 与 <code>retryPolicy</code>(<strong>对冲</strong>)</p><p>重试中参数的解释</p><ol><li><code>MaxAttempts</code>：最大重试次数</li><li><code>InitialBackoff</code>：默认退避时间</li><li><code>MaxBackoff</code>：最大退避时间</li><li><code>BackoffMultiplier</code>：退避时间增加倍率</li><li><code>RetryableStatusCodes</code>: 服务端返回什么错误码才重试</li></ol><p><strong>对冲</strong>是指在不等待响应的情况下主动发送单词调用的多个请求。通俗解释就是 如果<code>HedgingDelay</code>时间没有响应，那么直接发送第二次请求，以此类推，直到达到最大次数 <code>MaxAttempts</code></p><ol><li><code>MaxAttempts</code>：最大重试次数</li><li><code>HedgingDelay</code>：等待响应时间</li></ol><p>也可以通过可选参数关闭重试策略</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDisableRetry</span><span class="params">()</span> <span class="title">DialOption</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> newFuncDialOption(<span class="function"><span class="keyword">func</span><span class="params">(o *dialOptions)</span></span> &#123;</span><br><span class="line">      o.disableRetry = <span class="literal">true</span></span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重试策略"><a class="markdownIt-Anchor" href="#重试策略"></a> 重试策略</h3><p>这两种策略都是通过实现统一的重试接口进行加载</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> isMethodConfig_RetryOrHedgingPolicy <span class="keyword">interface</span> &#123;</span><br><span class="line">   isMethodConfig_RetryOrHedgingPolicy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过转换而进行重试测试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pushback := <span class="number">0</span><span class="comment">//记录重试间隔时间</span></span><br><span class="line">hasPushback := <span class="literal">false</span>  <span class="comment">//记录是否要重试</span></span><br><span class="line"><span class="keyword">if</span> cs.attempt.s != <span class="literal">nil</span> &#123;<span class="comment">//存在重试任务</span></span><br><span class="line">   <span class="keyword">if</span> !cs.attempt.s.TrailersOnly() &#123;<span class="comment">//如果流不是只有trailer,则无法直接读取元数据</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   sps := cs.attempt.s.Trailer()[<span class="string">"grpc-retry-pushback-ms"</span>]<span class="comment">//获取元数据</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(sps) == <span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> e error</span><br><span class="line">      <span class="keyword">if</span> pushback, e = strconv.Atoi(sps[<span class="number">0</span>]); e != <span class="literal">nil</span> || pushback &lt; <span class="number">0</span> &#123;</span><br><span class="line">         cs.retryThrottler.throttle() <span class="comment">// 记录重试次数</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">      &#125;</span><br><span class="line">      hasPushback = <span class="literal">true</span><span class="comment">//重试</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(sps) &gt; <span class="number">1</span> &#123;<span class="comment">//如果存在多个 sps 表示异常</span></span><br><span class="line">      cs.retryThrottler.throttle() <span class="comment">// 记录重试次数(用于重试失败限速)</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>Trailers</code> 是一种消息元数据，用于在相应结束时传递关于次消息的附加信息，通常包含状态码，消息和错误信息的传递。Trailers 通常会在流关闭之前发送。<code>Trailers</code> 发送的情况有几下几种</p><ul><li>RPC正常结束，<code>Trailers</code>中携带调用的状态、错误码、响应时间等信息；</li><li>RPC出错结束，<code>Trailers</code>中携带错误信息，例如错误码、错误消息等；</li><li>服务器关闭了stream，<code>Trailers</code>中携带stream关闭的原因；</li><li>客户端取消了RPC调用，<code>Trailers</code>中携带调用取消的原因</li></ul><p>它的特点：</p><ul><li><p><code>Trailers</code> 并不是每个RPC调用都会发，而是流关闭的时候才会发！！！ 可以包含在最后一个数据帧中附加一个<code>Trailers</code>，所以抓包看不到一个独立的 <code>Trailers</code>。</p></li><li><p>如果流中不仅仅有<code>Trailers</code>，那么无法直接从流中获取 <code>Trailers</code>，而是需要其他办法，比如拦截器</p></li><li><p>包含元数据存储在ctx中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx := metadata.NewOutgoingContext(context.Background(), metadata.Pairs(</span><br><span class="line">    <span class="string">"grpc-retry-pushback-ms"</span>, <span class="string">"5000"</span>,</span><br><span class="line">))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>这里还多了一个 <code>retryThrottler.throttle</code>，在下面的重试速率中说明</p></li><li><p>如果有 没有配置 <code>grpc-retry-pushback-ms</code>，那么就使用重试策略，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dur time.Duration</span><br><span class="line"><span class="keyword">if</span> hasPushback &#123;<span class="comment">//设置了重试元数据</span></span><br><span class="line">   dur = time.Millisecond * time.Duration(pushback)</span><br><span class="line">   cs.numRetriesSincePushback = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   fact := math.Pow(rp.BackoffMultiplier, <span class="keyword">float64</span>(cs.numRetriesSincePushback))</span><br><span class="line">   cur := <span class="keyword">float64</span>(rp.InitialBackoff) * fact</span><br><span class="line">   <span class="keyword">if</span> max := <span class="keyword">float64</span>(rp.MaxBackoff); cur &gt; max &#123;<span class="comment">//最大判断</span></span><br><span class="line">      cur = max</span><br><span class="line">   &#125;</span><br><span class="line">   dur = time.Duration(grpcrand.Int63n(<span class="keyword">int64</span>(cur)))</span><br><span class="line">   cs.numRetriesSincePushback++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，退避时间随着重试次数指数级增长 <code>InitialBackoff * math.Pow(rp.BackoffMultiplier, float64(cs.numRetriesSincePushback))</code></p></li></ol><p>根据上述计算的退避时间执行等待逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t := time.NewTimer(dur)<span class="comment">//开启一个定时器</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-t.C:<span class="comment">//定时器触发，重试次数+1</span></span><br><span class="line">   cs.numRetries++</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;-cs.ctx.Done():<span class="comment">//流程结束停止重试</span></span><br><span class="line">   t.Stop()</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>, status.FromContextError(cs.ctx.Err()).Err()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重试速率"><a class="markdownIt-Anchor" href="#重试速率"></a> 重试速率</h3><p>重试过程中还能看到 <code>RetryThrottlingPolicy</code> 做了一层重试限制，其实除了配置重试策略，还能控制重试的速率，防止重试的次数太多给服务器造成太大压力</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">policy := grpcutil.RetryThrottlingPolicy&#123;</span><br><span class="line">    MaxTokens:    <span class="number">10</span>,            <span class="comment">// 最大令牌数</span></span><br><span class="line">    TokenRate:    <span class="number">1</span>,             <span class="comment">// 每秒产生的令牌数</span></span><br><span class="line">    RetryBudget:  <span class="number">100</span> * time.Millisecond, <span class="comment">// 重试预算</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 DialOption，使用上面的 RetryThrottlingPolicy</span></span><br><span class="line">dialOption := grpc.WithRetryThrottlingPolicy(policy)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 dialOption 创建 gRPC 客户端</span></span><br></pre></td></tr></table></figure><ul><li><code>MaxTokens</code>：最大令牌数，任何时间点同时允许的最大令牌数</li><li><code>TokenRate</code>：每秒产生的令牌数，每个请求都会消耗一个令牌</li><li><code>RetryBudget</code>：重试预算，制定重试操作可以使用的总时间，如果一个请求需要重试，但是时间已经超过了 <code>RetryBudget</code>，那么不在进行重试</li></ul><h4 id="限速原理"><a class="markdownIt-Anchor" href="#限速原理"></a> 限速原理</h4><p>第一步：初始化速率配置</p><p>结构体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> retryThrottler <span class="keyword">struct</span> &#123;</span><br><span class="line">max    <span class="keyword">float64</span><span class="comment">//最大令牌数</span></span><br><span class="line">thresh <span class="keyword">float64</span><span class="comment">//预算</span></span><br><span class="line">  ratio  <span class="keyword">float64</span><span class="comment">//每秒令牌数</span></span><br><span class="line"></span><br><span class="line">mu     sync.Mutex</span><br><span class="line">tokens <span class="keyword">float64</span> <span class="comment">//可用令牌数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换规则</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cc.sc.retryThrottling != <span class="literal">nil</span> &#123;</span><br><span class="line">   newThrottler := &amp;retryThrottler&#123;</span><br><span class="line">      tokens: cc.sc.retryThrottling.MaxTokens,</span><br><span class="line">      max:    cc.sc.retryThrottling.MaxTokens,</span><br><span class="line">      thresh: cc.sc.retryThrottling.MaxTokens / <span class="number">2</span>,</span><br><span class="line">      ratio:  cc.sc.retryThrottling.TokenRatio,</span><br><span class="line">   &#125;</span><br><span class="line">   cc.retryThrottler.Store(newThrottler)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   cc.retryThrottler.Store((*retryThrottler)(<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：计算是否进行限速</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rt *retryThrottler)</span> <span class="title">throttle</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> rt == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">rt.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rt.mu.Unlock()</span><br><span class="line">rt.tokens--</span><br><span class="line"><span class="keyword">if</span> rt.tokens &lt; <span class="number">0</span> &#123;</span><br><span class="line">rt.tokens = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rt.tokens &lt;= rt.thresh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：成功调用则更新可用 <code>tokens</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rt *retryThrottler)</span> <span class="title">successfulRPC</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> rt == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">rt.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rt.mu.Unlock()</span><br><span class="line">rt.tokens += rt.ratio</span><br><span class="line"><span class="keyword">if</span> rt.tokens &gt; rt.max &#123;</span><br><span class="line">rt.tokens = rt.max</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是：一个流中只有只有成功调用的时候才会将增加可用 <code>token</code> 数量</p><h3 id="业务重试"><a class="markdownIt-Anchor" href="#业务重试"></a> 业务重试</h3><p>业务重试一般直接使用重试封装逻辑(已新建流为例)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">op := <span class="function"><span class="keyword">func</span><span class="params">(a *csAttempt)</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> a.newStream() &#125;</span><br><span class="line"><span class="keyword">if</span> err := cs.withRetry(op, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; cs.bufferForRetryLocked(<span class="number">0</span>, op) &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">   cs.finish(err)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部逻辑如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *clientStream)</span> <span class="title">withRetry</span><span class="params">(op <span class="keyword">func</span>(a *csAttempt)</span> <span class="title">error</span>, <span class="title">onSuccess</span> <span class="title">func</span><span class="params">()</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">   cs.mu.Lock()<span class="comment">//获取流的写锁，防止在重试过程又出现新的重试</span></span><br><span class="line">  <span class="keyword">for</span> &#123;<span class="comment">//使用for循环不断尝试</span></span><br><span class="line">      <span class="keyword">if</span> cs.committed &#123;<span class="comment">//流不在发送任何东西</span></span><br><span class="line">         cs.mu.Unlock()</span><br><span class="line">         <span class="keyword">return</span> toRPCErr(op(cs.attempt))</span><br><span class="line">      &#125;</span><br><span class="line">      a := cs.attempt</span><br><span class="line">      cs.mu.Unlock()</span><br><span class="line">      err := op(a)<span class="comment">//执行操作</span></span><br><span class="line">      cs.mu.Lock()</span><br><span class="line">      <span class="keyword">if</span> a != cs.attempt &#123;<span class="comment">//如果重试对象已经变更，则直接跳过继续下一次操作</span></span><br><span class="line">         <span class="comment">// We started another attempt already.</span></span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> err == io.EOF &#123; </span><br><span class="line">         &lt;-a.s.Done()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//执行成功的后续操作</span></span><br><span class="line">      <span class="keyword">if</span> err == <span class="literal">nil</span> || (err == io.EOF &amp;&amp; a.s.Status().Code() == codes.OK) &#123;</span><br><span class="line">         onSuccess()</span><br><span class="line">         cs.mu.Unlock()</span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//执行失败则尝试重试</span></span><br><span class="line">      <span class="keyword">if</span> err := cs.retryLocked(err); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         cs.mu.Unlock()</span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>committed</code>：当客户端调用 <code>CloseSend</code> 方法关闭发送流的时候，会标记 <code>ClientStream</code>为已提交，表示客户端不再发送任何消息</p><p>有个奇怪的地方如下所示，为什么不发送任何东西还要继续 <code>op</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cs.committed &#123;<span class="comment">//流不在发送任何东西</span></span><br><span class="line">   cs.mu.Unlock()</span><br><span class="line">   <span class="keyword">return</span> toRPCErr(op(cs.attempt))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因是如果是正在处理中的请求(尝试重试、取消等操作)，还是会尝试执行 <code>op</code>并返回错误结束尝试</p></li><li><p>如果在重试过程中，重试任务发生了变化，那么也会跳过直接进行下一次重试</p></li></ul><h4 id="成功"><a class="markdownIt-Anchor" href="#成功"></a> 成功</h4><p>如果执行成功，那么只需要执行后续的 <code>OnSuccess</code> 函数即可，一般有有两种</p><ul><li><p>如果是 <code>commitAttemptLocked</code>，那么表示执行成功更新状态即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *clientStream)</span> <span class="title">commitAttemptLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> !cs.committed &amp;&amp; cs.onCommit != <span class="literal">nil</span> &#123;</span><br><span class="line">      cs.onCommit() <span class="comment">//配置的重试逻辑</span></span><br><span class="line">   &#125;</span><br><span class="line">   cs.committed = <span class="literal">true</span><span class="comment">//重试逻辑执行成功</span></span><br><span class="line">   cs.buffer = <span class="literal">nil</span><span class="comment">//清空这个重试缓存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果是 <code>bufferForRetryLocked</code>，那么会缓存当前的重试操作到回放缓冲区(后续发生失败的时候再执行一次)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *clientStream)</span> <span class="title">bufferForRetryLocked</span><span class="params">(sz <span class="keyword">int</span>, op <span class="keyword">func</span>(a *csAttempt)</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">   <span class="comment">// Note: we still will buffer if retry is disabled (for transparent retries).</span></span><br><span class="line">   <span class="keyword">if</span> cs.committed &#123;<span class="comment">//如果重试逻辑执行成功结束</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   cs.bufferSize += sz</span><br><span class="line">   <span class="keyword">if</span> cs.bufferSize &gt; cs.callInfo.maxRetryRPCBufferSize &#123;<span class="comment">//回放缓冲区太大就不回放了</span></span><br><span class="line">      cs.commitAttemptLocked()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   cs.buffer = <span class="built_in">append</span>(cs.buffer, op) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="失败"><a class="markdownIt-Anchor" href="#失败"></a> 失败</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *clientStream)</span> <span class="title">retryLocked</span><span class="params">(lastErr error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      cs.attempt.finish(toRPCErr(lastErr))</span><br><span class="line">      isTransparent, err := cs.shouldRetry(lastErr)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         cs.commitAttemptLocked()</span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line">      cs.firstAttempt = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">if</span> err := cs.newAttemptLocked(isTransparent); err != <span class="literal">nil</span> &#123;<span class="comment">//创建一个新attemp</span></span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> lastErr = cs.replayBufferLocked(); lastErr == <span class="literal">nil</span> &#123;<span class="comment">//回放缓冲区，</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先，当前的尝试 <code>cs.attempt</code> 将被标记为已完成，其结果会被传递给 <code>cs.finish()</code></li><li>然后，会调用 <code>cs.shouldRetry()</code> 判断当前错误是否应该重试(服务端错误 <code>DoNotTransparentRetry</code> )<ul><li>如果返回的错误可以重试，则会通过 <code>cs.newAttemptLocked()</code> 创建新的尝试，即新的流，并在其上发起新的请求</li><li>如果没有返回新的错误，则尝试从回放缓冲区 <code>cs.replayBufferLocked()</code> 中获取上一次重试的错误</li></ul></li><li>如果在回放缓冲区中找到了错误，继续进行下一次重试，否则返回 nil 表示重试成功</li></ol><p>前面提到了，有一种成功即使执行成功也会加入到 buffer中，在执行失败的之后重新再执行一遍</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *clientStream)</span> <span class="title">replayBufferLocked</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   a := cs.attempt</span><br><span class="line">   <span class="keyword">for</span> _, f := <span class="keyword">range</span> cs.buffer &#123;</span><br><span class="line">      <span class="keyword">if</span> err := f(a); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是在构建流的时候加入的，如果构建流成功，那么会将构建流的函数加入到<code>buffer</code>，如果后续有一次临时性的失败，会将所有成功的构建流全部执行一遍。<strong>为什么其中一个创建流失败之后，需要将其他创建成功的逻辑都进行重试？</strong></p><p>答：如果一次失败了，那么执行之前的操作。前提是能够保证和之前成功的那次执行得到相同的结果。这里创建流与发送消息都会将成功的操作放入到缓冲区中，当消息发送完毕，那么这个流就结束了。所以在发送过程中，如果其中一个帧发送失败，那么它会将从流构建到消息发送再次传输一遍(相当于一个新的请求)</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>重试机制 <code>withRetry</code> 包含的业务<ul><li>建立流链接</li><li>发送头帧</li><li>发送消息</li><li>接收消息</li><li>关闭发送</li></ul></li><li>服务端响应的时候并没有重试机制</li><li>重试速率限制是针对整个连接而不是每个流一个</li><li>同时执行一个重试任务，并且执行的都是最新的那个</li><li>只有重试成功，才会更新令牌<code>tokens</code>数量。那是不是影响其他调用的重试，会但影响不大。第一是因为只要有一个成功，那么token数量都会更新。第二是重试次数过多，单次调用会因为超时停止重试。</li><li>如果在发送过程中，某一个帧发送失败，那么它会从创建流开始重新发起调用</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://blog.csdn.net/u011582922/article/details/120578941" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/120578941</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;重试机制是为了在短暂异常情况下能够正常恢复，也能防止长时间异常而不退出。这里看一下grpc-go 中的重试机制以及使用方法&lt;/p&gt;
&lt;p&gt;带着问题看世界：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;grpc-go 的重试策略的使用&lt;/li&gt;
&lt;li&gt;grpc-go 的重试机制是怎样的&lt;/l
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
</feed>
