<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XBoom Dove</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xboom.github.io/"/>
  <updated>2023-07-01T09:03:09.648Z</updated>
  <id>http://xboom.github.io/</id>
  
  <author>
    <name>XBoom Dove</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go入门25-PoolDequeue</title>
    <link href="http://xboom.github.io/2023/07/01/Go/Go%E5%85%A5%E9%97%A825-PoolDequeue/"/>
    <id>http://xboom.github.io/2023/07/01/Go/Go%E5%85%A5%E9%97%A825-PoolDequeue/</id>
    <published>2023-07-01T08:51:45.000Z</published>
    <updated>2023-07-01T09:03:09.648Z</updated>
    
    <content type="html"><![CDATA[<p>在学习Golang 中 的内存池 <code>Sync.Pool</code> 之前，底层是使用的 一个<strong>无锁</strong>的 <strong>动态扩容</strong> 的<strong>双端队列</strong>支持 <strong>单生产者</strong> <strong>多消费者</strong>  的 <code>Sync.Pool</code> 内存分配模式，它是一个私有结构体，所以外部无法访问它，这里来看看如何实现的</p><p><strong>代码：</strong><code>src/sync/poolqueue.go</code></p><p>带着问题看世界</p><ol><li>如何动态扩容的</li><li>为什么内存池要是用这样的 数组 + 链表</li></ol><h3 id="pooldequeue"><a class="markdownIt-Anchor" href="#pooldequeue"></a> poolDequeue</h3><p>首先看一下基本结构结构体，使用数组实现了一个 <code>ring buffer</code> 的结构</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/PoolDequeue1.png" alt="PoolDequeue1" style="zoom:50%;" /><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolDequeue <span class="keyword">struct</span> &#123;    </span><br><span class="line">  <span class="comment">// headTail 包含了 32bit的头部索引与32位尾部索引指向 vals</span></span><br><span class="line">  <span class="comment">// head 高 32 位, 指向下一个存放对象的索引</span></span><br><span class="line">  <span class="comment">// tail 低 32 位, 指向队列中最早(下一个读取)的对象索引</span></span><br><span class="line"><span class="comment">// 索引区间 tail &lt;= i &lt; head, 是消费者可以在该区间不断获取对象，直至获取到的对象为 nil</span></span><br><span class="line">headTail <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// vals 表示队列元素容器，大小必须为 2 的 N 次幂</span></span><br><span class="line"><span class="comment">// 容器会在初始化时指定容量，实现数据元素内存预初始化</span></span><br><span class="line"><span class="comment">// 队列会将未使用的槽位设置为nil</span></span><br><span class="line">vals []eface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么要将 <code>head</code> 和 <code>tail</code> 合并到一个变量里面？</strong></p><p>当队列中存在多个对象，两边同时操作貌似没什么问题，但为了防止队列中仅剩一个对象时，就需要锁住两个索引进行操作，所以利用了 <code>atomic</code> 包的提供的 <code>CAS</code> 操作，完成两个字段的 <code>lock free</code> 无锁编程</p><p>更新 <code>head</code> 和 <code>tail</code> 两个字段的时候，也是通过 <code>CAS + 位运算</code> 进行操作的。更新逻辑如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dequeueNil 是用于在 poolDequeue 中表示 interface&#123;&#125;(nil) 的类型。由于使用 nil 来表示空槽位，所以需要一个特殊值来表示 nil。</span></span><br><span class="line"><span class="keyword">type</span> dequeueNil *<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span> <span class="title">unpack</span><span class="params">(ptrs <span class="keyword">uint64</span>)</span> <span class="params">(head, tail <span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> mask = <span class="number">1</span>&lt;&lt;dequeueBits - <span class="number">1</span><span class="comment">//获取掩码</span></span><br><span class="line">head = <span class="keyword">uint32</span>((ptrs &gt;&gt; dequeueBits) &amp; mask)<span class="comment">//获取头部索引</span></span><br><span class="line">tail = <span class="keyword">uint32</span>(ptrs &amp; mask)<span class="comment">//获取尾部索引</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span> <span class="title">pack</span><span class="params">(head, tail <span class="keyword">uint32</span>)</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> mask = <span class="number">1</span>&lt;&lt;dequeueBits - <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">uint64</span>(head) &lt;&lt; dequeueBits) |</span><br><span class="line"><span class="keyword">uint64</span>(tail&amp;mask)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>unpack</code> 与 <code>pack</code> 实现了在 <code>poolDequeue</code> 结构中进行索引值的打包和解包操作。使得在 <code>poolDequeue</code> 结构中使用单个 64 位整数来同时存储头部索引和尾部索引</p><p>所以整体就如下图所示</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/PoolDequeue3.png" alt="PoolDequeue3" style="zoom:50%;" /><p>接着是对队列的操作，分为 <strong>头部写入</strong>、<strong>头部弹出</strong>、<strong>尾部弹出</strong></p><h4 id="pushhead"><a class="markdownIt-Anchor" href="#pushhead"></a> pushHead</h4><p>头部写入返回成功失败</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span> <span class="title">pushHead</span><span class="params">(val any)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="comment">//1. 原子操作获取索引</span></span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)</span><br><span class="line">  <span class="comment">//2. 解析头尾索引</span></span><br><span class="line">head, tail := d.unpack(ptrs)</span><br><span class="line">  <span class="comment">//3. (当尾部索引 + 队列长度)&amp; 掩码 == 头部索引，说明队列满了</span></span><br><span class="line"><span class="keyword">if</span> (tail+<span class="keyword">uint32</span>(<span class="built_in">len</span>(d.vals)))&amp;(<span class="number">1</span>&lt;&lt;dequeueBits<span class="number">-1</span>) == head &#123;</span><br><span class="line">  <span class="comment">// Queue is full.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//4. 没有满则获取头部位置</span></span><br><span class="line">slot := &amp;d.vals[head&amp;<span class="keyword">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 判断头部是否已经被释放</span></span><br><span class="line">typ := atomic.LoadPointer(&amp;slot.typ)</span><br><span class="line"><span class="keyword">if</span> typ != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Another goroutine is still cleaning up the tail, so</span></span><br><span class="line"><span class="comment">// the queue is actually still full.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The head slot is free, so we own it.</span></span><br><span class="line">    <span class="comment">//如果存放的是nil，那么使用 dequeueNil(nil) 表示存放的是一个nil类型</span></span><br><span class="line"><span class="keyword">if</span> val == <span class="literal">nil</span> &#123;</span><br><span class="line">val = dequeueNil(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">*(*any)(unsafe.Pointer(slot)) = val</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为头部索引是高32位，所以 增加 1&lt;&lt;dequeueBits，同理尾部索引是低32，直接减1</span></span><br><span class="line">atomic.AddUint64(&amp;d.headTail, <span class="number">1</span>&lt;&lt;dequeueBits)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>type == nil</code>，则表示 <code>slot</code> 已经被释放，如果 <code>value = dequeueNil(nil)</code> 表示存放的是一个 <code>nil</code> (但注意，<code>Sync.Pool</code> 的<code>Put(nil)</code> 会直接返回，而不会真的存放一个 <code>nil</code>)</p><h4 id="pophead"><a class="markdownIt-Anchor" href="#pophead"></a> popHead</h4><p>返回头部索引位置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span> <span class="title">popHead</span><span class="params">()</span> <span class="params">(any, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> slot *eface</span><br><span class="line">    <span class="comment">//使用 CAS 不断尝试获取头部值</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//加载并解析索引获取头部位置，判断是否为空</span></span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)</span><br><span class="line">head, tail := d.unpack(ptrs)</span><br><span class="line"><span class="keyword">if</span> tail == head &#123;</span><br><span class="line"><span class="comment">// Queue is empty.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算更新后的索引值</span></span><br><span class="line">head--</span><br><span class="line">ptrs2 := d.pack(head, tail)</span><br><span class="line">        <span class="comment">//CAS 更新</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;</span><br><span class="line"><span class="comment">//获取头部位置</span></span><br><span class="line">slot = &amp;d.vals[head&amp;<span class="keyword">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 如果 不是 ptrs 所以已经发生了变化那么重试</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val := *(*any)(unsafe.Pointer(slot))</span><br><span class="line"><span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;<span class="comment">//如果存放的是nil，那么返回nil</span></span><br><span class="line">val = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将槽置位 zero，为什么不会与pushHead冲突</span></span><br><span class="line">*slot = eface&#123;&#125; </span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>popTail</code> 与 <code>popHead</code>差不多，最后的赋值有区别</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slot.val = <span class="literal">nil</span><span class="comment">//直接赋值空值</span></span><br><span class="line">atomic.StorePointer(&amp;slot.typ, <span class="literal">nil</span>)<span class="comment">//表示为空</span></span><br></pre></td></tr></table></figure><p><strong>为什么 <code>popTail</code>  与 <code>popHead</code> 处理方式不一样</strong>，是因为设计的就是单个生产者与多个消费者，所以<code>popHead</code>并不会有竞争的问题，最后都是存放的 <code>slot{}</code></p><h3 id="poolchainelt"><a class="markdownIt-Anchor" href="#poolchainelt"></a> poolChainElt</h3><p><code>poolChainElt</code> 是一个双向链表的节点，包含林一个每个节点 <code>poolDequeue</code> 结构 以及 双向指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolChainElt <span class="keyword">struct</span> &#123;</span><br><span class="line">poolDequeue</span><br><span class="line">next, prev *poolChainElt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="poolchain"><a class="markdownIt-Anchor" href="#poolchain"></a> poolChain</h3><p>有了双向链表节点，那么就有双向链表 <code>poolChain</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolChain <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//由于只有生产者访问该字段，因此不需要同步操作</span></span><br><span class="line">head *poolChainElt</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于消费者访问该字段，因此读写必须是原子操作</span></span><br><span class="line">tail *poolChainElt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>poolChain</code> 是一个双向链表队列，其中每个 <code>poolDequeue</code> 的大小是前一个 <code>poolDequeue</code> 的两倍。一旦一个 <code>poolDequeue</code> 填满，就会分配一个新的 <code>poolDequeue</code>，并且只会将数据推入到最新的 <strong>poolDequeue</strong>。弹出操作发生在列表的另一端，当一个 <code>poolDequeue</code> 被耗尽后，它会从链表中移除。</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/PoolDequeue4.png" alt="PoolDequeue4" style="zoom:50%;" /><p>通过这种设计，<code>poolChain</code> 实现了一个可以动态增长的队列，以适应对象池中的元素数量变化。它能够高效地管理多个不同大小的队列，并提供生产者和消费者之间的并发访问。生产者将数据推入到最新的 <code>poolDequeue</code>，而消费者从链表的另一端弹出数据。这样可以避免竞争条件和锁等待，并提高并发性能</p><h4 id="pushhead-2"><a class="markdownIt-Anchor" href="#pushhead-2"></a> pushHead</h4><p>有了双向链表之后，再来看它是如何写入一个值的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span> <span class="title">pushHead</span><span class="params">(val any)</span></span> &#123;</span><br><span class="line">    <span class="comment">//1. 获取双向链表头部节点</span></span><br><span class="line">d := c.head</span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">//2. 如果头部节点是空的，说明整个链表都是空的，那么就需要初始化一个链表节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initSize = <span class="number">8</span> <span class="comment">// 默认大小是8，必须是2的倍数</span></span><br><span class="line">d = <span class="built_in">new</span>(poolChainElt)</span><br><span class="line">d.vals = <span class="built_in">make</span>([]eface, initSize)<span class="comment">//节点popDequeue的默认大小是8</span></span><br><span class="line">c.head = d<span class="comment">//双向链表的的头部指针指向这个节点</span></span><br><span class="line">        storePoolChainElt(&amp;c.tail, d) <span class="comment">//将节点追加到双向链表尾部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将值写入头部节点的内存池队列中，如果成功就结束</span></span><br><span class="line"><span class="keyword">if</span> d.pushHead(val) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果到这里，说明插入失败了，那么就会创建一个更大(2倍)的内存池队列 poolDequeue</span></span><br><span class="line">newSize := <span class="built_in">len</span>(d.vals) * <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> newSize &gt;= dequeueLimit &#123;<span class="comment">//最大不能超过 1 &lt;&lt; 32 / 4 = 1 &lt;&lt; 30</span></span><br><span class="line">newSize = dequeueLimit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">d2 := &amp;poolChainElt&#123;prev: d&#125;<span class="comment">//新建节点前驱是 d</span></span><br><span class="line">d2.vals = <span class="built_in">make</span>([]eface, newSize)<span class="comment">//构建指定大小的切片</span></span><br><span class="line">c.head = d2<span class="comment">//将d2设置为头部节点</span></span><br><span class="line">storePoolChainElt(&amp;d.next, d2) <span class="comment">//d的后继为d2</span></span><br><span class="line">d2.pushHead(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照效果如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">8</span>] -- [<span class="number">16</span>] -- [<span class="number">32</span>] -- head</span><br></pre></td></tr></table></figure><h4 id="pophead-2"><a class="markdownIt-Anchor" href="#pophead-2"></a> popHead</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span> <span class="title">popHead</span><span class="params">()</span> <span class="params">(any, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//获取头部节点</span></span><br><span class="line">d := c.head</span><br><span class="line"><span class="keyword">for</span> d != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">//获取队列头部节点</span></span><br><span class="line"><span class="keyword">if</span> val, ok := d.popHead(); ok &#123;</span><br><span class="line"><span class="keyword">return</span> val, ok</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 到这里是没有获取到，然后指向前驱继续获取</span></span><br><span class="line">d = loadPoolChainElt(&amp;d.prev)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="poptail"><a class="markdownIt-Anchor" href="#poptail"></a> popTail</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span> <span class="title">popTail</span><span class="params">()</span> <span class="params">(any, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//1. 加载尾部队列节点，如果没有表示链表为空则返回 false</span></span><br><span class="line">d := loadPoolChainElt(&amp;c.tail)</span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 记录尾部的后驱</span></span><br><span class="line">d2 := loadPoolChainElt(&amp;d.next)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出队列尾部值</span></span><br><span class="line"><span class="keyword">if</span> val, ok := d.popTail(); ok &#123;</span><br><span class="line"><span class="keyword">return</span> val, ok</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 d 没有了，d2 也为空，说明没有值</span></span><br><span class="line"><span class="keyword">if</span> d2 == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// CAS 尝试获取 d</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;c.tail)), unsafe.Pointer(d), unsafe.Pointer(d2)) &#123;</span><br><span class="line"><span class="comment">//如果获取到那么去掉前继</span></span><br><span class="line">storePoolChainElt(&amp;d2.prev, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//更新尾部指针</span></span><br><span class="line">d = d2</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>无锁的原因是队列形式，单个生产者在头部操作，消费者从队尾消费</li><li>并不是固定大小，而是作为双向链表节点的队列最大长度是 <code>1 &lt;&lt; 32/ 4</code>  ，并且用环形缓冲区 <code>ring buffer</code> 实现</li><li>Pool 底层 使用 数组 + 链表的形式的原因是由 Pool 的特性决定的，它需要频繁的内存分配，所以数组是一个好的选择。又为了解决扩容的问题，使用链表来连接数组</li></ul><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://mp.weixin.qq.com/s/dLzWAqM9lCln83jhkvmtMw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dLzWAqM9lCln83jhkvmtMw</a></li><li><a href="https://geektutu.com/post/hpg-sync-pool.html" target="_blank" rel="noopener">https://geektutu.com/post/hpg-sync-pool.html</a></li><li><a href="https://studygolang.com/articles/28386" target="_blank" rel="noopener">https://studygolang.com/articles/28386</a></li><li><a href="https://juejin.cn/post/7213257917255385149" target="_blank" rel="noopener">https://juejin.cn/post/7213257917255385149</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习Golang 中 的内存池 &lt;code&gt;Sync.Pool&lt;/code&gt; 之前，底层是使用的 一个&lt;strong&gt;无锁&lt;/strong&gt;的 &lt;strong&gt;动态扩容&lt;/strong&gt; 的&lt;strong&gt;双端队列&lt;/strong&gt;支持 &lt;strong&gt;单生产者&lt;/str
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>协议-03-Raft</title>
    <link href="http://xboom.github.io/2023/06/26/Protocol/%E5%8D%8F%E8%AE%AE-03-Raft/"/>
    <id>http://xboom.github.io/2023/06/26/Protocol/%E5%8D%8F%E8%AE%AE-03-Raft/</id>
    <published>2023-06-26T02:25:38.000Z</published>
    <updated>2023-06-26T10:29:53.701Z</updated>
    
    <content type="html"><![CDATA[<p>在学习分布式系统过程中，经常能碰到一致性算法，即使出现部分节点故障，网络延时等情况，也不影响整体可用性，进而提高系统的整体可用性。Raft协议是一种分布式一致性算法(共识算法)，共识就是多个节点对某一个事件达成一致的算法，常见的一致性协议有Raft、Paxos、ZAB，根据 《ETCD 技术内幕》 学习 Raft 协议</p><h3 id="基本定义"><a class="markdownIt-Anchor" href="#基本定义"></a> 基本定义</h3><p>Raft 为了实现共识，会选举出主从节点，任意节点都处于下面3类角色：</p><ul><li><strong>Leader(领袖)</strong>：领袖由群众投票选举得出，每次选举，只能选出一名领袖；</li><li><strong>Candidate(候选人)</strong>：当没有领袖时，某些群众可以成为候选人，然后去竞争领袖的位置；</li><li><strong>Follower(群众)</strong>：相对于 Leader 来说，在非选举过程中的其他节点就是 Follower，任何节点都可能通过 Candidate 成为 Leader</li></ul><p>在进行选举过程中，还有几个重要的概念：</p><ul><li><strong>Leader Election(领导人选举)</strong>：简称选举，就是指选出 Leader；</li><li><strong>Term(任期)</strong>：其实是一个单独递增的连续数字，每一次任期就会重新发起一次 Leader Election，每个节点都会记录当前的任期值</li><li><strong>Election Timeout(选举超时)</strong>：就是一个超时时间，当 Follower 超时未收到 Leader 的心跳时，会重新进行选举</li></ul><p><strong>任期(Term)</strong>：实际上是一个全局的、连续递增的整数。<strong>在raft中，每进行一次选举，任期就会+1</strong></p><p>节点存在三种状态分别是：</p><ul><li>Leader节点：可读可写、处理日志复制、保证⼀致性、维护⼼跳</li><li>Follower节点：可进行读操作，写操作需要路由到Leader处理；参与投票，<strong>⼀个term任期内只能投⼀次;</strong> 当触发 election timeout 时，晋升为 Candidate</li><li>Candidate节点：集群的候选者，会发起投票试图当选leader ; 通过 <code>RequestVote</code> 通知其他节点来投票;</li></ul><p>集群中任意一个节点都处于这三个状态之一</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220125000023.png" alt="image-20220125000018705" style="zoom:80%;" /><p>如上图所示</p><ol><li><p><strong>当 Etcd节点刚启动的时候，节点初始化状态为 Follower</strong></p></li><li><p>为了进行 Leader Election 有两个时间</p><ul><li><strong>选举超时时间(Election timeout)</strong>: 每个 Follower 节点在接收不到 Leader 节点的心跳消息之后，并不会立即发起新一轮选举，而是需要等待一段时间之后才切换成 Candidate 状态发起新一轮选举。<strong>是一个一定范围的随机数，为了保证各节点不是同时发起选举请求</strong></li><li><strong>心跳超时时间(Heartbeat timeout):</strong> Leader节点向集群中其他Follower节点发送心跳消息的时间间隔</li></ul></li><li><ul><li><ul><li></li></ul></li></ul></li></ol><h3 id="leader选举"><a class="markdownIt-Anchor" href="#leader选举"></a> Leader选举</h3><p>能成为 Leader 的条件有</p><ul><li>当前集群⽆可用 leader</li><li>触发 Election timeout</li><li>Term 任期最新</li><li>Log 日志最新</li><li>获取多数投票</li></ul><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312200222.png" alt="image-20220312200222021" /></p><p>流程可以查看：<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></p><p>需要注意的是：</p><ol><li>超过集群半数节点应答，才将日志写入WAL中，也是就如果没有等到半数应答就挂了，那么数据就丢了</li><li>Follower 收到 Leader 的 复制日志 则直接将日志写入 WAL 中</li><li>当Follower收到 Vote Request 也会重置 election timeout 定时器(降低同时出现两个候选人的概率)</li><li>Term 将持续直到某个节点因为心跳超时而从新发起选举</li><li>出现多个候选人都没有称为 Leader，那么选举失败，切换为Follower，等待下一个选举超时</li><li>Leader 宕机后，其他节点重新选出新 Leader。等到旧Leader 恢复，会因为收到新Leader心跳 而自己的 Term 落后，切换成 Follower，更新自己的Term，然后重新投出自己的选票</li></ol><h4 id="基本流程"><a class="markdownIt-Anchor" href="#基本流程"></a> 基本流程</h4><p>将设ETCD集群中有三个节点(A、B、C)</p><img src="/Users/xboom/Library/Application Support/typora-user-images/image-20230626161744828.png" alt="image-20230626161744828" style="zoom:50%;" /><ol><li>初始化，<strong>所有节点起初都是 Follower 状态</strong>(Term = 0， 得票数 = 0)</li><li>节点 A 由于长时间未收到 Leader 的心跳消息，就会切换成为 Candidate 状态并发起选举<ul><li>节点 A 的选举计时器 Election Timer 己被重置</li></ul></li><li>节点 A 首先会将自己的选票投给自己，并会向集群中其他节点发送选举请求 **Request Vote **以获取其选票，此时节点会有几种状态<ul><li>当前状态是 Leader(初始化的时候不会)</li><li>当前状态是 Candidate，当处于 Candidate 状态而收到 <code>Request Vote</code> 的时候，如果接收到 Term 值比自身记录的 Term 值大的请求时，节点会切换成 Follower 状态井更新自身记录的 Term 值</li><li>当前状态是 Follower，此时的节点 B 和节点 C 还都是处于 Term=0 的任期之中，且都是 Follower 状态，均未投出 Term=1 任期中的选票，所以节点 B 和节点 C 在接收到节点 A 的选举请求后会将选票投给节点 A，任期变为1</li></ul></li></ol><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220306235342.png" alt="image-20220306235342760" style="zoom:50%;"/><ol start="4"><li><p>在节点 A 收到节点 B、 C 的投票之后，其收到了集群中超过半数的选票，所以在 Term = 1 的任期中，该集群的 Leader 节点就是节点 A，其他节点将切换成 Follower 状态，</p><blockquote><p>节点除了记录当期任期号(CurrentTerm)，还记录在该任期中当前节点的投票结果(VoteFor)</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220307000505.png" alt="image-20220307000505928" style="zoom:50%;" /></li><li><p>成为 Term = 1 任期的 Leader 节点之后，节点 A 会定期向集群中的其他节点发送心跳消息，防止节点 B 和节点 C 中的选举计时器Election timer 超时而触发新一轮的选举(重置定时器)，此时当前节点的状态</p><ul><li>当前状态是 Follower，当节点 B 和节点 C (Follower) 收到节点 A 的心跳消息之后会重置选举计时器，更新 Term</li><li>当前状态是 Candidate， 当处于 Candidate 状态而收到 <code>Request Vote</code> 的时候，如果接收到 Term 值比自身记录的 Term 值大的请求时，节点会切换成 Follower 状态井更新自身记录的 Term 值</li></ul><blockquote><p>心跳超时时间（heartbeat timeout）需要远小于选举超时时间(election timeout)</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220307000654.png" alt="image-20220307000653976" style="zoom:50%;" /></li></ol><blockquote><p>Candidate 发起选举前,会先尝试连接集群中的其他节点。如果连接不上，放弃本次选举。这个状态称之为：<strong>Prevote</strong></p></blockquote><p>带着问题看世界</p><ol><li><p>如果Leader节点频繁宕机，或者选举反复进行，怎么办？</p><p>答：要求 心跳超时时间 &lt;&lt; 选举超时时间 &lt;&lt; 平均故障间隔时间</p><ul><li><p>心跳超时时间：节点直接发送心跳信息的完整返回时间 Hearthbeat timeout：0.5ms~50ms</p></li><li><p>选举超时时间：election timer：200ms~1s</p></li><li><p>故障间隔时间：两次故障的平均时间：1个月或更多(保证节点的不要经常出故障)</p></li></ul></li><li><p>是不是谁先发起了选举请求，谁就得到了Leader？</p><p>答：不是，除了看先后顺序，还取决于Candidate节点日志是不是最新最全的日志，否则拒绝投票，防止出现日志(即数据)丢失的情况</p></li><li><p>如果两个节点同时成为 Candidate 发起选举，刚好它们的日志 都是最新的是如何选举的</p><p>答：虽然每个节点的 Election Timer 都不同，但也是不能避免两个节点同时触发选举。比如有 4 个节点</p></li></ol><h4 id="异常情况"><a class="markdownIt-Anchor" href="#异常情况"></a> 异常情况</h4><p><strong>场景 1</strong>：假设A、B同时触发选举，A 的<code>Request Vote</code>先抵达节点 C ，B 的<code>Request Vote</code>先抵达节点 D，A、B 除了得到自身的选票之外，还分别得到了节点 C 和节点 D 的 <code>Vote</code>且票数相同没有超过半数</p><p>在这种情况下， Term = 4 这个任期会以选举失败结束，随着时间的流逝，当任意节点的 Election Timer 到期之后，会再次发起新一轮的选举。由于 <code>election timeout</code> 是在一个时间区间内取的随机数，所以在配置合理的时候，像上述情况多次出现的概率并不大</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230626165029693.png" alt="image-20230626165029693" style="zoom:50%;" /><p><strong>场景 2</strong>：假设选举已经完成， Leader 在运行过程中 Down 掉了</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230626170654713.png" alt="image-20230626170654713" style="zoom:50%;" /><p>当 A 恢复之后，会收到节点 D 发来的心跳消息，该<strong>消息中携带的任期号 Term=6 &gt; 节点 A 前记录的任期号 Term=5</strong> ，A 切换成 Follower</p><p>并更新自身的 Term，同时重置远举计时器</p><p>场景 3：当节点与其他节点断开连接(出现网络分区)，不断触发选举超时，在恢复的时候因为 Term 比较大又成了 Leader</p><p>为了防止选举超时而不断的增加 Term ，当恢复的时候因为 Term 而变成 Leader，所以采取了 Prevote 措施，变为 candidate 的条件</p><ul><li>询问其他节点是否有可用 leader</li><li>可连通绝⼤数节点</li></ul><h3 id="日志复制"><a class="markdownIt-Anchor" href="#日志复制"></a> 日志复制</h3><p>Leader 节点除了向 Follower 节点发送心跳消息，还会处理客户端的请求，并将客户端的写操作 以消息(Append Entries 消息)的形式发送到集群中所有Follower节点</p><p>步骤如下：</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312204541.png" alt="image-20220312204541060"  /><ol><li>Leader 节点接到 client 请求后 <code>set a=10</code>,将本请求计入本地log</li></ol><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312204707.png" alt="image-20220312204707596" /></p><ol start="2"><li>Leader 节点向 Follower1 和 Follower2 发送Append Entries消息 <code>set a=10</code></li><li>Follower1 和 Follower2 将此信息计入本地log，并返回给 Leader</li></ol><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312204848.png" alt="image-20220312204848066" /></p><ol start="4"><li>Leader 将日志信息置为 已提交(Commited),然后状态机处理。</li><li>响应 client 请求</li><li>向 Follower1 和 Follower2 发送消息，该信息已提交</li><li>Follower1 和 Follower2 接到消息后，修改日志状态，交给自己的状态机处理</li></ol><h4 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引</h4><p>集群中各个节点都会维护一个本地 Log 用于记录更新操作，还会维护 <code>commitlndex</code> 和<code>lastApplied</code> 两个值，它们是本地Log 的索引值</p><ul><li><code>commitlndex</code> 表示的是当前节点已知的、最大的、己提交的日志索引值</li><li><code>lastApplied</code> 表示的是当前节点最后一条被应用到状态机中的日志索引值。</li></ul><p>当节点中的 <code>commitlndex</code> 值大于 <code>lastApplied</code> 值时，会将 <code>lastApplied + 1</code> ，并将 <code>lastApplied</code> 对应的日志应用到其状态机中。</p><p>Leader 还需要了解集群中其他 Follower 节点的这些信息，而决定下次发送 Append Entries 消息中包含哪些日志记录。为此， Leader 节点会维护 <code>nextlndex[]</code>和 <code>matchlndex[]</code>两个数组，这两个数组中记录的都是日志索引值</p><ul><li><code>nextlndex[]</code> 记录了需要发送给 Follower 节点的下一条日志的索引值</li><li><code>matchlndex[]</code> 记录了己经复制给每个Follower 节点的最大的日志索引值</li></ul><blockquote><p>一个数组不就可以表达了吗？</p><p>答：不行，<code>nextIndex</code>用于指示Leader节点将要发送给Follower节点的下一个日志条目的位置，帮助Leader节点推进复制进度；<code>matchIndex</code>用于指示Leader节点已经复制到Follower节点上的最高日志条目的位置，帮助Leader节点确定已经<strong>被大多数节点确认的日志条目</strong>，可以进行提交</p></blockquote><p>Leader 节点中 <code>matchlndex</code> 大于等于该 Follower 节点对应的 <code>nextlndex</code> 值，那么通过 Append Entries 消息发送从<code>nextlndex</code> 开始的所有日志。之后，Leader节点会检测该 Follower 节点返回的相应响应，</p><ul><li>如果成功则更新相应该 Follower 节点对应的 <code>nextlndex</code> 值和<code>matchlndex</code> 值；</li><li>如果因为日志不一致而失败，则减少 <code>nextlndex</code> 值重试</li></ul><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230626172915420.png" alt="image-20230626172915420" style="zoom:50%;" /><p>A 作为 Leader 节点记录了 <code>nextlnde</code> 和 <code>matchlndex</code>，所以 A 应该知道向 B 、C 节点发送哪日志</p><p>Raft 协议采用批量发送的方式，当B、C 收到 Append Entries 消息后将日志记录到本地 Log 中，然后向 Leader 节点返回追加日志成功的响应，Leader 节点收到响应之后会递增节点对应的<code>nextlndex</code> 、<code>matchlnde</code> 这样，Leader 节点就知道下次发送日志的位置</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230626173725246.png" alt="image-20230626173725246" style="zoom:50%;" /><p>上面是 Leader 的情况，当 Leader 从 A 切换到 B，B 并不知道 Leader 节点记录 <code>nextlndex</code>、<code>matchlndex</code> 信息 ，所以新 Leader 节点<strong>会重置 nextlndex、matchlnd</strong> ，其中会将 <code>nextlndex</code> 全部重置为其自身 Log 的最后一条己提交日志的 Index，而 <code>matchlndex</code> 全部重置为 0</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230626173850377.png" alt="image-20230626173850377" style="zoom:50%;" /><p>新任期中的 Leader 节点向其他节点发送 Append Entrie 消息，拥有了当前 Leader 全部日志记录，会返回追加成功的响应并等后续的日志，而 C 没有 Index=2 Index=3 两条日志，所以追加日志失败的响应， Leader 节点会将 <code>nextindex</code> 前移</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230626174033113.png" alt="image-20230626174033113" style="zoom:50%;" /><p>然后新 Leader 会再次尝试发送 append entries 消息，循环往复，不断减小 nextlndex值，直至节点C 返回追加成功的响应，之后就进入了正常追加消息记录的流程</p><h4 id="日志判断"><a class="markdownIt-Anchor" href="#日志判断"></a> 日志判断</h4><p>那么又是如何判断两条日志是相同的呢，可能两个节点的 log index 相同但是内容并不相同</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312211352.png" alt="image-20220312211352566" style="zoom:50%;" /><p>raft 中的每个日志记录都带有 term 和 log index 来唯⼀标识，日志记录具有两个特性</p><ul><li>如果两条不同节点的某两个日志记录具有相同的 term 和 index 号，则两条记录⼀定是完全相同的 ;</li><li>如果两条不同节点的某两个日志记录具有相同的 term 和 index 号，则两条记录之前的所有记录也⼀定是完全相同的 ;</li></ul><p>以此来判断 leader与 follower 之间的日志是否相同</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312210348.png" alt="image-20220312210348704" style="zoom:50%;" /><ul><li>leader 从来不会覆盖，删除或者修改其日志 ;</li><li>若 follower 对比其前⼀条 log 不⼀致，则会拒绝 leader 发来的请求. 此时 leader 就将其在 <code>nextIndex[]</code> 中的对应值减⼀</li><li>leader 按照自身日志顺序将日志正常复制给 follower，并不断将 nextIndex[] 对应 值 +1，直到对应值 “追上” 自身日志的 index 为⽌;</li></ul><blockquote><p>问题 1：为什么要一个一个对比，而不直接找到对应的位置，批量复制？</p><p>答：通过数组存储的是索引，但是日志比较是通过 index 与 term</p></blockquote><p>所以，在选举过程中，Follower 节点还需要比较该 Candidate 节点的日志记录与自身的日志记录，拒绝那些日志没有自己新的 Candidat 节点发来的投票请求，确保将选票投给包含了全部己提交(Commited)日志记录的 Candidate 节点</p><p>Raft 协议通过较两节点日志中的最后一条日志记录的索引值和任期号，以决定谁的日志比较新</p><ul><li>首先比较最后一条日志记录的任期号，如果最后的日志记录的任期号不同，那么任期号大的日志记录比较新：</li><li>如果最后一条日志记录的任期号相同，那么日志索引较大的比较新</li></ul><h4 id="复制异常"><a class="markdownIt-Anchor" href="#复制异常"></a> 复制异常</h4><p><strong>场景1</strong>：两个Follower 节点不可用，Leader 如何处理请求</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312201120.png" alt="image-20220312201120077" style="zoom:50%;" /><ul><li><p>leader 通过⼼跳已知 follower 已挂, 则直接返回错误 ;</p></li><li><p>leader 不知节点已挂, 同步数据时得知异常; 触发异常触发超时</p></li></ul><p><strong>场景2</strong>： 提交给Leader后，发生了crash</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312201343.png" alt="image-20220312201343089" style="zoom:50%;" /><ul><li><p>leader 本地已记录已提交日志, 重启后强制同步新 leader 数据 ;</p></li><li><p>leader 还没记录未提交日志就crash, 丢了就丢了;</p></li></ul><p><strong>场景3</strong>：复制给 follower-1 后, leader就发⽣了 crash ?</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312202452.png" alt="image-20220312202452036" style="zoom:50%;" /><ul><li>leader 发⽣了重启，集群触发新的选举 ;</li><li>由于 follower-1 的数据较新, 那么该节点会晋升 leader ;</li><li>follower-1 会把 uncommited 的 v=3 同步给其他节点 ;</li><li>follower-1 收到其他节点接收确认后, 进⾏提交日志 ;</li></ul><p><strong>场景4</strong>：follower 返回确认消息时, leader 发⽣了 crash ?</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312202600.png" alt="image-20220312202600126" style="zoom:50%;" /><ul><li>三个节点的数据已经⼀致, 都为 uncommited v=3 ; 这时谁当 Leader 都可以 ; 新leader当选后, 需要进⾏同步提交通知 ;</li></ul><h3 id="脑裂问题"><a class="markdownIt-Anchor" href="#脑裂问题"></a> 脑裂问题</h3><p>脑裂问题是原本一个集群，被分成了两个集群，同时出现了两个“大脑”，这就是所谓的“脑裂”现象</p><p>出现脑裂的情况：</p><ol><li><p>两边都得到过半票数而选举出Leader的情况，不可能出现</p></li><li><p>两边都无法得到过半票数而无法选举出Leader的情况，则服务端会返回客户端集群不可用</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20220312195949.png" alt="image-20220312195949615" style="zoom:50%;" /></li><li><p>第三种情况：Leader 与 其他节点通信异常，导致其他节点重新选出 Leader</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230626175732437.png" alt="image-20230626175732437" style="zoom:50%;" /><p>由于 E 能收到超过半数的节点选举票 3 而成为新的 Leader，而 A 、B 会发起 PreVote 因为无法获取半数响应，所以不会触发选举</p><h3 id="客户端交互"><a class="markdownIt-Anchor" href="#客户端交互"></a> 客户端交互</h3><p>集群中只有 Leader 点可以处理客户端发来的请求，当  follower 节点收到客户端的请求时，也须将 Leader 信息告知客户端，然后由 Leader 点处理其请求，具体步骤如下：</p><ol><li>当客户端初次 接到集群时， 会随机挑选个服务器节点进行通信</li><li>如果客户端第一次挑选的节点不是 Leader 节点 ，那么该节点会拒绝客户端的请求，并且将它所知道的 Leader 节点的信息返回给客户端。</li><li>当客户端连接到 Leader 节点之后，即可发送消息进行交互</li><li>如果在交互过程中 Leader 节点宕机，那么客户端的请求会超时，客户端会再次随挑选集群中的节点，并从步骤2重新开始执行</li></ol><p><strong>异常 1</strong>：发生脑裂</p><p>与节点之间发生网络分区之后，客户端发往节点 A 请求将会超时，这是因为节点 A 无法将请求发送到集群中超过半数的节点 ，该请求相应的日志记录也就无法提交，从而导致无法给客户端返回相应的响应</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20230626181508973.png" alt="image-20230626181508973" style="zoom:50%;" /><p><strong>异常 2</strong>：Leader 与其他节点通信异常</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/20220313111102.png" alt="image-20220313111102564" style="zoom:40%;" /><ul><li>由于 leader A ⽆法同步数据到多数节点, 造成 client 写请求失败 ;</li><li>⽹络分区后 follower c 长时间未收到⼼跳, 则触发选举且当选 ;</li><li>client 按照策略⼀直尝试跟可用的节点进⾏请求 ;</li><li>当⽹络恢复后, leader A B 将降为 follower, 并且强制同步 Leader C 的数据 ;</li></ul></li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li>《ETCD技术内幕》</li><li><a href="http://www.xuyasong.com/?p=1706" target="_blank" rel="noopener">http://www.xuyasong.com/?p=1706</a></li><li><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习分布式系统过程中，经常能碰到一致性算法，即使出现部分节点故障，网络延时等情况，也不影响整体可用性，进而提高系统的整体可用性。Raft协议是一种分布式一致性算法(共识算法)，共识就是多个节点对某一个事件达成一致的算法，常见的一致性协议有Raft、Paxos、ZAB，根据
      
    
    </summary>
    
    
      <category term="Protocol" scheme="http://xboom.github.io/categories/Protocol/"/>
    
    
      <category term="ETCD" scheme="http://xboom.github.io/tags/ETCD/"/>
    
      <category term="Distributed System" scheme="http://xboom.github.io/tags/Distributed-System/"/>
    
      <category term="Raft" scheme="http://xboom.github.io/tags/Raft/"/>
    
  </entry>
  
  <entry>
    <title>Go入门15-SyncMap</title>
    <link href="http://xboom.github.io/2023/04/04/Go/Go%E5%85%A5%E9%97%A815-SyncMap/"/>
    <id>http://xboom.github.io/2023/04/04/Go/Go%E5%85%A5%E9%97%A815-SyncMap/</id>
    <published>2023-04-04T13:01:05.349Z</published>
    <updated>2023-05-31T16:01:10.769Z</updated>
    
    <content type="html"><![CDATA[<p>一开始以为 <code>Sync.Map</code> 仅仅是封装的了一层，后来在与同事的讨论中发现并不是这样，这里重新学习一下源码</p><h3 id="线程安全"><a class="markdownIt-Anchor" href="#线程安全"></a> 线程安全</h3><p>首先搞清楚一个问题，什么是并发安全。由于没有完整的解释，我找了一段Java中的表达</p><blockquote><p>当多个线程访问某个类时，不管运行环境采用何种调度方式或者这些进程将如何交替执行，并且在主调代码中不需要任何额外的协同或者同步，这个类都能表现出正确的行为，那么这个类是线程安全的</p></blockquote><p>大致抓住两点 <strong>无论如何交替执行</strong> <strong>表现出正确的行为</strong>，有点抽象，反过来问 <strong>什么情况会导致线程不安全</strong>？<strong>怎样才能保证线程安全？</strong></p><p><u>当前的一个操作可能不是原子的，执行过程中会被打断，其他线程有能力修改共享变量的值，同时存在线程修改的值不是立即对其他线程可见的，因为线程有自己的执行空间，另外一点就是存在程序可能存在乱序执行的情况，单线程没问题，但是多个线程同时执行，线程共享的数据会出现错乱</u>。那么保证线程安全的三个特征：</p><ul><li><strong>原子性</strong>：提供互斥访问、同一时刻只能有一个线程在操作</li><li><strong>可见性</strong>：一个线程对主内容的修改可以及时被其他线程看到</li><li><strong>有序性</strong>：程序在执行的时候，程序的代码执行顺序和语句的顺序是一致的有序性<ul><li>多个协程并发执行，那么<strong>几个协程之间是没有有序性的</strong>，但是协程里面的代码是有序的</li><li>什么情况下代码的执行顺序与语句顺序不一致？比如指令重排序，将多次访问主存合并到一起执行</li></ul></li></ul><p>这样就好理解为啥普通的map会存在并发安全问题了，因为一个协程的修改对于另外一个协程可能是不可见的。另外当map并发读写时候触发的panic是map内部实现的，结构体的并发读写只会报错不会panic。</p><h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3><p>普通的map并发处理实践</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="keyword">struct</span>&#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>sync.Map</code> 则可以</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter sync.Map</span><br></pre></td></tr></table></figure><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>源码：<code>src/sync/map.go</code></p><p>为了实现并发安全的Map，<code>Sync.Map</code>实现了一种读写分离的方式</p><ol><li>空间换时间。 通过冗余的两个数据结构(read、dirty),实现加锁对性能的影响。</li><li>动态调整，miss次数多了之后，将dirty数据提升为read。</li><li>double-checking，因为是判断与获取并不是原子操作，所以会出现 double-checking</li><li>延迟删除。 删除一个键值只是打标记，只有在提升dirty的时候才清理删除的数据。</li><li>优先从read读取、更新、删除，因为对read的读取不需要锁。</li></ol><p><strong>问题1</strong>：如何在并发情况下修改或删除已经存在的Key？</p><p>答：通过将 key 映射到 val 的地址，然后 val 指针指向真正的值，那么只需要保证 <code>address</code> 指针的原子操作，就能解决并发安全问题</p><blockquote><p>key -&gt; &amp;地址 --&gt; 真正的值</p></blockquote><p><strong>问题2</strong>：如何在写的同时保证读的准确性</p><p>答：读写指向的是同一个指针，首先在写时会通过互斥锁防止并发操作 <code>dirty</code>，其次就是用到了<code>atomic</code>原子操作<code>value</code>指针</p><p><strong>问题3</strong>：如果读写分离，如何将写入的数据同步到读中</p><p>答： 1. 第一种是当<code>misses == len(dirty)</code>的时候就会升级<code>dirty</code>到<code>read</code>中；第二种就是在遍历的如果<code>dirty</code>有<code>read</code>中没有的数据；</p><p>第三其实也不是读写分离，而是乐观锁，因为如果<code>read</code>中已经有key/val，也会尝试去更新<code>read</code>，发现已经删除，则去dirty中更新</p><p>最后的实现就变成了下面这个样子</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/20200505120255.png" alt="sync.map 整体结构" style="zoom:50%;" /><p><strong>问题4</strong>：指向的是同一个<code>entry</code>，不还是一样需要加锁吗？内部 的<code>mutex</code> 与 <code>atomic.pointer</code>的区别跟作用又是什么？</p><p><code>mutex</code> 与 <code>atomic</code> 的区别是：<code>mutex</code> 通过阻塞其他协程起到了原子操作的功能，是用来保护 dirty 的读写的。而<code>atomic</code>是通过CPU指令，来达到值操作的原子性，所以 <code>atomic</code>与<code>mutex</code>并不是一个层面的东西，<code>atomic</code>也比<code>mutex</code>更快。</p><p>所以才会出现 <code>mutex</code> 保护的是 <code>dirty</code>，而 <code>atomic</code> 保护的是 <code>entry</code> 具体值</p><h4 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h4><p>定义的 <code>Map</code> 中 除普通的map 与 互斥锁，还增加了两个字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">//当涉及到dirty的操作的时候，需要使用这个锁</span></span><br><span class="line">   mu Mutex</span><br><span class="line">  <span class="comment">// 一个只读结构(实际也会更新这个数据的entries，标记为未删除的unexpunger)</span></span><br><span class="line">   read atomic.Pointer[readOnly]</span><br><span class="line">  <span class="comment">// dirty包含最新的entries(包括read中未删除的数据,虽有冗余，但也提升dirty字段为read的时候非常快，不用一个一个的复制，而是直接将这个数据结构作为read字段的一部分),有些数据还可能没有移动到read字段中。</span></span><br><span class="line"><span class="comment">// 对于dirty的操作需要加锁，因为对它的操作可能会有读写竞争。</span></span><br><span class="line"><span class="comment">// 当dirty为空的时候， 比如初始化或者刚提升完，下一次的写操作会复制read字段中未删除的数据到这个数据中。</span></span><br><span class="line">   dirty <span class="keyword">map</span>[any]*entry</span><br><span class="line">  <span class="comment">// 当从Map中读取entry的时候，如果read中不包含这个entry,会尝试从dirty中读取，这个时候会将misses加一，</span></span><br><span class="line"><span class="comment">// 当misses累积到 dirty的长度的时候， 就会将dirty提升为read,避免从dirty中miss太多次。因为操作dirty需要加锁</span></span><br><span class="line">   misses <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中存在两个结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">m       <span class="keyword">map</span>[any]*entry</span><br><span class="line">amended <span class="keyword">bool</span> <span class="comment">// 为true 表示dirty中存在一些新增的键值对</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基本"><a class="markdownIt-Anchor" href="#基本"></a> 基本</h4><ol><li><code>read</code> 与 <code>dirty</code> 的转换</li><li><code>entry</code>的操作</li></ol><h5 id="entry"><a class="markdownIt-Anchor" href="#entry"></a> entry</h5><p><code>entry</code> 代表的是每个 key 在<code>Map</code>中对应的一个 <code>entry</code>，并且还记录了 <strong>其他信息</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">p atomic.Pointer[any]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> expunged = <span class="built_in">new</span>(any) <span class="comment">//</span></span><br></pre></td></tr></table></figure><p><code>p</code> 一共记录林 <code>entry</code> 的三种状态</p><ol><li><code>nil</code>: <code>entry</code>已被删除了，并且<code>m.dirty</code>为<code>nil</code></li><li><code>expunged</code>: <code>entry</code>已被删除了，并且<code>m.dirty</code>不为<code>nil</code>，而且这个<code>entry</code>不存在于<code>m.dirty</code>中</li><li>其它： <code>entry</code>是一个正常的值</li></ol><p>构建一个 <code>entry</code> 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newEntry</span><span class="params">(i any)</span> *<span class="title">entry</span></span> &#123;</span><br><span class="line">   e := &amp;entry&#123;&#125;</span><br><span class="line">   e.p.Store(&amp;i)</span><br><span class="line">   <span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">load</span><span class="params">()</span> <span class="params">(value any, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">p := e.p.Load()</span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;<span class="comment">//表示不存在</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *p, <span class="literal">true</span><span class="comment">//表示存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>entry</code> 使用 <code>atomic.Pointer[n]</code> 的作用在后面才体现出来, <code>atomic.Pointer</code> 原子地读取和存储指针类型的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">trySwap</span><span class="params">(i *any)</span> <span class="params">(*any, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      p := e.p.Load()</span><br><span class="line">      <span class="keyword">if</span> p == expunged &#123;<span class="comment">//如果已经被删除则返回false</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> e.p.CompareAndSwap(p, i) &#123;<span class="comment">//否则不断的CAS更新</span></span><br><span class="line">         <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h4><p>操作与正常的map类似，包含 存储、获取、删除、遍历。除此之外还增加的 交换、比较交换、比较删除</p><h5 id="获取"><a class="markdownIt-Anchor" href="#获取"></a> 获取</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Load</span><span class="params">(key any)</span> <span class="params">(value any, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1.首先从m.read中得到只读readOnly,从它的map中查找，不需要加锁</span></span><br><span class="line">  read := m.loadReadOnly()</span><br><span class="line">e, ok := read.m[key]</span><br><span class="line">  <span class="comment">//2. 如果没找到，并且m.dirty中有新数据，需要从m.dirty查找，这个时候需要加锁</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123; <span class="comment">// a 操作</span></span><br><span class="line">m.mu.Lock()  <span class="comment">//b 操作</span></span><br><span class="line">    <span class="comment">//双检查，避免加锁的时候m.dirty提升为m.read,这个时候m.read可能被替换了。</span></span><br><span class="line">read = m.loadReadOnly()</span><br><span class="line">e, ok = read.m[key]</span><br><span class="line">    <span class="comment">// 如果m.read中还是不存在，并且m.dirty中有新数据</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">      <span class="comment">// 从m.dirty查找</span></span><br><span class="line">e, ok = m.dirty[key]</span><br><span class="line">      <span class="comment">// 不管m.dirty中存不存在，都将misses计数加一</span></span><br><span class="line"><span class="comment">// missLocked()中满足条件后就会提升m.dirty</span></span><br><span class="line">m.missLocked()</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个注意事项</p><ol><li><p>出现double-check，是因为在执行 <code>if !ok &amp;&amp; read.amended</code> 的过程中，dirty可能升级为read，所以还是需要锁操作</p></li><li><p>不管 m.dirty中是否存在，都需要misses+1，表明 read中不存在才到 dirty中获取</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">missLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">m.misses++</span><br><span class="line"><span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">m.read.Store(&amp;readOnly&#123;m: m.dirty&#125;)<span class="comment">//直接将dirty升级到read中，然后</span></span><br><span class="line">m.dirty = <span class="literal">nil</span></span><br><span class="line">m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>什么时候讲dirty提升为 read，当 <code>misses &gt;= len(m.dirty)</code></p><h5 id="存储"><a class="markdownIt-Anchor" href="#存储"></a> 存储</h5><p>从接口实现可以看出，存储 k/v 内部使用的其实 Swap 接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Store</span><span class="params">(key, value any)</span></span> &#123;</span><br><span class="line">   _, _ = m.Swap(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接查看 <code>Swap</code> 的实现原理</p><p>根据描述，<code>Swap</code> 的作用是 将 <code>newValue</code> 更新入 <code>key</code> 所对应的 <code>value</code>中，并将 <code>oldValue</code> 返回。另外一个返回值<code>loaded</code>表示 <code>key</code> 是否存在</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Swap</span><span class="params">(key, value any)</span> <span class="params">(previous any, loaded <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 如果m.read存在这个键，并且这个entry没有被标记删除，尝试直接存储。</span></span><br><span class="line"><span class="comment">// 因为m.dirty也指向这个entry,所以m.dirty也保持最新的entry。</span></span><br><span class="line">   read := m.loadReadOnly()</span><br><span class="line">   <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;<span class="comment">//如果只读存在</span></span><br><span class="line">      <span class="keyword">if</span> v, ok := e.trySwap(&amp;value); ok &#123;<span class="comment">//尝试去更新value，如果未 标记删除</span></span><br><span class="line">         <span class="keyword">if</span> v == <span class="literal">nil</span> &#123;<span class="comment">//value为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> *v, <span class="literal">true</span><span class="comment">//更新成功 返回 true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   m.mu.Lock()<span class="comment">// 加锁，如果`m.read`不存在或者已经被标记删除</span></span><br><span class="line">   read = m.loadReadOnly()</span><br><span class="line">   <span class="keyword">if</span> e, ok := read.m[key]; ok &#123; <span class="comment">//只读存在</span></span><br><span class="line">     <span class="keyword">if</span> e.unexpungeLocked() &#123;<span class="comment">//如果未标记删除则删除read,然后存入dirty(写数据到dirty中)</span></span><br><span class="line">         m.dirty[key] = e<span class="comment">//存入 dirty</span></span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">if</span> v := e.swapLocked(&amp;value); v != <span class="literal">nil</span> &#123;<span class="comment">//未标记删除则直接更新read</span></span><br><span class="line">         loaded = <span class="literal">true</span></span><br><span class="line">         previous = *v</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;<span class="comment">//只读不存在但是dirty存在</span></span><br><span class="line">      <span class="keyword">if</span> v := e.swapLocked(&amp;value); v != <span class="literal">nil</span> &#123;</span><br><span class="line">         loaded = <span class="literal">true</span></span><br><span class="line">         previous = *v</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;<span class="comment">//都不存在</span></span><br><span class="line">      <span class="keyword">if</span> !read.amended &#123;<span class="comment">//dirty中没有新值</span></span><br><span class="line">         m.dirtyLocked()<span class="comment">//如果dirty为空，从 m.read中复制未删除的数据</span></span><br><span class="line">         m.read.Store(&amp;readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;) <span class="comment">//read中存储</span></span><br><span class="line">      &#125;</span><br><span class="line">      m.dirty[key] = newEntry(value)<span class="comment">//dirty 存储一个新的 value地址</span></span><br><span class="line">   &#125;</span><br><span class="line">   m.mu.Unlock()</span><br><span class="line">   <span class="keyword">return</span> previous, loaded</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>dirtyLocked的</code>作用是将未删除的复制到<code>dirty</code>中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">dirtyLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;<span class="comment">//如果不为空直接返回</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   read := m.loadReadOnly()</span><br><span class="line">   m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[any]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line">   <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">      <span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">         m.dirty[k] = e</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">tryExpungeLocked</span><span class="params">()</span> <span class="params">(isExpunged <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   p := e.p.Load()<span class="comment">//加载entry中的地址</span></span><br><span class="line">   <span class="keyword">for</span> p == <span class="literal">nil</span> &#123;<span class="comment">//如果为空</span></span><br><span class="line">      <span class="keyword">if</span> e.p.CompareAndSwap(<span class="literal">nil</span>, expunged) &#123;<span class="comment">//尝试使用 expunged更新状态</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      p = e.p.Load()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> p == expunged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Delete</span><span class="params">(key any)</span></span> &#123;</span><br><span class="line">m.LoadAndDelete(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">LoadAndDelete</span><span class="params">(key any)</span> <span class="params">(value any, loaded <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//先从read中加载</span></span><br><span class="line">read := m.loadReadOnly()</span><br><span class="line">e, ok := read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;<span class="comment">//read没有且dirty中有新数据</span></span><br><span class="line">    <span class="comment">//开启锁</span></span><br><span class="line">m.mu.Lock()</span><br><span class="line">read = m.loadReadOnly()</span><br><span class="line">e, ok = read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;<span class="comment">//如果read没有，则dirty中有新数据</span></span><br><span class="line">e, ok = m.dirty[key]</span><br><span class="line"><span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">      m.missLocked()<span class="comment">//当misses数量达到 len(m.dirty),dirty升级为read</span></span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">return</span> e.<span class="built_in">delete</span>()<span class="comment">//如果read存在则标记删除</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果read中存在，那么仅会标记删除</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">delete</span><span class="params">()</span> <span class="params">(value any, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      p := e.p.Load()</span><br><span class="line">      <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;<span class="comment">//如果为空或者标记删除，返回没有数据</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> e.p.CompareAndSwap(p, <span class="literal">nil</span>) &#123;<span class="comment">//标记为nil，并不会直接删除</span></span><br><span class="line">         <span class="keyword">return</span> *p, <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遍历"><a class="markdownIt-Anchor" href="#遍历"></a> 遍历</h5><p>因为是读写分离，所以在遍历的过程中</p><ol><li>如果dirty中没有新数据，那么就使用read遍历</li><li>如果dirty中有新数据，那么就将dirty升级为read，然后遍历read</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Range</span><span class="params">(f <span class="keyword">func</span>(key, value any)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">   <span class="comment">//判断dirty是否有新值</span></span><br><span class="line">   read := m.loadReadOnly()</span><br><span class="line">   <span class="keyword">if</span> read.amended &#123;</span><br><span class="line">      m.mu.Lock()<span class="comment">//开锁</span></span><br><span class="line">      read = m.loadReadOnly()</span><br><span class="line">      <span class="keyword">if</span> read.amended &#123;<span class="comment">//dirty是否有新值</span></span><br><span class="line">         read = readOnly&#123;m: m.dirty&#125;</span><br><span class="line">         m.read.Store(&amp;read)<span class="comment">//升级dirty为read</span></span><br><span class="line">         m.dirty = <span class="literal">nil</span></span><br><span class="line">         m.misses = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">      m.mu.Unlock()</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//遍历read</span></span><br><span class="line">   <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">      v, ok := e.load()</span><br><span class="line">      <span class="keyword">if</span> !ok &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> !f(k, v) &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3><ol><li><p>该map仅针对特定的场景</p><ul><li>Key 读多写少的情况，例如只增长的缓存</li><li>多个协程针对不同的key合集进行读写更新时候可以用</li><li>sync.Map 不能在第一次使用后复制</li></ul></li><li><p>由于dirty达到一定条件就需要升级为read，所以适用读多写少的场景</p></li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://www.cnblogs.com/qcrao-2018/p/12833787.html" target="_blank" rel="noopener">https://www.cnblogs.com/qcrao-2018/p/12833787.html</a></li><li><a href="https://colobu.com/2017/07/11/dive-into-sync-Map/#sync-Map%E7%9A%84%E6%80%A7%E8%83%BD" target="_blank" rel="noopener">https://colobu.com/2017/07/11/dive-into-sync-Map/#sync-Map的性能</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一开始以为 &lt;code&gt;Sync.Map&lt;/code&gt; 仅仅是封装的了一层，后来在与同事的讨论中发现并不是这样，这里重新学习一下源码&lt;/p&gt;
&lt;h3 id=&quot;线程安全&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线程安全&quot;&gt;&lt;/a&gt; 线程安全&lt;
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go入门24-协程池问题</title>
    <link href="http://xboom.github.io/2023/03/05/Go/Go%E5%85%A5%E9%97%A824-%E5%8D%8F%E7%A8%8B%E6%B1%A0%E9%97%AE%E9%A2%98/"/>
    <id>http://xboom.github.io/2023/03/05/Go/Go%E5%85%A5%E9%97%A824-%E5%8D%8F%E7%A8%8B%E6%B1%A0%E9%97%AE%E9%A2%98/</id>
    <published>2023-03-05T06:46:45.000Z</published>
    <updated>2023-04-05T04:17:47.389Z</updated>
    
    <content type="html"><![CDATA[<p>之前在整理 <a href="https://www.yuankang.top/2022/07/06/GoZero/GoZero4-%E5%8D%8F%E7%A8%8B%E6%B1%A01/" target="_blank" rel="noopener">GoZero4-协程池</a>的过程中发现 <a href="https://github.com/bytedance/gopkg/tree/develop/util/gopool" target="_blank" rel="noopener">字节跳动开源的协程池</a>在使用中需要注意的地方：</p><p>​<strong>使用双向链表存储任务，表示它理论上支持无限个任务。后面的任务可能存在长时间等待的情况，并不存在任务过期处理逻辑</strong></p><p>没想到在实际应用中真的没注意踩了一遍，这里记录一下这个原因与后续的解决思路，排查过程就不赘述了。</p><p>伪代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Send</span><span class="params">(conn *grpc.ClientConn)</span></span> &#123;</span><br><span class="line">c := pb.NewGreeterClient(conn)</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">3</span>*time.Second)</span><br><span class="line"></span><br><span class="line">gopool.CtxGo(ctx, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="comment">//1. 通信消息自定义处理</span></span><br><span class="line">Handle(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 发送消息</span></span><br><span class="line">_, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: *name&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"could not greet: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="comment">//log.Printf("end success")</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">5</span>):</span><br><span class="line">log.Printf(<span class="string">"time out"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题原因</strong>：负责底层通信的 grpc-go(进行过二次开发) 使用了上述的协程池进行发送接口的超时控制。当突然大量的消息进入，消息接受速率 大于 消息发送-响应速率。导致过量的消息全部堆积到这个双向链表中，而本身消息是有超时时间的，就导致堆积的消息越来越多，消息等到发送的时候已经超时了，所以就出现了服务OOM，消息也无法发送出去。</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/%E5%8D%8F%E7%A8%8B%E6%B1%A0%E9%97%AE%E9%A2%982.png" alt="协程池问题2" style="zoom:50%;" /><p>类似上图所示，模拟客户端通过协程池的发送协程 <strong>work</strong> 实现超时控制消息任务 <strong>t</strong> 的发送</p><ul><li>第一阶段，发送协程 <strong>work</strong> 的消费速率 大于 消息任务 <strong>t</strong> 的生产速率，一切正常</li><li>第二阶段，发送协程 <strong>work</strong> 的消费速率 小于 消息任务 <strong>t</strong> 的生产速率的时候，消息开始在双向链表中堆积，出现内存快速增长</li><li>第三阶段，当 消息任务 <strong>t</strong> 的堆积 超过自定义超时时间的时候，所有消息都发送超时失败</li><li>第四阶段，当 双向链表中的任务堆积导致内存超时服务上限的时候，服务OOM</li></ul><p>这里产生了如下几个思考</p><ol><li>能否在任务双向链表中限制数量大小当发送超过限制的时候直接失败?</li><li>为什么不直接使用管道来代替底层的双向链表？</li><li>能否自动丢弃超时的消息并返回结果，注意这个时候是在协程里面运行的</li><li>如何像linux一样保存 pod因为OOM而产生的core方便后续分析</li></ol><p>第一个问题是可以解决的，协程池对象存在 taskCount 记录当前任务数量，也就是说可以增加协程池容量判断来达到限制目的</p><ul><li>增加协程池任务容量字段 <code>taskCap</code></li><li>增加接口，协程失败返回错误 error</li><li>添加协程池容量判断</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pool)</span> <span class="title">CtxGo2</span><span class="params">(ctx context.Context, f <span class="keyword">func</span>()</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">  cur := atomic.AddInt32(&amp;p.taskCount, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> cur &gt; p.taskCap &#123;<span class="comment">//当前任务容量判断</span></span><br><span class="line"><span class="keyword">return</span> errors.New</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个问题管道的缺点是管道数量是固定的，也就是达不到根据任务数量动态扩容 <code>work</code> 的功效</p><p>第三个问题由于任务放入协程中相当于异步处理，并不能直接将任务待执行超时的情况返回给客户端，可以通过自定义处理函数或者内部的panic处理任务超时的情况；但又能如何发现任务超时，时间轮貌似是个好东西</p><p>第四个问题找到<a href="https://juejin.cn/post/6844903792136159239" target="_blank" rel="noopener">一篇实践</a>，实操之后再单独记录</p><p>总结：</p><ol><li>我在使用过程中忽视了双向队列任务堆积的情况，令牌桶的使用也可能存在这样的情况(正常情况不会配置速率上千万的情况)，注意异常情况下的配置范围</li><li>上述需要改进与实操的部分尝试解决之后再来补充这边文章</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在整理 &lt;a href=&quot;https://www.yuankang.top/2022/07/06/GoZero/GoZero4-%E5%8D%8F%E7%A8%8B%E6%B1%A01/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GoZero4-协
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>算法-E10C-最大公约数</title>
    <link href="http://xboom.github.io/2023/02/02/Algorithms%20To%20Live%20By/%E7%AE%97%E6%B3%95-E10C-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"/>
    <id>http://xboom.github.io/2023/02/02/Algorithms%20To%20Live%20By/%E7%AE%97%E6%B3%95-E10C-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</id>
    <published>2023-02-02T12:25:25.494Z</published>
    <updated>2023-02-15T13:39:32.337Z</updated>
    
    <content type="html"><![CDATA[<p>今天碰到一道有意思的题目，学到了很多东西，所以记录一下</p><p><a href="https://leetcode.cn/problems/check-if-it-is-a-good-array/" target="_blank" rel="noopener">检查好数组</a></p><p>碰到之后完全不知道如何入手，最后通过看解答才弄明白，但是中间有很多知识点可以记录一下</p><p><strong>首先</strong> 需要知道裴蜀定理，又称贝祖定理，是一个最大公约数定理：设 a, b 是不全为零的整数，则存在整数 x , y , 使得</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ax + by = gcd(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span></p><ol><li><p>若任何一个等于0，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">gcd(a, b) == a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span></p></li><li><p>对任何整数a、b和它们的最大公约数d，关于未知数x和y的线性丢番图方程</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">ax + by = m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span></span></p><p>有解当前仅当 m 是 d 的倍数</p></li></ol><blockquote><p>这里有一个奇特的点 0 因为没有因数，所以 0 不与其他数存在最大公约数，等我看了 类欧几里德算法 再补充</p></blockquote><p>所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ax + by = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 有解，那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(a, b) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><p>其次 我们如何求一个两个数的最大公约数，经典的 <strong>辗转相除法</strong>(又称 <strong>欧几里德算法</strong>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以使用现有函数 gcd(a, b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b ? GCD(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>证明 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a, b) = gcd(b, a \% b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 过程如下</p><ol><li><p>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi><mi>k</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a = bk + c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>，所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">c = a \% b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span></span></span></span></p></li><li><p>设 d 是 a , b 的公约数</p></li><li><p>所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>=</mo><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>∗</mo><mi>k</mi><mo>+</mo><mi>c</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">a / d = b / d * k + c / d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span></p></li><li><p>因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">a / d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">b / d * k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 是整数，所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">c / d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span> 也是整数</p></li><li><p>将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">c = a \% b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span></span></span></span> 带入第3步得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>−</mo><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>∗</mo><mi>k</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">a / d - b / d * k = a \% b / d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span>，因为 左边是整数，所有等式右边也是整数</p></li><li><p>那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>+</mo><mi>b</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">a / d = a \% b / d + b / d * k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，那么 d 也是  b, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">a \% b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span></span></span></span> 的约数，也是 a, b 的约数</p></li><li><p>尽然两式的公约数是相同的，那么最大公约数也会相同</p></li><li><p>所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a, b) = gcd(b, a mod b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p></li></ol><p>最后就是这个题目的解答</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b ? Gcd(b, a % b) : a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isGoodArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//1与任意正整数的最大公约数是1</span></span><br><span class="line">            v = Gcd(nums[i], v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://oi-wiki.org/math/number-theory/gcd/" target="_blank" rel="noopener">https://oi-wiki.org/math/number-theory/gcd/</a></li><li><a href="https://leetcode.cn/problems/check-if-it-is-a-good-array/" target="_blank" rel="noopener">https://leetcode.cn/problems/check-if-it-is-a-good-array/</a></li><li><a href="https://oi-wiki.org/math/number-theory/bezouts/" target="_blank" rel="noopener">https://oi-wiki.org/math/number-theory/bezouts/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天碰到一道有意思的题目，学到了很多东西，所以记录一下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/check-if-it-is-a-good-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;检查好
      
    
    </summary>
    
    
      <category term="Algorithms To Live By" scheme="http://xboom.github.io/categories/Algorithms-To-Live-By/"/>
    
    
      <category term="Algorithms To Live By" scheme="http://xboom.github.io/tags/Algorithms-To-Live-By/"/>
    
  </entry>
  
  <entry>
    <title>Go入门23-arena</title>
    <link href="http://xboom.github.io/2023/01/10/Go/Go%E5%85%A5%E9%97%A823-arena/"/>
    <id>http://xboom.github.io/2023/01/10/Go/Go%E5%85%A5%E9%97%A823-arena/</id>
    <published>2023-01-10T08:00:20.000Z</published>
    <updated>2023-06-02T08:42:51.246Z</updated>
    
    <content type="html"><![CDATA[<p>最近 <code>Go1.20</code> 更新，中间讲到了一个特性 <code>arena</code> ，这里看看加入 <code>arena</code> 的作用</p><blockquote><p>在Go的内存管理中，<code>arena</code> 其实就是所谓的堆区，然后将这个区域分割成 <code>8KB</code> 大小的页，组合起来称为 <code>mspan</code>，<code>mspan</code>就是Go中内存管理的基本单元，是由一片连续的 8KB 的页组成的大块内存。其实 <code>mspan</code> 是一个包含起始地址、规格、页的数量等内容的双端链表</p></blockquote><p>虽然 Go 的垃圾回收机制能够正常的进行内存管理，但是存在以下问题</p><ol><li>垃圾回收机制需要花费大量CPU进行垃圾回收操作</li><li>垃圾回收机制有一定的延迟性，导致花费的内存比实际的内存要大</li></ol><p>而 <code>arena</code> 的优势 <strong>允许从连续的内存空间中分配对象并一次性进行释放</strong></p><p>注意：在 <a href="https://github.com/golang/go/issues/51317" target="_blank" rel="noopener">github arena 的话题</a>中，有一个最新的笔记提醒, 即处在测试阶段的 arena 功能随时可能被去除掉</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Note, 2023-01-17. This proposal is on hold indefinitely due to serious API concerns. The GOEXPERIMENT=arena code may be changed incompatibly or removed at any time, and we do not recommend its use in production.</span><br></pre></td></tr></table></figure><p>带着问题看世界：</p><ol><li>它跟内存池的区别</li><li>由于需要连续的内存空间，那么当需要分配的内存比较多，没有这么大的连续内存空间怎么办？</li><li>如果它分配的对象有一部分存在内存逃逸，那么该如何处理？</li><li>能支持并发吗</li></ol><h3 id="基础功能"><a class="markdownIt-Anchor" href="#基础功能"></a> 基础功能</h3><p>由于是实验功能，所以需要配置环境变量 <code>GOEXPERIMENT=arenas</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"arena"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;</span><br><span class="line">Foo <span class="keyword">string</span></span><br><span class="line">Bar [<span class="number">16</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processRequest</span><span class="params">(req *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// Create an arena in the beginning of the function.</span></span><br><span class="line">mem := arena.NewArena()</span><br><span class="line"><span class="comment">// Free the arena in the end.</span></span><br><span class="line"><span class="keyword">defer</span> mem.Free()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a bunch of objects from the arena.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">obj := arena.New[T](mem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or a slice with length and capacity.</span></span><br><span class="line">slice := arena.MakeSlice[T](mem, <span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想在arena释放时候继续使用它分配的对象，则可以通过 Clone 从堆中浅拷贝一个对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj1 := arena.New[T](mem) <span class="comment">// arena-allocated</span></span><br><span class="line">obj2 := arena.Clone(obj1) <span class="comment">// heap-allocated</span></span><br><span class="line">fmt.Println(obj2 == obj1) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">mem.Free()</span><br></pre></td></tr></table></figure><p>其他接口包括</p><ul><li><code>NewArena</code>：创建一个新的 arena 内存空间。</li><li><code>Free</code>：释放 arena 及其关联对象。</li><li><code>New</code>：基于 arena，创建新对象。</li><li><code>MakeSlice</code>：基于 arena，创建新切片。</li><li><code>Clone</code>：克隆一个 arena 的对象，并移动到内存堆上。<strong>只能是指针、slice或者字符串</strong></li></ul><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>代码路径：</p><ol><li><code>src/runtime/arena.go</code></li><li><code>src/arena/arena.go</code></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arena 表示多个Go一起分配与释放的内存集合，当其中的对象不在被引用那么将会自动释放</span></span><br><span class="line"><span class="keyword">type</span> Arena <span class="keyword">struct</span> &#123;</span><br><span class="line">a unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewArena allocates a new arena.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewArena</span><span class="params">()</span> *<span class="title">Arena</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Arena&#123;a: runtime_arena_newArena()&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据描述这里注意点有两个：</p><ol><li>arena 分配的对象需要及时释放</li><li>既然是自动释放，然后在使用中 <code>defer arena.Free()</code> 可以任务是，不用等到二次垃圾回收，直接将资源释放，并将可重复使用的mspan放入<code>reused</code>中</li></ol><p>查看Arena 内部结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> userArena <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 指向一个链表，表示一系列没有足够空闲内存的 mspan(内存段)。当该内存管理区域被释放时，这些 mspan 也会被释放</span></span><br><span class="line">fullList *mspan  <span class="comment">//内存组件 mspan</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向一个 mspan，表示未满的内存段。这个 mspan 中还有可用的内存可以分配</span></span><br><span class="line">active *mspan   </span><br><span class="line"></span><br><span class="line">  <span class="comment">//一个指向 unsafe.Pointer 类型的切片，用于引用当前内存管理区域的对象。这可以防止在仍然有引用对象时释放该内存管理区域</span></span><br><span class="line">refs []unsafe.Pointer</span><br><span class="line"></span><br><span class="line">  <span class="comment">//一个原子布尔类型的变量，用于标记内存管理区域是否已经被释放。如果为 true，表示该内存管理区域已经被释放，以避免重复释放</span></span><br><span class="line">defunct atomic.Bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Arena 如果重复释放也没有关系，判断释放过则直接结束</li></ul><p>**第一步：**分配一个 <code>Arena</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newUserArena creates a new userArena ready to be used.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newUserArena</span><span class="params">()</span> *<span class="title">userArena</span></span> &#123;</span><br><span class="line">a := <span class="built_in">new</span>(userArena)</span><br><span class="line">SetFinalizer(a, <span class="function"><span class="keyword">func</span><span class="params">(a *userArena)</span></span> &#123; <span class="comment">//g</span></span><br><span class="line"><span class="comment">// If arena handle is dropped without being freed, then call</span></span><br><span class="line"><span class="comment">// free on the arena, so the arena chunks are never reclaimed</span></span><br><span class="line"><span class="comment">// by the garbage collector.</span></span><br><span class="line">a.free()</span><br><span class="line">&#125;)</span><br><span class="line">a.refill()</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *userArena)</span> <span class="title">refill</span><span class="params">()</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line"><span class="comment">// If there's an active chunk, assume it's full.</span></span><br><span class="line">s := a.active</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the partially-used list.</span></span><br><span class="line">lock(&amp;userArenaState.lock)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(userArenaState.reuse) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">//当前存在可重用的就使用重用的</span></span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;userArenaState.lock)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Allocate a new one. 否则分配一个新的mspan</span></span><br><span class="line">x, s = newUserArenaChunk()</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"out of memory"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a.refs = <span class="built_in">append</span>(a.refs, x)<span class="comment">//记录mspan.base()，报活mspan</span></span><br><span class="line">a.active = s<span class="comment">//记录当前使用的mspan</span></span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>SetFinalizer</code> 函数可参考<a href="https://www.yuankang.top/2023/01/04/Go/Go%E5%85%A5%E9%97%A821-SetFinalizer/" target="_blank" rel="noopener">文章</a>，当gc检测到unreachable对象有关联的SetFinalizer函数时，会执行关联的SetFinalizer函数， 同时取消关联。 这样当下一次gc的时候，对象重新处于unreachable状态并且没有SetFinalizer关联， 就会被回收。</li></ul><p>**第二步：**从 arena 中分配具体类型的对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *userArena)</span> <span class="title">refill</span><span class="params">()</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line"><span class="comment">// If there's an active chunk, assume it's full.</span></span><br><span class="line">s := a.active<span class="comment">//上次分配了mspan</span></span><br><span class="line"><span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> s.userArenaChunkFree.size() &gt; userArenaChunkMaxAllocBytes &#123;</span><br><span class="line"><span class="comment">// It's difficult to tell when we're actually out of memory</span></span><br><span class="line"><span class="comment">// in a chunk because the allocation that failed may still leave</span></span><br><span class="line"><span class="comment">// some free space available. However, that amount of free space</span></span><br><span class="line"><span class="comment">// should never exceed the maximum allocation size.</span></span><br><span class="line">throw(<span class="string">"wasted too much memory in an arena chunk"</span>)</span><br><span class="line">&#125;</span><br><span class="line">s.next = a.fullList <span class="comment">//将这个mspan放到fullList的链表头部</span></span><br><span class="line">a.fullList = s</span><br><span class="line">a.active = <span class="literal">nil</span><span class="comment">//active置为空</span></span><br><span class="line">s = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the partially-used list.</span></span><br><span class="line">lock(&amp;userArenaState.lock)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(userArenaState.reuse) &gt; <span class="number">0</span> &#123;<span class="comment">//</span></span><br><span class="line"><span class="comment">//如果有可以重用的mspan则放到s中</span></span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;userArenaState.lock)</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Allocate a new one.</span></span><br><span class="line">x, s = newUserArenaChunk()<span class="comment">//否则新分配一个新的</span></span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"out of memory"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a.refs = <span class="built_in">append</span>(a.refs, x)</span><br><span class="line">a.active = s</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**第三步：**释放的核心是这块代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s := a.fullList<span class="comment">//获取这个mspan</span></span><br><span class="line">i := <span class="built_in">len</span>(a.refs) - <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> s != <span class="literal">nil</span> &#123;<span class="comment">//不为空</span></span><br><span class="line">  a.fullList = s.next<span class="comment">//指向下一个节点</span></span><br><span class="line">  s.next = <span class="literal">nil</span></span><br><span class="line">  freeUserArenaChunk(s, a.refs[i])<span class="comment">//释放这个mspan</span></span><br><span class="line">  s = a.fullList<span class="comment">//指向下一个节点</span></span><br><span class="line">  i--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>释放的时候仅仅是将fullList中所有的都释放掉了，而active中的则会进去到全局reuse对象中用于下次使用</li></ul><p>这个全局变量就是 <code>userArenaState</code> 用于存放可重复使用的mspan以及回收的mspan</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> userArenaState <span class="keyword">struct</span> &#123;</span><br><span class="line">lock mutex</span><br><span class="line"></span><br><span class="line">  <span class="comment">//可重复使用</span></span><br><span class="line">reuse []liveUserArenaChunk</span><br><span class="line"></span><br><span class="line">  <span class="comment">//回收释放的</span></span><br><span class="line">fault []liveUserArenaChunk</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对比syncpool"><a class="markdownIt-Anchor" href="#对比syncpool"></a> 对比Sync.Pool</h3><p>arena 与 Sync.Pool 同样都是为了解决频繁分配对象和大量对象GC带来的开销</p><p><code>Sync.Pool</code>相同类型的对象，使用完后暂时缓存不GC，下次再有相同的对象分配时直接用之前的缓存的对象，避免频繁创建大量对象。不承诺这些缓存对象的生命周期，GC时会释放之前的缓存，适合解决频繁创建相同对象带来的压力，短时间(两次GC之间)大量创建可能还是会有较大冲击，使用相对简单，但只能用于相同结构创建，不能创建slice等复杂结构</p><p><code>arena</code>手动管理连续内容并统一释放，对象的生命周期完全自己控制，使用相对复杂，支持slice等复杂结构，也不是一个真正意义的连续超大空间，而是通过管理不同的mspan实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"arena"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyObj <span class="keyword">struct</span> &#123;</span><br><span class="line">Index <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkCreateObj</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *MyObj</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++ &#123;</span><br><span class="line">p = <span class="built_in">new</span>(MyObj)</span><br><span class="line">p.Index = j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">objPool = sync.Pool&#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;MyObj&#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkCreateObj_SyncPool</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *MyObj</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++ &#123;</span><br><span class="line">p = objPool.Get().(*MyObj)</span><br><span class="line">p.Index = <span class="number">23</span></span><br><span class="line">objPool.Put(p)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkCreateObj_Arena</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *MyObj</span><br><span class="line"></span><br><span class="line">a := arena.NewArena()</span><br><span class="line"><span class="keyword">defer</span> a.Free()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++ &#123;</span><br><span class="line">p = arena.New[MyObj](a)</span><br><span class="line">p.Index = <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性能对比的结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cpu: Intel(R) Core(TM) i7-8559U CPU @ 2.70GHz</span><br><span class="line">BenchmarkCreateObj-8                      100518             11370 ns/op            8000 B/op       1000 allocs/op</span><br><span class="line">BenchmarkCreateObj_SyncPool-8             110017             11523 ns/op               0 B/op          0 allocs/op</span><br><span class="line">BenchmarkCreateObj_Arena-8                 80409             15340 ns/op            8032 B/op          0 allocs/op</span><br></pre></td></tr></table></figure><p><code>Sync.Pool</code> 不需要重复分配且每次操作时间短，而<code>Arena</code>执行时间会长一点且每次还是需要分配内存的，因为需要引入新的 <code>mspan</code></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li><code>Arena</code> 不支持并发，可以看出操作同一个 arena的时候并不存在锁操作</li><li>Arena 强制 Free()之后的对象无法继续使用</li><li>优点：<ul><li>一旦被释放但仍然被访问则会显示的导致程序错误</li><li>arena 地址空间除非没有指针指向，否则将不能被重用</li><li>arena 永远不会被垃圾回收机制回收(如果GC不可达它会执行 <code>SetFinalizer</code> 自己释放掉，那我们手动free的意义在哪里 --&gt; 也就是构建arena的目的，提前释放内存，降低GC扫描频率)</li></ul></li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://uptrace.dev/blog/golang-memory-arena.html" target="_blank" rel="noopener">https://uptrace.dev/blog/golang-memory-arena.html</a></li><li><a href="https://colobu.com/2022/10/17/a-first-look-at-arena/" target="_blank" rel="noopener">https://colobu.com/2022/10/17/a-first-look-at-arena/</a></li><li><a href="https://zhuanlan.zhihu.com/p/604686258" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/604686258</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近 &lt;code&gt;Go1.20&lt;/code&gt; 更新，中间讲到了一个特性 &lt;code&gt;arena&lt;/code&gt; ，这里看看加入 &lt;code&gt;arena&lt;/code&gt; 的作用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在Go的内存管理中，&lt;code&gt;arena&lt;/code&gt; 其实
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go入门21-SetFinalizer</title>
    <link href="http://xboom.github.io/2023/01/04/Go/Go%E5%85%A5%E9%97%A821-SetFinalizer/"/>
    <id>http://xboom.github.io/2023/01/04/Go/Go%E5%85%A5%E9%97%A821-SetFinalizer/</id>
    <published>2023-01-04T13:45:13.344Z</published>
    <updated>2023-06-02T08:49:46.059Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读Go 1.20 新特性 arena 的时候，看到在构建 arena 对象的时候使用了 <code>SetFinalizer</code> 这样一个函数</p><p>带着问题看世界</p><ol><li>它有什么用</li><li>它怎么用</li><li>它有什么缺点导致不是随处可见这种用法</li></ol><p>这里来详细看看它的作用，备注如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SetFinalizer sets the finalizer associated with obj to the provided finalizer function. When the garbage collector finds an unreachable block with an associated finalizer, it clears the association and runs finalizer(obj) in a separate goroutine. This makes obj reachable again,</span><br><span class="line">but now without an associated finalizer. Assuming that SetFinalizer is not called again, the next time the garbage collector sees that obj is unreachable, it will free obj.</span><br></pre></td></tr></table></figure><p>大意是：<strong>为对象提供一个析构函数，当GC发现不可达对象带有析构函数的时候，会单独使用协程执行这个析构函数。这样对GC来说对象是可达但没有了析构函数，下次GC发现对象不可达就会释放掉对象</strong></p><p>有一些协程的生命周期是与整个服务一致的，比如定时清理机制，它的好处是自动处理一些业务而不需要人工调用，但如果是在一些与业务完全分离的场景。比如为业务提供一个缓存池，缓存池中为了清理过期的缓存而设计了一个常驻协程。是否可以使用 <code>SetFinalizer</code> 的过期删除机制</p><p>首先看一个栗子：</p><p>一般情况我们会提供对象一个 <code>Close()</code>函数用于业务在不需要的时候清理对象，这里就可以用到这个 <code>SetFinalizer</code>，如 <code>os.NewFile</code> 就注册了 <code>SetFinalizer</code>逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newFile</span><span class="params">(fd <span class="keyword">uintptr</span>, name <span class="keyword">string</span>, kind newFileKind)</span> *<span class="title">File</span></span> &#123;</span><br><span class="line">fdi := <span class="keyword">int</span>(fd)</span><br><span class="line"><span class="keyword">if</span> fdi &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">f := &amp;File&#123;&amp;file&#123;</span><br><span class="line">pfd: poll.FD&#123;</span><br><span class="line">Sysfd:         fdi,</span><br><span class="line">IsStream:      <span class="literal">true</span>,</span><br><span class="line">ZeroReadIsEOF: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line">name:        name,</span><br><span class="line">stdoutOrErr: fdi == <span class="number">1</span> || fdi == <span class="number">2</span>,</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">runtime.SetFinalizer(f.file, (*file).<span class="built_in">close</span>)</span><br><span class="line"><span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">num  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">finalizer</span><span class="params">(f *Foo)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"a finalizer has run for "</span>, f.name, f.num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeFoo</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(a_foo *Foo)</span></span> &#123;</span><br><span class="line">a_foo = &amp;Foo&#123;name, counter&#125;</span><br><span class="line">counter++</span><br><span class="line">runtime.SetFinalizer(a_foo, finalizer)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">f1 := MakeFoo(<span class="string">"one"</span>)</span><br><span class="line">f2 := MakeFoo(<span class="string">"two"</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"f1 is: "</span>, f1.name)</span><br><span class="line">fmt.Println(<span class="string">"f2 is: "</span>, f2.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">Bar()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">runtime.GC()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"done."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f1 is:  one</span><br><span class="line">f2 is:  two</span><br><span class="line">a finalizer has run <span class="keyword">for</span>  two <span class="number">1</span></span><br><span class="line">a finalizer has run <span class="keyword">for</span>  one <span class="number">0</span></span><br><span class="line">f1 is:  one</span><br><span class="line">f2 is:  two</span><br><span class="line">a finalizer has run <span class="keyword">for</span>  two <span class="number">3</span></span><br><span class="line">a finalizer has run <span class="keyword">for</span>  one <span class="number">2</span></span><br><span class="line">f1 is:  one</span><br><span class="line">f2 is:  two</span><br><span class="line">a finalizer has run <span class="keyword">for</span>  two <span class="number">5</span></span><br><span class="line">a finalizer has run <span class="keyword">for</span>  one <span class="number">4</span></span><br><span class="line">done.</span><br></pre></td></tr></table></figure><p>注意事项</p><ol><li>obj 必须是指针</li><li><code>SetFinalizer</code> 执行顺序按照类似对象的出栈顺序</li><li>可以通过 <code>SetFinalizer(obj, nil)</code> 清理对象的析构器</li></ol><p>栗子2，它的实际效果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"runtime/debug"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">debug.SetGCPercent(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ms runtime.MemStats</span><br><span class="line">runtime.ReadMemStats(&amp;ms)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Allocation: %f Mb, Number of allocation: %d\n"</span>, <span class="keyword">float32</span>(ms.HeapAlloc)/<span class="keyword">float32</span>(<span class="number">1024</span>*<span class="number">1024</span>), ms.HeapObjects)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</span><br><span class="line">f := NewFoo(i)</span><br><span class="line">_ = fmt.Sprintf(<span class="string">"%d"</span>, f.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runtime.ReadMemStats(&amp;ms)</span><br><span class="line">fmt.Printf(<span class="string">"Allocation: %f Mb, Number of allocation: %d\n"</span>, <span class="keyword">float32</span>(ms.HeapAlloc)/<span class="keyword">float32</span>(<span class="number">1024</span>*<span class="number">1024</span>), ms.HeapObjects)</span><br><span class="line"></span><br><span class="line">runtime.GC()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">runtime.ReadMemStats(&amp;ms)</span><br><span class="line">fmt.Printf(<span class="string">"Allocation: %f Mb, Number of allocation: %d\n"</span>, <span class="keyword">float32</span>(ms.HeapAlloc)/<span class="keyword">float32</span>(<span class="number">1024</span>*<span class="number">1024</span>), ms.HeapObjects)</span><br><span class="line"></span><br><span class="line">runtime.GC()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">runtime.ReadMemStats(&amp;ms)</span><br><span class="line">fmt.Printf(<span class="string">"Allocation: %f Mb, Number of allocation: %d\n"</span>, <span class="keyword">float32</span>(ms.HeapAlloc)/<span class="keyword">float32</span>(<span class="number">1024</span>*<span class="number">1024</span>), ms.HeapObjects)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFoo</span><span class="params">(i <span class="keyword">int</span>)</span> *<span class="title">Foo</span></span> &#123;</span><br><span class="line">f := &amp;Foo&#123;a: rand.Intn(<span class="number">50</span>)&#125;</span><br><span class="line">runtime.SetFinalizer(f, <span class="function"><span class="keyword">func</span><span class="params">(f *Foo)</span></span> &#123;</span><br><span class="line">_ = fmt.Sprintf(<span class="string">"foo "</span> + strconv.Itoa(i) + <span class="string">" has been garbage collected"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Allocation: <span class="number">0.121063</span> Mb, Number of allocation: <span class="number">140</span></span><br><span class="line">Allocation: <span class="number">29.111671</span> Mb, Number of allocation: <span class="number">1899990</span></span><br><span class="line">Allocation: <span class="number">128.025635</span> Mb, Number of allocation: <span class="number">4382420</span></span><br><span class="line">Allocation: <span class="number">0.122147</span> Mb, Number of allocation: <span class="number">155</span></span><br></pre></td></tr></table></figure><p>可以看出，正如它功能说的一样，在第二次GC之后，分配的内存被释放</p><p>它也有缺点：</p><ol><li><code>SetFinalizer</code> 最大的问题是延长了对象生命周期。在第一次回收时执行 Finalizer 函数，且目标对象重新变成可达状态，直到第二次才真正 “销毁”。这对于有大量对象分配的高并发算法，可能会造成很大麻烦</li><li>指针构成的 “循环引⽤” 加上 <code>runtime.SetFinalizer</code> 会导致内存泄露</li><li><code>SetFinalizer</code>只在GC 发现对象不可达之后的任意时间执行，所以如果程序正常结束或者发生错误，而对象还没有被GC选中那么 <code>SetFinalizer</code> 也不会执行。</li></ol><p>所以保险起见还是提供了 <code>Close()</code> 逻辑供业务调用</p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/76504936" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/76504936</a></li><li><a href="https://go.dev/play/p/jWhRSPNvxJ" target="_blank" rel="noopener">https://go.dev/play/p/jWhRSPNvxJ</a></li><li><a href="https://medium.com/a-journey-with-go/go-finalizers-786df8e17687" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-finalizers-786df8e17687</a></li><li><code>runtime/mfinal.go</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在阅读Go 1.20 新特性 arena 的时候，看到在构建 arena 对象的时候使用了 &lt;code&gt;SetFinalizer&lt;/code&gt; 这样一个函数&lt;/p&gt;
&lt;p&gt;带着问题看世界&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它有什么用&lt;/li&gt;
&lt;li&gt;它怎么用&lt;/li&gt;
&lt;li&gt;它
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>算法之美-八数码问题</title>
    <link href="http://xboom.github.io/2022/12/11/Algorithms%20To%20Live%20By/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>http://xboom.github.io/2022/12/11/Algorithms%20To%20Live%20By/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/</id>
    <published>2022-12-11T09:47:28.000Z</published>
    <updated>2022-12-11T09:47:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>八数码问题也称为九宫问题。在3×3的棋盘，摆有八个棋子，每个棋子上标有1至8的某一数字，不同棋子上标的数字不相同。棋盘上还有一个空格，与空格相邻的棋子可以移到空格中。要求解决的问题是：给出一个初始状态和一个目标状态，找出一种从初始转变成目标状态的移动棋子步数最少的移动步骤</p><blockquote><p>所谓一个状态就是棋子在棋盘上的一种摆法。棋子移动后，状态就会发生改变。实际上就是找出从初始状态到达目标状态所经过的一系列中间过渡状态</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-11-03_23-53-25_bashuma_1.png" alt="Snipaste_2022-11-03_23-53-25_bashuma_1" style="zoom:67%;" /><p>首先这个九宫格的状态数量是 9!，那么存在问题</p><ol><li><p>是否存在从一个状态转移到另外一个状态无解的情况？</p></li><li><p>如何计算或者衡量从一个转移到另外一个状态的需要走多少步？</p></li></ol><h3 id="排列的性质"><a class="markdownIt-Anchor" href="#排列的性质"></a> 排列的性质</h3><p>为了搞清楚上述问题，需要知道几个基本定义与引理</p><ol><li><p>把n个不同的元素按一定的顺序排列成一行，成为这n个元素的一个<strong>排列</strong>。n个不同元素的排列共有 <strong>n!</strong> 种</p></li><li><p>对于n个自然数的一个排列，如果一个大数排在一个小数之前，就称这两个数构成一个<strong>逆序</strong>。一个排列的逆序总和称为该排列的<strong>逆序对</strong>，记为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi><mo stretchy="false">(</mo><mi>j</mi><mn>1</mn><mi>j</mi><mn>2</mn><mo>⋯</mo><mi>j</mi><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>τ</mi><mo>∗</mo><mo stretchy="false">(</mo><mo>∗</mo><mi>j</mi><mo>∗</mo><mn>1</mn><mo>∗</mo><mi>j</mi><mo>∗</mo><mn>2</mn><mo>⋯</mo><mo>∗</mo><mi>j</mi><mo>∗</mo><mo>∗</mo><mi>n</mi><mo>∗</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">τ(j1j2⋯jn)*τ*(*j*1*j*2⋯*j**n*)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">∗</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∗</span><span class="mord mathdefault">n</span><span class="mord">∗</span><span class="mclose">)</span></span></span></span></p><blockquote><p>如5阶排列31542的逆序是(3,1),(3,2),(5,4),(5,2),(4,2),故 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi><mo stretchy="false">(</mo><mn>31542</mn><mo stretchy="false">)</mo><mo>=</mo><mn>5</mn><mo>∗</mo><mi>τ</mi><mo>∗</mo><mo stretchy="false">(</mo><mn>31542</mn><mo stretchy="false">)</mo><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">τ(31542)=5*τ*(31542)=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mopen">(</span><span class="mord">3</span><span class="mord">1</span><span class="mord">5</span><span class="mord">4</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mord">1</span><span class="mord">5</span><span class="mord">4</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span></p></blockquote></li><li><p>逆序对为奇数的排列称为<strong>奇排列</strong>。逆序对为偶数的排列称为<strong>偶排列</strong>。<strong>自然排列</strong> 123⋯<em>n</em>的逆序对为0，故它是偶排列</p></li><li><p>在一个排列中，把某两个数的位置互换（其他数不动）变成另一个排列的变动称为一个<strong>对换</strong>，将相邻的两个数对换称为<strong>相邻对换</strong></p></li></ol><h3 id="性质的证明"><a class="markdownIt-Anchor" href="#性质的证明"></a> 性质的证明</h3><p><strong>性质1</strong>：<strong>一个排列中的任意两个数对换后，排列改变奇偶性。即经过一次对换，奇排列变成偶排列，偶排列变成奇排列</strong></p><p>证明：</p><ol><li><p>先证明相邻对换的情形</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-11-05_23-25-04-bashuma2.png" alt="Snipaste_2022-11-05_23-25-04-bashuma2" style="zoom:50%;" /><ul><li><p>设排列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>s</mi></msub><mi>a</mi><mi>b</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 ... a_s a b b_1 b_2 ... b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，对换a 与 b 的排列变为  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>s</mi></msub><mi>b</mi><mi>a</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 ... a_s b a b_1 b_2 ... b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p></li><li><p>a 与 b 的 对换不影响  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 ... a_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">b_1 b_2 ... b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 与 其他数的关系</p></li><li><p>但a与b的序关系变为：</p><ul><li><p>当 a &lt; b 时，在新排列中 a 、b 构成逆序</p></li><li><p>当 a &gt; b 时，在新排列中 a、b 不构成逆序</p></li></ul></li><li><p>因此 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>s</mi></msub><mi>a</mi><mi>b</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 ... a_s a b b_1 b_2 ... b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 比  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>s</mi></msub><mi>b</mi><mi>a</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 ... a_s b a b_1 b_2 ... b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的逆序多1或者少1</p></li></ul></li><li><p>再证一般对换情形</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-11-05_23-30-29-bashuma3.png" alt="Snipaste_2022-11-05_23-30-29-bashuma3" style="zoom:50%;" /><ul><li>设存在排列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>s</mi></msub><mi>a</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>…</mo><msub><mi>b</mi><mi>m</mi></msub><mi>b</mi><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>…</mo><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 … a_s a b_1 b_2 … b_m b c_1 c_2 … c_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>将 b 做 m 次相邻对换变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>s</mi></msub><mi>a</mi><mi>b</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>…</mo><msub><mi>b</mi><mi>m</mi></msub><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>…</mo><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 … a_s a b b_1 b_2 … b_m c_1 c_2 … c_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>再将 a 做 (m + 1) 次相邻对换变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>s</mi></msub><mi>b</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>…</mo><msub><mi>b</mi><mi>m</mi></msub><mi>a</mi><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>…</mo><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 … a_s b b_1 b_2 … b_m a c_1 c_2 … c_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>所以 经过 (2m + 1) 次相邻兑换，可以把排列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>s</mi></msub><mi>a</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>…</mo><msub><mi>b</mi><mi>m</mi></msub><mi>b</mi><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>…</mo><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 … a_s a b_1 b_2 … b_m b c_1 c_2 … c_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>转变成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>s</mi></msub><mi>b</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>…</mo><msub><mi>b</mi><mi>m</mi></msub><mi>a</mi><msub><mi>c</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>…</mo><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_1 a_2 … a_s b b_1 b_2 … b_m a c_1 c_2 … c_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，这两个排列的奇偶性相反</li></ul></li></ol><p><strong>性质2：在全部的 n(n≥2)阶排列中，奇偶排列各占一半，各有 n!/2 个</strong></p><p>证明：</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-11-06_09-56-51-bashuma4.png" alt="Snipaste_2022-11-06_09-56-51-bashuma4" style="zoom:50%;" /><ul><li><p>假设在全部n级排列中共有t个奇排列，s个偶排列</p></li><li><p>将t个奇排列中的前两个数字对换，得到t个互不相同的偶排列。因此 t≤s</p></li><li><p>同理可证 s≤t</p></li><li><p>于是 s=t，即奇、偶排列的总数相等，各有 n!/2个</p></li></ul><p><strong>性质3：任意一个n阶排列都可以经过一系列对换变成自然排列，并且所作对换的次数与这个排列有相同的奇偶性</strong></p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-11-06_13-10-01-bashuma5.png" alt="Snipaste_2022-11-06_13-10-01-bashuma5" style="zoom:50%;" /><p>证明(归纳法)：</p><ul><li>1阶排列只有一个，结论显然成立</li><li>假设对n-1阶排列已经成立，证对n阶排列的情形结论也成立<ul><li>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mn>1</mn></msub><msub><mi>j</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>j</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">j_1 j_2 ... j_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是一个n阶排列<ul><li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mi>n</mi></msub><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">j_n=n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> ，假设n-1级排列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mn>1</mn></msub><msub><mi>j</mi><mn>2</mn></msub><mo>…</mo><msub><mi>j</mi><mi>n</mi></msub><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">j_1 j_2 … j_n−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 可以经过一系列变换变成自然序列，即 1 2 … n−1，于是这一系列对换也就把 j1j2⋯jn 变成 12⋯n 这种自然序列的形式。</li><li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mi>n</mi><mi mathvariant="normal">≠</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">jn≠n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，那么对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mn>1</mn></msub><msub><mi>j</mi><mn>2</mn></msub><mo>…</mo><msub><mi>j</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">j_1 j_2 … j_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">j_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 n 的对换，它就变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mn>1</mn></msub><msub><mi>j</mi><mn>2</mn></msub><mo>…</mo><msub><mi>j</mi><mi>n</mi></msub><mi mathvariant="normal">−</mi><mn>1</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">j_1 j_2 … j_n−1 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">−</span><span class="mord">1</span><span class="mord mathdefault">n</span></span></span></span> ，这就归结成上面的情形，因此</li></ul></li></ul></li></ul><p><strong>性质4：奇偶性与可达性关系与证明</strong></p><blockquote><p>必要性证明：排列的奇偶性不同则对应在八数码问题中不可达</p></blockquote><p>在满足上述约定的八数码问题中，空格与相邻棋子的交换不会改变棋局中棋子数列的逆序对的奇偶性</p><ul><li><p>空格与左右棋子交换：是不改变棋子数列的逆序对的(因为数列并没有改变)</p></li><li><p>空格与上下棋子交换：也是不改变棋子数列的逆序对的</p><ul><li>假设交换棋子为c[i]=X</li><li>原数列p=c[1]… X c[i+1]c[i+2]…c[8]将变为新数列q=c[1]…c[i+1]c[i+2]X …c[8]（注意：在棋盘中，上下相邻的两棋格之间隔有两个棋格）。可以解释为用X与c[i+1]、 c[i+2]先后进行两次相邻交换而完成状态转变。</li><li>由p状态到q状态并不会改变改变棋子数列的逆序对的奇偶性。同理可证空格与下方棋子交换也不会改变棋子数列的逆序对的奇偶性。所以，空格与相邻棋子的交换不会改变棋局中棋子数列的逆序对的奇偶性</li></ul></li></ul><p>得出 <strong>定理1：对于任意两个状态映射的序列，如果这两个状态等价，那么它们的逆序数相同</strong></p><blockquote><p>充分性证明：<strong>排列的奇偶性相同则对应在八数码问题中也可达</strong></p></blockquote><p>首先明确几个定义：</p><ul><li><p><strong>状态</strong>(<strong>state</strong>)：八数码中8个数字与0的排列被定义为八数码的<strong>状态</strong>，比如：</p></li><li><p><strong>状态空间</strong>(<strong>state space</strong>)：八数码所有状态的合集被称为<strong>状态空间</strong></p></li><li><p><strong>完全态</strong>(<strong>completeness</strong>)：当状态空间的子集中任何两个状态都能通过一定步骤得到，那么称这个状态空间的子集是<strong>完全态</strong></p></li><li><p><strong>状态映射</strong>(<strong>a sequence mapped by a state</strong>)：一个状态{}可以映射(忽略0)成一个排序，那么这个排列就称为这个<strong>状态的映射</strong></p></li><li><p><strong>标准格式(a standard form)</strong>：如果 0 在正中间，那么称这个状态为<strong>标准格式</strong></p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/image-20221211150738067.png" alt="image-20221211150738067" style="zoom:50%;" /></li><li><p><strong>区域(field)</strong>：对于任意状态(state)，4个位置中任意两个都相邻，那么称之为 <strong>区域</strong>，特别的，当两个区域有相同的两个位置，则称为 <strong>同边区域</strong></p></li><li><p><strong>转圈(circle moving)</strong>：0在一个区域内移动称 <strong>转圈</strong></p></li></ul><p><strong>引理1：对于标准格式中的任意区域，转圈可以得到两个等价的区域</strong></p><p>考虑到 <strong>标准格式</strong> 的对称性，只需要考虑一个区域的的变化</p><p>第一种情况(顺时针方向部分先后): a b d</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121101.png" alt="bashuma-121101" style="zoom:50%;" /><p>第二种情况(顺时针方向不分先后): a d b</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121102.png" alt="bashuma-121102" /></p><p>接着考虑在一个标准格式中，在两个具有相同边的区域交换数据，由于标准格式的对称性，所以只考虑上半部分</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121103.png" alt="bashuma-121103" style="zoom:50%;" /><blockquote><p>这个图形转换根据上述原则手动绘制交换流程更容易理解</p></blockquote><p>得出的<strong>规律1</strong>: m 属于 {a ,d}，n 属于 {c, e}，p 属于 {a, d} 但 p != m，q 属于 {c, e}但 q != n，那么交换 m n，则 n 来到 m 之前的位置，而 m 来到 q 之前的位置，q 来到 n 之前的位置</p><p>得出的<strong>规律2</strong>：abc 可以经过转换编程 cab 或者 bac，不影响其他行且逆序对不变</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121104.png" alt="bashuma-121104" style="zoom:80%;" /><p>对于标准格式，如果它们的逆序对的奇偶性相同，那么它们是等价的</p><p>证明：</p><p>首先，将九宫格分为A、B、C、D分为四个区域</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121106.png" alt="bashuma-121106" style="zoom:50%;" /><p>第一步，将 h 移动到位置 位置 9，这是肯定可以的</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121107.png" alt="bashuma-121107" style="zoom:50%;" /><p>第二步，将 g、e 移动到区域D</p><blockquote><p>为什么不考虑g、e的顺序，因为可以在不影响h的情况下 g 在 位置 6 与 位置8 任意切换</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121112.png" alt="bashuma-121112" style="zoom:50%;" /><ul><li><p>2.1 如果 g、e 已经在区域D，那么不需要移动</p></li><li><p>2.2 如果其中 g 在 区域D，而e 在其他区域</p><ul><li><p>2.2.1 e 在区域A</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121109.png" alt="bashuma-121109" style="zoom:50%;" /></li><li><p>2.2.2 e 在区域B</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/Snipaste_2022-12-11_16-55-10.png" alt="Snipaste_2022-12-11_16-55-10" style="zoom:50%;" /></li><li><p>2.2.3 e 在区域C</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-121111.png" alt="bashuma-121111" style="zoom:50%;" /></li></ul><p>第三步，将 b、c 移动到 B区域</p><ul><li><p>3.1 如果 b、c 都在区域 B，那么不需要移动</p></li><li><p>3.2 如果 b、c 有一个在区域B，那么</p><blockquote><p>b 、c 的位置也同样可以忽略，如果b、c是正常顺序，那么也可以在不影响 g e h 位置的情况下调整 b c 的顺序</p></blockquote><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma-1211-13.png" alt="bashuma-1211-13" style="zoom:50%;" /><ul><li><p>3.1.1 如果在位置3</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/bashuma121110.png" alt="bashuma121110" style="zoom:50%;" /></li><li><p>3.1.2 如果在位置2，那么先将c移动位置3再执行上述步骤</p></li></ul></li><li><p>如果 b、c 都不在区域B，同理将c 移动到位置3，然后在执行上述3.1.1 步骤</p></li></ul></li></ul><p>第四步，在不影响bcehg的情况下调整adf的顺序</p><ul><li>规律二在 此场景下仍然适用，所以首先将防止到位置7</li><li>根据定理1，如果两者等价，那么它们的逆序对是相同的。而如果位置1与位置3交换其他位置不变，那边整个序列的逆序对是变化的。所以a一定在位置1，d在位置4</li></ul><p>所以，如果奇偶性相同，那么两个状态都能转换成一个相同的标准状态，那么两个状态之间是可达的</p><p>得出结论：<strong>两个排列的逆序对奇偶性相同，那么在八数码中必可达</strong></p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://blog.csdn.net/u011008379/article/details/40144147" target="_blank" rel="noopener">https://blog.csdn.net/u011008379/article/details/40144147</a></li><li><a href="https://chengfeng96.com/blog/2018/05/26/%E5%88%A9%E7%94%A8BFS%EF%BC%8CDFS%EF%BC%8CA-%E8%A7%A3%E5%86%B3%E5%85%AB%E6%95%B0%E7%A0%81%E9%9A%BE%E9%A2%98/" target="_blank" rel="noopener">https://chengfeng96.com/blog/2018/05/26/利用BFS，DFS，A-解决八数码难题/</a></li><li><a href="http://www.huaying1988.com/blogs/8_Puzzle_StrictProof_SolutionAlgorithm_AndOthers/detail.html" target="_blank" rel="noopener">http://www.huaying1988.com/blogs/8_Puzzle_StrictProof_SolutionAlgorithm_AndOthers/detail.html</a></li><li>《A constructive proof for the subsets completeness of 8-Puzzle state space》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;八数码问题也称为九宫问题。在3×3的棋盘，摆有八个棋子，每个棋子上标有1至8的某一数字，不同棋子上标的数字不相同。棋盘上还有一个空格，与空格相邻的棋子可以移到空格中。要求解决的问题是：给出一个初始状态和一个目标状态，找出一种从初始转变成目标状态的移动棋子步数最少的移动步骤&lt;
      
    
    </summary>
    
    
      <category term="Algorithms To Live By" scheme="http://xboom.github.io/categories/Algorithms-To-Live-By/"/>
    
    
      <category term="Algorithms To Live By" scheme="http://xboom.github.io/tags/Algorithms-To-Live-By/"/>
    
  </entry>
  
  <entry>
    <title>Go入门22-Goland激活</title>
    <link href="http://xboom.github.io/2022/12/09/Go/Go%E5%85%A5%E9%97%A822-Goland%E6%BF%80%E6%B4%BB/"/>
    <id>http://xboom.github.io/2022/12/09/Go/Go%E5%85%A5%E9%97%A822-Goland%E6%BF%80%E6%B4%BB/</id>
    <published>2022-12-09T08:00:20.000Z</published>
    <updated>2023-05-28T01:52:00.096Z</updated>
    
    <content type="html"><![CDATA[<p>Goland好用但是激活太贵，网上找了一个使用激活服务器的办法， Goland 2022.2.2 激活成功</p><blockquote><p>最好支持正版！！！</p></blockquote><p>第一步：首先打开网址 <a href="https://search.censys.io" target="_blank" rel="noopener">https://search.censys.io</a></p><p>第二步：搜索信息 <code>services.http.response.headers.location: account.jetbrains.com/fls-auth</code></p><p>第三步：点击搜索到的网址信息</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/goland-acitve-1.png" alt="goland-acitve-1" /></p><p>第四步：找到状态为302的信息网址信息，如果没有找到请重复第三步</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/goland-acitve-302.png" alt="goland-acitve-302" /></p><p>第五步：复制上一步信息中的Details信息，这里是 <code>https://188.210.42.106</code></p><p>第六步：将地址信息填入 goland 中的 Licence Service 并点击 Acitve 激活</p><p>第七步：如果激活成功将出现下图所示，否则重复第三步</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/goland-acitve-success.png" alt="goland-acitve-success" /></p><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://dushusir.com/jetbrains/" target="_blank" rel="noopener">https://dushusir.com/jetbrains/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Goland好用但是激活太贵，网上找了一个使用激活服务器的办法， Goland 2022.2.2 激活成功&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最好支持正版！！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一步：首先打开网址 &lt;a href=&quot;https://sear
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-14-健康检查</title>
    <link href="http://xboom.github.io/2022/11/04/Grpc/Grpc-14-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/"/>
    <id>http://xboom.github.io/2022/11/04/Grpc/Grpc-14-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/</id>
    <published>2022-11-04T14:58:29.000Z</published>
    <updated>2023-05-27T10:56:13.039Z</updated>
    
    <content type="html"><![CDATA[<p>前面学习了保持链接，这里看一下健康检查</p><p>带着问题看世界</p><ol><li>健康检查的作用</li><li>健康检查的原理</li><li>保持链接与健康检查的区别</li></ol><p>首先看一下源码例子中的ReadMe说明，gRPC提供了一个健康检查库，用于向客户端通报系统的健康状况。它通过使用health/v1 API提供服务定义。通过使用健康检查库，客户端可以在遇到问题时优雅地避免使用服务器。大多数语言都提供了现成的实现，这使得它在不同系统之间可以互操作。内置健康检查的优势</p><ul><li>健康检查的格式与普通的RPC一样</li><li>重用现有的配额等机制，内部对健康检查有完全的控制权</li></ul><h3 id="基本使用"><a class="markdownIt-Anchor" href="#基本使用"></a> 基本使用</h3><p>内部定义了健康检查的 proto</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> grpc.health.v1;</span><br><span class="line"></span><br><span class="line">message HealthCheckRequest &#123;</span><br><span class="line">  <span class="keyword">string</span> service = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HealthCheckResponse &#123;</span><br><span class="line">  enum ServingStatus &#123;</span><br><span class="line">    UNKNOWN = <span class="number">0</span>;</span><br><span class="line">    SERVING = <span class="number">1</span>;</span><br><span class="line">    NOT_SERVING = <span class="number">2</span>;</span><br><span class="line">    SERVICE_UNKNOWN = <span class="number">3</span>;  <span class="comment">// Used only by the Watch method.</span></span><br><span class="line">  &#125;</span><br><span class="line">  ServingStatus status = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service Health &#123;</span><br><span class="line">  rpc Check(HealthCheckRequest) returns (HealthCheckResponse);</span><br><span class="line"></span><br><span class="line">  rpc Watch(HealthCheckRequest) returns (stream HealthCheckResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共有两种方式进行健康检查</p><ul><li><code>Check</code> 探测服务器的健康状态</li><li><code>Watch</code> 观察服务端变化，这里注意 是一个<code>服务端流</code>，也就是客户端不断会收到服务端的状态更新</li></ul><p>一般，客户端不需要手动执行 <code>Check</code>操作，而是通过配置 <code>healthCheckConfig</code> ，它会在内部自动执行 <code>Watch</code>操作</p><h4 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import grpc/health to enable transparent client side checking </span></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">"google.golang.org/grpc/health"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set up appropriate service config</span></span><br><span class="line">serviceConfig := grpc.WithDefaultServiceConfig(<span class="string">`&#123;</span></span><br><span class="line"><span class="string">  "loadBalancingPolicy": "round_robin",</span></span><br><span class="line"><span class="string">  "healthCheckConfig": &#123;</span></span><br><span class="line"><span class="string">    "serviceName": ""</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;`</span>)</span><br><span class="line"></span><br><span class="line">conn, err := grpc.Dial(..., serviceConfig)</span><br></pre></td></tr></table></figure><h4 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h4><p>启动一个协程，来模拟服务端状态变化，核心逻辑就是设置服务的状态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">port  = flag.Int(<span class="string">"port"</span>, <span class="number">50051</span>, <span class="string">"the port to serve on"</span>)</span><br><span class="line">sleep = flag.Duration(<span class="string">"sleep"</span>, time.Second*<span class="number">5</span>, <span class="string">"duration between changes in health"</span>)</span><br><span class="line"></span><br><span class="line">system = <span class="string">""</span> <span class="comment">// empty string represents the health of the system</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line">lis, err := net.Listen(<span class="string">"tcp"</span>, fmt.Sprintf(<span class="string">":%d"</span>, *port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to listen: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s := grpc.NewServer()</span><br><span class="line">healthcheck := health.NewServer()</span><br><span class="line">healthpb.RegisterHealthServer(s, healthcheck)<span class="comment">//健康检查</span></span><br><span class="line">pb.RegisterEchoServer(s, &amp;echoServer&#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//健康状态更新</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// asynchronously inspect dependencies and toggle serving status as needed</span></span><br><span class="line">next := healthpb.HealthCheckResponse_SERVING</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">healthcheck.SetServingStatus(system, next)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> next == healthpb.HealthCheckResponse_SERVING &#123;</span><br><span class="line">next = healthpb.HealthCheckResponse_NOT_SERVING</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">next = healthpb.HealthCheckResponse_SERVING</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(*sleep)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to serve: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>健康服务器可以返回四种状态：<code>UNKNOWN</code>、<code>SERVING</code>、<code>NOT_SERVING</code>和<code>SERVICE_UNKNOWN</code>。</p><ul><li><p><code>UNKNOWN</code> 表示当前状态尚未知晓。在服务器实例启动时经常会看到这种状态。</p></li><li><p><code>SERVING</code> 表示系统健康，准备好提供服务请求。</p></li><li><p><code>NOT_SERVING</code> 表示系统当前无法处理请求。</p></li><li><p><code>SERVICE_UNKNOWN</code> 表示客户端请求的服务名未被服务器所知。此状态仅由 <code>Watch()</code> 调用报告</p></li></ul><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><h4 id="客户端-2"><a class="markdownIt-Anchor" href="#客户端-2"></a> 客户端</h4><p>客户端默认初始化<code>Watch</code>函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">   internal.HealthCheckFunc = clientHealthCheck</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> healthCheckMethod = <span class="string">"/grpc.health.v1.Health/Watch"</span><span class="comment">//指定健康检查方法名称</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clientHealthCheck</span><span class="params">(ctx context.Context, newStream <span class="keyword">func</span>(<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>, <span class="title">setConnectivityState</span> <span class="title">func</span><span class="params">(connectivity.State, error)</span>, <span class="title">service</span> <span class="title">string</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">   tryCnt := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">retryConnection:</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">//退避重试</span></span><br><span class="line">      <span class="keyword">if</span> tryCnt &gt; <span class="number">0</span> &amp;&amp; !backoffFunc(ctx, tryCnt<span class="number">-1</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">      tryCnt++</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ctx.Err() != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">      setConnectivityState(connectivity.Connecting, <span class="literal">nil</span>)<span class="comment">//设置状态</span></span><br><span class="line">      rawS, err := newStream(healthCheckMethod)<span class="comment">//构建流链接</span></span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">continue</span> retryConnection</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      s, ok := rawS.(grpc.ClientStream)</span><br><span class="line">      <span class="keyword">if</span> !ok &#123;</span><br><span class="line">         setConnectivityState(connectivity.Ready, <span class="literal">nil</span>)<span class="comment">//服务端健康</span></span><br><span class="line">         <span class="keyword">return</span> fmt.Errorf(<span class="string">"newStream returned %v (type %T); want grpc.ClientStream"</span>, rawS, rawS)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> err = s.SendMsg(&amp;healthpb.HealthCheckRequest&#123;Service: service&#125;); err != <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123;</span><br><span class="line">         <span class="comment">// Stream should have been closed, so we can safely continue to create a new stream.</span></span><br><span class="line">         <span class="keyword">continue</span> retryConnection</span><br><span class="line">      &#125;</span><br><span class="line">      s.CloseSend()</span><br><span class="line"></span><br><span class="line">      resp := <span class="built_in">new</span>(healthpb.HealthCheckResponse)</span><br><span class="line">      <span class="keyword">for</span> &#123;<span class="comment">//不断接收服务端响应</span></span><br><span class="line">         err = s.RecvMsg(resp)</span><br><span class="line"></span><br><span class="line">         <span class="comment">// </span></span><br><span class="line">         <span class="keyword">if</span> status.Code(err) == codes.Unimplemented &#123;<span class="comment">//表示服务端未支持健康检查</span></span><br><span class="line">            setConnectivityState(connectivity.Ready, <span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 其他错误</span></span><br><span class="line">         <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            setConnectivityState(connectivity.TransientFailure, fmt.Errorf(<span class="string">"connection active but received health check RPC error: %v"</span>, err))</span><br><span class="line">            <span class="keyword">continue</span> retryConnection</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//收到消息那么</span></span><br><span class="line">         tryCnt = <span class="number">0</span></span><br><span class="line">         <span class="keyword">if</span> resp.Status == healthpb.HealthCheckResponse_SERVING &#123;</span><br><span class="line">            setConnectivityState(connectivity.Ready, <span class="literal">nil</span>)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setConnectivityState(connectivity.TransientFailure, fmt.Errorf(<span class="string">"connection active but health check failed. status=%s"</span>, resp.Status))</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据策略启动健康检查，<strong>针对的是同一个域名对应的多个子地址</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启健康检查</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ac *addrConn)</span> <span class="title">startHealthCheck</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> healthcheckManagingState <span class="keyword">bool</span></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> !healthcheckManagingState &#123;</span><br><span class="line">         ac.updateConnectivityState(connectivity.Ready, <span class="literal">nil</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="comment">//... 判断健康检查是否开启</span></span><br><span class="line">   currentTr := ac.transport</span><br><span class="line">   newStream := <span class="function"><span class="keyword">func</span><span class="params">(method <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">      ac.mu.Lock()</span><br><span class="line">      <span class="keyword">if</span> ac.transport != currentTr &#123;</span><br><span class="line">         ac.mu.Unlock()</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.Canceled, <span class="string">"the provided transport is no longer valid to use"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      ac.mu.Unlock()</span><br><span class="line">      <span class="keyword">return</span> newNonRetryClientStream(ctx, &amp;StreamDesc&#123;ServerStreams: <span class="literal">true</span>&#125;, method, currentTr, ac)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//更新连接状态</span></span><br><span class="line">   setConnectivityState := <span class="function"><span class="keyword">func</span><span class="params">(s connectivity.State, lastErr error)</span></span> &#123;</span><br><span class="line">      ac.mu.Lock()</span><br><span class="line">      <span class="keyword">defer</span> ac.mu.Unlock()</span><br><span class="line">      <span class="keyword">if</span> ac.transport != currentTr &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      ac.updateConnectivityState(s, lastErr)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 独立协程去检查健康状态</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      err := ac.cc.dopts.healthCheckFunc(ctx, newStream, setConnectivityState, healthCheckConfig.ServiceName)</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">   &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以通过健康检查更新连接状态，但不是唯一更新连接状态的方式</p><h4 id="服务端-2"><a class="markdownIt-Anchor" href="#服务端-2"></a> 服务端</h4><h5 id="维护"><a class="markdownIt-Anchor" href="#维护"></a> 维护</h5><p>首先需要明白服务端是如何维护状态的 <code>SetServingStatus</code> 其实还是需要用户自定义状态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">SetServingStatus</span><span class="params">(service <span class="keyword">string</span>, servingStatus healthpb.HealthCheckResponse_ServingStatus)</span></span> &#123;</span><br><span class="line">   <span class="comment">//....</span></span><br><span class="line">   s.setServingStatusLocked(service, servingStatus)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">setServingStatusLocked</span><span class="params">(service <span class="keyword">string</span>, servingStatus healthpb.HealthCheckResponse_ServingStatus)</span></span> &#123;</span><br><span class="line">   s.statusMap[service] = servingStatus</span><br><span class="line">   <span class="keyword">for</span> _, update := <span class="keyword">range</span> s.updates[service] &#123;</span><br><span class="line">      <span class="comment">// Clears previous updates, that are not sent to the client, from the channel.</span></span><br><span class="line">      <span class="comment">// This can happen if the client is not reading and the server gets flow control limited.</span></span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-update:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Puts the most recent update to the channel.</span></span><br><span class="line">      update &lt;- servingStatus</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">statusMap <span class="keyword">map</span>[<span class="keyword">string</span>]healthpb.HealthCheckResponse_ServingStatus</span><br><span class="line">updates   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[healthgrpc.Health_WatchServer]<span class="keyword">chan</span> healthpb.HealthCheckResponse_ServingStatus</span><br></pre></td></tr></table></figure><p>这里的状态更新有两种</p><ol><li>更新 <code>statusMap[service]</code> 对应的服务状态</li><li>将状态写入到服务对应的隧道中，隧道中的状态则是通过<code>Watch</code>函数不断地通知客户端(不同的状态才会通知)</li></ol><p>这里有两种特殊的情况可以直接使用内置函数，就是服务恢复正常与停止服务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Shutdown</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s.mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line">   s.shutdown = <span class="literal">true</span></span><br><span class="line">   <span class="keyword">for</span> service := <span class="keyword">range</span> s.statusMap &#123;</span><br><span class="line">      s.setServingStatusLocked(service, healthpb.HealthCheckResponse_NOT_SERVING)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Resume</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s.mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line">   s.shutdown = <span class="literal">false</span></span><br><span class="line">   <span class="keyword">for</span> service := <span class="keyword">range</span> s.statusMap &#123;</span><br><span class="line">      s.setServingStatusLocked(service, healthpb.HealthCheckResponse_SERVING)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会统一更新服务的状态，而不需要单独设置某个服务的状态更新，一般用于服务启动与恢复。</p><p>接着就是接收客户端的健康检查请求</p><h5 id="check"><a class="markdownIt-Anchor" href="#check"></a> Check</h5><p>当客户端请求服务状态的时候，直接从状态服务中返回结果  <code>statusMap[in.Service]</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Check</span><span class="params">(ctx context.Context, in *healthpb.HealthCheckRequest)</span> <span class="params">(*healthpb.HealthCheckResponse, error)</span></span> &#123;</span><br><span class="line">   s.mu.RLock()</span><br><span class="line">   <span class="keyword">defer</span> s.mu.RUnlock()</span><br><span class="line">   <span class="keyword">if</span> servingStatus, ok := s.statusMap[in.Service]; ok &#123;</span><br><span class="line">      <span class="keyword">return</span> &amp;healthpb.HealthCheckResponse&#123;</span><br><span class="line">         Status: servingStatus,</span><br><span class="line">      &#125;, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.NotFound, <span class="string">"unknown service"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="watch"><a class="markdownIt-Anchor" href="#watch"></a> Watch</h5><p><code>watch</code> 其实就是服务端不断地将状态的变化通知给客户端</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Watch implements `service Health`.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Watch</span><span class="params">(in *healthpb.HealthCheckRequest, stream healthgrpc.Health_WatchServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   service := in.Service</span><br><span class="line">   <span class="comment">// update channel is used for getting service status updates.</span></span><br><span class="line">   update := <span class="built_in">make</span>(<span class="keyword">chan</span> healthpb.HealthCheckResponse_ServingStatus, <span class="number">1</span>)</span><br><span class="line">   s.mu.Lock()</span><br><span class="line">   <span class="comment">// Puts the initial status to the channel.</span></span><br><span class="line">   <span class="keyword">if</span> servingStatus, ok := s.statusMap[service]; ok &#123;</span><br><span class="line">      update &lt;- servingStatus<span class="comment">//如果服务状态存在，那么写入隧道中</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果不存在，则更新未知</span></span><br><span class="line">      update &lt;- healthpb.HealthCheckResponse_SERVICE_UNKNOWN</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注册状态</span></span><br><span class="line">   <span class="keyword">if</span> _, ok := s.updates[service]; !ok &#123;</span><br><span class="line">      s.updates[service] = <span class="built_in">make</span>(<span class="keyword">map</span>[healthgrpc.Health_WatchServer]<span class="keyword">chan</span> healthpb.HealthCheckResponse_ServingStatus)</span><br><span class="line">   &#125;</span><br><span class="line">   s.updates[service][stream] = update</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      s.mu.Lock()</span><br><span class="line">      <span class="built_in">delete</span>(s.updates[service], stream)</span><br><span class="line">      s.mu.Unlock()</span><br><span class="line">   &#125;()</span><br><span class="line">   s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> lastSentStatus healthpb.HealthCheckResponse_ServingStatus = <span class="number">-1</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">     </span><br><span class="line">      <span class="keyword">case</span> servingStatus := &lt;-update:<span class="comment">//监听 update</span></span><br><span class="line">         <span class="keyword">if</span> lastSentStatus == servingStatus &#123;<span class="comment">//与上一次的状态相同，那么就不会响应</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//否则发送状态</span></span><br><span class="line">         lastSentStatus = servingStatus</span><br><span class="line">         err := stream.Send(&amp;healthpb.HealthCheckResponse&#123;Status: servingStatus&#125;)</span><br><span class="line">         <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> status.Error(codes.Canceled, <span class="string">"Stream has ended."</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> &lt;-stream.Context().Done():</span><br><span class="line">         <span class="keyword">return</span> status.Error(codes.Canceled, <span class="string">"Stream has ended."</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li><p>心跳检查是为了客户端可以根据服务端状态进行自定义操作</p></li><li><p>心跳检查启动的时候启动了退避算法，gRPC默认的退避算法是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultConfig = Config&#123;</span><br><span class="line">BaseDelay:  <span class="number">1.0</span> * time.Second,</span><br><span class="line">Multiplier: <span class="number">1.6</span>,</span><br><span class="line">Jitter:     <span class="number">0.2</span>,</span><br><span class="line">MaxDelay:   <span class="number">120</span> * time.Second,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>Watch</code>中如果与上一次的状态没有变化，则不会通知客户端</p></li><li><p>健康检查针对的是具有相同地址的多个服务，一个服务异常整体连接在不会断开，而是更新连接状态</p><ul><li>针对不能提供服务的服务器端，客户端会将链接状态更新为<code>TransientFailure</code>，但是链接不会断的；当该连接的状态重新更新为<code>Ready</code>时，还可以继续创建流，传输数据。</li><li>针对可以对外提供服务的服务器端，客户端会将链接状态更新为<code>Ready</code>，生成<code>Picker</code>，即将此链接缓存到平衡器里，并且将链接状态更新为<code>Ready</code>，接下来，就可以创建流，传输数据了</li></ul></li><li><p>健康检查可以应用会更新连接状态，且不能自定义 <code>withHealthCheckFunc</code></p></li><li><p>如果在传输过程中收到服务端通知，由于数据发送存在重试机制，所以还是可以从平衡器中选择 <code>Ready</code> 的连接重新传输数据</p></li><li><p>健康检查与保持链接的区别</p><ol><li><code>keepalive</code>和<code>healthcheck</code>都是用于确保通信的可用性和健康状态的机制。</li><li><code>keepalive</code>是一种保持连接活动的机制，用于检测连接是否处于空闲状态，并在需要时发送ping帧以防止连接关闭。<code>keepalive</code>机制确保长时间的空闲连接不会被关闭，以避免重新建立连接的开销</li><li><code>healthcheck</code>是一种检查服务可用性的机制，用于检测服务器是否可用，以及在服务器不可用时采取相应的措施。<code>healthcheck</code>机制通过发送特定的RPC请求来检查服务器的可用性，并根据响应的状态码和错误信息来确定服务器的状态。</li></ol></li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://github.com/grpc/grpc/blob/master/doc/health-checking.md" target="_blank" rel="noopener">https://github.com/grpc/grpc/blob/master/doc/health-checking.md</a></li><li><a href="https://blog.csdn.net/u011582922/article/details/120052706" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/120052706</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面学习了保持链接，这里看一下健康检查&lt;/p&gt;
&lt;p&gt;带着问题看世界&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;健康检查的作用&lt;/li&gt;
&lt;li&gt;健康检查的原理&lt;/li&gt;
&lt;li&gt;保持链接与健康检查的区别&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先看一下源码例子中的ReadMe说明，gRPC提供了一
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-13-保持链接</title>
    <link href="http://xboom.github.io/2022/10/31/Grpc/Grpc-13-%E4%BF%9D%E6%8C%81%E9%93%BE%E6%8E%A5/"/>
    <id>http://xboom.github.io/2022/10/31/Grpc/Grpc-13-%E4%BF%9D%E6%8C%81%E9%93%BE%E6%8E%A5/</id>
    <published>2022-10-31T14:58:29.000Z</published>
    <updated>2023-05-27T10:56:04.414Z</updated>
    
    <content type="html"><![CDATA[<p>在学习的过程中看到了grpc-go中的两个概念 <strong>保持链接</strong> 和 <strong>心跳检查</strong>，这里先学习一下<strong>保持链接</strong></p><p>带着问题看世界</p><ol><li>保持链接的作用</li><li>保持链接的原理</li><li>它与TCP的 <code>keepalive</code> 有什么区别</li></ol><p>首先来看一下<a href="https://github.com/grpc/grpc-go/blob/master/Documentation/keepalive.md" target="_blank" rel="noopener">官方的介绍</a>，</p><ul><li><p>保持连接功能可以检测TCP层面的连接故障。在某些情况下，TCP连接会丢失数据包(包括FIN)，需要等待系统TCP超时时间(可能为30分钟)才能检测到故障。使用保持连接功能可以让gRPC更早地检测到这种故障</p></li><li><p>另外是保持连接活动，比如在L4代理中配置为关闭“空闲连接”的情况下，发送包活消息可以是连接不处于“空闲”状态</p></li></ul><p>这里补充一下TCP的 keepalive 的原理：</p><p>当一方发送一个数据包后，如果对方没有回应，那么TCP协议会按照指数退避的算法重新发送数据包，最多会重发12次。如果在这12次内仍然没有收到对方的响应，则会将连接标记为“超时”，并关闭连接。这个过程通常需要30分钟左右</p><blockquote><p>可以手动修改TCP默认的超时时间</p><p>sudo sysctl -w net.ipv4.tcp_keepalive_time=300</p></blockquote><h3 id="基本使用"><a class="markdownIt-Anchor" href="#基本使用"></a> 基本使用</h3><h4 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kacp = keepalive.ClientParameters&#123;</span><br><span class="line">   Time:                <span class="number">10</span> * time.Second, <span class="comment">// send pings every 10 seconds if there is no activity</span></span><br><span class="line">   Timeout:             time.Second,      <span class="comment">// wait 1 second for ping ack before considering the connection dead</span></span><br><span class="line">   PermitWithoutStream: <span class="literal">true</span>,             <span class="comment">// send pings even without active streams</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithKeepaliveParams(kacp))</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端的保持心跳参数一共有三个</p><ol><li><code>Time</code>：在没有活动的情况下，发送 ping 的时间间隔(<strong>不能少于10s</strong>)</li><li><code>Timeout</code>：等待ping确认的超时时间</li><li><code>PermitWithoutStream</code>：及时没有活动的流也要发送<code>ping</code>请求</li></ol><h4 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kaep = keepalive.EnforcementPolicy&#123;</span><br><span class="line">   MinTime:             <span class="number">5</span> * time.Second, <span class="comment">// If a client pings more than once every 5 seconds, terminate the connection</span></span><br><span class="line">   PermitWithoutStream: <span class="literal">true</span>,            <span class="comment">// Allow pings even when there are no active streams</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kasp = keepalive.ServerParameters&#123;</span><br><span class="line">   MaxConnectionIdle:     <span class="number">15</span> * time.Second, <span class="comment">// If a client is idle for 15 seconds, send a GOAWAY</span></span><br><span class="line">   MaxConnectionAge:      <span class="number">30</span> * time.Second, <span class="comment">// If any connection is alive for more than 30 seconds, send a GOAWAY</span></span><br><span class="line">   MaxConnectionAgeGrace: <span class="number">5</span> * time.Second,  <span class="comment">// Allow 5 seconds for pending RPCs to complete before forcibly closing connections</span></span><br><span class="line">   Time:                  <span class="number">5</span> * time.Second,  <span class="comment">// Ping the client if it is idle for 5 seconds to ensure the connection is still active</span></span><br><span class="line">   Timeout:               <span class="number">1</span> * time.Second,  <span class="comment">// Wait 1 second for the ping ack before assuming the connection is dead</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := grpc.NewServer(grpc.KeepaliveEnforcementPolicy(kaep), grpc.KeepaliveParams(kasp))</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一共有两个保活配置 <code>EnforcementPolicy</code> 与 <code>ServerParameters</code></p><p><code>EnforcementPolicy</code> 定义了服务端如何执行保活策略</p><ul><li><code>MinTime</code>：如果客户端每隔不到5秒就发送一个ping请求，服务器就终止连接</li><li><code>PermitWithoutStream</code>：表示即使没有活动的流，也允许ping请求</li></ul><p>ServerParameters 定义了保活</p><ul><li><code>MaxConnectionIdle</code>：如果客户端闲置超过 15 秒，则发送 <code>GOAWAY</code></li><li><code>MaxConnectionAge</code>： 如果任何连接存在时间超过 30 秒，则发送 <code>GOAWAY</code></li><li><code>MaxConnectionAgeGrace</code>：允许在强制关闭连接之前等待 5 秒钟以完成待处理的 <code>RPC</code></li><li><code>Time</code>：如果客户端闲置超过 5 秒钟，则发送 <code>ping</code> 以确保连接仍处于活动状态</li><li><code>Timeout</code>：等待 1 秒钟以获取 <code>ping</code> 的响应，在此之后假定连接已断开</li></ul><p><code>MaxConnectionAge</code>是指整个连接（connection）的最长存在时间，不是单个流(stream)的最长存在时间。当一个连接的时间超过了 <code>MaxConnectionAge</code> 指定的时间，服务器会发送一个 <code>GOAWAY</code> 帧，表示不再接受来自该连接的新流。任何新的流的创建请求都会被拒绝，并且服务器会等待 <code>MaxConnectionAgeGrace</code> 指定的一段时间，让尚未完成的 RPC 请求完成。在这段时间内，服务器不会发送任何新的数据帧，但仍会响应已有的流。</p><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><h4 id="客户端-2"><a class="markdownIt-Anchor" href="#客户端-2"></a> 客户端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newHTTP2Client</span><span class="params">(connectCtx, ctx context.Context, addr resolver.Address, opts ConnectOptions, onPrefaceReceipt <span class="keyword">func</span>()</span>, <span class="title">onGoAway</span> <span class="title">func</span><span class="params">(GoAwayReason)</span>, <span class="title">onClose</span> <span class="title">func</span><span class="params">()</span>) <span class="params">(_ *http2Client, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">kp := opts.KeepaliveParams</span><br><span class="line"><span class="comment">// Validate keepalive parameters.</span></span><br><span class="line"><span class="keyword">if</span> kp.Time == <span class="number">0</span> &#123;</span><br><span class="line">kp.Time = defaultClientKeepaliveTime</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> kp.Timeout == <span class="number">0</span> &#123;</span><br><span class="line">kp.Timeout = defaultClientKeepaliveTimeout</span><br><span class="line">&#125;</span><br><span class="line">keepaliveEnabled := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> kp.Time != infinity &#123;</span><br><span class="line"><span class="keyword">if</span> err = syscall.SetTCPUserTimeout(conn, kp.Timeout); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, connectionErrorf(<span class="literal">false</span>, err, <span class="string">"transport: failed to set TCP_USER_TIMEOUT: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">keepaliveEnabled = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//... </span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> t.keepaliveEnabled &#123;<span class="comment">//如果开启包活</span></span><br><span class="line">t.kpDormancyCond = sync.NewCond(&amp;t.mu)</span><br><span class="line"><span class="keyword">go</span> t.keepalive()</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是在构建链接的时候设置的超时时间 <code>SetTCPUserTimeout</code>，指定发送数据后多久没有收到确认信号就会超时。</p><ul><li>这是设置是设置网络层的，并不会影响gRPC应用层，因为gRPC超时会重试</li><li>并不是所有的操作系统都支持 <code>syscall.SetTCPUserTimeout</code>(可能老的操作系统不支持，Linux、Windows、MacOS都支持)</li></ul><p>如果开启保活，通过开启独立协程发送ping帧确保链接是活的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *http2Client)</span> <span class="title">keepalive</span><span class="params">()</span></span> &#123;</span><br><span class="line">   p := &amp;ping&#123;data: [<span class="number">8</span>]<span class="keyword">byte</span>&#123;&#125;&#125;</span><br><span class="line">   outstandingPing := <span class="literal">false</span> <span class="comment">//是否有等待响应的ping帧</span></span><br><span class="line">   timeoutLeft := time.Duration(<span class="number">0</span>)<span class="comment">//记录发送ping之后剩余时间</span></span><br><span class="line">   prevNano := time.Now().UnixNano() <span class="comment">//记录活动时间</span></span><br><span class="line">   timer := time.NewTimer(t.kp.Time)<span class="comment">//开启定时器</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">         lastRead := atomic.LoadInt64(&amp;t.lastRead)</span><br><span class="line">         <span class="keyword">if</span> lastRead &gt; prevNano &#123;<span class="comment">//自从上次定时器已经读取过了</span></span><br><span class="line">            outstandingPing = <span class="literal">false</span></span><br><span class="line">            <span class="comment">// Next timer should fire at kp.Time seconds from lastRead time.</span></span><br><span class="line">           <span class="comment">//重新计算下次触发定时器时间(从上次读取时间开始算)</span></span><br><span class="line">            timer.Reset(time.Duration(lastRead) + t.kp.Time - time.Duration(time.Now().UnixNano()))</span><br><span class="line">            prevNano = lastRead</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//outstandingPing  有等待响应的ping帧，且已经超时。表示链接超时关闭</span></span><br><span class="line">         <span class="keyword">if</span> outstandingPing &amp;&amp; timeoutLeft &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            t.Close(connectionErrorf(<span class="literal">true</span>, <span class="literal">nil</span>, <span class="string">"keepalive ping failed to receive ACK within timeout"</span>))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         t.mu.Lock()</span><br><span class="line">         <span class="keyword">if</span> t.state == closing &#123;<span class="comment">//如果链接的状态是关闭中，那么也退出</span></span><br><span class="line">            t.mu.Unlock()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//如果没有活动流，且没有活动流不允许发送ping帧</span></span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">len</span>(t.activeStreams) &lt; <span class="number">1</span> &amp;&amp; !t.kp.PermitWithoutStream &#123;</span><br><span class="line">            outstandingPing = <span class="literal">false</span></span><br><span class="line">            t.kpDormant = <span class="literal">true</span></span><br><span class="line">            t.kpDormancyCond.Wait() <span class="comment">//在初始化流或者关闭客户端的时候 会触发 t.kpDormancyCond.Signal()</span></span><br><span class="line">         &#125;</span><br><span class="line">         t.kpDormant = <span class="literal">false</span></span><br><span class="line">         t.mu.Unlock()</span><br><span class="line"></span><br><span class="line">         <span class="comment">//没有等待响应的ping帧，就发送ping帧</span></span><br><span class="line">         <span class="keyword">if</span> !outstandingPing &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            t.controlBuf.put(p)<span class="comment">//发送ping帧</span></span><br><span class="line">            timeoutLeft = t.kp.Timeout</span><br><span class="line">            outstandingPing = <span class="literal">true</span></span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         sleepDuration := minTime(t.kp.Time, timeoutLeft)</span><br><span class="line">         timeoutLeft -= sleepDuration</span><br><span class="line">         timer.Reset(sleepDuration)<span class="comment">//计算定时器下一次触发时间</span></span><br><span class="line">      <span class="keyword">case</span> &lt;-t.ctx.Done():</span><br><span class="line">         <span class="keyword">if</span> !timer.Stop() &#123;</span><br><span class="line">            &lt;-timer.C</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是根据 ping帧的状态以及链接是否有活动来计算发送ping帧时间。</p><p>有几个注意点</p><ol><li><p>如何判断有ping帧响应的</p><p>其实它并没有判断是有有相应帧，而是是否在指定时间内是否读取到消息即可</p></li><li><p>如果没有活动流又不允许非活动流发送ping，那么它是如何处理的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果没有活动流，且没有活动流不允许发送ping帧</span></span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">len</span>(t.activeStreams) &lt; <span class="number">1</span> &amp;&amp; !t.kp.PermitWithoutStream &#123;</span><br><span class="line">    outstandingPing = <span class="literal">false</span></span><br><span class="line">    t.kpDormant = <span class="literal">true</span></span><br><span class="line">    t.kpDormancyCond.Wait() <span class="comment">//在初始化流或者关闭客户端的时候 会触发 t.kpDormancyCond.Signal()</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>而出发 <code>kpDormancyCond.Signal()</code>的位置是 构建流或者关闭连接</p></li></ol><h4 id="服务端-2"><a class="markdownIt-Anchor" href="#服务端-2"></a> 服务端</h4><p>服务端同样也是使用独立协程来运行保活逻辑</p><ol><li>超过 最长闲置时间 <code>MaxConnectionIdle</code> 优雅的关闭连接</li><li>超过 最大连接时间 MaxConnectionAge 优雅的关闭连接</li><li>等待 <code>MaxConnectionAgeGrace</code> 后强制关闭连接。</li><li>以 <code>Time</code> 的频率发送 <code>ping</code> 确保连接存活，并在 <code>Timeout</code> 的额外时间内关闭无响应的连接</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *http2Server)</span> <span class="title">keepalive</span><span class="params">()</span></span> &#123;</span><br><span class="line">   p := &amp;ping&#123;&#125;</span><br><span class="line">   outstandingPing := <span class="literal">false</span> <span class="comment">//是否有等待响应帧</span></span><br><span class="line">   kpTimeoutLeft := time.Duration(<span class="number">0</span>)</span><br><span class="line">   prevNano := time.Now().UnixNano()</span><br><span class="line">   <span class="comment">// Initialize the different timers to their default values.</span></span><br><span class="line">   idleTimer := time.NewTimer(t.kp.MaxConnectionIdle)</span><br><span class="line">   ageTimer := time.NewTimer(t.kp.MaxConnectionAge)</span><br><span class="line">   kpTimer := time.NewTimer(t.kp.Time)</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      idleTimer.Stop()</span><br><span class="line">      ageTimer.Stop()</span><br><span class="line">      kpTimer.Stop()</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-idleTimer.C:<span class="comment">//闲置定时器</span></span><br><span class="line">         t.mu.Lock()</span><br><span class="line">         idle := t.idle</span><br><span class="line">         <span class="keyword">if</span> idle.IsZero() &#123; <span class="comment">//未闲置则重置最大闲置时间</span></span><br><span class="line">            t.mu.Unlock()</span><br><span class="line">            idleTimer.Reset(t.kp.MaxConnectionIdle)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         val := t.kp.MaxConnectionIdle - time.Since(idle)</span><br><span class="line">         t.mu.Unlock()</span><br><span class="line">         <span class="keyword">if</span> val &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            t.Drain()<span class="comment">//优雅关闭连接</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         idleTimer.Reset(val)<span class="comment">//重置闲置连接</span></span><br><span class="line">      <span class="keyword">case</span> &lt;-ageTimer.C:<span class="comment">//最长连接</span></span><br><span class="line">         t.Drain()</span><br><span class="line">         ageTimer.Reset(t.kp.MaxConnectionAgeGrace)</span><br><span class="line">         <span class="keyword">select</span> &#123;</span><br><span class="line">         <span class="keyword">case</span> &lt;-ageTimer.C:</span><br><span class="line">            <span class="comment">// Close the connection after grace period.</span></span><br><span class="line">            <span class="keyword">if</span> logger.V(logLevel) &#123;</span><br><span class="line">               logger.Infof(<span class="string">"transport: closing server transport due to maximum connection age."</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            t.Close()</span><br><span class="line">         <span class="keyword">case</span> &lt;-t.done:</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">case</span> &lt;-kpTimer.C:<span class="comment">//保活定时器</span></span><br><span class="line">         lastRead := atomic.LoadInt64(&amp;t.lastRead)</span><br><span class="line">         <span class="keyword">if</span> lastRead &gt; prevNano &#123;</span><br><span class="line">            <span class="comment">// There has been read activity since the last time we were</span></span><br><span class="line">            <span class="comment">// here. Setup the timer to fire at kp.Time seconds from</span></span><br><span class="line">            <span class="comment">// lastRead time and continue.</span></span><br><span class="line">            outstandingPing = <span class="literal">false</span></span><br><span class="line">            kpTimer.Reset(time.Duration(lastRead) + t.kp.Time - time.Duration(time.Now().UnixNano()))</span><br><span class="line">            prevNano = lastRead</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> outstandingPing &amp;&amp; kpTimeoutLeft &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> logger.V(logLevel) &#123;</span><br><span class="line">               logger.Infof(<span class="string">"transport: closing server transport due to idleness."</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            t.Close()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> !outstandingPing &#123;<span class="comment">//如果没有等待保活则发送保活帧</span></span><br><span class="line">            <span class="keyword">if</span> channelz.IsOn() &#123;</span><br><span class="line">               atomic.AddInt64(&amp;t.czData.kpCount, <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            t.controlBuf.put(p)</span><br><span class="line">            kpTimeoutLeft = t.kp.Timeout</span><br><span class="line">            outstandingPing = <span class="literal">true</span></span><br><span class="line">         &#125;</span><br><span class="line">         sleepDuration := minTime(t.kp.Time, kpTimeoutLeft)</span><br><span class="line">         kpTimeoutLeft -= sleepDuration</span><br><span class="line">         kpTimer.Reset(sleepDuration)</span><br><span class="line">      <span class="keyword">case</span> &lt;-t.done:</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：</p><ol><li><p>连接什么时候闲置的?</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(t.activeStreams) == <span class="number">1</span> &#123;</span><br><span class="line">  t.idle = time.Time&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在处理头帧的时候(构建了一个活跃流)，如果 <code>len(t.activeStreams) == 1</code> ，表示刚新建一个流且仅有一个活跃流，那么这个时候连接是闲置的</p></li><li><p>服务端也会主动发送ping帧</p></li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li><p>TCP与gRPC的区别</p><p>TCP的Keepalive是一种机制，它允许在网络连接空闲时发送探测包（keepalive包）来维护连接的状态。这些探测包不包含有效负载，只是一个空的TCP报文段，主要用于检测连接是否仍然活着。</p><p>当TCP连接上没有传输数据时会进入空闲状态，即使连接已经中断或不可用，导致不必要的延迟和资源浪费。Keepalive机制可以在连接空闲时周期性地发送探测包，以检测连接是否仍然活着。如果远程端点没有响应这些探测包，则可以视为连接已经断开，并且可以关闭连接。</p><p>在gRPC中，使用Keepalive可以检测底层TCP连接是否失效，并在检测到连接问题时及时重新建立连接，从而提高网络连接的可靠性和性能。</p></li><li><p>客户端与服务端都会根据配置向对端发送ping帧，只要在指定时间内读取到帧，那么就不会主动发送ping帧</p></li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://blog.csdn.net/u011582922/article/details/120279303" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/120279303</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习的过程中看到了grpc-go中的两个概念 &lt;strong&gt;保持链接&lt;/strong&gt; 和 &lt;strong&gt;心跳检查&lt;/strong&gt;，这里先学习一下&lt;strong&gt;保持链接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;带着问题看世界&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;保持链接的作用&lt;/l
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-02-平衡器</title>
    <link href="http://xboom.github.io/2022/10/28/Grpc/Grpc-12-%E5%B9%B3%E8%A1%A1%E5%99%A8/"/>
    <id>http://xboom.github.io/2022/10/28/Grpc/Grpc-12-%E5%B9%B3%E8%A1%A1%E5%99%A8/</id>
    <published>2022-10-28T14:58:29.000Z</published>
    <updated>2023-05-27T10:55:56.060Z</updated>
    
    <content type="html"><![CDATA[<p>平衡器的核心目的就是用于向服务端发起链接，主要包括</p><ul><li>子链接的维护，每个 target 可能对应多个地址(类似一个服务有多个副本)，进行子链接的新增与删除</li><li>当平衡器状态发生变化，更新 <code>ClientConn</code> 的状态，自定义选择器，从而让客户端选择具体子链接进行发送</li><li>在满足一定条件的情况下，执行解析器操作。如解析器由阻塞状态 --&gt; 非阻塞状态</li></ul><h4 id="整体流程"><a class="markdownIt-Anchor" href="#整体流程"></a> 整体流程</h4><h4 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h4><p>代码路径:<code>/balancer/balancer.go</code>，在这个文件中一共定义了五个接口</p><ul><li><strong>Builder 接口</strong>，主要用来创建平衡器</li><li><strong>SubConn 接</strong>口，主要用来负责具体的链接(<strong>这里的链接指的是一对实际建立链接的客户端与服务器</strong>)</li><li><strong>Picker 接口</strong>，主要是从众多 <code>SubConn</code>中按照某个策略选择一个链接进行数据传输，也就是 <strong>选择器</strong></li><li><strong>Balancer 接口</strong>，主要是更新 <code>ClientConn</code> 的状态，更新<code>SubConn</code>状态</li><li><strong>ClientConn 接口</strong>，主要是负责链路的维护，包括创建、移除、更新一个子链路，更新 <code>ClientConn</code> 状态</li></ul><p>所以平衡器也跟解析器一样，由两部分组成平衡器构建器与平衡器，内部在封装到一个结构体实现平衡器功能</p><h4 id="平衡器构建器注册"><a class="markdownIt-Anchor" href="#平衡器构建器注册"></a> 平衡器构建器注册</h4><p>平衡器构建器通过注册的方式将自己平衡器的构建方法存入全局变量中，当需要使用的时候则直接根据名称获取</p><ol><li><p>使用一个全局的 map  <code>var m = make(map[string]Builder)</code>进行平衡器构建器 <code>Builder</code> 的存储。k/v 分别对应的是构建 构建器的名称以及构建器的实现方法。</p></li><li><p>平衡器构建器可以通过 <code>Register</code> 函数存储到这个 map 中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Register 注册平衡器构建器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Register</span><span class="params">(b Builder)</span></span> &#123;</span><br><span class="line">m[strings.ToLower(b.Name())] = b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Get 获取平衡器构建器，如果找不到则返回nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Builder</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> b, ok := m[strings.ToLower(name)]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>有了存储与添加，它还增加了一个删除操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//仅做测试使用，去掉某一个平衡器解析器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unregisterForTesting</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(m, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">internal.BalancerUnregister = unregisterForTesting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除操作则是利用 <code>init</code> 给 <code>BalancerUnregister</code> 复制一个 删除函数 <code>unregisterForTesting</code></p></li><li><p>而一个普通的平衡器构建器(已轮询平衡器构建器为例<code>rrPickerBuilder</code>)，则是利用 init 函数直接初始化到这个全局map中，那么就可以在需要使用的时候，直接从全局map 中获取</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Name = <span class="string">"round_robin"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个平衡器构建器对洗那个</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newBuilder</span><span class="params">()</span> <span class="title">balancer</span>.<span class="title">Builder</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> base.NewBalancerBuilder(Name, &amp;rrPickerBuilder&#123;&#125;, base.Config&#123;HealthCheck: <span class="literal">true</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化将 round_robin平衡器构建器存入全局 map 中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">balancer.Register(newBuilder())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="构建平衡器"><a class="markdownIt-Anchor" href="#构建平衡器"></a> 构建平衡器</h4><p>有了平衡器构建器之后，通过选定的平衡器构建器进行平衡器的构建</p><ol><li><p>设置通过哪个平衡器构建器获取平衡器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serviceConfig = <span class="string">`&#123;</span></span><br><span class="line"><span class="string">"loadBalancingConfig": [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">"grpclb": &#123;</span></span><br><span class="line"><span class="string">"childPolicy": [</span></span><br><span class="line"><span class="string">&#123;"round_robin": ""&#125;,</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line">grpc.WithDefaultServiceConfig(serviceConfig)</span><br></pre></td></tr></table></figure><p>如果不设置负载均衡构建器名称，那么grpc-go 会默认使用 <code>round_robin</code> 构建平衡器</p></li><li><p>指定了构建器之后就会在构建链接过程中调用构建函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialContext</span><span class="params">(ctx context.Context, target <span class="keyword">string</span>, opts ...DialOption)</span> <span class="params">(conn *ClientConn, err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//...                                                                                                      </span></span><br><span class="line">    cc.balancerWrapper = newCCBalancerWrapper(cc, balancer.BuildOptions&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在建立连接的过程中，通过</p></li></ol><h4 id="构建链接"><a class="markdownIt-Anchor" href="#构建链接"></a> 构建链接</h4><h4 id="存储链接"><a class="markdownIt-Anchor" href="#存储链接"></a> 存储链接</h4><h4 id="实际应用"><a class="markdownIt-Anchor" href="#实际应用"></a> 实际应用</h4><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://blog.csdn.net/u011582922/article/details/117547171" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/117547171</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平衡器的核心目的就是用于向服务端发起链接，主要包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子链接的维护，每个 target 可能对应多个地址(类似一个服务有多个副本)，进行子链接的新增与删除&lt;/li&gt;
&lt;li&gt;当平衡器状态发生变化，更新 &lt;code&gt;ClientConn&lt;/code&gt; 
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-03-选择器</title>
    <link href="http://xboom.github.io/2022/10/25/Grpc/Grpc-11-%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <id>http://xboom.github.io/2022/10/25/Grpc/Grpc-11-%E9%80%89%E6%8B%A9%E5%99%A8/</id>
    <published>2022-10-25T14:58:29.000Z</published>
    <updated>2023-05-27T10:55:51.743Z</updated>
    
    <content type="html"><![CDATA[<ol><li>什么是Grpc</li><li>为什么我们要使用grpc</li><li>优点有哪些</li></ol><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/20210605094836494.jpg" alt="resolver、balancer、picker之间的关系" /></p><p>从图中可以看出 grpc 客户端与服务端的通信主要有两个阶段</p><ol><li>建立链接阶段</li><li>帧传输阶段</li></ol><p>这其中存在三个主要的功能接口</p><ul><li><p>解析器 resolver 负责根据域名解析地址</p></li><li><p>平衡器 balancer 负责根据地址构建对应连接</p></li><li><p>选择器 picker 负责在发送的时候选择合适的连接</p></li></ul><p>在第一阶段建立链接的过程中，主要通过 解析器与平衡器构建链接；在第二阶段发送过程中通过选择器从准备好的连接中选择合适的连接进行帧的传输</p><p>根据负载均衡器的位置不同，可以分为</p><ul><li>根据作用的位置可以分为客户端负载均衡器、服务端负载均衡器</li><li>根据部署的方式可以分为 <strong>集中式LB(Proxy Model)</strong>、进程内LB(Balancing-aware Client)、<strong>独立LB进程(External Load Balancing Service)</strong></li></ul><blockquote><p>独立LB与集中式LB的区别是，独立LB不在进程内部，但是是伴随着进程的，类似SideCar模式。</p></blockquote><p>在 <code>grpc-go</code> 的中的负载均衡器(选择器)，其实是一种 <strong>进程内LB</strong>，它的核心功能就是：<strong>根据规则选择合适的子链接进行消息发送</strong></p><h3 id="整体流程"><a class="markdownIt-Anchor" href="#整体流程"></a> 整体流程</h3><h3 id="实际应用"><a class="markdownIt-Anchor" href="#实际应用"></a> 实际应用</h3><p>代码路径：<code>balancer\balancer.go</code></p><p>选择器定义了一个 <code>Picker</code> 的接口，按照备注</p><ol><li><code>Pick</code> 函数用于发送RPC消息的连接以及相关信息</li><li><code>Pick</code> 函数不应该被阻塞，如果有任何I/O、阻塞、一定时间开销的操作，那么应该返回 <code>ErrNoSubConnAvailable</code>的内部错误，那么它将重复调用(注意：它会一致重复！)直到Picker更新 <code>ClientConn.UpdateState</code></li><li>如果返回了其他错误<ul><li>如果返回一个状态错误来源于 <code>status\status.go</code>，那么 rpc将停止并返回这个错误</li><li>如果是其他错误，那么等待的rpc调用将继续调用，不需要等待的rpc调用将立即停止并返回这个错误以及 状态 Code 为 <code>Unavailable</code></li></ul></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Picker <span class="keyword">interface</span> &#123;</span><br><span class="line">Pick(info PickInfo) (PickResult, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择器执行失败的逻辑处理，代码路径：<code>picker_wrapper.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">pickResult, err := p.Pick(info)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == balancer.ErrNoSubConnAvailable &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, ok := status.FromError(err); ok &#123;</span><br><span class="line"><span class="comment">// Status error: end the RPC unconditionally with this status.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, dropError&#123;error: err&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// For all other errors, wait for ready RPCs should block and other</span></span><br><span class="line"><span class="comment">// RPCs should fail with unavailable.</span></span><br><span class="line"><span class="keyword">if</span> !failfast &#123;</span><br><span class="line">lastPickErr = err</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, status.Error(codes.Unavailable, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 failfast 是通过 <code>serviceconfig.MethodConfig</code> 中的 <code>WaitForReady</code> 控制，可在初始化连接配置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grpc.WithDefaultServiceConfig(<span class="string">`&#123;"methodConfig": [&#123;"waitForReady": true&#125;]&#125;`</span>)</span><br></pre></td></tr></table></figure><h3 id="实际应用-2"><a class="markdownIt-Anchor" href="#实际应用-2"></a> 实际应用</h3><h4 id="pickfirst"><a class="markdownIt-Anchor" href="#pickfirst"></a> PickFirst</h4><p>pickFirst 是 grpc-go 内置的选择器，它的作用是从链接中选择第一个已经建立好的链接给流使用</p><p>代码路径：<code>pickfirst.go</code></p><p>首先，看下选择器 <code>pickfirstBalancer</code> 结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pickfirstBalancer <span class="keyword">struct</span> &#123;</span><br><span class="line">state connectivity.State</span><br><span class="line">cc    balancer.ClientConn</span><br><span class="line">sc    balancer.SubConn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>connectivity.State 表示选择器的状态</li><li>balancer.ClientConn 负责子链接 SubConn 的创建、移除。更新客户端链接 ClientConn 的状态。由 <code>ccBalancerWrapper</code>结构实现</li><li>balancer.SubConn 主要负责向 grpc 服务发起链接</li></ul><p>其次，<code>pickfirstBalancer</code> 其实实现了平衡器构建接口，也就是说，通过 <code>pickfirstBalancer</code> 可以构建一个平衡器</p><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/377860784" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/377860784</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;什么是Grpc&lt;/li&gt;
&lt;li&gt;为什么我们要使用grpc&lt;/li&gt;
&lt;li&gt;优点有哪些&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-10-连接</title>
    <link href="http://xboom.github.io/2022/10/22/Grpc/Grpc-10-%E8%BF%9E%E6%8E%A5/"/>
    <id>http://xboom.github.io/2022/10/22/Grpc/Grpc-10-%E8%BF%9E%E6%8E%A5/</id>
    <published>2022-10-22T14:58:29.000Z</published>
    <updated>2023-05-27T10:55:43.898Z</updated>
    
    <content type="html"><![CDATA[<h3 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h3><ol><li><p>构建链接阶段设置超时时间</p><p>构建链接阶段有单独的超时控制，也就是链接的超时控制与发送请求的超时控制是分开的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conn, err := grpc.DialContext(context.Background(), *addr, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatalf(<span class="string">"did not connect: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br></pre></td></tr></table></figure><p>在构建链接的过程中，通过强制等待</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialContext</span><span class="params">(ctx context.Context, target <span class="keyword">string</span>, opts ...DialOption)</span> <span class="params">(conn *ClientConn, err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//等待最后的结果，要么ctx.Done()结束</span></span><br><span class="line">     <span class="keyword">select</span> &#123;</span><br><span class="line">     <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> ctx.Err() == err:<span class="comment">//失败错误</span></span><br><span class="line">           conn = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> err == <span class="literal">nil</span> || !cc.dopts.returnLastError:<span class="comment">//将服务端的错误与错误信息一起返回给客户端而不是仅仅一个错误码</span></span><br><span class="line">           conn, err = <span class="literal">nil</span>, ctx.Err()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">           conn, err = <span class="literal">nil</span>, fmt.Errorf(<span class="string">"%v: %v"</span>, ctx.Err(), err)<span class="comment">//返回其他错误</span></span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span> cc.dopts.block &#123;<span class="comment">//如果是阻塞模式</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">cc.Connect()</span><br><span class="line">s := cc.GetState()</span><br><span class="line"><span class="keyword">if</span> s == connectivity.Ready &#123;<span class="comment">//连接状态，健康检查的时候也会更新</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> cc.dopts.copts.FailOnNonTempDialError &amp;&amp; s == connectivity.TransientFailure &#123;</span><br><span class="line"><span class="keyword">if</span> err = cc.connectionError(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">terr, ok := err.(<span class="keyword">interface</span> &#123;</span><br><span class="line">Temporary() <span class="keyword">bool</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> ok &amp;&amp; !terr.Temporary() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !cc.WaitForStateChange(ctx, s) &#123;<span class="comment">//为什么是等待状态变化，因为构建链接的时候是每个都使用一个协程进行建立连接</span></span><br><span class="line"><span class="comment">// ctx got timeout or canceled.</span></span><br><span class="line"><span class="keyword">if</span> err = cc.connectionError(); err != <span class="literal">nil</span> &amp;&amp; cc.dopts.returnLastError &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ctx.Err()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> cc, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等待连接的状态其实就是等待结果后者超时的过程，通过隧道通知</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *ClientConn)</span> <span class="title">WaitForStateChange</span><span class="params">(ctx context.Context, sourceState connectivity.State)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   ch := cc.csMgr.getNotifyChan()</span><br><span class="line">   <span class="keyword">if</span> cc.csMgr.getState() != sourceState &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Dfasdf</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;客户端&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#客户端&quot;&gt;&lt;/a&gt; 客户端&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;构建链接阶段设置超时时间&lt;/p&gt;
&lt;p&gt;构建链接阶段有单独的超时控制，也就是链接的超时控制与发送请求的超时控制是分开的
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-05-重试机制</title>
    <link href="http://xboom.github.io/2022/10/19/Grpc/Grpc-09-%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/"/>
    <id>http://xboom.github.io/2022/10/19/Grpc/Grpc-09-%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/</id>
    <published>2022-10-19T14:58:29.000Z</published>
    <updated>2023-05-27T10:55:34.640Z</updated>
    
    <content type="html"><![CDATA[<p>重试机制是为了在短暂异常情况下能够正常恢复，也能防止长时间异常而不退出。这里看一下grpc-go 中的重试机制以及使用方法</p><p>带着问题看世界：</p><ol><li>grpc-go 的重试策略的使用</li><li>grpc-go 的重试机制是怎样的</li><li>grpc-go 的重试机制都应用在哪些地方</li></ol><h3 id="基本使用"><a class="markdownIt-Anchor" href="#基本使用"></a> 基本使用</h3><p>通过 <code>Dial</code> 可选参数设置自定义重试策略</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   addr = flag.String(<span class="string">"addr"</span>, <span class="string">"localhost:50052"</span>, <span class="string">"the address to connect to"</span>)</span><br><span class="line">   <span class="comment">// see https://github.com/grpc/grpc/blob/master/doc/service_config.md to know more about service config</span></span><br><span class="line">   retryPolicy = <span class="string">`&#123;</span></span><br><span class="line"><span class="string">      "methodConfig": [&#123;</span></span><br><span class="line"><span class="string">        "name": [&#123;"service": "grpc.examples.echo.Echo"&#125;],</span></span><br><span class="line"><span class="string">        "waitForReady": true,</span></span><br><span class="line"><span class="string">        "retryPolicy": &#123;</span></span><br><span class="line"><span class="string">           "MaxAttempts": 4,</span></span><br><span class="line"><span class="string">           "InitialBackoff": ".01s",</span></span><br><span class="line"><span class="string">           "MaxBackoff": ".01s",</span></span><br><span class="line"><span class="string">           "BackoffMultiplier": 1.0,</span></span><br><span class="line"><span class="string">           "RetryableStatusCodes": [ "UNAVAILABLE" ]</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        "hedgingPolicy": &#123;</span></span><br><span class="line"><span class="string">        "MaxAttempts": "",</span></span><br><span class="line"><span class="string">        "HedgingDelay": "",</span></span><br><span class="line"><span class="string">        "NonFatalStatusCodes": [""]</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;]&#125;`</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// use grpc.WithDefaultServiceConfig() to set service config</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retryDial</span><span class="params">()</span> <span class="params">(*grpc.ClientConn, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithDefaultServiceConfig(retryPolicy))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，这里有两种重试策略 <code>hedgingPolicy</code> (<strong>重试</strong>) 与 <code>retryPolicy</code>(<strong>对冲</strong>)</p><p>重试中参数的解释</p><ol><li><code>MaxAttempts</code>：最大重试次数</li><li><code>InitialBackoff</code>：默认退避时间</li><li><code>MaxBackoff</code>：最大退避时间</li><li><code>BackoffMultiplier</code>：退避时间增加倍率</li><li><code>RetryableStatusCodes</code>: 服务端返回什么错误码才重试</li></ol><p><strong>对冲</strong>是指在不等待响应的情况下主动发送单词调用的多个请求。通俗解释就是 如果<code>HedgingDelay</code>时间没有响应，那么直接发送第二次请求，以此类推，直到达到最大次数 <code>MaxAttempts</code></p><ol><li><code>MaxAttempts</code>：最大重试次数</li><li><code>HedgingDelay</code>：等待响应时间</li></ol><p>也可以通过可选参数关闭重试策略</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDisableRetry</span><span class="params">()</span> <span class="title">DialOption</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> newFuncDialOption(<span class="function"><span class="keyword">func</span><span class="params">(o *dialOptions)</span></span> &#123;</span><br><span class="line">      o.disableRetry = <span class="literal">true</span></span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重试策略"><a class="markdownIt-Anchor" href="#重试策略"></a> 重试策略</h3><p>这两种策略都是通过实现统一的重试接口进行加载</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> isMethodConfig_RetryOrHedgingPolicy <span class="keyword">interface</span> &#123;</span><br><span class="line">   isMethodConfig_RetryOrHedgingPolicy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过转换而进行重试测试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pushback := <span class="number">0</span><span class="comment">//记录重试间隔时间</span></span><br><span class="line">hasPushback := <span class="literal">false</span>  <span class="comment">//记录是否要重试</span></span><br><span class="line"><span class="keyword">if</span> cs.attempt.s != <span class="literal">nil</span> &#123;<span class="comment">//存在重试任务</span></span><br><span class="line">   <span class="keyword">if</span> !cs.attempt.s.TrailersOnly() &#123;<span class="comment">//如果流不是只有trailer,则无法直接读取元数据</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   sps := cs.attempt.s.Trailer()[<span class="string">"grpc-retry-pushback-ms"</span>]<span class="comment">//获取元数据</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(sps) == <span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> e error</span><br><span class="line">      <span class="keyword">if</span> pushback, e = strconv.Atoi(sps[<span class="number">0</span>]); e != <span class="literal">nil</span> || pushback &lt; <span class="number">0</span> &#123;</span><br><span class="line">         cs.retryThrottler.throttle() <span class="comment">// 记录重试次数</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">      &#125;</span><br><span class="line">      hasPushback = <span class="literal">true</span><span class="comment">//重试</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(sps) &gt; <span class="number">1</span> &#123;<span class="comment">//如果存在多个 sps 表示异常</span></span><br><span class="line">      cs.retryThrottler.throttle() <span class="comment">// 记录重试次数(用于重试失败限速)</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>Trailers</code> 是一种消息元数据，用于在相应结束时传递关于次消息的附加信息，通常包含状态码，消息和错误信息的传递。Trailers 通常会在流关闭之前发送。<code>Trailers</code> 发送的情况有几下几种</p><ul><li>RPC正常结束，<code>Trailers</code>中携带调用的状态、错误码、响应时间等信息；</li><li>RPC出错结束，<code>Trailers</code>中携带错误信息，例如错误码、错误消息等；</li><li>服务器关闭了stream，<code>Trailers</code>中携带stream关闭的原因；</li><li>客户端取消了RPC调用，<code>Trailers</code>中携带调用取消的原因</li></ul><p>它的特点：</p><ul><li><p><code>Trailers</code> 并不是每个RPC调用都会发，而是流关闭的时候才会发！！！ 可以包含在最后一个数据帧中附加一个<code>Trailers</code>，所以抓包看不到一个独立的 <code>Trailers</code>。</p></li><li><p>如果流中不仅仅有<code>Trailers</code>，那么无法直接从流中获取 <code>Trailers</code>，而是需要其他办法，比如拦截器</p></li><li><p>包含元数据存储在ctx中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx := metadata.NewOutgoingContext(context.Background(), metadata.Pairs(</span><br><span class="line">    <span class="string">"grpc-retry-pushback-ms"</span>, <span class="string">"5000"</span>,</span><br><span class="line">))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>这里还多了一个 <code>retryThrottler.throttle</code>，在下面的重试速率中说明</p></li><li><p>如果有 没有配置 <code>grpc-retry-pushback-ms</code>，那么就使用重试策略，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dur time.Duration</span><br><span class="line"><span class="keyword">if</span> hasPushback &#123;<span class="comment">//设置了重试元数据</span></span><br><span class="line">   dur = time.Millisecond * time.Duration(pushback)</span><br><span class="line">   cs.numRetriesSincePushback = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   fact := math.Pow(rp.BackoffMultiplier, <span class="keyword">float64</span>(cs.numRetriesSincePushback))</span><br><span class="line">   cur := <span class="keyword">float64</span>(rp.InitialBackoff) * fact</span><br><span class="line">   <span class="keyword">if</span> max := <span class="keyword">float64</span>(rp.MaxBackoff); cur &gt; max &#123;<span class="comment">//最大判断</span></span><br><span class="line">      cur = max</span><br><span class="line">   &#125;</span><br><span class="line">   dur = time.Duration(grpcrand.Int63n(<span class="keyword">int64</span>(cur)))</span><br><span class="line">   cs.numRetriesSincePushback++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，退避时间随着重试次数指数级增长 <code>InitialBackoff * math.Pow(rp.BackoffMultiplier, float64(cs.numRetriesSincePushback))</code></p></li></ol><p>根据上述计算的退避时间执行等待逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t := time.NewTimer(dur)<span class="comment">//开启一个定时器</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-t.C:<span class="comment">//定时器触发，重试次数+1</span></span><br><span class="line">   cs.numRetries++</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;-cs.ctx.Done():<span class="comment">//流程结束停止重试</span></span><br><span class="line">   t.Stop()</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>, status.FromContextError(cs.ctx.Err()).Err()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重试速率"><a class="markdownIt-Anchor" href="#重试速率"></a> 重试速率</h3><p>重试过程中还能看到 <code>RetryThrottlingPolicy</code> 做了一层重试限制，其实除了配置重试策略，还能控制重试的速率，防止重试的次数太多给服务器造成太大压力</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">policy := grpcutil.RetryThrottlingPolicy&#123;</span><br><span class="line">    MaxTokens:    <span class="number">10</span>,            <span class="comment">// 最大令牌数</span></span><br><span class="line">    TokenRate:    <span class="number">1</span>,             <span class="comment">// 每秒产生的令牌数</span></span><br><span class="line">    RetryBudget:  <span class="number">100</span> * time.Millisecond, <span class="comment">// 重试预算</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 DialOption，使用上面的 RetryThrottlingPolicy</span></span><br><span class="line">dialOption := grpc.WithRetryThrottlingPolicy(policy)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 dialOption 创建 gRPC 客户端</span></span><br></pre></td></tr></table></figure><ul><li><code>MaxTokens</code>：最大令牌数，任何时间点同时允许的最大令牌数</li><li><code>TokenRate</code>：每秒产生的令牌数，每个请求都会消耗一个令牌</li><li><code>RetryBudget</code>：重试预算，制定重试操作可以使用的总时间，如果一个请求需要重试，但是时间已经超过了 <code>RetryBudget</code>，那么不在进行重试</li></ul><h4 id="限速原理"><a class="markdownIt-Anchor" href="#限速原理"></a> 限速原理</h4><p>第一步：初始化速率配置</p><p>结构体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> retryThrottler <span class="keyword">struct</span> &#123;</span><br><span class="line">max    <span class="keyword">float64</span><span class="comment">//最大令牌数</span></span><br><span class="line">thresh <span class="keyword">float64</span><span class="comment">//预算</span></span><br><span class="line">  ratio  <span class="keyword">float64</span><span class="comment">//每秒令牌数</span></span><br><span class="line"></span><br><span class="line">mu     sync.Mutex</span><br><span class="line">tokens <span class="keyword">float64</span> <span class="comment">//可用令牌数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换规则</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cc.sc.retryThrottling != <span class="literal">nil</span> &#123;</span><br><span class="line">   newThrottler := &amp;retryThrottler&#123;</span><br><span class="line">      tokens: cc.sc.retryThrottling.MaxTokens,</span><br><span class="line">      max:    cc.sc.retryThrottling.MaxTokens,</span><br><span class="line">      thresh: cc.sc.retryThrottling.MaxTokens / <span class="number">2</span>,</span><br><span class="line">      ratio:  cc.sc.retryThrottling.TokenRatio,</span><br><span class="line">   &#125;</span><br><span class="line">   cc.retryThrottler.Store(newThrottler)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   cc.retryThrottler.Store((*retryThrottler)(<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：计算是否进行限速</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rt *retryThrottler)</span> <span class="title">throttle</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> rt == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">rt.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rt.mu.Unlock()</span><br><span class="line">rt.tokens--</span><br><span class="line"><span class="keyword">if</span> rt.tokens &lt; <span class="number">0</span> &#123;</span><br><span class="line">rt.tokens = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rt.tokens &lt;= rt.thresh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：成功调用则更新可用 <code>tokens</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rt *retryThrottler)</span> <span class="title">successfulRPC</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> rt == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">rt.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rt.mu.Unlock()</span><br><span class="line">rt.tokens += rt.ratio</span><br><span class="line"><span class="keyword">if</span> rt.tokens &gt; rt.max &#123;</span><br><span class="line">rt.tokens = rt.max</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是：一个流中只有只有成功调用的时候才会将增加可用 <code>token</code> 数量</p><h3 id="业务重试"><a class="markdownIt-Anchor" href="#业务重试"></a> 业务重试</h3><p>业务重试一般直接使用重试封装逻辑(已新建流为例)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">op := <span class="function"><span class="keyword">func</span><span class="params">(a *csAttempt)</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> a.newStream() &#125;</span><br><span class="line"><span class="keyword">if</span> err := cs.withRetry(op, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; cs.bufferForRetryLocked(<span class="number">0</span>, op) &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">   cs.finish(err)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部逻辑如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *clientStream)</span> <span class="title">withRetry</span><span class="params">(op <span class="keyword">func</span>(a *csAttempt)</span> <span class="title">error</span>, <span class="title">onSuccess</span> <span class="title">func</span><span class="params">()</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">   cs.mu.Lock()<span class="comment">//获取流的写锁，防止在重试过程又出现新的重试</span></span><br><span class="line">  <span class="keyword">for</span> &#123;<span class="comment">//使用for循环不断尝试</span></span><br><span class="line">      <span class="keyword">if</span> cs.committed &#123;<span class="comment">//流不在发送任何东西</span></span><br><span class="line">         cs.mu.Unlock()</span><br><span class="line">         <span class="keyword">return</span> toRPCErr(op(cs.attempt))</span><br><span class="line">      &#125;</span><br><span class="line">      a := cs.attempt</span><br><span class="line">      cs.mu.Unlock()</span><br><span class="line">      err := op(a)<span class="comment">//执行操作</span></span><br><span class="line">      cs.mu.Lock()</span><br><span class="line">      <span class="keyword">if</span> a != cs.attempt &#123;<span class="comment">//如果重试对象已经变更，则直接跳过继续下一次操作</span></span><br><span class="line">         <span class="comment">// We started another attempt already.</span></span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> err == io.EOF &#123; </span><br><span class="line">         &lt;-a.s.Done()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//执行成功的后续操作</span></span><br><span class="line">      <span class="keyword">if</span> err == <span class="literal">nil</span> || (err == io.EOF &amp;&amp; a.s.Status().Code() == codes.OK) &#123;</span><br><span class="line">         onSuccess()</span><br><span class="line">         cs.mu.Unlock()</span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//执行失败则尝试重试</span></span><br><span class="line">      <span class="keyword">if</span> err := cs.retryLocked(err); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         cs.mu.Unlock()</span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>committed</code>：当客户端调用 <code>CloseSend</code> 方法关闭发送流的时候，会标记 <code>ClientStream</code>为已提交，表示客户端不再发送任何消息</p><p>有个奇怪的地方如下所示，为什么不发送任何东西还要继续 <code>op</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cs.committed &#123;<span class="comment">//流不在发送任何东西</span></span><br><span class="line">   cs.mu.Unlock()</span><br><span class="line">   <span class="keyword">return</span> toRPCErr(op(cs.attempt))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因是如果是正在处理中的请求(尝试重试、取消等操作)，还是会尝试执行 <code>op</code>并返回错误结束尝试</p></li><li><p>如果在重试过程中，重试任务发生了变化，那么也会跳过直接进行下一次重试</p></li></ul><h4 id="成功"><a class="markdownIt-Anchor" href="#成功"></a> 成功</h4><p>如果执行成功，那么只需要执行后续的 <code>OnSuccess</code> 函数即可，一般有有两种</p><ul><li><p>如果是 <code>commitAttemptLocked</code>，那么表示执行成功更新状态即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *clientStream)</span> <span class="title">commitAttemptLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> !cs.committed &amp;&amp; cs.onCommit != <span class="literal">nil</span> &#123;</span><br><span class="line">      cs.onCommit() <span class="comment">//配置的重试逻辑</span></span><br><span class="line">   &#125;</span><br><span class="line">   cs.committed = <span class="literal">true</span><span class="comment">//重试逻辑执行成功</span></span><br><span class="line">   cs.buffer = <span class="literal">nil</span><span class="comment">//清空这个重试缓存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果是 <code>bufferForRetryLocked</code>，那么会缓存当前的重试操作到回放缓冲区(后续发生失败的时候再执行一次)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *clientStream)</span> <span class="title">bufferForRetryLocked</span><span class="params">(sz <span class="keyword">int</span>, op <span class="keyword">func</span>(a *csAttempt)</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">   <span class="comment">// Note: we still will buffer if retry is disabled (for transparent retries).</span></span><br><span class="line">   <span class="keyword">if</span> cs.committed &#123;<span class="comment">//如果重试逻辑执行成功结束</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   cs.bufferSize += sz</span><br><span class="line">   <span class="keyword">if</span> cs.bufferSize &gt; cs.callInfo.maxRetryRPCBufferSize &#123;<span class="comment">//回放缓冲区太大就不回放了</span></span><br><span class="line">      cs.commitAttemptLocked()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   cs.buffer = <span class="built_in">append</span>(cs.buffer, op) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="失败"><a class="markdownIt-Anchor" href="#失败"></a> 失败</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *clientStream)</span> <span class="title">retryLocked</span><span class="params">(lastErr error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      cs.attempt.finish(toRPCErr(lastErr))</span><br><span class="line">      isTransparent, err := cs.shouldRetry(lastErr)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         cs.commitAttemptLocked()</span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line">      cs.firstAttempt = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">if</span> err := cs.newAttemptLocked(isTransparent); err != <span class="literal">nil</span> &#123;<span class="comment">//创建一个新attemp</span></span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> lastErr = cs.replayBufferLocked(); lastErr == <span class="literal">nil</span> &#123;<span class="comment">//回放缓冲区，</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先，当前的尝试 <code>cs.attempt</code> 将被标记为已完成，其结果会被传递给 <code>cs.finish()</code></li><li>然后，会调用 <code>cs.shouldRetry()</code> 判断当前错误是否应该重试(服务端错误 <code>DoNotTransparentRetry</code> )<ul><li>如果返回的错误可以重试，则会通过 <code>cs.newAttemptLocked()</code> 创建新的尝试，即新的流，并在其上发起新的请求</li><li>如果没有返回新的错误，则尝试从回放缓冲区 <code>cs.replayBufferLocked()</code> 中获取上一次重试的错误</li></ul></li><li>如果在回放缓冲区中找到了错误，继续进行下一次重试，否则返回 nil 表示重试成功</li></ol><p>前面提到了，有一种成功即使执行成功也会加入到 buffer中，在执行失败的之后重新再执行一遍</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *clientStream)</span> <span class="title">replayBufferLocked</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   a := cs.attempt</span><br><span class="line">   <span class="keyword">for</span> _, f := <span class="keyword">range</span> cs.buffer &#123;</span><br><span class="line">      <span class="keyword">if</span> err := f(a); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是在构建流的时候加入的，如果构建流成功，那么会将构建流的函数加入到<code>buffer</code>，如果后续有一次临时性的失败，会将所有成功的构建流全部执行一遍。<strong>为什么其中一个创建流失败之后，需要将其他创建成功的逻辑都进行重试？</strong></p><p>答：如果一次失败了，那么执行之前的操作。前提是能够保证和之前成功的那次执行得到相同的结果。这里创建流与发送消息都会将成功的操作放入到缓冲区中，当消息发送完毕，那么这个流就结束了。所以在发送过程中，如果其中一个帧发送失败，那么它会将从流构建到消息发送再次传输一遍(相当于一个新的请求)</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>重试机制 <code>withRetry</code> 包含的业务<ul><li>建立流链接</li><li>发送头帧</li><li>发送消息</li><li>接收消息</li><li>关闭发送</li></ul></li><li>服务端响应的时候并没有重试机制</li><li>重试速率限制是针对整个连接而不是每个流一个</li><li>同时执行一个重试任务，并且执行的都是最新的那个</li><li>只有重试成功，才会更新令牌<code>tokens</code>数量。那是不是影响其他调用的重试，会但影响不大。第一是因为只要有一个成功，那么token数量都会更新。第二是重试次数过多，单次调用会因为超时停止重试。</li><li>如果在发送过程中，某一个帧发送失败，那么它会从创建流开始重新发起调用</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://blog.csdn.net/u011582922/article/details/120578941" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/120578941</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;重试机制是为了在短暂异常情况下能够正常恢复，也能防止长时间异常而不退出。这里看一下grpc-go 中的重试机制以及使用方法&lt;/p&gt;
&lt;p&gt;带着问题看世界：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;grpc-go 的重试策略的使用&lt;/li&gt;
&lt;li&gt;grpc-go 的重试机制是怎样的&lt;/l
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-08-超时处理</title>
    <link href="http://xboom.github.io/2022/10/17/Grpc/Grpc-08-%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86/"/>
    <id>http://xboom.github.io/2022/10/17/Grpc/Grpc-08-%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86/</id>
    <published>2022-10-17T14:58:29.000Z</published>
    <updated>2023-05-27T10:55:27.452Z</updated>
    
    <content type="html"><![CDATA[<p><code>grpc-go</code> 通信的超时处理有两种方式</p><ol><li>业务出现异常或判断处理超时主动取消</li><li><code>grpc-go</code> 存在截止时间，超过截止时间自动停止</li></ol><p>带着问题看世界</p><ol><li>取消发生在不同时机是如何处理的<ul><li>链路建立阶段</li><li>客户端发送阶段</li><li>请求传输阶段</li><li>服务端处理阶段</li><li>消息响应阶段</li></ul></li><li>截止时间又是如何做到的<ul><li>服务端是如何在截止时间停止的</li></ul></li></ol><h3 id="主动取消"><a class="markdownIt-Anchor" href="#主动取消"></a> 主动取消</h3><h4 id="基本使用"><a class="markdownIt-Anchor" href="#基本使用"></a> 基本使用</h4><p>客户端使用<code>context</code>并创建双向流，发送两条之后取消再次发送消息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">10</span>*time.Second)</span><br><span class="line">stream, err := c.BidirectionalStreamingEcho(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatalf(<span class="string">"error creating stream: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send some test messages.</span></span><br><span class="line"><span class="keyword">if</span> err := sendMessage(stream, <span class="string">"hello"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatalf(<span class="string">"error sending on stream: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := sendMessage(stream, <span class="string">"world"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatalf(<span class="string">"error sending on stream: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ensure the RPC is working.</span></span><br><span class="line">recvMessage(stream, codes.OK)</span><br><span class="line">recvMessage(stream, codes.OK)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"cancelling context"</span>)</span><br><span class="line">cancel()</span><br><span class="line"></span><br><span class="line"><span class="comment">//失败</span></span><br><span class="line">sendMessage(stream, <span class="string">"closed"</span>)</span><br></pre></td></tr></table></figure><p>服务端则是响应流的处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">BidirectionalStreamingEcho</span><span class="params">(stream pb.Echo_BidirectionalStreamingEchoServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">in, err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"server: error receiving from stream: %v\n"</span>, err)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"echoing message %q\n"</span>, in.Message)</span><br><span class="line">stream.Send(&amp;pb.EchoResponse&#123;Message: in.Message&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h4><h5 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h5><p>从调用方法的内部实现，超时控制大致分为三个阶段 构建流阶段、发送消息阶段、接收消息阶段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(ctx context.Context, method <span class="keyword">string</span>, req, reply <span class="keyword">interface</span>&#123;&#125;, cc *ClientConn, opts ...CallOption)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   cs, err := newClientStream(ctx, unaryStreamDesc, cc, method, opts...)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err := cs.SendMsg(req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> cs.RecvMsg(reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据实际情况将通过一下几个阶段进行分析</p><ul><li><p>构建流阶段</p></li><li><p>客户端发送阶段</p></li><li><p>请求传输阶段</p></li><li><p>服务端处理阶段</p></li><li><p>消息响应阶段</p></li></ul><h6 id="构建流"><a class="markdownIt-Anchor" href="#构建流"></a> 构建流</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newClientStreamWithParams</span><span class="params">(ctx context.Context, desc *StreamDesc, cc *ClientConn, method <span class="keyword">string</span>, mc serviceconfig.MethodConfig, onCommit, doneFunc <span class="keyword">func</span>()</span>, <span class="title">opts</span> ...<span class="title">CallOption</span>) <span class="params">(_ iresolver.ClientStream, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  <span class="keyword">var</span> cancel context.CancelFunc</span><br><span class="line">  <span class="keyword">if</span> mc.Timeout != <span class="literal">nil</span> &amp;&amp; *mc.Timeout &gt;= <span class="number">0</span> &#123;</span><br><span class="line">     ctx, cancel = context.WithTimeout(ctx, *mc.Timeout)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     ctx, cancel = context.WithCancel(ctx)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        cancel()</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//如果一元调用</span></span><br><span class="line">  <span class="keyword">if</span> desc != unaryStreamDesc &#123; <span class="comment">//var unaryStreamDesc = &amp;StreamDesc&#123;ServerStreams: false, ClientStreams: false&#125;</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="comment">//使用协程来清理结束时候的流</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-cc.ctx.Done():</span><br><span class="line">cs.finish(ErrClientConnClosing)</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">cs.finish(toRPCErr(ctx.Err()))</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果配置了超时时间则使用超时时间，否则默认ctx，这个超时时间以前是为了针对 <code>WithTimeout</code>，后来被 <code>DialContext</code>替代</p><p>接着，将超时时间封装到一个流的头帧的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *http2Client)</span> <span class="title">NewStream</span><span class="params">(ctx context.Context, callHdr *CallHdr)</span> <span class="params">(_ *Stream, err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//解析成头帧的KV字段</span></span><br><span class="line">  ctx = peer.NewContext(ctx, t.getPeer())</span><br><span class="line">headerFields, err := t.createHeaderFields(ctx, callHdr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">s := t.newStream(ctx, callHdr)</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//封装到头帧中</span></span><br><span class="line">  hdr := &amp;headerFrame&#123;</span><br><span class="line">hf:        headerFields,</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">//发送头帧</span></span><br><span class="line">success, err := t.controlBuf.executeAndPut(<span class="function"><span class="keyword">func</span><span class="params">(it <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !checkForStreamQuota(it) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !checkForHeaderListSize(it) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;, hdr)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ch:<span class="comment">//配额没有了</span></span><br><span class="line"><span class="keyword">case</span> &lt;-s.ctx.Done():<span class="comment">//流结束</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ContextErr(s.ctx.Err())</span><br><span class="line"><span class="keyword">case</span> &lt;-t.goAway:<span class="comment">//返回关闭流的帧</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errStreamDrain</span><br><span class="line"><span class="keyword">case</span> &lt;-t.ctx.Done():<span class="comment">//连接结束</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrConnClosing</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建流的过程中，只发送到队列中，那么流就算发送成功，</p><p>所以在构建流的过程中，如果触发 <code>context.Done()</code>，那么</p><ol><li>首先会返回 <code>context</code>中的错误</li><li>其次更新状态流的状态</li></ol><h5 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h5><h4 id="原理分析"><a class="markdownIt-Anchor" href="#原理分析"></a> 原理分析</h4><p>客户端向服务端请求的一个完整阶段，需要经历：</p><ol><li>链路建立阶段</li><li>流建立阶段</li><li>数据发送阶段</li><li>数据接收阶段</li></ol><p>在创建完客户端流<code>clientStream</code>后，取消功能以异步方式启动，开始监听是否有取消指令，有的话，就开始执行取消指令。因此，取消功能可以发生在数据发送阶段和数据接收阶段，且两个阶段的流程是一样的</p><ol><li>取消是流级别的而不是链路级别的，也就是可以用于取消单个请求</li><li>当客户端主动发起 cancel请求的时候 会构建 <code>cleanupStream</code>的请求关闭流，并发送RST帧，将流ID，取消状态码封装到RST帧中，发送给服务端</li><li>服务端收到<code>RST</code>帧之后，会停止读取 stream 中的数据，并移除对应的流</li></ol><h3 id="截止时间"><a class="markdownIt-Anchor" href="#截止时间"></a> 截止时间</h3><p>截止时间与cancel函数的原理类似，主动取消是通过</p><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://blog.csdn.net/u011582922/article/details/119834758" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/119834758</a></li><li><a href="https://blog.csdn.net/u011582922/article/details/119944259" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/119944259</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;grpc-go&lt;/code&gt; 通信的超时处理有两种方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;业务出现异常或判断处理超时主动取消&lt;/li&gt;
&lt;li&gt;&lt;code&gt;grpc-go&lt;/code&gt; 存在截止时间，超过截止时间自动停止&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;带着问题看世界&lt;/p
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-07-滑动窗口</title>
    <link href="http://xboom.github.io/2022/10/15/Grpc/Grpc-07-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://xboom.github.io/2022/10/15/Grpc/Grpc-07-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2022-10-15T14:58:29.000Z</published>
    <updated>2023-05-27T10:55:20.349Z</updated>
    
    <content type="html"><![CDATA[<p>回顾一下 tcp 的滑动窗口</p><p>那么这一章需要解决的问题是：</p><ol><li>tcp 有了滑动窗口为什么 grpc-go又需要滑动窗口，它们两者有什么区分，为什么两者都需要用到滑动窗口</li><li>grpc-go 的滑动窗口原理是什么</li><li>grpc-go 的滑动窗口是如何实现的</li></ol><p>滑动窗口的目的是，计算出下次发送数据帧的最大字节数</p><ul><li><p>客户端的帧发送器在发送数据帧时存在一些发送指标，服务器端在接收数据帧的不同阶段，也存在一些指标</p><ul><li>发送指标是如何定义的 TODO?</li></ul></li><li><p>服务器在接收数据帧时，会根据自己的接收数据帧、存储数据帧、读取数据帧的速度，向客户端发送窗口更新帧或者设置帧；</p><ul><li>计算原理是什么 ？ 窗口更新帧与设置帧的区别？ TODO</li></ul></li><li><p>客户端接收到服务器端发送过来的设置帧或者窗口更新帧后，会更新本地的发送指标</p></li><li><p>发送指标的更新，会影响到客户端下次发送数据帧的最大字节数</p></li><li><p>最大字节数的计算，服务器端会通过发送窗口更新帧或者设置帧来动态的影响客户端计算数据帧大小的参数，从而影响下次发送的最大字节数</p></li></ul><p>每个链接、每个流、每个客户端的指标都是如何定义的？ TODO</p><h3 id="滑动窗口原理"><a class="markdownIt-Anchor" href="#滑动窗口原理"></a> 滑动窗口原理</h3><p><img src="https://img-blog.csdnimg.cn/20210626180317624.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE1ODI5MjI=,size_16,color_FFFFFF,t_70#pic_center" alt="gRPC-go滑动窗口整体处理流程" /></p><h4 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h4><ul><li>构建好数据帧<code>dataFrame</code></li><li>通过发送参数指标，计算本次发送的最大字节数<em>maxSize</em>；</li><li>数据帧截取器，从数据帧里截取指定的字节数<em>maxSize</em>，交由帧发送器</li><li>帧发送器将截取的字节，转换成http2原生的帧，发送给服务器端</li></ul><h4 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h4><ul><li>帧接收器接收到数据帧，交由帧分发器处理</li><li>帧分发器根据帧的类型，交由数据处理器handleData处理，数据处理器handleData：<ul><li>抽样级别流控：对本地的接收参数进行更新(如b.sampelCount,b.sample,b.bwMax,b.bdp)，触发阈值条件后，会向客户端发送窗口更新帧outgoingWindowUpdate，其中设置streamID=0，或者发送设置帧outgoingSettings</li><li>链接级别流控：对本地的接收参数进行更新(如f.unacked,f.limit)，触发阈值条件后，会向客户端发送窗口更新帧outgoingWindowUpdate，其中设置streamID=0</li><li>流级别流控：对本地的接收参数进行更新(如f.pendingData,f.pendingUpdate,f.limit,f.delta)，触发阈值条件后，会向客户端发送窗口更新帧outgoingWindowUpdate，其中设置streamID=0</li><li>将数据帧存储到go语言原生自带的缓存bytes.Buffer里</li><li>构建recvMsg结构体，将bytes.Buffer存储到recvMsg里；（recvMsg就是对bytes.Buffer封装）</li><li>将recvMsg存储到recvBuffer里：存储逻辑是<ul><li>i.若recvMsg类型的通道里，没有数据的话，就直接将recvMsg存储到该通道里</li><li>ii.若recvMsg类型的通道里，已经有数据了的话，就将recvMsg添加到类型为recvMsg的切片的尾部</li></ul></li></ul></li><li>接收数据并解压recvAndDecompress：<ul><li>a)读取数据前，先对本地的窗口参数进行调整，如f.delta;满足触发阈值条件的话，就向客户端发送窗口更新帧outgoingWindowUpdate，其中streamID非0；</li><li>b)recvBufer读取器：<br />i.从recvBuffer的通道里获取数据recvMsg<br />ii.数据获取到后，recvBuffer缓存中，将切片的第一个数据，加载到通道里；(因为通道里刚才已经消费了数据，需要重新添加上)<br />iii.从recvMsg里获取到bytes.Buffer对象<br />iv.将bytes.Buffer里的数据读取到字节切片里<br />c)读取完成数据后，更新流级别参数，如f.pendingData,f.pendingUpdate若满足触发阈值条件的话，就向客户端发送窗口更新帧outgoingWindowUpdate，其中streamID非0；<br />d)对切片里的数据进行解压，对解压后的数据，交由handle方法<br />e)handle方法：就是grpc服务器内部，真正执行客户端请求的方法入口<br />i.对解压后的数据，进行反序列化，得到请求方法的具体参数值<br />ii.真正的执行客户端的请求方法，得到执行结果<br />f)将执行结果封装到数据帧里，存储到controlBuf缓存里<br />g)帧发送器，从帧缓存里获取到数据帧，发送给客户端</li></ul></li></ul><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://blog.csdn.net/u011582922/article/details/118887625" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/118887625</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;回顾一下 tcp 的滑动窗口&lt;/p&gt;
&lt;p&gt;那么这一章需要解决的问题是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;tcp 有了滑动窗口为什么 grpc-go又需要滑动窗口，它们两者有什么区分，为什么两者都需要用到滑动窗口&lt;/li&gt;
&lt;li&gt;grpc-go 的滑动窗口原理是什么&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Go入门19-Fuzzing</title>
    <link href="http://xboom.github.io/2022/10/14/Go/Go%E5%85%A5%E9%97%A819-Fuzzing/"/>
    <id>http://xboom.github.io/2022/10/14/Go/Go%E5%85%A5%E9%97%A819-Fuzzing/</id>
    <published>2022-10-14T15:31:50.000Z</published>
    <updated>2023-04-05T04:17:29.273Z</updated>
    
    <content type="html"><![CDATA[<p>Golang在1.18引入的第三个特性就是 Fuzzing 模糊测试：构造随机数据来找出代码里的漏洞或者可能导致程序崩溃的输入。</p><p>单元测试有局限性，每个测试输入必须由开发者指定加到单元测试的测试用例里。fuzzing的优点之一是可以基于开发者代码里指定的测试输入作为基础数据，进一步自动生成新的随机测试数据，用来发现指定测试输入没有覆盖到的边界情况。</p><p>通过fuzzing可以找出的漏洞包括SQL注入、缓冲区溢出、拒绝服务(Denial of Service)攻击和XSS(cross-site scripting)攻击等</p><p>这里通过编写反转字符串函数通过 <code>fuzz test</code> 来发现并修改问题</p><h3 id="第一步实现基本功能"><a class="markdownIt-Anchor" href="#第一步实现基本功能"></a> 第一步：实现基本功能</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">b := []<span class="keyword">byte</span>(s)</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(b)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(b)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">b[i], b[j] = b[j], b[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">input := <span class="string">"The quick brown fox jumped over the lazy dog"</span></span><br><span class="line">rev := Reverse(input)</span><br><span class="line">doubleRev := Reverse(rev)</span><br><span class="line">fmt.Printf(<span class="string">"original: %q\n"</span>, input)</span><br><span class="line">fmt.Printf(<span class="string">"reversed: %q\n"</span>, rev)</span><br><span class="line">fmt.Printf(<span class="string">"reversed again: %q\n"</span>, doubleRev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果是</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">original: <span class="string">"The quick brown fox jumped over the lazy dog"</span></span><br><span class="line">reversed: <span class="string">"god yzal eht revo depmuj xof nworb kciuq ehT"</span></span><br><span class="line">reversed again: <span class="string">"The quick brown fox jumped over the lazy dog"</span></span><br></pre></td></tr></table></figure><h3 id="第二步编写单元测试"><a class="markdownIt-Anchor" href="#第二步编写单元测试"></a> 第二步：编写单元测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func TestReverse(t *testing.T) &#123;</span><br><span class="line">testcases :&#x3D; []struct &#123;</span><br><span class="line">in, want string</span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;&quot;Hello, world&quot;, &quot;dlrow ,olleH&quot;&#125;,</span><br><span class="line">&#123;&quot; &quot;, &quot; &quot;&#125;,</span><br><span class="line">&#123;&quot;!12345&quot;, &quot;54321!&quot;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">for _, tc :&#x3D; range testcases &#123;</span><br><span class="line">rev :&#x3D; Reverse(tc.in)</span><br><span class="line">if rev !&#x3D; tc.want &#123;</span><br><span class="line">t.Errorf(&quot;Reverse: %q, want %q&quot;, rev, tc.want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行单元测试发现，一切正常</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ok      example/fuzz    0.003s</span><br></pre></td></tr></table></figure><h3 id="第三步添加模糊测试"><a class="markdownIt-Anchor" href="#第三步添加模糊测试"></a> 第三步：添加模糊测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuzzReverse</span><span class="params">(f *testing.F)</span></span> &#123;</span><br><span class="line">testcases := []<span class="keyword">string</span>&#123;<span class="string">"Hello, world"</span>, <span class="string">" "</span>, <span class="string">"!12345"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, tc := <span class="keyword">range</span> testcases &#123;</span><br><span class="line">f.Add(tc) <span class="comment">// Use f.Add to provide a seed corpus</span></span><br><span class="line">&#125;</span><br><span class="line">f.Fuzz(<span class="function"><span class="keyword">func</span><span class="params">(t *testing.T, orig <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">rev := Reverse(orig)</span><br><span class="line">doubleRev := Reverse(rev)</span><br><span class="line">    <span class="comment">//这一行是为了解释后面的错误加的，暂时可以忽略</span></span><br><span class="line">    t.Logf(<span class="string">"Number of runes: orig=%d, rev=%d, doubleRev=%d"</span>, utf8.RuneCountInString(orig), utf8.RuneCountInString(rev), utf8.RuneCountInString(doubleRev))</span><br><span class="line"><span class="keyword">if</span> orig != doubleRev &#123;</span><br><span class="line">t.Errorf(<span class="string">"Before: %q, after: %q"</span>, orig, doubleRev)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> utf8.ValidString(orig) &amp;&amp; !utf8.ValidString(rev) &#123;</span><br><span class="line">t.Errorf(<span class="string">"Reverse produced invalid UTF-8 string %q"</span>, rev)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：</p><ol><li><code>Reverse</code>函数如果是一个错误的版本(直接return返回输入的字符串)，虽然可以通过上面的模糊测试，但没法通过第二步的单元测试，所以模糊测试与单元测试是互补的关系</li><li><code>go test</code> <strong>只会使用种子语料库，而不会生成随机测试数据</strong>。通过这种方式可以用来验证种子语料库的测试数据是否可以测试通过</li><li>如果<code>reverse_test.go</code>文件里有其它单元测试函数或者模糊测试函数，但只想运行<code>FuzzReverse</code>模糊测试函数，我们可以执行<code>go test -run=FuzzReverse</code>命令</li><li>如果要基于种子语料库生成随机测试数据用于模糊测试，需要给<code>go test</code>命令增加<code>-fuzz</code>参数</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@13ce5bc74ac3:/code/fuzz# go test -fuzz .</span><br><span class="line">fuzz: elapsed: 0s, gathering baseline coverage: 0/7 completed</span><br><span class="line">fuzz: elapsed: 0s, gathering baseline coverage: 7/7 completed, now fuzzing with 2 workers</span><br><span class="line">fuzz: elapsed: 0s, execs: 648 (17784/sec), new interesting: 1 (total: 8)</span><br><span class="line">--- FAIL: FuzzReverse (0.04s)</span><br><span class="line">    --- FAIL: FuzzReverse (0.00s)</span><br><span class="line">    hello_test.go:32: Number of runes: orig=1, rev=2, doubleRev=1</span><br><span class="line">        hello_test.go:36: Reverse produced invalid UTF-8 string "\x9e\xdb"</span><br><span class="line">    </span><br><span class="line">    Failing input written to testdata/fuzz/FuzzReverse/d6a654c77ca8db001e0bbe2cbb5493efcd20e17777911523bf59bd30bd33e199</span><br><span class="line">    To re-run:</span><br><span class="line">    go test -run=FuzzReverse/d6a654c77ca8db001e0bbe2cbb5493efcd20e17777911523bf59bd30bd33e199</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    example/fuzz    0.048s</span><br></pre></td></tr></table></figure><ol start="5"><li><p>运行之后会生成testdata的文件夹，那么下次即使没有带上 <code>-fuzz</code> 参数，也会使用该数据进行模糊测试</p><p>路径：<code>./testdata/fuzz/FuzzReverse/d6a654c77ca8db001e0bbe2cbb5493efcd20e17777911523bf59bd30bd33e199</code>，内容是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> test fuzz v1  <span class="comment">//语料库文件里的第1行标识的是编码版本</span></span><br><span class="line"><span class="keyword">string</span>(<span class="string">"۞"</span>)</span><br></pre></td></tr></table></figure><p>从第2行开始，每一行数据对应的是语料库的每条测试数据(corpus entry)的其中一个参数，按照参数先后顺序排列，因为fuzz target函数<code>func(t *testing.T, orig string)</code>只有<code>orig</code>这1个参数作为真正的测试输入，也就是每条测试数据其实就1个输入，因此在上面示例的<code>testdata/fuzz/FuzzReverse</code>目录下的文件里只有string(“۞”)这一行</p></li></ol><h3 id="第四步修复bug"><a class="markdownIt-Anchor" href="#第四步修复bug"></a> 第四步：修复Bug</h3><p>模糊测试中得出的错误为 <code>Reverse produced invalid UTF-8 string &quot;\x9e\xdb&quot;</code></p><p><code>Reverse</code>函数是按照字节(byte)为维度进行字符串反转，这就是问题所在。比如字符<code>string(&quot;۞&quot;)</code> 如果按照字节反转，反转后得到的就是一个无效的字符串了。因此为了保证字符串反转后得到的仍然是一个有效的UTF-8编码的字符串，需要按照<code>rune</code>进行字符串反转。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    r := []<span class="keyword">rune</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(r)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(r)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        r[i], r[j] = r[j], r[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 <code>go test</code> 命令单元测试通过，表示老的数据能够正常的处理，但是如果再次执行 <code>go test -fuzz</code> 会出现新的错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@<span class="number">13</span>ce5bc74ac3:/code/fuzz# <span class="keyword">go</span> test -fuzz .</span><br><span class="line">fuzz: elapsed: <span class="number">0</span>s, gathering baseline coverage: <span class="number">0</span>/<span class="number">9</span> completed</span><br><span class="line">fuzz: minimizing <span class="number">38</span>-<span class="keyword">byte</span> failing input file</span><br><span class="line">fuzz: elapsed: <span class="number">0</span>s, gathering baseline coverage: <span class="number">4</span>/<span class="number">9</span> completed</span><br><span class="line">--- FAIL: FuzzReverse (<span class="number">0.01</span>s)</span><br><span class="line">    --- FAIL: FuzzReverse (<span class="number">0.00</span>s)</span><br><span class="line">        hello_test.<span class="keyword">go</span>:<span class="number">34</span>: Before: <span class="string">"\xe5"</span>, after: <span class="string">"�"</span></span><br><span class="line">    </span><br><span class="line">    Failing input written to testdata/fuzz/FuzzReverse/<span class="number">91862839</span>dc552bd95b4e42be6576a6c198f0d4c8fc2884c953030d898573b014</span><br><span class="line">    To re-run:</span><br><span class="line">    <span class="keyword">go</span> test -run=FuzzReverse/<span class="number">91862839</span>dc552bd95b4e42be6576a6c198f0d4c8fc2884c953030d898573b014</span><br><span class="line">FAIL</span><br><span class="line">exit status <span class="number">1</span></span><br><span class="line">FAIL    example/fuzz    <span class="number">0.011</span>s</span><br></pre></td></tr></table></figure><p>结构就是对一个字符串做了2次反转后得到的和原字符串不一样，这次测试输入本身是非法的unicode</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !utf8.ValidString(s) &#123;<span class="comment">//判断是否是合法的 utf-8编码</span></span><br><span class="line">        <span class="keyword">return</span> s, errors.New(<span class="string">"input is not valid UTF-8"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    r := []<span class="keyword">rune</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(r)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(r)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        r[i], r[j] = r[j], r[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(r), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改对应的引用和单元测试后，通过测试</p><h3 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h3><p>Go模糊测试和单元测试在语法上有如下差异：</p><ol><li>Go模糊测试函数以<code>FuzzXxx</code>开头，单元测试函数以<code>TestXxx</code>开头</li><li>Go模糊测试函数以 <code>*testing.F</code>作为入参，单元测试函数以<code>*testing.T</code>作为入参</li><li>Go模糊测试会调用<code>f.Add</code>函数和<code>f.Fuzz</code>函数。<ul><li><code>f.Add</code>函数把指定输入作为模糊测试的种子语料库(seed corpus)，fuzzing基于种子语料库生成随机输入。</li><li><code>f.Fuzz</code>函数接收一个fuzz target函数作为入参。fuzz target函数有多个参数，第一个参数是<code>*testing.T</code>，其它参数是被模糊的类型(<strong>注意</strong>：被模糊的类型目前只支持部分内置类型,<ul><li><code>string</code>, <code>[]byte</code></li><li><code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>/<code>rune</code>, <code>int64</code></li><li><code>uint</code>, <code>uint8</code>/<code>byte</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code></li><li><code>float32</code>, <code>float64</code></li><li><code>bool</code></li></ul></li></ul></li></ol><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><ol><li><a href="https://go.dev/doc/tutorial/fuzz" target="_blank" rel="noopener">https://go.dev/doc/tutorial/fuzz</a></li><li><a href="https://segmentfault.com/a/1190000041650681" target="_blank" rel="noopener">https://segmentfault.com/a/1190000041650681</a></li><li><a href="https://segmentfault.com/a/1190000041467510" target="_blank" rel="noopener">https://segmentfault.com/a/1190000041467510</a></li><li><a href="https://go.googlesource.com/proposal/+/master/design/draft-fuzzing.md" target="_blank" rel="noopener">https://go.googlesource.com/proposal/+/master/design/draft-fuzzing.md</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Golang在1.18引入的第三个特性就是 Fuzzing 模糊测试：构造随机数据来找出代码里的漏洞或者可能导致程序崩溃的输入。&lt;/p&gt;
&lt;p&gt;单元测试有局限性，每个测试输入必须由开发者指定加到单元测试的测试用例里。fuzzing的优点之一是可以基于开发者代码里指定的测试输
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xboom.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://xboom.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-06-多路复用</title>
    <link href="http://xboom.github.io/2022/10/13/Grpc/Grpc-06-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>http://xboom.github.io/2022/10/13/Grpc/Grpc-06-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</id>
    <published>2022-10-13T14:58:29.000Z</published>
    <updated>2023-05-27T10:55:14.892Z</updated>
    
    <content type="html"><![CDATA[<p>多路复用是 HTTP/2中的重要特性，允许同一个TCP连接上同时传输多个HTTP请求和响应</p><p>带着问题看世界：</p><ol><li>通过《帧发送器》可知帧是一个一个进行消息发送，多个流的帧如何发送</li><li>服务端是如何区分不同的流的帧</li><li>帧太大一定会进行分包，最大是多少，服务端如何存储分包的帧，保证它的顺序</li><li>服务端如何从分包的数据帧的恢复数据</li></ol><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE1ODI5MjI=,size_16,color_FFFFFF,t_70-20230411222936879.png" alt="在这里插入图片描述" style="zoom:20%;" /><h3 id="发送端"><a class="markdownIt-Anchor" href="#发送端"></a> 发送端</h3><p>多路复用从 《帧接收器》说起，一个请求入上图所示，由头帧跟多个数据帧组成，现在直接看数据帧的发送逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">it, err := l.cbuf.get(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = l.handle(it); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, err = l.processData(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是从发送缓冲区获取数据进行发送，一共分为三步</p><ol><li><p>从缓冲区获取帧(这里的帧是应用帧中的数据帧 <code>dataFrame</code>)</p></li><li><p>将帧进行流的处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *loopyWriter)</span> <span class="title">preprocessData</span><span class="params">(df *dataFrame)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   str, ok := l.estdStreams[df.streamID]</span><br><span class="line">   <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// If we got data for a stream it means that</span></span><br><span class="line">   <span class="comment">// stream was originated and the headers were sent out.</span></span><br><span class="line">   str.itl.enqueue(df)</span><br><span class="line">   <span class="keyword">if</span> str.state == empty &#123;</span><br><span class="line">      str.state = active</span><br><span class="line">      l.activeStreams.enqueue(str)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意思就是：</p><ol><li><p>根据帧ID <strong>streamID</strong> 从 已经建立连接的流中 <code>estdStreams</code> 获取到流</p><blockquote><p>estdStreams 表示所有已建立但未被清除的流(stream)</p><p>在客户端，表示所有已发送头部信息的流</p><p>在服务端，表示所有已接收头部信息的流</p><p><code>activeStreams</code> 就表示的是已经发送或接收了头帧以及部分数据帧的流</p></blockquote></li><li><p>将帧存入到流的单向链表中</p></li><li><p>如果链表为空(表示仅仅是发送了头帧，还没有数据帧)，那么将流加入到 <code>activeStreams</code> 数据流中</p></li></ol></li><li><p>进行消息发送</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *loopyWriter)</span> <span class="title">processData</span><span class="params">()</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="comment">//1. 从数据流中拿第一个流的数据帧</span></span><br><span class="line">   str := l.activeStreams.dequeue() <span class="comment">// Remove the first stream.</span></span><br><span class="line">   <span class="keyword">if</span> str == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   dataItem := str.itl.peek().(*dataFrame)</span><br><span class="line">   <span class="comment">//dataItem 是业务数据帧，在这里讲真正分解为发送的多个数据帧 dataFrame</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(dataItem.h) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(dataItem.d) == <span class="number">0</span> &#123; <span class="comment">// 如果是空的</span></span><br><span class="line">      <span class="comment">//发送结束帧</span></span><br><span class="line">      <span class="keyword">if</span> err := l.framer.fr.WriteData(dataItem.streamID, dataItem.endStream, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//...根据流的帧后续是否仍然有数据进行处理</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> (</span><br><span class="line">      buf []<span class="keyword">byte</span></span><br><span class="line">   )</span><br><span class="line">  </span><br><span class="line">   maxSize := http2MaxFrameLen <span class="comment">//16KB</span></span><br><span class="line">   <span class="comment">//计算一个帧最大值，默认16KB</span></span><br><span class="line">   hSize := min(maxSize, <span class="built_in">len</span>(dataItem.h))<span class="comment">//头部的最大长度</span></span><br><span class="line">   dSize := min(maxSize-hSize, <span class="built_in">len</span>(dataItem.d)) <span class="comment">//负载的最大长度</span></span><br><span class="line">   <span class="comment">//... 将dataItem 部分数据写入到buf中</span></span><br><span class="line"></span><br><span class="line">   size := hSize + dSize</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">   <span class="keyword">var</span> endStream <span class="keyword">bool</span></span><br><span class="line">   <span class="comment">//是否是流的最后一帧</span></span><br><span class="line">   <span class="keyword">if</span> dataItem.endStream &amp;&amp; <span class="built_in">len</span>(dataItem.h)+<span class="built_in">len</span>(dataItem.d) &lt;= size &#123;</span><br><span class="line">      endStream = <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="keyword">if</span> err := l.framer.fr.WriteData(dataItem.streamID, endStream, buf[:size]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   str.bytesOutStanding += size</span><br><span class="line">   l.sendQuota -= <span class="keyword">uint32</span>(size)</span><br><span class="line">   dataItem.h = dataItem.h[hSize:]<span class="comment">//剩余头部长度</span></span><br><span class="line">   dataItem.d = dataItem.d[dSize:]<span class="comment">//剩余负载长度</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//如果数据为空，则从链表中删除这个数据帧</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(dataItem.h) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(dataItem.d) == <span class="number">0</span> &#123; <span class="comment">// All the data from that message was written out.</span></span><br><span class="line">      str.itl.dequeue()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果流中的数据帧为空，那么标记流为 empty</span></span><br><span class="line">   <span class="comment">//如果流中下一个为头帧，那么发送头帧并清理流</span></span><br><span class="line">   <span class="comment">//如果还有一部分数据未发送完毕，那么将剩下的帧存入 activeStreams 的链表中下次再发</span></span><br><span class="line">   <span class="comment">//...发送处理</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应代码具体步骤如下：</p><ol><li>获取第一个活动流<code>activeStream</code>(有Data)</li><li>拿到流中间的数据帧 <code>dataFrame</code> (应用帧)</li><li>如果需要发送的数据是空的，那么发送数据帧并表示结束 <code>endStream == true</code></li><li>如果有一部分没有发送完毕，那么将剩下的部分作为数据帧存入 activeStreams中下次再计算发送</li></ol></li></ol><p>总结：</p><ol><li>在发送端，由于同一个链接中多个流公用一个帧缓冲区，所以虽然是多路复用，但其实客户端所有的帧还是一个一个发送的。只是可能存在一个流的帧没有发完就会发送另一个流的帧</li><li>一个帧最大为 16KB，剩下部分会作为一个帧重新加入到帧缓冲区链表中，下一次重新计算发送</li></ol><h3 id="接收端"><a class="markdownIt-Anchor" href="#接收端"></a> 接收端</h3><p>接收端可以分为上述三个问题</p><ol><li>如何接收数据帧分帧的</li><li>如何存储数据帧分帧的</li></ol><h4 id="帧的读取"><a class="markdownIt-Anchor" href="#帧的读取"></a> 帧的读取</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fr *Framer)</span> <span class="title">ReadFrame</span><span class="params">()</span> <span class="params">(Frame, error)</span></span> &#123;</span><br><span class="line">   fr.errDetail = <span class="literal">nil</span></span><br><span class="line">   <span class="keyword">if</span> fr.lastFrame != <span class="literal">nil</span> &#123;</span><br><span class="line">      fr.lastFrame.invalidate()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//1. 利用第三方依赖，直接读取帧的头部</span></span><br><span class="line">   fh, err := readFrameHeader(fr.headerBuf[:], fr.r)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> fh.Length &gt; fr.maxReadSize &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ErrFrameTooLarge</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2. 获取负载长度并读取</span></span><br><span class="line">   payload := fr.getReadBuf(fh.Length)</span><br><span class="line">   <span class="keyword">if</span> _, err := io.ReadFull(fr.r, payload); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//根据帧的类型，将真转换为程序数据结构</span></span><br><span class="line">   f, err := typeFrameParser(fh.Type)(fr.frameCache, fh, payload)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ce, ok := err.(connError); ok &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, fr.connError(ce.Code, ce.Reason)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//检查帧的顺序</span></span><br><span class="line">   <span class="keyword">if</span> err := fr.checkFrameOrder(f); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果是头帧，还需要将其中的元数据再解析一次，最终变为 MetaHeadersFrame 帧</span></span><br><span class="line">   <span class="keyword">if</span> fh.Type == FrameHeaders &amp;&amp; fr.ReadMetaHeaders != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fr.readMetaFrame(f.(*HeadersFrame))</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> f, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="帧转换器"><a class="markdownIt-Anchor" href="#帧转换器"></a> 帧转换器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> frameParsers = <span class="keyword">map</span>[FrameType]frameParser&#123;</span><br><span class="line">   FrameData:         parseDataFrame,</span><br><span class="line">   FrameHeaders:      parseHeadersFrame,</span><br><span class="line">   FramePriority:     parsePriorityFrame,</span><br><span class="line">   FrameRSTStream:    parseRSTStreamFrame,</span><br><span class="line">   FrameSettings:     parseSettingsFrame,</span><br><span class="line">   FramePushPromise:  parsePushPromise,</span><br><span class="line">   FramePing:         parsePingFrame,</span><br><span class="line">   FrameGoAway:       parseGoAwayFrame,</span><br><span class="line">   FrameWindowUpdate: parseWindowUpdateFrame,</span><br><span class="line">   FrameContinuation: parseContinuationFrame,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typeFrameParser</span><span class="params">(t FrameType)</span> <span class="title">frameParser</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> f := frameParsers[t]; f != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> f</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> parseUnknownFrame</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据帧处理"><a class="markdownIt-Anchor" href="#数据帧处理"></a> 数据帧处理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *http2Server)</span> <span class="title">handleData</span><span class="params">(f *http2.DataFrame)</span></span> &#123;</span><br><span class="line">   size := f.Header().Length</span><br><span class="line">   <span class="comment">//...流控</span></span><br><span class="line">   <span class="comment">// Select the right stream to dispatch.</span></span><br><span class="line">   s, ok := t.getStream(f)</span><br><span class="line">   <span class="comment">//... </span></span><br><span class="line">   <span class="keyword">if</span> size &gt; <span class="number">0</span> &#123;<span class="comment">//负载大于0</span></span><br><span class="line">      <span class="comment">//... 流控</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(f.Data()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">         buffer := t.bufferPool.get()</span><br><span class="line">         buffer.Reset()</span><br><span class="line">         buffer.Write(f.Data())</span><br><span class="line">         s.write(recvMsg&#123;buffer: buffer&#125;)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//如果流结束了，</span></span><br><span class="line">   <span class="keyword">if</span> f.StreamEnded() &#123;</span><br><span class="line">      <span class="comment">// Received the end of stream from the client.</span></span><br><span class="line">      s.compareAndSwapState(streamActive, streamReadDone)</span><br><span class="line">      s.write(recvMsg&#123;err: io.EOF&#125;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li>如果是数据帧则获取流的大小以及负载</li><li>将负载封装成<code>recvMsg</code>写入到流中</li><li>如果对方告知流结束了，那么将流的状态从 <code>streamActive</code> 改为 <code>streamReadDone</code></li><li>封装帧结束消息 <code>recvMsg{err: io.EOF}</code></li></ol><p>核心就是讲数据写入流中的 <code>s.write(recvMsg{buffer: buffer})</code></p><h4 id="帧缓冲区"><a class="markdownIt-Anchor" href="#帧缓冲区"></a> 帧缓冲区</h4><p>与发送端所有流的帧都放入到一个帧缓冲区不一样，这里的缓冲区是一个缓冲区切片，用于接收同一个流中的分帧数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> recvBuffer <span class="keyword">struct</span> &#123;</span><br><span class="line">   c       <span class="keyword">chan</span> recvMsg<span class="comment">//缓冲区为1 的 channel</span></span><br><span class="line">   mu      sync.Mutex<span class="comment">//原子锁</span></span><br><span class="line">   backlog []recvMsg<span class="comment">//缓冲切片</span></span><br><span class="line">   err     error<span class="comment">//错误信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="帧的存储"><a class="markdownIt-Anchor" href="#帧的存储"></a> 帧的存储</h5><p>如果 切片 里面没有没有数据，就直接存入隧道，说明切面的消息已经都消费了</p><p>如果 切片 里面有数据，那么就存入到切片的后面，保证消息的顺序消费</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *recvBuffer)</span> <span class="title">put</span><span class="params">(r recvMsg)</span></span> &#123;</span><br><span class="line">   b.mu.Lock()</span><br><span class="line">   <span class="keyword">if</span> b.err != <span class="literal">nil</span> &#123;</span><br><span class="line">      b.mu.Unlock()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   b.err = r.err</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(b.backlog) == <span class="number">0</span> &#123;<span class="comment">//切片为空，则直接存入隧道</span></span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> b.c &lt;- r:</span><br><span class="line">         b.mu.Unlock()</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   b.backlog = <span class="built_in">append</span>(b.backlog, r)<span class="comment">//切片不为空则直接存入切片尾部</span></span><br><span class="line">   b.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="帧的消费"><a class="markdownIt-Anchor" href="#帧的消费"></a> 帧的消费</h5><p>如果切片长度大于0，说明切片内部有消息，则直接将切片第一条数据传入隧道，这样每次读取隧道中的数据即可，也能缓冲一部分数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *recvBuffer)</span> <span class="title">load</span><span class="params">()</span></span> &#123;</span><br><span class="line">   b.mu.Lock()</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(b.backlog) &gt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> b.c &lt;- b.backlog[<span class="number">0</span>]:</span><br><span class="line">         b.backlog[<span class="number">0</span>] = recvMsg&#123;&#125;</span><br><span class="line">         b.backlog = b.backlog[<span class="number">1</span>:]</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   b.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然帧被放入到了同一个流的 <code>recvBuffer</code>中，但还是没有说明：<strong>如果一个帧的分帧是前后发送的，但是接收的顺序是乱序的时候，即使顺序消费也无法保证数据帧能够正常的解析</strong>？</p><p>答：这里可以这样想，由于TCP是有序的，那么所有的TCP包都会按照发送顺序在接收端组装完成。也就是说只要发送顺序一定，那么接收端的顺序与发送端的是一样的。又因为同一个连接共用一个帧缓冲器，也就是说同一个流中的帧都是顺序发送的，所以接收端收到的帧的顺序也是不会乱序的。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li><p>多路复用可以在同一个TCP连接上同时传输多个HTTP请求和响应，避免建立和关闭连接的开销</p></li><li><p>和长连接的区别是: <strong>多路复用</strong> 可以避免 <strong>队头阻塞(Head-of-Line Blocking)</strong> 问题。如果某个请求在传输过程过程中出现阻塞，那么后续的请求也会被阻塞</p></li><li><p>和分包的区别是:HTTP分包是指将一个HTTP消息分为多个TCP数据包(Packet)进行传输，而多路复用是在同一个TCP连接上同时传输多个HTTP请求和响应</p></li><li><p>HTTP2 帧的最大传输字节是 16KB，TCP最大传输MSS是 1460B，IP层最大传输单元 MTU 1500B</p><blockquote><p>HTTP2 的帧有一个固定9B的头部，用于描述帧的类型，长度，标志等信息。其中保存林该帧的有效载荷的长度，最大长度 2^24 - 1 大约为 16KB</p></blockquote></li><li><p>多路复使用相同的 StreamID 来标识属于同一个流，使用recvBuffer进行帧的缓存(多个数据帧)，使用独立协程或者生产者消费者模式进行帧处理</p></li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://blog.csdn.net/u011582922/article/details/120426690" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/120426690</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;多路复用是 HTTP/2中的重要特性，允许同一个TCP连接上同时传输多个HTTP请求和响应&lt;/p&gt;
&lt;p&gt;带着问题看世界：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过《帧发送器》可知帧是一个一个进行消息发送，多个流的帧如何发送&lt;/li&gt;
&lt;li&gt;服务端是如何区分不同的流的帧&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>Grpc-03-帧</title>
    <link href="http://xboom.github.io/2022/10/11/Grpc/Grpc-05-%E5%B8%A7/"/>
    <id>http://xboom.github.io/2022/10/11/Grpc/Grpc-05-%E5%B8%A7/</id>
    <published>2022-10-11T14:58:29.000Z</published>
    <updated>2023-05-27T10:55:06.561Z</updated>
    
    <content type="html"><![CDATA[<p>从前面可知，流单独负责一次调用，并且在服务端使用多路复用实现消息的处理。流其实是通过 ID 标志的虚拟概念，真正传输的其实是帧，帧通过发送器与帧接收器进行发送处理。</p><p>带着问题看世界：</p><ol><li>帧的类型有哪些，具体结构是怎样的</li><li>当消息体过大的时候分帧是如何处理的</li><li>当帧的缓冲区是否也会满，什么时候清理</li></ol><p>在 grpc-go 中，通过对 HTTP/2 中协议的封装，增加了<code>grpc-go</code>自己的业务类型。看源码的时候注意不要弄混了。这里说的协议帧 是 HTTP/2 中定义实际传输过程中的帧 是由 net 库实现的；而应用帧则是 <code>grpc-go</code> 根据自己的实际需要由转换了一层</p><h3 id="协议帧"><a class="markdownIt-Anchor" href="#协议帧"></a> 协议帧</h3><p>每个协议帧都是由<strong>头部</strong>与<strong>负载</strong>两个部分组成</p><h4 id="头部"><a class="markdownIt-Anchor" href="#头部"></a> 头部</h4><p>协议帧指的就是HTTP2中帧的结构，每个帧也分为头部与负载</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+--------+--------+--------+--------+--------+--------+</span><br><span class="line">|        Length(<span class="number">24</span>)        |Type(<span class="number">8</span>) |Flags(<span class="number">8</span>)|R|       StreamID(<span class="number">31</span>)     |</span><br><span class="line">+--------+--------+--------+--------+--------+--------+--------+--------+</span><br></pre></td></tr></table></figure><blockquote><p>虽然Length 是24位，但这不意味着就能处理 2^24 16M大小的帧，一般是默认只支持2^16 16k以下的帧，而2^16 - 2^24 16M 的帧 需要接收端公布自己可以处理这么大的帧，需要在 <strong>SETTINGS_MAX_FRAME_SIZE</strong> 帧中告知</p></blockquote><p>将二进制buffer转换为帧头部结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FrameHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">valid <span class="keyword">bool</span> <span class="comment">// 是否有效，供内部使用</span></span><br><span class="line">Type FrameType<span class="comment">// 帧的类型</span></span><br><span class="line">Flags Flags<span class="comment">// 标志位</span></span><br><span class="line">Length <span class="keyword">uint32</span><span class="comment">// 帧的负载长度(即不包括头部)</span></span><br><span class="line">StreamID <span class="keyword">uint32</span><span class="comment">// 流ID，有的帧没有流，那么StreamID == 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以头部的整体解析流程就变成了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFrameHeader</span><span class="params">(buf []<span class="keyword">byte</span>, r io.Reader)</span> <span class="params">(FrameHeader, error)</span></span> &#123;</span><br><span class="line">   _, err := io.ReadFull(r, buf[:frameHeaderLen])<span class="comment">//读取9B到buf中</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> FrameHeader&#123;&#125;, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> FrameHeader&#123;<span class="comment">//解析成头部接头</span></span><br><span class="line">      Length:   (<span class="keyword">uint32</span>(buf[<span class="number">0</span>])&lt;&lt;<span class="number">16</span> | <span class="keyword">uint32</span>(buf[<span class="number">1</span>])&lt;&lt;<span class="number">8</span> | <span class="keyword">uint32</span>(buf[<span class="number">2</span>])),<span class="comment">//头部长度 </span></span><br><span class="line">      Type:     FrameType(buf[<span class="number">3</span>]),<span class="comment">//类型</span></span><br><span class="line">      Flags:    Flags(buf[<span class="number">4</span>]),<span class="comment">//标志位</span></span><br><span class="line">      StreamID: binary.BigEndian.Uint32(buf[<span class="number">5</span>:]) &amp; (<span class="number">1</span>&lt;&lt;<span class="number">31</span> - <span class="number">1</span>),</span><br><span class="line">      valid:    <span class="literal">true</span>,<span class="comment">//是否有效</span></span><br><span class="line">   &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是：</p><ol><li><code>binary.BigEndian.Uint32</code> 这个作用是将 4个字节的二进制数据转换为 uint32类型的数据</li><li><code>1&lt;&lt;31 - 1</code> 用于将高位设置为0，确保能被正确的解析为uint32位的值</li></ol><p>最后数据帧的格式如下</p><p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/http2_dataframe.png" alt="" /></p><h4 id="帧的类型"><a class="markdownIt-Anchor" href="#帧的类型"></a> 帧的类型</h4><p>其中 <code>FrameType</code> 代表的帧类型，一共有10中</p><table><thead><tr><th>帧类型</th><th>说明</th><th>值</th><th>字符</th></tr></thead><tbody><tr><td><strong>FrameData</strong></td><td>表示数据帧，用于传输 HTTP 报文的实际数据部分</td><td>0x0</td><td>“DATA”</td></tr><tr><td><strong>FrameHeaders</strong></td><td>携带请求或响应头部，也可以分为多个帧进行传输</td><td>0x1</td><td>“HEADERS”</td></tr><tr><td><strong>FramePriority</strong></td><td>表示某个流的优先级，用于流量控制</td><td>0x2</td><td>“PRIORITY”</td></tr><tr><td><strong>FrameRSTStream</strong></td><td>重置某个流，表示这个流将不再使用</td><td>0x3</td><td>“RST_STREAM”</td></tr><tr><td><strong>FrameSettings</strong></td><td>表示设置帧，用于在连接和流级别上传输参数设置</td><td>0x4</td><td>“SETTINGS”</td></tr><tr><td><strong>FramePushPromise</strong></td><td>允许服务端在客户端还没有请求的情况下发送响应头部，用于服务端推送(server push)功能</td><td>0x5</td><td>“PUSH_PROMISE”</td></tr><tr><td><strong>FramePing</strong></td><td>表示 Ping 帧，用于检测连接是否存活</td><td>0x6</td><td>“PING”</td></tr><tr><td><strong>FrameGoAway</strong></td><td>表示断开帧，用于通知对端关闭连接</td><td>0x7</td><td>“GOAWAY”</td></tr><tr><td><strong>FrameWindowUpdate</strong></td><td>用于流量控制，通知对端窗口大小的变化</td><td>0x8</td><td>“WINDOW_UPDATE”</td></tr><tr><td><strong>FrameContinuation</strong></td><td>表示继续帧，将头部帧或推送帧拆分为多个帧进行传输时，用于指示后续帧属于同一个头部块</td><td>0x9</td><td>“CONTINUATION”</td></tr></tbody></table><h4 id="帧的标志位"><a class="markdownIt-Anchor" href="#帧的标志位"></a> 帧的标志位</h4><p>另外一个标志位Flags则是帧</p><table><thead><tr><th>帧类型</th><th>Flags类型</th><th>说明</th><th>值</th></tr></thead><tbody><tr><td><strong>FrameData</strong></td><td>FlagDataEndStream</td><td>标志位用于 <code>DATA</code> 帧，表示这是最后一个 <code>DATA</code> 帧，即流已经结束，接收方不应该再等待更多的 <code>DATA</code> 帧</td><td>0x1</td></tr><tr><td></td><td>FlagDataPadded</td><td>数据帧的填充(Padded)标志，表示数据帧后面跟随一个填充字段</td><td>0x8</td></tr><tr><td><strong>FrameHeaders</strong></td><td>FlagHeadersEndStream</td><td>首部帧(Headers Frame)的结束流标志，表示发送方已经发送完整个消息</td><td>0x1</td></tr><tr><td></td><td>FlagHeadersEndHeaders</td><td>首部帧的结束头(End Headers)标志，表示这个首部块是消息的最后一个首部块</td><td>0x4</td></tr><tr><td></td><td>FlagHeadersPadded</td><td>首部帧的填充标志，表示首部帧后面跟随一个填充字段</td><td>0x8</td></tr><tr><td></td><td>FlagHeadersPriority</td><td>首部帧的优先级(Priority)标志，表示这个首部块包含了一个优先级信息</td><td>0x20</td></tr><tr><td><strong>FrameSettings</strong></td><td>FlagSettingsAck</td><td>设置帧(Settings Frame)的确认(Ack)标志，表示这是一个确认帧</td><td>0x1</td></tr><tr><td><strong>FramePing</strong></td><td>FlagPingAck</td><td>Ping帧的确认标志，表示这是一个确认帧</td><td>0x1</td></tr><tr><td><strong>FrameContinuation</strong></td><td>FlagContinuationEndHeaders</td><td>连续帧(Continuation Frame)的结束头标志，表示这个连续块是消息的最后一个连续块</td><td>0x4</td></tr><tr><td><strong>FramePushPromise</strong></td><td>FlagPushPromiseEndHeaders</td><td>推送帧(Push Promise Frame)的结束头标志，表示这个推送帧包含了一个完整的首部块</td><td>0x4</td></tr><tr><td></td><td>FlagPushPromisePadded</td><td>推送帧的填充标志，表示推送帧后面跟随一个填充字段</td><td>0x8</td></tr></tbody></table><p>有了上述的帧的关键字段说明，接下来来看看各个数据帧的解析</p><h4 id="负载"><a class="markdownIt-Anchor" href="#负载"></a> 负载</h4><p>头部定义之后，负载通过头部长度 <strong>Length</strong> 进行解析，负载解析如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">payload := fr.getReadBuf(fh.Length)<span class="comment">//获取负载长度</span></span><br><span class="line"><span class="keyword">if</span> _, err := io.ReadFull(fr.r, payload); err != <span class="literal">nil</span> &#123;<span class="comment">//读取负载长度</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">f, err := typeFrameParser(fh.Type)(fr.frameCache, fh, payload)<span class="comment">//将负载根据类型解析为对应的帧 fh是上一步读取的帧头</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> ce, ok := err.(connError); ok &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, fr.connError(ce.Code, ce.Reason)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据帧的解析是通过类型参数进行解析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f, err := typeFrameParser(fh.Type)(fr.frameCache, fh, payload)</span><br></pre></td></tr></table></figure><p>其中</p><ol><li><code>fh.Type</code> 是从头部解析出来的帧的类型，用于找到指定类型的数据帧解析器</li><li><code>fr.frameCache</code> 流都具有自己的帧内存缓存池。在需要发送帧时，可以从自己的缓存池中获取内存，并在完成后将其返回以供重用</li><li><code>fh</code> 之前解析出的帧的头部，用来与解析完的负载合并成一个完整的帧</li><li><code>payload</code> 则是帧的负载，用于解析帧的数据部分</li></ol><p>需要关注的是</p><ol><li>是如何转换成其他类型的</li><li>如果有存在分帧，又是如何进行解析的</li><li>如果有帧的丢失怎么办</li></ol><h5 id="framedata"><a class="markdownIt-Anchor" href="#framedata"></a> FrameData</h5><p>数据帧的解析对应的是 <code>parseDataFrame</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseDataFrame</span><span class="params">(fc *frameCache, fh FrameHeader, payload []<span class="keyword">byte</span>)</span> <span class="params">(Frame, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> fh.StreamID == <span class="number">0</span> &#123;<span class="comment">//数据帧StreamID必不为0</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, connError&#123;ErrCodeProtocol, <span class="string">"DATA frame with stream ID 0"</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   f := fc.getDataFrame()<span class="comment">//从内存池获取一个数据帧结构</span></span><br><span class="line">   f.FrameHeader = fh<span class="comment">//帧头部</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> padSize <span class="keyword">byte</span></span><br><span class="line">   <span class="keyword">if</span> fh.Flags.Has(FlagDataPadded) &#123;<span class="comment">//如果有追加</span></span><br><span class="line">      <span class="keyword">var</span> err error</span><br><span class="line">      payload, padSize, err = readByte(payload)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">int</span>(padSize) &gt; <span class="built_in">len</span>(payload) &#123;<span class="comment">//当追加的长度大于负载的长度</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, connError&#123;ErrCodeProtocol, <span class="string">"pad size larger than data payload"</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   f.data = payload[:<span class="built_in">len</span>(payload)-<span class="keyword">int</span>(padSize)]<span class="comment">//帧的负载就是 负载 - 追加</span></span><br><span class="line">   <span class="keyword">return</span> f, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当存在追加帧 <code>FlagDataPadded</code> 的时候 使用 <code>readByte</code>进行解析出去除追加长度的负载</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readByte</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(remain []<span class="keyword">byte</span>, b <span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(p) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, io.ErrUnexpectedEOF</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> p[<span class="number">1</span>:], p[<span class="number">0</span>], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，正常情况只有负载，但是如果数据帧存在追加  <code>FlagDataPadded</code>，数据帧的负载还有一个长度</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|             padSize(<span class="number">32</span>)|</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|data...</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|padding ...</span><br><span class="line">+--------+--------+--------+--------+</span><br></pre></td></tr></table></figure><p><strong>追加的内容在解析成数据帧的过程中，丢掉了！！！！！</strong> 这是因为填充字段仅仅是为了将数据帧填充到规定的长度</p><p>最终组成数据帧</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DataFrame <span class="keyword">struct</span> &#123;</span><br><span class="line">   FrameHeader</span><br><span class="line">   data []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么另外一个标志位 <code>FlagDataEndStream</code> 是在应用gRPC使用</p><ul><li>服务端收到数据帧结束流之后，设置流的状态并结束继续读取流数据</li><li>客户端收到数据帧结束流之后，关闭流(结束读取并清理流)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">if</span> f.StreamEnded() &#123;</span><br><span class="line">t.closeStream(s, io.EOF, <span class="literal">false</span>, http2.ErrCodeNo, status.New(codes.Internal, <span class="string">"server closed the stream without sending trailers"</span>), <span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">if</span> f.StreamEnded() &#123;</span><br><span class="line">   <span class="comment">// Received the end of stream from the client.</span></span><br><span class="line">   s.compareAndSwapState(streamActive, streamReadDone)</span><br><span class="line">   s.write(recvMsg&#123;err: io.EOF&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他注意事项</p><ol><li>如果数据帧中 <code>StreamID == 0</code> ，那么这个数据帧异常，也就是说数据帧必须绑定一个流</li></ol><h5 id="frameheaders"><a class="markdownIt-Anchor" href="#frameheaders"></a> FrameHeaders</h5><p>头帧也是由头部与负载组成，通过 <code>parseHeadersFrame</code> 解析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseHeadersFrame</span><span class="params">(_ *frameCache, fh FrameHeader, p []<span class="keyword">byte</span>)</span> <span class="params">(_ Frame, err error)</span></span> &#123;</span><br><span class="line">   hf := &amp;HeadersFrame&#123;</span><br><span class="line">      FrameHeader: fh,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> fh.StreamID == <span class="number">0</span> &#123;<span class="comment">//头帧流ID不能为0</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, connError&#123;ErrCodeProtocol, <span class="string">"HEADERS frame with stream ID 0"</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> padLength <span class="keyword">uint8</span></span><br><span class="line">   <span class="keyword">if</span> fh.Flags.Has(FlagHeadersPadded) &#123;<span class="comment">//如果有头部追加，同理解析出负载与追加长度</span></span><br><span class="line">      <span class="keyword">if</span> p, padLength, err = readByte(p); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> fh.Flags.Has(FlagHeadersPriority) &#123;<span class="comment">//如果有优先级</span></span><br><span class="line">      <span class="keyword">var</span> v <span class="keyword">uint32</span></span><br><span class="line">      p, v, err = readUint32(p)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">      &#125;</span><br><span class="line">      hf.Priority.StreamDep = v &amp; <span class="number">0x7fffffff</span></span><br><span class="line">      hf.Priority.Exclusive = (v != hf.Priority.StreamDep) <span class="comment">// high bit was set</span></span><br><span class="line">      p, hf.Priority.Weight, err = readByte(p)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(p)-<span class="keyword">int</span>(padLength) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, streamError(fh.StreamID, ErrCodeProtocol)</span><br><span class="line">   &#125;</span><br><span class="line">   hf.headerFragBuf = p[:<span class="built_in">len</span>(p)-<span class="keyword">int</span>(padLength)]<span class="comment">//去掉追加部分</span></span><br><span class="line">   <span class="keyword">return</span> hf, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体来看，头帧结构如下所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|             padSize(<span class="number">32</span>)|</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|             priority(<span class="number">32</span>)|</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|weight(<span class="number">8</span>)|</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|             payload|</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|padding|</span><br><span class="line">+--------+--------+--------+--------+</span><br></pre></td></tr></table></figure><p>这里比数据帧多的第一个标志位就是 优先级 <code>FlagHeadersPriority</code>，它的作用是表示流的优先级</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PriorityParam <span class="keyword">struct</span> &#123;</span><br><span class="line">   StreamDep <span class="keyword">uint32</span></span><br><span class="line">   Exclusive <span class="keyword">bool</span></span><br><span class="line">   Weight <span class="keyword">uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>StreamDep</code>：一个31位的流标识符，表示此流依赖的流。如果为0，表示没有依赖关系。</li><li><code>Exclusive</code>：表示此流是否具有互斥性。如果此字段为true，表示此流是在其依赖的流和同级的兄弟流之间互斥的。</li><li><code>Weight</code>：此流的权重值，是一个0-255的值。根据规范，应该将此字段与<code>StreamDep</code>一起设置，或者两者都不设置。为了获得1到256之间的权重，请将此值加1</li></ol><blockquote><p>为什么流有依赖关系或者互斥关系???</p><p>流之间的依赖关系或者互斥关系可以帮助控制流之间的优先级和竞争关系，从而更有效地利用网络带宽和资源。</p><p>例如1：如果一个网页需要加载多个资源，比如图片、脚本和样式表，那么这些资源就可以分别被分配到不同的流中。为了更快地呈现网页，图片这类占用带宽较大的资源可以被赋予更高的优先级，使其在竞争网络资源时更优先被传输，从而减少用户等待时间。</p><p>例如2：如果一个客户端同时向服务器发起了多个请求，这些请求可能会在服务器端形成竞争关系，造成某些请求的延迟和等待时间过长。通过为请求之间建立依赖关系和互斥关系，可以更好地控制请求的执行顺序和资源利用，提高服务质量和用户体验</p></blockquote><p>最后组成结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HeadersFrame <span class="keyword">struct</span> &#123;</span><br><span class="line">   FrameHeader</span><br><span class="line">   Priority PriorityParam</span><br><span class="line">   headerFragBuf []<span class="keyword">byte</span> <span class="comment">// not owned</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外两个标志位 <code>FlagHeadersEndStream</code> 和 <code>FlagHeadersEndHeaders</code> 同理，是在应用层使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> fh.Type &#123;</span><br><span class="line"><span class="keyword">case</span> FrameHeaders, FrameContinuation:</span><br><span class="line">   <span class="keyword">if</span> fh.Flags.Has(FlagHeadersEndHeaders) &#123;</span><br><span class="line">      fr.lastHeaderStream = <span class="number">0</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fr.lastHeaderStream = fh.StreamID</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="framepriority"><a class="markdownIt-Anchor" href="#framepriority"></a> FramePriority</h5><p>虽然头帧中可以设置流的优先级，但是如果有大量的流需要设置优先级，将会导致头帧变得非常庞大，传输的效率也会受到影响。优先级帧可以独立于其他帧来设置流的优先级。同时，PRIORITY 帧也可以用于修改流的依赖关系，因此它具有比头帧更强的功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parsePriorityFrame</span><span class="params">(_ *frameCache, fh FrameHeader, payload []<span class="keyword">byte</span>)</span> <span class="params">(Frame, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> fh.StreamID == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, connError&#123;ErrCodeProtocol, <span class="string">"PRIORITY frame with stream ID 0"</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(payload) != <span class="number">5</span> &#123;<span class="comment">//负载必须是5</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, connError&#123;ErrCodeFrameSize, fmt.Sprintf(<span class="string">"PRIORITY frame payload size was %d; want 5"</span>, <span class="built_in">len</span>(payload))&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   v := binary.BigEndian.Uint32(payload[:<span class="number">4</span>])</span><br><span class="line">   streamID := v &amp; <span class="number">0x7fffffff</span> <span class="comment">// mask off high bit</span></span><br><span class="line">   <span class="keyword">return</span> &amp;PriorityFrame&#123;</span><br><span class="line">      FrameHeader: fh,</span><br><span class="line">      PriorityParam: PriorityParam&#123;</span><br><span class="line">         Weight:    payload[<span class="number">4</span>],<span class="comment">//256</span></span><br><span class="line">         StreamDep: streamID,</span><br><span class="line">         Exclusive: streamID != v, <span class="comment">//是否是独立</span></span><br><span class="line">      &#125;,</span><br><span class="line">   &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组成的优先级帧如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|           StreamDep(<span class="number">32</span>)|</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|Weight(<span class="number">8</span>)|</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure><h5 id="framerststream"><a class="markdownIt-Anchor" href="#framerststream"></a> FrameRSTStream</h5><p>重置帧则只需要负载的前4个字节用于标志重置原因</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func parseRSTStreamFrame(_ *frameCache, fh FrameHeader, p []byte) (Frame, error) &#123;</span><br><span class="line">   if len(p) !&#x3D; 4 &#123;</span><br><span class="line">      return nil, ConnectionError(ErrCodeFrameSize)</span><br><span class="line">   &#125;</span><br><span class="line">   if fh.StreamID &#x3D;&#x3D; 0 &#123;</span><br><span class="line">      return nil, ConnectionError(ErrCodeProtocol)</span><br><span class="line">   &#125;</span><br><span class="line">   return &amp;RSTStreamFrame&#123;fh, ErrCode(binary.BigEndian.Uint32(p[:4]))&#125;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析成如下结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|            ErrCode(<span class="number">32</span>)|</span><br><span class="line">+--------+--------+--------+--------+</span><br></pre></td></tr></table></figure><p>组成的数据结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RSTStreamFrame <span class="keyword">struct</span> &#123;</span><br><span class="line">   FrameHeader</span><br><span class="line">   ErrCode ErrCode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="framesettings"><a class="markdownIt-Anchor" href="#framesettings"></a> FrameSettings</h5><p>设置帧是通过 <code>parseSettingsFrame</code> 解析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseSettingsFrame</span><span class="params">(_ *frameCache, fh FrameHeader, p []<span class="keyword">byte</span>)</span> <span class="params">(Frame, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> fh.Flags.Has(FlagSettingsAck) &amp;&amp; fh.Length &gt; <span class="number">0</span> &#123;<span class="comment">//如果负载长度大于0，则肯定不是ACK帧</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ConnectionError(ErrCodeFrameSize)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> fh.StreamID != <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ConnectionError(ErrCodeProtocol)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(p)%<span class="number">6</span> != <span class="number">0</span> &#123;<span class="comment">//设置帧固定是 6的倍数</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ConnectionError(ErrCodeFrameSize)</span><br><span class="line">   &#125;</span><br><span class="line">   f := &amp;SettingsFrame&#123;FrameHeader: fh, p: p&#125;<span class="comment">//直接将负载存入设置帧中</span></span><br><span class="line">   <span class="keyword">if</span> v, ok := f.Value(SettingInitialWindowSize); ok &amp;&amp; v &gt; (<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ConnectionError(ErrCodeFlowControl)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> f, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它因为直接使用了KV结构，所以固定每一对的长度是6，那么就能统计出每一对的内容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *SettingsFrame)</span> <span class="title">Value</span><span class="params">(id SettingID)</span> <span class="params">(v <span class="keyword">uint32</span>, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   f.checkValid()</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; f.NumSettings(); i++ &#123;</span><br><span class="line">      <span class="keyword">if</span> s := f.Setting(i); s.ID == id &#123;</span><br><span class="line">         <span class="keyword">return</span> s.Val, <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *SettingsFrame)</span> <span class="title">Setting</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">Setting</span></span> &#123;</span><br><span class="line">buf := f.p</span><br><span class="line"><span class="keyword">return</span> Setting&#123;</span><br><span class="line">ID:  SettingID(binary.BigEndian.Uint16(buf[i*<span class="number">6</span> : i*<span class="number">6</span>+<span class="number">2</span>])),</span><br><span class="line">Val: binary.BigEndian.Uint32(buf[i*<span class="number">6</span>+<span class="number">2</span> : i*<span class="number">6</span>+<span class="number">6</span>]),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共存在6对</p><table><thead><tr><th>标志</th><th>说明</th><th>值</th></tr></thead><tbody><tr><td>SettingHeaderTableSize</td><td>客户端和服务器通信时，指定用于HPACK头表大小的值</td><td>0x1</td></tr><tr><td>SettingEnablePush</td><td>服务器指示客户端是否可以推送资源</td><td>0x2</td></tr><tr><td>SettingMaxConcurrentStreams</td><td>指定客户端可以同时使用的最大流数</td><td>0x3</td></tr><tr><td>SettingInitialWindowSize</td><td>指定流控制窗口的初始大小</td><td>0x4</td></tr><tr><td>SettingMaxFrameSize</td><td>指定帧大小的最大值</td><td>0x5</td></tr><tr><td>SettingMaxHeaderListSize</td><td>指定头部列表大小的最大值</td><td>0x6</td></tr></tbody></table><p>所以对应的结构就是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SettingsFrame <span class="keyword">struct</span> &#123;</span><br><span class="line">   FrameHeader</span><br><span class="line">   p []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化窗口大小不能大于 <code>v &gt; (1&lt;&lt;31)-1</code></p><h5 id="framepushpromise"><a class="markdownIt-Anchor" href="#framepushpromise"></a> FramePushPromise</h5><p><code>FramePushPromise</code> 通过 <code>parsePushPromise</code> 进行数据解析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parsePushPromise</span><span class="params">(_ *frameCache, fh FrameHeader, countError <span class="keyword">func</span>(<span class="keyword">string</span>)</span>, <span class="title">p</span> []<span class="title">byte</span>) <span class="params">(_ Frame, err error)</span></span> &#123;</span><br><span class="line">   pp := &amp;PushPromiseFrame&#123;</span><br><span class="line">      FrameHeader: fh,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> pp.StreamID == <span class="number">0</span> &#123;</span><br><span class="line">      countError(<span class="string">"frame_pushpromise_zero_stream"</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ConnectionError(ErrCodeProtocol)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果有追加，那么就读取追加长度</span></span><br><span class="line">   <span class="keyword">var</span> padLength <span class="keyword">uint8</span></span><br><span class="line">   <span class="keyword">if</span> fh.Flags.Has(FlagPushPromisePadded) &#123;</span><br><span class="line">      <span class="keyword">if</span> p, padLength, err = readByte(p); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         countError(<span class="string">"frame_pushpromise_pad_short"</span>)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   p, pp.PromiseID, err = readUint32(p)<span class="comment">//读取PromiseID </span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      countError(<span class="string">"frame_pushpromise_promiseid_short"</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   pp.PromiseID = pp.PromiseID &amp; (<span class="number">1</span>&lt;&lt;<span class="number">31</span> - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">int</span>(padLength) &gt; <span class="built_in">len</span>(p) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ConnectionError(ErrCodeProtocol)</span><br><span class="line">   &#125;</span><br><span class="line">   pp.headerFragBuf = p[:<span class="built_in">len</span>(p)-<span class="keyword">int</span>(padLength)]</span><br><span class="line">   <span class="keyword">return</span> pp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以二进制可以看出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|           padLength(<span class="number">32</span>)|</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|PromiseID(<span class="number">32</span>)|</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|payload|</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|  padding|</span><br><span class="line">+--------+--------+--------+--------+</span><br></pre></td></tr></table></figure><p>所以最后组成的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PushPromiseFrame <span class="keyword">struct</span> &#123;</span><br><span class="line">   FrameHeader</span><br><span class="line">   PromiseID     <span class="keyword">uint32</span></span><br><span class="line">   headerFragBuf []<span class="keyword">byte</span> <span class="comment">// not owned</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="frameping"><a class="markdownIt-Anchor" href="#frameping"></a> FramePing</h5><p><code>FramePing</code> 通过 <code>parsePingFrame</code> 进行数据解析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parsePingFrame</span><span class="params">(_ *frameCache, fh FrameHeader, countError <span class="keyword">func</span>(<span class="keyword">string</span>)</span>, <span class="title">payload</span> []<span class="title">byte</span>) <span class="params">(Frame, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(payload) != <span class="number">8</span> &#123;</span><br><span class="line">      countError(<span class="string">"frame_ping_length"</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ConnectionError(ErrCodeFrameSize)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> fh.StreamID != <span class="number">0</span> &#123;</span><br><span class="line">      countError(<span class="string">"frame_ping_has_stream"</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ConnectionError(ErrCodeProtocol)</span><br><span class="line">   &#125;</span><br><span class="line">   f := &amp;PingFrame&#123;FrameHeader: fh&#125;</span><br><span class="line">   <span class="built_in">copy</span>(f.Data[:], payload)</span><br><span class="line">   <span class="keyword">return</span> f, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组成的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PingFrame <span class="keyword">struct</span> &#123;</span><br><span class="line">   FrameHeader</span><br><span class="line">   Data [<span class="number">8</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ping帧中很特别的是负载是指定长度的8，通常是时间戳</p><h5 id="framegoaway"><a class="markdownIt-Anchor" href="#framegoaway"></a> FrameGoAway</h5><p><code>FrameGoAway</code> 通过 <code>parseGoAwayFrame</code> 进行数据解析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseGoAwayFrame</span><span class="params">(_ *frameCache, fh FrameHeader, countError <span class="keyword">func</span>(<span class="keyword">string</span>)</span>, <span class="title">p</span> []<span class="title">byte</span>) <span class="params">(Frame, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> fh.StreamID != <span class="number">0</span> &#123;</span><br><span class="line">      countError(<span class="string">"frame_goaway_has_stream"</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ConnectionError(ErrCodeProtocol)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(p) &lt; <span class="number">8</span> &#123;</span><br><span class="line">      countError(<span class="string">"frame_goaway_short"</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ConnectionError(ErrCodeFrameSize)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &amp;GoAwayFrame&#123;</span><br><span class="line">      FrameHeader:  fh,</span><br><span class="line">      LastStreamID: binary.BigEndian.Uint32(p[:<span class="number">4</span>]) &amp; (<span class="number">1</span>&lt;&lt;<span class="number">31</span> - <span class="number">1</span>),</span><br><span class="line">      ErrCode:      ErrCode(binary.BigEndian.Uint32(p[<span class="number">4</span>:<span class="number">8</span>])),</span><br><span class="line">      debugData:    p[<span class="number">8</span>:],</span><br><span class="line">   &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GoAway</code>帧用于通知对端，当前的连接即将关闭，以及关闭的原因。<code>LastStreamID</code> 表示这个流之后的所有流都将被关闭</p><p>组成的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GoAwayFrame <span class="keyword">struct</span> &#123;</span><br><span class="line">   FrameHeader</span><br><span class="line">   LastStreamID <span class="keyword">uint32</span></span><br><span class="line">   ErrCode      ErrCode</span><br><span class="line">   debugData    []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="framewindowupdate"><a class="markdownIt-Anchor" href="#framewindowupdate"></a> FrameWindowUpdate</h5><p><code>FrameWindowUpdate</code> 通过 <code>parseWindowUpdateFrame</code> 进行数据解析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseWindowUpdateFrame</span><span class="params">(_ *frameCache, fh FrameHeader, countError <span class="keyword">func</span>(<span class="keyword">string</span>)</span>, <span class="title">p</span> []<span class="title">byte</span>) <span class="params">(Frame, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(p) != <span class="number">4</span> &#123;</span><br><span class="line">      countError(<span class="string">"frame_windowupdate_bad_len"</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ConnectionError(ErrCodeFrameSize)</span><br><span class="line">   &#125;</span><br><span class="line">   inc := binary.BigEndian.Uint32(p[:<span class="number">4</span>]) &amp; <span class="number">0x7fffffff</span> <span class="comment">// mask off high reserved bit</span></span><br><span class="line">   <span class="keyword">if</span> inc == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> fh.StreamID == <span class="number">0</span> &#123;</span><br><span class="line">         countError(<span class="string">"frame_windowupdate_zero_inc_conn"</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, ConnectionError(ErrCodeProtocol)</span><br><span class="line">      &#125;</span><br><span class="line">      countError(<span class="string">"frame_windowupdate_zero_inc_stream"</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, streamError(fh.StreamID, ErrCodeProtocol)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &amp;WindowUpdateFrame&#123;</span><br><span class="line">      FrameHeader: fh,</span><br><span class="line">      Increment:   inc,</span><br><span class="line">   &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组成的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WindowUpdateFrame <span class="keyword">struct</span> &#123;</span><br><span class="line">   FrameHeader</span><br><span class="line">   Increment <span class="keyword">uint32</span> <span class="comment">// never read with high bit set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="framecontinuation"><a class="markdownIt-Anchor" href="#framecontinuation"></a> FrameContinuation</h5><p><code>FrameContinuation</code> 通过 <code>parseContinuationFrame</code> 进行数据解析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseContinuationFrame</span><span class="params">(_ *frameCache, fh FrameHeader, countError <span class="keyword">func</span>(<span class="keyword">string</span>)</span>, <span class="title">p</span> []<span class="title">byte</span>) <span class="params">(Frame, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> fh.StreamID == <span class="number">0</span> &#123;</span><br><span class="line">      countError(<span class="string">"frame_continuation_zero_stream"</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, connError&#123;ErrCodeProtocol, <span class="string">"CONTINUATION frame with stream ID 0"</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &amp;ContinuationFrame&#123;fh, p&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组成的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ContinuationFrame <span class="keyword">struct</span> &#123;</span><br><span class="line">   FrameHeader</span><br><span class="line">   headerFragBuf []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个将用在帧过大的时候进行数据分帧，这个逻辑将在下面的分帧逻辑进行进一步分析</p><h3 id="应用帧"><a class="markdownIt-Anchor" href="#应用帧"></a> 应用帧</h3><p>上面其实看的是HTTP2协议中的协议帧，而实际在grpc-go中又做了进一步的区分</p><table><thead><tr><th>帧类型</th><th>说明</th></tr></thead><tbody><tr><td>incomingWindowUpdate</td><td>通知发送方更新发送窗口的大小</td></tr><tr><td>outgoingWindowUpdate</td><td>通知接收方更新接收窗口的大小</td></tr><tr><td>incomingSettings</td><td>设置帧</td></tr><tr><td>outgoingSettings</td><td>设置帧</td></tr><tr><td>headerFrame</td><td>帧的头部信息</td></tr><tr><td>registerStream</td><td>服务器专用</td></tr><tr><td>cleanupStream</td><td>针对RST帧</td></tr><tr><td>earlyAbortStream</td><td></td></tr><tr><td>incomingGoAway</td><td>为客户端服务，客户端一旦接受此帧，帧发送器状态为draining</td></tr><tr><td>dataFrame</td><td>数据帧</td></tr><tr><td>ping</td><td>Ping帧</td></tr><tr><td>goAway</td><td>goAway帧</td></tr><tr><td>outFlowControlSizeRequest</td><td></td></tr></tbody></table><p>这里特殊说明一个数据帧，因为在后续的分帧会说到</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> dataFrame <span class="keyword">struct</span> &#123;</span><br><span class="line">   streamID  <span class="keyword">uint32</span><span class="comment">//帧所属的流</span></span><br><span class="line">   endStream <span class="keyword">bool</span><span class="comment">//该帧是否为该流的最后一帧</span></span><br><span class="line">   h         []<span class="keyword">byte</span><span class="comment">//帧的头部，包含了一些控制信息，例如帧长度、类型、标志等</span></span><br><span class="line">   d         []<span class="keyword">byte</span><span class="comment">//帧的数据负载</span></span><br><span class="line">   onEachWrite <span class="function"><span class="keyword">func</span><span class="params">()</span>//在每次写出帧的一部分数据时调用的回调函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特殊注意的就是<code>d</code> 字段，表示的数据负载在传输时可能被切割成多个 <code>dataFrame</code> 进行传输。</p><h3 id="分帧"><a class="markdownIt-Anchor" href="#分帧"></a> 分帧</h3><p>当数据过大时，就需要分批发送</p><blockquote><p>TCP 分段(segment):将应用层数据分成多个 TCP 段进行传输，每个 TCP 段都有自己的头部信息</p><p>应用层 分包(packet)：分包是指将一个应用层数据包分成多个 IP 数据报进行传输</p><p>IP数据包 分片(fragmentation)：分片是指将一个 IP 数据报分成多个较小的数据报进行传输</p></blockquote><p><img src="https://img-blog.csdnimg.cn/f3f3f45e713842cdb0162ae119b6045f.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE1ODI5MjI=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /></p><p>将发送的请求Body超过限制16KB就能看到分帧了</p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_3/http2_dataframe2.png" alt="http2_dataframe2" style="zoom:50%;" /><p>抓包可以看到其实单个帧的大小是 16384，而他们两个区别是</p><ol><li>在第二个中间带上的是<code>0x01 EndStream</code>，表示这个流结束</li><li>因为负载不同，所以他们头部<code>Length</code>也不一样，但是最大就是16384</li></ol><p>然后直接看看分帧分别是如何发送与接收的</p><h4 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h4><p>接着上述 dataFrame的结构说起，它并不是直接切分成多个，而是一部分一部分的切割发送</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *http2Client)</span> <span class="title">Write</span><span class="params">(s *Stream, hdr []<span class="keyword">byte</span>, data []<span class="keyword">byte</span>, opts *Options)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">df := &amp;dataFrame&#123;</span><br><span class="line">streamID:  s.id,</span><br><span class="line">endStream: opts.Last,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> hdr != <span class="literal">nil</span> || data != <span class="literal">nil</span> &#123; <span class="comment">// If it's not an empty data frame.</span></span><br><span class="line"><span class="comment">// Add some data to grpc message header so that we can equally</span></span><br><span class="line"><span class="comment">// distribute bytes across frames.</span></span><br><span class="line">emptyLen := http2MaxFrameLen - <span class="built_in">len</span>(hdr)</span><br><span class="line"><span class="keyword">if</span> emptyLen &gt; <span class="built_in">len</span>(data) &#123;</span><br><span class="line">emptyLen = <span class="built_in">len</span>(data)</span><br><span class="line">&#125;</span><br><span class="line">hdr = <span class="built_in">append</span>(hdr, data[:emptyLen]...)</span><br><span class="line">data = data[emptyLen:]</span><br><span class="line">df.h, df.d = hdr, data</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t.controlBuf.put(df)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析如下：</p><ol><li><code>hdr</code> 是应用层grpc帧的头 长度为 5B(1B是否压缩 + 4B负载长度)</li><li>data 是应用层grpc帧的负载数据</li><li>构建步骤如下：<ol><li>首先构建一个数据帧(应用层的)，指定流ID以及是否是最后一个流(<code>!cs.desc.ClientStreams</code>)</li><li>然后判断数据是否超过http2MaxFrameLen(16384)</li><li>接着 **从data中截取一部分放入到 数据帧的<code>h</code>，然后将剩余部分放入到d中！！！！！**所以这里的<code>h</code>与<code>d</code>并不是指的头与负载</li><li>最后将整个帧放入到帧缓冲器中</li></ol></li></ol><p>经过获取帧并将帧放入到链表之后到数据帧的处理中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *loopyWriter)</span> <span class="title">processData</span><span class="params">()</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">   dataItem := str.itl.peek().(*dataFrame) <span class="comment">//头部数据帧的指针，并不是出栈</span></span><br><span class="line"><span class="comment">//如果数据帧是空的，那么直接发送结束帧并关闭流</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(dataItem.h) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(dataItem.d) == <span class="number">0</span> &#123; <span class="comment">// Empty data frame</span></span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> (</span><br><span class="line">      idx <span class="keyword">int</span></span><br><span class="line">      buf []<span class="keyword">byte</span></span><br><span class="line">   )</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(dataItem.h) != <span class="number">0</span> &#123; <span class="comment">// data header has not been written out yet.</span></span><br><span class="line">      buf = dataItem.h</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      idx = <span class="number">1</span></span><br><span class="line">      buf = dataItem.d</span><br><span class="line">   &#125;</span><br><span class="line">   size := http2MaxFrameLen</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(buf) &lt; size &#123;</span><br><span class="line">      size = <span class="built_in">len</span>(buf)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//... 流级别与连接级别流控</span></span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="comment">//发送最大帧以及流控控制下的size</span></span><br><span class="line">   <span class="keyword">if</span> err := l.framer.fr.WriteData(dataItem.streamID, endStream, buf[:size]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   buf = buf[size:]<span class="comment">//更新剩余部分</span></span><br><span class="line">   <span class="keyword">if</span> idx == <span class="number">0</span> &#123;</span><br><span class="line">      dataItem.h = buf</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dataItem.d = buf</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//如果消息发完那么流头部消息发送完毕，则退出该消息</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(dataItem.h) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(dataItem.d) == <span class="number">0</span> &#123; <span class="comment">// All the data from that message was written out.</span></span><br><span class="line">      str.itl.dequeue()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于整个数据一次性放入到流的消息链表中，然后每次从数据中截取一部分给HTTP2进行发送</p><h4 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h4><p>服务端则是从结束数据开始看</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *parser)</span> <span class="title">recvMsg</span><span class="params">(maxReceiveMessageSize <span class="keyword">int</span>)</span> <span class="params">(pf payloadFormat, msg []<span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> _, err := p.r.Read(p.header[:]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   pf = payloadFormat(p.header[<span class="number">0</span>])</span><br><span class="line">   length := binary.BigEndian.Uint32(p.header[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">   <span class="comment">//...负载长度判断</span></span><br><span class="line">   <span class="keyword">if</span> _, err := p.r.Read(msg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">         err = io.ErrUnexpectedEOF</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> pf, msg, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先直接读取头部长度</li><li>接着校验负载长度是否异常(不能超过 接收最大长度)</li><li>接着读取指定长度</li></ul><p>到这里其实消息体已经是完整的应用层数据帧了，接着我们看下这个应用层数据帧是如何缓存的以及怎样触发读取的</p><p>分帧得从</p><p>由于流使用的是多路复用，所以每个流需要使用缓冲保存分帧数据，当判断已经获取到完整的帧的时候，再从缓冲中获取数据即可。这里用到的结构是 <code>recvBuffer</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> recvBuffer <span class="keyword">struct</span> &#123;</span><br><span class="line">   c       <span class="keyword">chan</span> recvMsg<span class="comment">//make(chan recvMsg, 1)</span></span><br><span class="line">   mu      sync.Mutex</span><br><span class="line">   backlog []recvMsg</span><br><span class="line">   err     error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到数据帧之后，会将帧存入到 <code>recvBuffer</code> 中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stream)</span> <span class="title">write</span><span class="params">(m recvMsg)</span></span> &#123;</span><br><span class="line">   s.buf.put(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这里做了一个特殊的设计</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *recvBuffer)</span> <span class="title">put</span><span class="params">(r recvMsg)</span></span> &#123;</span><br><span class="line">   b.mu.Lock()</span><br><span class="line">   <span class="keyword">if</span> b.err != <span class="literal">nil</span> &#123;</span><br><span class="line">      b.mu.Unlock()</span><br><span class="line">      <span class="comment">// An error had occurred earlier, don't accept more</span></span><br><span class="line">      <span class="comment">// data or errors.</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   b.err = r.err</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(b.backlog) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> b.c &lt;- r:</span><br><span class="line">         b.mu.Unlock()</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   b.backlog = <span class="built_in">append</span>(b.backlog, r)</span><br><span class="line">   b.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个操作</p><ol><li>当 backlog 为空，则直接写入到隧道中</li><li>当 backlog 不为空，则追加到backlog后面</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>帧分为帧头与负载，帧头长度为9</li><li>帧类型为10种，并结合flags进行使用</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://blog.csdn.net/u011582922/article/details/120578941" target="_blank" rel="noopener">https://blog.csdn.net/u011582922/article/details/120578941</a></li><li><a href="https://www.jianshu.com/p/e22fef60a7f0" target="_blank" rel="noopener">https://www.jianshu.com/p/e22fef60a7f0</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从前面可知，流单独负责一次调用，并且在服务端使用多路复用实现消息的处理。流其实是通过 ID 标志的虚拟概念，真正传输的其实是帧，帧通过发送器与帧接收器进行发送处理。&lt;/p&gt;
&lt;p&gt;带着问题看世界：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;帧的类型有哪些，具体结构是怎样的&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/categories/Grpc/"/>
    
    
      <category term="Grpc" scheme="http://xboom.github.io/tags/Grpc/"/>
    
  </entry>
  
</feed>
