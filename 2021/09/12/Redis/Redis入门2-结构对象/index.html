<!DOCTYPE html>
<html lang=en>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Redis入门2-结构对象 | XBoom Dove</title>
  <meta name="description" content="Redis 底层数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合，等等。 Redis 并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种前面所介绍的数据结构。  其中最新的版本中数据结构又进行了优化：  Redis 的对象系统还实">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis入门2-结构对象">
<meta property="og:url" content="http://xboom.github.io/2021/09/12/Redis/Redis%E5%85%A5%E9%97%A82-%E7%BB%93%E6%9E%84%E5%AF%B9%E8%B1%A1/index.html">
<meta property="og:site_name" content="XBoom Dove">
<meta property="og:description" content="Redis 底层数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合，等等。 Redis 并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种前面所介绍的数据结构。  其中最新的版本中数据结构又进行了优化：  Redis 的对象系统还实">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912172338.jpg">
<meta property="og:image" content="http://xboom.github.io/Users/yuankang/Library/Application%20Support/typora-user-images/image-20211224231150889.png">
<meta property="og:image" content="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912172921.png">
<meta property="og:image" content="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912173038.png">
<meta property="og:image" content="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912173211.png">
<meta property="og:image" content="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912173349.png">
<meta property="og:image" content="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912174222.png">
<meta property="og:image" content="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912174402.png">
<meta property="og:image" content="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912174531.png">
<meta property="og:image" content="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912174545.png">
<meta property="og:image" content="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912175436.png">
<meta property="og:image" content="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912175456.png">
<meta property="og:image" content="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912175642.png">
<meta property="og:image" content="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912180224.png">
<meta property="og:image" content="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912180348.png">
<meta property="og:image" content="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912181046.png">
<meta property="og:image" content="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912181104.png">
<meta property="og:image" content="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912181254.png">
<meta property="og:image" content="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912181310.png">
<meta property="og:image" content="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912181924.png">
<meta property="og:image" content="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912182052.png">
<meta property="og:image" content="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912182612.png">
<meta property="og:image" content="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912182710.png">
<meta property="og:image" content="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912182838.png">
<meta property="og:image" content="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912182949.png">
<meta property="article:published_time" content="2021-09-12T10:34:16.000Z">
<meta property="article:modified_time" content="2022-06-25T07:00:00.113Z">
<meta property="article:author" content="XBoom Dove">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912172338.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="http://xboom.github.io/2021/09/12/Redis/Redis%E5%85%A5%E9%97%A82-%E7%BB%93%E6%9E%84%E5%AF%B9%E8%B1%A1/index.html">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="XBoom Dove" type="application/atom+xml">
</head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/XBoom" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">XBoom Dove</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Linux Developer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">Home</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">Archives</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">Categories</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">Tags</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">Repository</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">About</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/XBoom" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=728081687@qq.com" target="_blank" title="Email" data-toggle=tooltip data-placement=top><i class="icon icon-email"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Board</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>Keep on going never give up!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithms-To-Live-By/">Algorithms To Live By</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Design-Patterns/">Design Patterns</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ETCD/">ETCD</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Go/">Go</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Interesting-Algorithm/">Interesting Algorithm</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Depth/">Linux Depth</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MQ/">MQ</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Microservices/">Microservices</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySql/">MySql</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Protocol/">Protocol</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TCP-IP/">TCP/IP</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gRPC/">gRPC</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go-zero/">go-zero</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/golang/">golang</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/k8s/">k8s</a><span class="category-list-count">5</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithms-To-Live-By/" rel="tag">Algorithms To Live By</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Design-Patterns/" rel="tag">Design Patterns</a><span class="tag-list-count">25</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ETCD/" rel="tag">ETCD</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Event/" rel="tag">Event</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go/" rel="tag">Go</a><span class="tag-list-count">18</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MQ/" rel="tag">MQ</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Memory/" rel="tag">Memory</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Microservices/" rel="tag">Microservices</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql/" rel="tag">MySql</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Quic/" rel="tag">Quic</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SMB/" rel="tag">SMB</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/" rel="tag">TCP/IP</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TLS/" rel="tag">TLS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gRPC/" rel="tag">gRPC</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-zero/" rel="tag">go-zero</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/" rel="tag">k8s</a><span class="tag-list-count">5</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 13.3px;">Algorithm</a> <a href="/tags/Algorithms-To-Live-By/" style="font-size: 13.5px;">Algorithms To Live By</a> <a href="/tags/Design-Patterns/" style="font-size: 14px;">Design Patterns</a> <a href="/tags/Docker/" style="font-size: 13px;">Docker</a> <a href="/tags/ETCD/" style="font-size: 13.3px;">ETCD</a> <a href="/tags/Event/" style="font-size: 13px;">Event</a> <a href="/tags/Go/" style="font-size: 13.9px;">Go</a> <a href="/tags/HTTP/" style="font-size: 13px;">HTTP</a> <a href="/tags/Kafka/" style="font-size: 13.3px;">Kafka</a> <a href="/tags/Linux/" style="font-size: 13.2px;">Linux</a> <a href="/tags/MQ/" style="font-size: 13.4px;">MQ</a> <a href="/tags/Memory/" style="font-size: 13px;">Memory</a> <a href="/tags/Microservices/" style="font-size: 13.2px;">Microservices</a> <a href="/tags/MySql/" style="font-size: 13.7px;">MySql</a> <a href="/tags/Quic/" style="font-size: 13px;">Quic</a> <a href="/tags/Redis/" style="font-size: 13.6px;">Redis</a> <a href="/tags/SMB/" style="font-size: 13px;">SMB</a> <a href="/tags/TCP-IP/" style="font-size: 13.4px;">TCP/IP</a> <a href="/tags/TLS/" style="font-size: 13px;">TLS</a> <a href="/tags/gRPC/" style="font-size: 13.1px;">gRPC</a> <a href="/tags/go-zero/" style="font-size: 13.8px;">go-zero</a> <a href="/tags/golang/" style="font-size: 13px;">golang</a> <a href="/tags/k8s/" style="font-size: 13.4px;">k8s</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a><span class="archive-list-count">25</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Go/">Go</a>
              </p>
              <p class="item-title">
                <a href="/2022/09/17/Go/Go%E5%85%A5%E9%97%A818-Fuzzing/" class="title">Go入门18-Fuzzing</a>
              </p>
              <p class="item-date">
                <time datetime="2022-09-17T09:06:06.892Z" itemprop="datePublished">2022-09-17</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/golang/">golang</a>
              </p>
              <p class="item-title">
                <a href="/2022/09/14/Go/Go%E5%85%A5%E9%97%A820-Goland%E6%BF%80%E6%B4%BB/" class="title">Go入门20-Goland激活</a>
              </p>
              <p class="item-date">
                <time datetime="2022-09-14T13:27:28.900Z" itemprop="datePublished">2022-09-14</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Go/">Go</a>
              </p>
              <p class="item-title">
                <a href="/2022/09/10/Go/Go%E5%85%A5%E9%97%A815-Sync/" class="title">Go入门15-Sync</a>
              </p>
              <p class="item-date">
                <time datetime="2022-09-10T00:59:08.235Z" itemprop="datePublished">2022-09-10</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Go/">Go</a>
              </p>
              <p class="item-title">
                <a href="/2022/08/31/Go/Go%E5%85%A5%E9%97%A814-%E6%B3%9B%E5%9E%8B/" class="title">Go入门14-泛型</a>
              </p>
              <p class="item-date">
                <time datetime="2022-08-31T14:04:54.799Z" itemprop="datePublished">2022-08-31</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Go/">Go</a>
              </p>
              <p class="item-title">
                <a href="/2022/08/31/Go/Go%E5%85%A5%E9%97%A816-%E5%B7%A5%E4%BD%9C%E5%8C%BA/" class="title">Go入门16-工作区</a>
              </p>
              <p class="item-date">
                <time datetime="2022-08-31T14:04:54.799Z" itemprop="datePublished">2022-08-31</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">Catalogue</h3>
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的类型与编码"><span class="toc-number">1.</span> <span class="toc-text"> 对象的类型与编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类型"><span class="toc-number">1.1.</span> <span class="toc-text"> 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#编码和底层实现"><span class="toc-number">1.2.</span> <span class="toc-text"> 编码和底层实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串对象"><span class="toc-number">2.</span> <span class="toc-text"> 字符串对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#编码的转换"><span class="toc-number">2.1.</span> <span class="toc-text"> 编码的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串命令的实现"><span class="toc-number">2.2.</span> <span class="toc-text"> 字符串命令的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#列表对象"><span class="toc-number">3.</span> <span class="toc-text"> 列表对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#编码的转换-2"><span class="toc-number">3.1.</span> <span class="toc-text"> 编码的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#列表命令的实现"><span class="toc-number">3.2.</span> <span class="toc-text"> 列表命令的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哈希对象"><span class="toc-number">4.</span> <span class="toc-text"> 哈希对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#编码转换"><span class="toc-number">4.1.</span> <span class="toc-text"> 编码转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#哈希命令的实现"><span class="toc-number">4.2.</span> <span class="toc-text"> 哈希命令的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合对象"><span class="toc-number">5.</span> <span class="toc-text"> 集合对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#编码转换-2"><span class="toc-number">5.1.</span> <span class="toc-text"> 编码转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#集合命令的实现"><span class="toc-number">5.2.</span> <span class="toc-text"> 集合命令的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有序集合对象"><span class="toc-number">6.</span> <span class="toc-text"> 有序集合对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#编码的转换-3"><span class="toc-number">6.1.</span> <span class="toc-text"> 编码的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有序集合命令的实现"><span class="toc-number">6.2.</span> <span class="toc-text"> 有序集合命令的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型检查和命令多态"><span class="toc-number">7.</span> <span class="toc-text"> 类型检查和命令多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类型检查的实现"><span class="toc-number">7.1.</span> <span class="toc-text"> 类型检查的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多态命令的实现"><span class="toc-number">7.2.</span> <span class="toc-text"> 多态命令的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存回收"><span class="toc-number">8.</span> <span class="toc-text"> 内存回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象共享"><span class="toc-number">9.</span> <span class="toc-text"> 对象共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的空转时长"><span class="toc-number">10.</span> <span class="toc-text"> 对象的空转时长</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">11.</span> <span class="toc-text"> 总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考链接"><span class="toc-number">12.</span> <span class="toc-text"> 参考链接</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Redis/Redis入门2-结构对象" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Redis入门2-结构对象
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/09/12/Redis/Redis%E5%85%A5%E9%97%A82-%E7%BB%93%E6%9E%84%E5%AF%B9%E8%B1%A1/" class="article-date">
	  <time datetime="2021-09-12T10:34:16.000Z" itemprop="datePublished">2021-09-12</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Redis/">Redis</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/Redis/" rel="tag">Redis</a>
  </span>


        

	<span class="article-read hidden-xs">
    	<i class="icon icon-eye-fill" aria-hidden="true"></i>
    	<span id="/2021/09/12/Redis/Redis%E5%85%A5%E9%97%A82-%E7%BB%93%E6%9E%84%E5%AF%B9%E8%B1%A1/" class="leancloud_visitors"  data-flag-title="Redis入门2-结构对象">0</span>
    </span>

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/09/12/Redis/Redis%E5%85%A5%E9%97%A82-%E7%BB%93%E6%9E%84%E5%AF%B9%E8%B1%A1/#comments" class="article-comment-link">Comments</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">Word Count: 14.4k(words)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">Read Time: 52(minutes)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>Redis 底层数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合，等等。</p>
<p>Redis 并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含<strong>字符串对象、列表对象、哈希对象、集合对象和有序集合对象</strong>这五种类型的对象，每种对象都用到了至少一种前面所介绍的数据结构。</p>
<p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912172338.jpg" alt="img" /></p>
<p>其中最新的版本中数据结构又进行了优化：</p>
<p><img src="/Users/yuankang/Library/Application%20Support/typora-user-images/image-20211224231150889.png" alt="image-20211224231150889" /></p>
<p>Redis 的对象系统还实现了<strong>基于引用计数技术的内存回收机制</strong>：当程序不再使用某个对象的时候，对象所占用的内存就会被自动释放；</p>
<p>Redis 还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。</p>
<p>最后，Redis 的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了 <code>maxmemory</code> 功能的情况下，空转时长较大的那些键可能会优先被服务器删除。</p>
<h3 id="对象的类型与编码"><a class="markdownIt-Anchor" href="#对象的类型与编码"></a> 对象的类型与编码</h3>
<p>Redis 使用对象来表示数据库中的键和值，每当在 Redis 的数据库中新创建一个键值对时，至少会创建两个对象，<strong>一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）</strong>。</p>
<p>举个例子，以下 SET 命令在数据库中创建了一个新的键值对，其中键值对的键是一个包含了字符串值 <code>&quot;msg&quot;</code> 的对象，而键值对的值则是一个包含了字符串值 <code>&quot;hello world&quot;</code> 的对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET msg <span class="string">"hello world"</span></span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>Redis 中的每个对象都由一个 <code>redisObject</code> 结构表示，该结构中和保存数据有关的三个属性分别是 <code>type</code> 属性、 <code>encoding</code> 属性和 <code>ptr</code> 属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<h4 id="类型"><a class="markdownIt-Anchor" href="#类型"></a> 类型</h4>
<p>对象的 <code>type</code> 属性记录了对象的类型，这个属性的值可以是表中列出的常量的其中一个。</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型常量</th>
<th style="text-align:left">对象的名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>REDIS_STRING</code></td>
<td style="text-align:left">字符串对象</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_LIST</code></td>
<td style="text-align:left">列表对象</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_HASH</code></td>
<td style="text-align:left">哈希对象</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_SET</code></td>
<td style="text-align:left">集合对象</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ZSET</code></td>
<td style="text-align:left">有序集合对象</td>
</tr>
</tbody>
</table>
<p>对于 Redis 数据库保存的键值对来说，<strong>键总是一个字符串对象</strong>，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种，因此：</p>
<ul>
<li>当我们称呼一个数据库键为“字符串键”时，我们指的是“这个数据库键所对应的值为字符串对象”；</li>
<li>当我们称呼一个键为“列表键”时，我们指的是“这个数据库键所对应的值为列表对象”，</li>
</ul>
<p>诸如此类。</p>
<p>TYPE 命令的实现也与此类似，对一个数据库键执行 TYPE 命令时，返回的结果为数据库键对应的值对象的类型，而不是键对象的类型：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 键为字符串对象，值为字符串对象</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET msg <span class="string">"hello world"</span></span></span><br><span class="line">OK</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> TYPE msg</span></span><br><span class="line">string</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 键为字符串对象，值为列表对象</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> RPUSH numbers 1 3 5</span></span><br><span class="line">(integer) 6</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> TYPE numbers</span></span><br><span class="line">list</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 键为字符串对象，值为哈希对象</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> HMSET profile name Tome age 25 career Programmer</span></span><br><span class="line">OK</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> TYPE profile</span></span><br><span class="line">hash</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 键为字符串对象，值为集合对象</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD fruits apple banana cherry</span></span><br><span class="line">(integer) 3</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> TYPE fruits</span></span><br><span class="line">set</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 键为字符串对象，值为有序集合对象</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZADD price 8.5 apple 5.0 banana 6.0 cherry</span></span><br><span class="line">(integer) 3</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> TYPE price</span></span><br><span class="line">zset</span><br></pre></td></tr></table></figure>
<p>TYPE 命令在面对不同类型的值对象时所产生的输出:</p>
<table>
<thead>
<tr>
<th style="text-align:left">对象</th>
<th style="text-align:left">对象 <code>type</code> 属性的值</th>
<th style="text-align:left">TYPE 命令的输出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">字符串对象</td>
<td style="text-align:left"><code>REDIS_STRING</code></td>
<td style="text-align:left"><code>&quot;string&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">列表对象</td>
<td style="text-align:left"><code>REDIS_LIST</code></td>
<td style="text-align:left"><code>&quot;list&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">哈希对象</td>
<td style="text-align:left"><code>REDIS_HASH</code></td>
<td style="text-align:left"><code>&quot;hash&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">集合对象</td>
<td style="text-align:left"><code>REDIS_SET</code></td>
<td style="text-align:left"><code>&quot;set&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">有序集合对象</td>
<td style="text-align:left"><code>REDIS_ZSET</code></td>
<td style="text-align:left"><code>&quot;zset&quot;</code></td>
</tr>
</tbody>
</table>
<h4 id="编码和底层实现"><a class="markdownIt-Anchor" href="#编码和底层实现"></a> 编码和底层实现</h4>
<p>对象的 <code>ptr</code> 指针指向对象的底层实现数据结构，而这些数据结构由对象的 <code>encoding</code> 属性决定。</p>
<p><code>encoding</code> 属性记录了对象所使用的编码，即这个对象使用了什么数据结构作为对象的底层实现，这个属性的值以下常量的其中一个。</p>
<table>
<thead>
<tr>
<th style="text-align:left">编码常量</th>
<th style="text-align:left">编码所对应的底层数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_INT</code></td>
<td style="text-align:left"><code>long</code> 类型的整数</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_EMBSTR</code></td>
<td style="text-align:left"><code>embstr</code> 编码的简单动态字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_RAW</code></td>
<td style="text-align:left">简单动态字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_HT</code></td>
<td style="text-align:left">字典</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_LINKEDLIST</code></td>
<td style="text-align:left">双端链表</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_ZIPLIST</code></td>
<td style="text-align:left">压缩列表</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_INTSET</code></td>
<td style="text-align:left">整数集合</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_SKIPLIST</code></td>
<td style="text-align:left">跳跃表和字典</td>
</tr>
</tbody>
</table>
<p>每种类型的对象都至少使用了两种不同的编码，每种类型的对象可以使用的编码:</p>
<table>
<thead>
<tr>
<th><code>REDIS_STRING</code></th>
<th><code>REDIS_ENCODING_INT</code></th>
<th>使用整数值实现的字符串对象。</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>REDIS_STRING</code></td>
<td><code>REDIS_ENCODING_EMBSTR</code></td>
<td>使用 <code>embstr</code> 编码的简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td><code>REDIS_STRING</code></td>
<td><code>REDIS_ENCODING_RAW</code></td>
<td>使用简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td><code>REDIS_LIST</code></td>
<td><code>REDIS_ENCODING_ZIPLIST</code></td>
<td>使用压缩列表实现的列表对象。</td>
</tr>
<tr>
<td><code>REDIS_LIST</code></td>
<td><code>REDIS_ENCODING_LINKEDLIST</code></td>
<td>使用双端链表实现的列表对象。</td>
</tr>
<tr>
<td><code>REDIS_HASH</code></td>
<td><code>REDIS_ENCODING_ZIPLIST</code></td>
<td>使用压缩列表实现的哈希对象。</td>
</tr>
<tr>
<td><code>REDIS_HASH</code></td>
<td><code>REDIS_ENCODING_HT</code></td>
<td>使用字典实现的哈希对象。</td>
</tr>
<tr>
<td><code>REDIS_SET</code></td>
<td><code>REDIS_ENCODING_INTSET</code></td>
<td>使用整数集合实现的集合对象。</td>
</tr>
<tr>
<td><code>REDIS_SET</code></td>
<td><code>REDIS_ENCODING_HT</code></td>
<td>使用字典实现的集合对象。</td>
</tr>
<tr>
<td><code>REDIS_ZSET</code></td>
<td><code>REDIS_ENCODING_ZIPLIST</code></td>
<td>使用压缩列表实现的有序集合对象。</td>
</tr>
<tr>
<td><code>REDIS_ZSET</code></td>
<td><code>REDIS_ENCODING_SKIPLIST</code></td>
<td>使用跳跃表和字典实现的有序集合对象。</td>
</tr>
</tbody>
</table>
<p>使用 OBJECT ENCODING 命令可以查看一个数据库键的值对象的编码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET msg <span class="string">"hello wrold"</span></span></span><br><span class="line">OK</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING msg</span></span><br><span class="line">"embstr"</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET story <span class="string">"long long long long long long ago ..."</span></span></span><br><span class="line">OK</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING story</span></span><br><span class="line">"raw"</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD numbers 1 3 5</span></span><br><span class="line">(integer) 3</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING numbers</span></span><br><span class="line">"intset"</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD numbers <span class="string">"seven"</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING numbers</span></span><br><span class="line">"hashtable"</span><br></pre></td></tr></table></figure>
<p>OBJECT ENCODING 对不同编码的输出</p>
<table>
<thead>
<tr>
<th style="text-align:left">对象所使用的底层数据结构</th>
<th style="text-align:left">编码常量</th>
<th style="text-align:left">OBJECT ENCODING 命令输出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">整数</td>
<td style="text-align:left"><code>REDIS_ENCODING_INT</code></td>
<td style="text-align:left"><code>&quot;int&quot;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>embstr</code> 编码的简单动态字符串（SDS）</td>
<td style="text-align:left"><code>REDIS_ENCODING_EMBSTR</code></td>
<td style="text-align:left"><code>&quot;embstr&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">简单动态字符串</td>
<td style="text-align:left"><code>REDIS_ENCODING_RAW</code></td>
<td style="text-align:left"><code>&quot;raw&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">字典</td>
<td style="text-align:left"><code>REDIS_ENCODING_HT</code></td>
<td style="text-align:left"><code>&quot;hashtable&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">双端链表</td>
<td style="text-align:left"><code>REDIS_ENCODING_LINKEDLIST</code></td>
<td style="text-align:left"><code>&quot;linkedlist&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">压缩列表</td>
<td style="text-align:left"><code>REDIS_ENCODING_ZIPLIST</code></td>
<td style="text-align:left"><code>&quot;ziplist&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">整数集合</td>
<td style="text-align:left"><code>REDIS_ENCODING_INTSET</code></td>
<td style="text-align:left"><code>&quot;intset&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">跳跃表和字典</td>
<td style="text-align:left"><code>REDIS_ENCODING_SKIPLIST</code></td>
<td style="text-align:left"><code>&quot;skiplist&quot;</code></td>
</tr>
</tbody>
</table>
<h3 id="字符串对象"><a class="markdownIt-Anchor" href="#字符串对象"></a> 字符串对象</h3>
<p>字符串对象的编码可以是 <code>int</code> 、 <code>raw</code> 或者 <code>embstr</code> 。</p>
<p>如果一个字符串对象保存的是整数值，并且这个整数值可以用 <code>long</code> 类型来表示，那么字符串对象会将整数值保存在字符串对象结构的 <code>ptr</code> 属性里面（将 <code>void*</code> 转换成 <code>long</code> ），并将字符串对象的编码设置为 <code>int</code> 。</p>
<p>举个例子，如果执行以下 SET 命令，那么服务器将创建一个如图 8-1 所示的 <code>int</code> 编码的字符串对象作为 <code>number</code> 键的值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET number 10086</span></span><br><span class="line">OK</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING number</span></span><br><span class="line">"int"</span><br></pre></td></tr></table></figure>
<p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912172921.png" alt="" /></p>
<p>如果字符串对象保存的是一个字符串值，并且<strong>这个字符串值的长度大于 <code>39</code> 字节</strong>，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为 <code>raw</code> 。</p>
<p>举个例子，如果我们执行以下命令，那么服务器将创建一个如图 8-2 所示的 <code>raw</code> 编码的字符串对象作为 <code>story</code> 键的值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET story <span class="string">"Long, long, long ago there lived a king ..."</span></span></span><br><span class="line">OK</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> STRLEN story</span></span><br><span class="line">(integer) 43</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING story</span></span><br><span class="line">"raw"</span><br></pre></td></tr></table></figure>
<p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912173038.png" alt="" /></p>
<p>如果字符串对象保存的是一个字符串值，且<strong>这个字符串值的长度小于等于 <code>39</code> 字节</strong>，字符串对象将使用 <code>embstr</code> 编码的方式来保存这个字符串值。</p>
<p><code>embstr</code> 编码是<strong>专门用于保存短字符串的一种优化编码方式</strong>，这种编码和 <code>raw</code> 编码一样，都使用 <code>redisObject</code> 结构和 <code>sdshdr</code> 结构来表示字符串对象，但 <code>raw</code> 编码会调用两次内存分配函数来分别创建 <code>redisObject</code> 结构和 <code>sdshdr</code> 结构，而 <code>embstr</code> 编码则通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含 <code>redisObject</code> 和 <code>sdshdr</code> 两个结构，如图 8-3 所示</p>
<p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912173211.png" alt="" /></p>
<p><code>embstr</code> 编码的字符串对象在执行命令时，产生的效果和 <code>raw</code> 编码的字符串对象执行命令时产生的效果是相同的，但使用 <code>embstr</code> 编码的字符串对象来保存短字符串值有以下好处：</p>
<ul>
<li><code>embstr</code> 编码将创建字符串对象所需的内存分配次数从 <code>raw</code> 编码的两次降低为一次。</li>
<li>释放 <code>embstr</code> 编码的字符串对象只需要调用一次内存释放函数，而释放 <code>raw</code> 编码的字符串对象需要调用两次内存释放函数。</li>
<li>因为 <code>embstr</code> 编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起 <code>raw</code> 编码的字符串对象能够更好地利用缓存带来的优势。作为例子，以下命令创建了一个 <code>embstr</code> 编码的字符串对象作为 <code>msg</code> 键的值，值对象的样子如图 8-4 所示：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET msg <span class="string">"hello"</span></span></span><br><span class="line">OK</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING msg</span></span><br><span class="line">"embstr"</span><br></pre></td></tr></table></figure>
<p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912173349.png" alt="" /></p>
<p>最后要说的是，可以用 <code>long double</code> 类型表示的浮点数在 Redis 中也是作为字符串值来保存的：如果我们要保存一个浮点数到字符串对象里面，那么程序会先将这个浮点数转换成字符串值，然后再保存起转换所得的字符串值。</p>
<p>举个例子，执行以下代码将创建一个包含 <code>3.14</code> 的字符串表示 <code>&quot;3.14&quot;</code> 的字符串对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET pi 3.14</span></span><br><span class="line">OK</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING pi</span></span><br><span class="line">"embstr"</span><br></pre></td></tr></table></figure>
<p>在有需要的时候，程序会将保存在字符串对象里面的字符串值转换回浮点数值，执行某些操作，然后再将执行操作所得的浮点数值转换回字符串值，并继续保存在字符串对象里面。</p>
<p>举个例子，如果我们执行以下代码的话：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> INCRBYFLOAT pi 2.0</span></span><br><span class="line">"5.14"</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING pi</span></span><br><span class="line">"embstr"</span><br></pre></td></tr></table></figure>
<p>那么程序首先会取出字符串对象里面保存的字符串值 <code>&quot;3.14&quot;</code> ，将它转换回浮点数值 <code>3.14</code> ，然后把 <code>3.14</code> 和 <code>2.0</code> 相加得出的值 <code>5.14</code> 转换成字符串 <code>&quot;5.14&quot;</code> ，并将这个 <code>&quot;5.14&quot;</code> 保存到字符串对象里面。</p>
<p>总结并列出了字符串对象保存各种不同类型的值所使用的编码方式</p>
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">编码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">可以用 <code>long</code> 类型保存的整数。</td>
<td style="text-align:left"><code>int</code></td>
</tr>
<tr>
<td style="text-align:left">可以用 <code>long double</code> 类型保存的浮点数。</td>
<td style="text-align:left"><code>embstr</code> 或者 <code>raw</code></td>
</tr>
<tr>
<td style="text-align:left">字符串值，或者因为长度太大而没办法用 <code>long</code> 类型表示的整数，又或者因为长度太大而没办法用 <code>long double</code> 类型表示的浮点数。</td>
<td style="text-align:left"><code>embstr</code> 或者 <code>raw</code></td>
</tr>
</tbody>
</table>
<h4 id="编码的转换"><a class="markdownIt-Anchor" href="#编码的转换"></a> 编码的转换</h4>
<p><code>int</code> 编码的字符串对象和 <code>embstr</code> 编码的字符串对象在条件满足的情况下，会被转换为 <code>raw</code> 编码的字符串对象。</p>
<p>对于 <code>int</code> 编码的字符串对象来说，如果我们向对象执行了一些命令，使得这个对象保存的不再是整数值，而是一个字符串值，那么字符串对象的编码将从 <code>int</code> 变为 <code>raw</code> 。</p>
<p>在下面的示例中，我们通过 APPEND 命令，向一个保存整数值的字符串对象追加了一个字符串值，因为追加操作只能对字符串值执行，所以程序会先将之前保存的整数值 <code>10086</code> 转换为字符串值 <code>&quot;10086&quot;</code> ，然后再执行追加操作，操作的执行结果就是一个 <code>raw</code> 编码的、保存了字符串值的字符串对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET number 10086</span></span><br><span class="line">OK</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING number</span></span><br><span class="line">"int"</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> APPEND number <span class="string">" is a good number!"</span></span></span><br><span class="line">(integer) 23</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GET number</span></span><br><span class="line">"10086 is a good number!"</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING number</span></span><br><span class="line">"raw"</span><br></pre></td></tr></table></figure>
<p>另外，因为 Redis 没有为 <code>embstr</code> 编码的字符串对象编写任何相应的修改程序（只有 <code>int</code> 编码的字符串对象和 <code>raw</code> 编码的字符串对象有这些程序），<strong>所以 <code>embstr</code> 编码的字符串对象实际上是只读的：当我们对 <code>embstr</code> 编码的字符串对象执行任何修改命令时，程序会先将对象的编码从 <code>embstr</code> 转换成 <code>raw</code> ，然后再执行修改命令；因为这个原因，<code>embstr</code> 编码的字符串对象在执行修改命令之后，总会变成一个 <code>raw</code> 编码的字符串对象。</strong></p>
<p>以下代码展示了一个 <code>embstr</code> 编码的字符串对象在执行 APPEND 命令之后，对象的编码从 <code>embstr</code> 变为 <code>raw</code> 的例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET msg <span class="string">"hello world"</span></span></span><br><span class="line">OK</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING msg</span></span><br><span class="line">"embstr"</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> APPEND msg <span class="string">" again!"</span></span></span><br><span class="line">(integer) 18</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING msg</span></span><br><span class="line">"raw"</span><br></pre></td></tr></table></figure>
<h4 id="字符串命令的实现"><a class="markdownIt-Anchor" href="#字符串命令的实现"></a> 字符串命令的实现</h4>
<p>因为字符串键的值为字符串对象，所以用于字符串键的所有命令都是针对字符串对象来构建的， 列举部分字符串命令，以及这些命令在不同编码的字符串对象下的实现方法。</p>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left"><code>int</code> 编码的实现方法</th>
<th style="text-align:left"><code>embstr</code> 编码的实现方法</th>
<th style="text-align:left"><code>raw</code> 编码的实现方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SET</td>
<td style="text-align:left">使用 <code>int</code> 编码保存值。</td>
<td style="text-align:left">使用 <code>embstr</code> 编码保存值。</td>
<td style="text-align:left">使用 <code>raw</code> 编码保存值。</td>
</tr>
<tr>
<td style="text-align:left">GET</td>
<td style="text-align:left">拷贝对象所保存的整数值，将这个拷贝转换成字符串值，然后向客户端返回这个字符串值。</td>
<td style="text-align:left">直接向客户端返回字符串值。</td>
<td style="text-align:left">直接向客户端返回字符串值。</td>
</tr>
<tr>
<td style="text-align:left">APPEND</td>
<td style="text-align:left">将对象转换成 <code>raw</code> 编码，然后按 <code>raw</code>编码的方式执行此操作。</td>
<td style="text-align:left">将对象转换成 <code>raw</code> 编码，然后按 <code>raw</code>编码的方式执行此操作。</td>
<td style="text-align:left">调用 <code>sdscatlen</code> 函数，将给定字符串追加到现有字符串的末尾。</td>
</tr>
<tr>
<td style="text-align:left">INCRBYFLOAT</td>
<td style="text-align:left">取出整数值并将其转换成<code>long double</code> 类型的浮点数，对这个浮点数进行加法计算，然后将得出的浮点数结果保存起来。</td>
<td style="text-align:left">取出字符串值并尝试将其转换成<code>long double</code> 类型的浮点数，对这个浮点数进行加法计算，然后将得出的浮点数结果保存起来。如果字符串值不能被转换成浮点数，那么向客户端返回一个错误。</td>
<td style="text-align:left">取出字符串值并尝试将其转换成<code>long double</code> 类型的浮点数，对这个浮点数进行加法计算，然后将得出的浮点数结果保存起来。如果字符串值不能被转换成浮点数，那么向客户端返回一个错误。</td>
</tr>
<tr>
<td style="text-align:left">INCRBY</td>
<td style="text-align:left">对整数值进行加法计算，得出的计算结果会作为整数被保存起来。</td>
<td style="text-align:left"><code>embstr</code> 编码不能执行此命令，向客户端返回一个错误。</td>
<td style="text-align:left"><code>raw</code> 编码不能执行此命令，向客户端返回一个错误。</td>
</tr>
<tr>
<td style="text-align:left">DECRBY</td>
<td style="text-align:left">对整数值进行减法计算，得出的计算结果会作为整数被保存起来。</td>
<td style="text-align:left"><code>embstr</code> 编码不能执行此命令，向客户端返回一个错误。</td>
<td style="text-align:left"><code>raw</code> 编码不能执行此命令，向客户端返回一个错误。</td>
</tr>
<tr>
<td style="text-align:left">STRLEN</td>
<td style="text-align:left">拷贝对象所保存的整数值，将这个拷贝转换成字符串值，计算并返回这个字符串值的长度。</td>
<td style="text-align:left">调用 <code>sdslen</code> 函数，返回字符串的长度。</td>
<td style="text-align:left">调用 <code>sdslen</code> 函数，返回字符串的长度。</td>
</tr>
<tr>
<td style="text-align:left">SETRANGE</td>
<td style="text-align:left">将对象转换成 <code>raw</code> 编码，然后按 <code>raw</code>编码的方式执行此命令。</td>
<td style="text-align:left">将对象转换成 <code>raw</code> 编码，然后按 <code>raw</code>编码的方式执行此命令。</td>
<td style="text-align:left">将字符串特定索引上的值设置为给定的字符。</td>
</tr>
<tr>
<td style="text-align:left">GETRANGE</td>
<td style="text-align:left">拷贝对象所保存的整数值，将这个拷贝转换成字符串值，然后取出并返回字符串指定索引上的字符。</td>
<td style="text-align:left">直接取出并返回字符串指定索引上的字符。</td>
<td style="text-align:left">直接取出并返回字符串指定索引上的字符。</td>
</tr>
</tbody>
</table>
<h3 id="列表对象"><a class="markdownIt-Anchor" href="#列表对象"></a> 列表对象</h3>
<p>列表对象的编码可以是 <code>ziplist</code> 或者 <code>linkedlist</code> 。</p>
<p><code>ziplist</code> 编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点（entry）保存了一个列表元素。</p>
<p>举个例子，如果执行以下 RPUSH 命令，那么服务器将创建一个列表对象作为 <code>numbers</code> 键的值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> RPUSH numbers 1 <span class="string">"three"</span> 5</span></span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>
<p>如果 <code>numbers</code> 键的值对象使用的是 <code>ziplist</code> 编码，这个这个值对象将会是图 8-5 所展示的样子。</p>
<p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912174222.png" alt="" /></p>
<p>另一方面，<code>linkedlist</code> 编码的列表对象使用双端链表作为底层实现，每个双端链表节点（node）都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。</p>
<p>举个例子，如果前面所说的 <code>numbers</code> 键创建的列表对象使用的不是 <code>ziplist</code> 编码，而是 <code>linkedlist</code> 编码，那么 <code>numbers</code> 键的值对象将是图 8-6 所示的样子</p>
<p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912174402.png" alt="" /></p>
<p>注意</p>
<ol>
<li>
<p><code>linkedlist</code> 编码的列表对象在底层的双端链表结构中包含了多个字符串对象，这种嵌套字符串对象的行为在稍后介绍的哈希对象、集合对象和有序集合对象中都会出现，<strong>字符串对象是 Redis 五种类型的对象中唯一一种会被其他四种类型对象嵌套的对象</strong>。</p>
</li>
<li>
<p>为了简化字符串对象的表示，在图 8-6 使用了一个带有 <code>StringObject</code> 字样的格子来表示一个字符串对象，而 <code>StringObject</code> 字样下面的是字符串对象所保存的值。</p>
</li>
</ol>
<p>比如说，图 8-7 代表的就是一个包含了字符串值 <code>&quot;three&quot;</code> 的字符串对象，它是 8-8 的简化表示。</p>
<p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912174531.png" alt="" /></p>
<p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912174545.png" alt="" /></p>
<h4 id="编码的转换-2"><a class="markdownIt-Anchor" href="#编码的转换-2"></a> 编码的转换</h4>
<p>当列表对象可以同时满足以下两个条件时，列表对象使用 <code>ziplist</code> 编码：</p>
<ul>
<li>列表对象保存的所有字符串元素的长度都小于 <code>64</code> 字节；</li>
<li>列表对象保存的元素数量小于 <code>512</code> 个；不能满足这两个条件的列表对象需要使用 <code>linkedlist</code> 编码。</li>
</ul>
<blockquote>
<ol>
<li>以上两个条件的上限值是可以修改的，具体请看配置文件中关于 <code>list-max-ziplist-value</code> 选项和 <code>list-max-ziplist-entries</code> 选项的说明</li>
<li>对于使用 <code>ziplist</code> 编码的列表对象来说，当使用 <code>ziplist</code> 编码所需的两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行：原本保存在压缩列表里的所有列表元素都会被转移并保存到双端链表里面，对象的编码也会从 <code>ziplist</code> 变为 <code>linkedlist</code> 。</li>
</ol>
</blockquote>
<p>会转换回来吗？</p>
<p>以下代码展示了列表对象因为保存了长度太大的元素而进行编码转换的情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 所有元素的长度都小于 64 字节</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> RPUSH blah <span class="string">"hello"</span> <span class="string">"world"</span> <span class="string">"again"</span></span></span><br><span class="line">(integer) 3</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING blah</span></span><br><span class="line">"ziplist"</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 将一个 65 字节长的元素推入列表对象中</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> RPUSH blah <span class="string">"wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww"</span></span></span><br><span class="line">(integer) 4</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 编码已改变</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING blah</span></span><br><span class="line">"linkedlist"</span><br></pre></td></tr></table></figure>
<p>除此之外，以下代码展示了列表对象因为保存的元素数量过多而进行编码转换的情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列表对象包含 512 个元素</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> EVAL <span class="string">"for i=1,512 do redis.call('RPUSH', KEYS[1], i) end"</span> 1 <span class="string">"integers"</span></span></span><br><span class="line">(nil)</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> LLEN integers</span></span><br><span class="line">(integer) 512</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING integers</span></span><br><span class="line">"ziplist"</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 再向列表对象推入一个新元素，使得对象保存的元素数量达到 513 个</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> RPUSH integers 513</span></span><br><span class="line">(integer) 513</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 编码已改变</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING integers</span></span><br><span class="line">"linkedlist"</span><br></pre></td></tr></table></figure>
<h4 id="列表命令的实现"><a class="markdownIt-Anchor" href="#列表命令的实现"></a> 列表命令的实现</h4>
<p>因为列表键的值为列表对象，所以用于列表键的所有命令都是针对列表对象来构建的，表 8-8 列出了其中一部分列表键命令，以及这些命令在不同编码的列表对象下的实现方法</p>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left"><code>ziplist</code> 编码的实现方法</th>
<th style="text-align:left"><code>linkedlist</code> 编码的实现方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">LPUSH</td>
<td style="text-align:left">调用 <code>ziplistPush</code> 函数，将新元素推入到压缩列表的表头。</td>
<td style="text-align:left">调用 <code>listAddNodeHead</code> 函数，将新元素推入到双端链表的表头。</td>
</tr>
<tr>
<td style="text-align:left">RPUSH</td>
<td style="text-align:left">调用 <code>ziplistPush</code> 函数，将新元素推入到压缩列表的表尾。</td>
<td style="text-align:left">调用 <code>listAddNodeTail</code> 函数，将新元素推入到双端链表的表尾。</td>
</tr>
<tr>
<td style="text-align:left">LPOP</td>
<td style="text-align:left">调用 <code>ziplistIndex</code> 函数定位压缩列表的表头节点，在向用户返回节点所保存的元素之后，调用 <code>ziplistDelete</code> 函数删除表头节点。</td>
<td style="text-align:left">调用 <code>listFirst</code> 函数定位双端链表的表头节点，在向用户返回节点所保存的元素之后，调用 <code>listDelNode</code> 函数删除表头节点。</td>
</tr>
<tr>
<td style="text-align:left">RPOP</td>
<td style="text-align:left">调用 <code>ziplistIndex</code> 函数定位压缩列表的表尾节点，在向用户返回节点所保存的元素之后，调用 <code>ziplistDelete</code> 函数删除表尾节点。</td>
<td style="text-align:left">调用 <code>listLast</code> 函数定位双端链表的表尾节点，在向用户返回节点所保存的元素之后，调用 <code>listDelNode</code> 函数删除表尾节点。</td>
</tr>
<tr>
<td style="text-align:left">LINDEX</td>
<td style="text-align:left">调用 <code>ziplistIndex</code> 函数定位压缩列表中的指定节点，然后返回节点所保存的元素。</td>
<td style="text-align:left">调用 <code>listIndex</code> 函数定位双端链表中的指定节点，然后返回节点所保存的元素。</td>
</tr>
<tr>
<td style="text-align:left">LLEN</td>
<td style="text-align:left">调用 <code>ziplistLen</code> 函数返回压缩列表的长度。</td>
<td style="text-align:left">调用 <code>listLength</code> 函数返回双端链表的长度。</td>
</tr>
<tr>
<td style="text-align:left">LINSERT</td>
<td style="text-align:left">插入新节点到压缩列表的表头或者表尾时，使用 <code>ziplistPush</code> 函数；插入新节点到压缩列表的其他位置时，使用 <code>ziplistInsert</code> 函数。</td>
<td style="text-align:left">调用 <code>listInsertNode</code> 函数，将新节点插入到双端链表的指定位置。</td>
</tr>
<tr>
<td style="text-align:left">LREM</td>
<td style="text-align:left">遍历压缩列表节点，并调用 <code>ziplistDelete</code> 函数删除包含了给定元素的节点。</td>
<td style="text-align:left">遍历双端链表节点，并调用 <code>listDelNode</code> 函数删除包含了给定元素的节点。</td>
</tr>
<tr>
<td style="text-align:left">LTRIM</td>
<td style="text-align:left">调用 <code>ziplistDeleteRange</code> 函数，删除压缩列表中所有不在指定索引范围内的节点。</td>
<td style="text-align:left">遍历双端链表节点，并调用 <code>listDelNode</code> 函数删除链表中所有不在指定索引范围内的节点。</td>
</tr>
<tr>
<td style="text-align:left">LSET</td>
<td style="text-align:left">调用 <code>ziplistDelete</code> 函数，先删除压缩列表指定索引上的现有节点，然后调用 <code>ziplistInsert</code> 函数，将一个包含给定元素的新节点插入到相同索引上面。</td>
<td style="text-align:left">调用 <code>listIndex</code> 函数，定位到双端链表指定索引上的节点，然后通过赋值操作更新节点的值。</td>
</tr>
</tbody>
</table>
<h3 id="哈希对象"><a class="markdownIt-Anchor" href="#哈希对象"></a> 哈希对象</h3>
<p>哈希对象的编码可以是 <code>ziplist</code> 或者 <code>hashtable</code> 。</p>
<p><code>ziplist</code> 编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾，因此：</p>
<ul>
<li>保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；</li>
<li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li>
</ul>
<p>举个例子，如果我们执行以下 HSET 命令，那么服务器将创建一个列表对象作为 <code>profile</code> 键的值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> HSET profile name <span class="string">"Tom"</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> HSET profile age 25</span></span><br><span class="line">(integer) 1</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> HSET profile career <span class="string">"Programmer"</span></span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>如果 <code>profile</code> 键的值对象使用 <code>ziplist</code> 编码，那么这个值对象将会是图 8-9 所示的样子，其中对象所使用的压缩列表如图 8-10 所示</p>
<p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912175436.png" alt="" /></p>
<p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912175456.png" alt="" /></p>
<p>另一方面，<code>hashtable</code> 编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：</p>
<ul>
<li>字典的每个键都是一个字符串对象，对象中保存了键值对的键；</li>
<li>字典的每个值都是一个字符串对象，对象中保存了键值对的值。</li>
</ul>
<p>举个例子，如果前面 <code>profile</code> 键创建的不是 <code>ziplist</code> 编码的哈希对象，而是 <code>hashtable</code> 编码的哈希对象，那么这个哈希对象应该会是图 8-11 所示的样子。</p>
<p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912175642.png" alt="" /></p>
<h4 id="编码转换"><a class="markdownIt-Anchor" href="#编码转换"></a> 编码转换</h4>
<p>当哈希对象可以同时满足以下两个条件时，哈希对象使用 <code>ziplist</code> 编码：</p>
<ul>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于 <code>64</code> 字节；</li>
<li>哈希对象保存的键值对数量小于 <code>512</code> 个；</li>
</ul>
<p>不能满足这两个条件的哈希对象需要使用 <code>hashtable</code> 编码</p>
<p>注意：</p>
<ol>
<li>两个条件的上限值可以修改，具体请看配置文件中 <code>hash-max-ziplist-value</code> 选项和 <code>hash-max-ziplist-entries</code> 选项的说明</li>
<li>对于使用 <code>ziplist</code> 编码的列表对象来说，当使用 <code>ziplist</code> 编码所需的两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行：原本保存在压缩列表里的所有键值对都会被转移并保存到字典里面，对象的编码也会从 <code>ziplist</code> 变为 <code>hashtable</code> 。</li>
</ol>
<p>以下代码展示了哈希对象因为键值对的键长度太大而引起编码转换的情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 哈希对象只包含一个键和值都不超过 64 个字节的键值对</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> HSET book name <span class="string">"Mastering C++ in 21 days"</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING book</span></span><br><span class="line">"ziplist"</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 向哈希对象添加一个新的键值对，键的长度为 66 字节</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> HSET book long_long_long_long_long_long_long_long_long_long_long_description <span class="string">"content"</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 编码已改变</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING book</span></span><br><span class="line">"hashtable"</span><br></pre></td></tr></table></figure>
<p>除了键的长度太大会引起编码转换之外，值的长度太大也会引起编码转换，以下代码展示了这种情况的一个示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 哈希对象只包含一个键和值都不超过 64 个字节的键值对</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> HSET blah greeting <span class="string">"hello world"</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING blah</span></span><br><span class="line">"ziplist"</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 向哈希对象添加一个新的键值对，值的长度为 68 字节</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> HSET blah story <span class="string">"many string ... many string ... many string ... many string ... many"</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 编码已改变</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING blah</span></span><br><span class="line">"hashtable"</span><br></pre></td></tr></table></figure>
<p>最后，以下代码展示了哈希对象因为包含的键值对数量过多而引起编码转换的情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个包含 512 个键值对的哈希对象</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> EVAL <span class="string">"for i=1, 512 do redis.call('HSET', KEYS[1], i, i) end"</span> 1 <span class="string">"numbers"</span></span></span><br><span class="line">(nil)</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> HLEN numbers</span></span><br><span class="line">(integer) 512</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING numbers</span></span><br><span class="line">"ziplist"</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 再向哈希对象添加一个新的键值对，使得键值对的数量变成 513 个</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> HMSET numbers <span class="string">"key"</span> <span class="string">"value"</span></span></span><br><span class="line">OK</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> HLEN numbers</span></span><br><span class="line">(integer) 513</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 编码改变</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING numbers</span></span><br><span class="line">"hashtable"</span><br></pre></td></tr></table></figure>
<h4 id="哈希命令的实现"><a class="markdownIt-Anchor" href="#哈希命令的实现"></a> 哈希命令的实现</h4>
<p>因为哈希键的值为哈希对象，所以用于哈希键的所有命令都是针对哈希对象来构建的，下表列出了其中一部分哈希键命令，以及这些命令在不同编码的哈希对象下的实现方法。</p>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left"><code>ziplist</code> 编码实现方法</th>
<th style="text-align:left"><code>hashtable</code> 编码的实现方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">HSET</td>
<td style="text-align:left">首先调用 <code>ziplistPush</code> 函数，将键推入到压缩列表的表尾，然后再次调用 <code>ziplistPush</code> 函数，将值推入到压缩列表的表尾。</td>
<td style="text-align:left">调用 <code>dictAdd</code> 函数，将新节点添加到字典里面。</td>
</tr>
<tr>
<td style="text-align:left">HGET</td>
<td style="text-align:left">首先调用 <code>ziplistFind</code> 函数，在压缩列表中查找指定键所对应的节点，然后调用 <code>ziplistNext</code> 函数，将指针移动到键节点旁边的值节点，最后返回值节点。</td>
<td style="text-align:left">调用 <code>dictFind</code> 函数，在字典中查找给定键，然后调用 <code>dictGetVal</code> 函数，返回该键所对应的值。</td>
</tr>
<tr>
<td style="text-align:left">HEXISTS</td>
<td style="text-align:left">调用 <code>ziplistFind</code> 函数，在压缩列表中查找指定键所对应的节点，如果找到的话说明键值对存在，没找到的话就说明键值对不存在。</td>
<td style="text-align:left">调用 <code>dictFind</code> 函数，在字典中查找给定键，如果找到的话说明键值对存在，没找到的话就说明键值对不存在。</td>
</tr>
<tr>
<td style="text-align:left">HDEL</td>
<td style="text-align:left">调用 <code>ziplistFind</code> 函数，在压缩列表中查找指定键所对应的节点，然后将相应的键节点、以及键节点旁边的值节点都删除掉。</td>
<td style="text-align:left">调用 <code>dictDelete</code> 函数，将指定键所对应的键值对从字典中删除掉。</td>
</tr>
<tr>
<td style="text-align:left">HLEN</td>
<td style="text-align:left">调用 <code>ziplistLen</code> 函数，取得压缩列表包含节点的总数量，将这个数量除以 <code>2</code> ，得出的结果就是压缩列表保存的键值对的数量。</td>
<td style="text-align:left">调用 <code>dictSize</code> 函数，返回字典包含的键值对数量，这个数量就是哈希对象包含的键值对数量。</td>
</tr>
<tr>
<td style="text-align:left">HGETALL</td>
<td style="text-align:left">遍历整个压缩列表，用 <code>ziplistGet</code>函数返回所有键和值（都是节点）。</td>
<td style="text-align:left">遍历整个字典，用 <code>dictGetKey</code> 函数返回字典的键，用 <code>dictGetVal</code> 函数返回字典的值。</td>
</tr>
</tbody>
</table>
<h3 id="集合对象"><a class="markdownIt-Anchor" href="#集合对象"></a> 集合对象</h3>
<p>集合对象的编码可以是 <code>intset</code> 或者 <code>hashtable</code> 。</p>
<p><code>intset</code> 编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。</p>
<p>举个例子，以下代码将创建一个如图 8-12 所示的 <code>intset</code> 编码集合对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD numbers 1 3 5</span></span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>
<p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912180224.png" alt="" /></p>
<p>另一方面，<code>hashtable</code> 编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为 <code>NULL</code> 。</p>
<p>举个例子，以下代码将创建一个如图 8-13 所示的 <code>hashtable</code> 编码集合对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD fruits <span class="string">"apple"</span> <span class="string">"banana"</span> <span class="string">"cherry"</span></span></span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>
<p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912180348.png" alt="" /></p>
<h4 id="编码转换-2"><a class="markdownIt-Anchor" href="#编码转换-2"></a> 编码转换</h4>
<p>当集合对象可以同时满足以下两个条件时，对象使用 <code>intset</code> 编码：</p>
<ul>
<li>集合对象保存的所有元素都是整数值；</li>
<li>集合对象保存的元素数量不超过 <code>512</code> 个；</li>
</ul>
<p>不能满足这两个条件的集合对象需要使用 <code>hashtable</code> 编码。</p>
<p>注意</p>
<ol>
<li>第二个条件的上限值是可以修改的，具体请看配置文件中关于 <code>set-max-intset-entries</code> 选项的说明。</li>
<li>对于使用 <code>intset</code> 编码的集合对象来说，当使用 <code>intset</code> 编码所需的两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行：原本保存在整数集合中的所有元素都会被转移并保存到字典里面，并且对象的编码也会从 <code>intset</code> 变为 <code>hashtable</code> 。</li>
</ol>
<p>举个例子，以下代码创建了一个只包含整数元素的集合对象，该对象的编码为 <code>intset</code> ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD numbers 1 3 5</span></span><br><span class="line">(integer) 3</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING numbers</span></span><br><span class="line">"intset"</span><br></pre></td></tr></table></figure>
<p>不过，只要我们向这个只包含整数元素的集合对象添加一个字符串元素，集合对象的编码转移操作就会被执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD numbers <span class="string">"seven"</span></span></span><br><span class="line">(integer) 1 </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING numbers</span></span><br><span class="line">"hashtable"</span><br></pre></td></tr></table></figure>
<p>除此之外，如果我们创建一个包含 <code>512</code> 个整数元素的集合对象，那么对象的编码应该会是 <code>intset</code> ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> EVAL <span class="string">"for i=1, 512 do redis.call('SADD', KEYS[1], i) end"</span> 1 </span></span><br><span class="line">integers(nil) </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SCARD integers</span></span><br><span class="line">(integer) 512 </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING integers</span></span><br><span class="line">"intset"</span><br></pre></td></tr></table></figure>
<p>但是，只要我们再向集合添加一个新的整数元素，使得这个集合的元素数量变成 <code>513</code> ，那么对象的编码转换操作就会被执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD integers 10086</span></span><br><span class="line">(integer) 1</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SCARD integers</span></span><br><span class="line">(integer) 513</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING integers</span></span><br><span class="line">"hashtable"</span><br></pre></td></tr></table></figure>
<h4 id="集合命令的实现"><a class="markdownIt-Anchor" href="#集合命令的实现"></a> 集合命令的实现</h4>
<p>因为集合键的值为集合对象，所以用于集合键的所有命令都是针对集合对象来构建的，表 8-10 列出了其中一部分集合键命令，以及这些命令在不同编码的集合对象下的实现方法。</p>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left"><code>intset</code> 编码的实现方法</th>
<th style="text-align:left"><code>hashtable</code> 编码的实现方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SADD</td>
<td style="text-align:left">调用 <code>intsetAdd</code> 函数，将所有新元素添加到整数集合里面。</td>
<td style="text-align:left">调用 <code>dictAdd</code> ，以新元素为键， <code>NULL</code> 为值，将键值对添加到字典里面。</td>
</tr>
<tr>
<td style="text-align:left">SCARD</td>
<td style="text-align:left">调用 <code>intsetLen</code> 函数，返回整数集合所包含的元素数量，这个数量就是集合对象所包含的元素数量。</td>
<td style="text-align:left">调用 <code>dictSize</code> 函数，返回字典所包含的键值对数量，这个数量就是集合对象所包含的元素数量。</td>
</tr>
<tr>
<td style="text-align:left">SISMEMBER</td>
<td style="text-align:left">调用 <code>intsetFind</code> 函数，在整数集合中查找给定的元素，如果找到了说明元素存在于集合，没找到则说明元素不存在于集合。</td>
<td style="text-align:left">调用 <code>dictFind</code> 函数，在字典的键中查找给定的元素，如果找到了说明元素存在于集合，没找到则说明元素不存在于集合。</td>
</tr>
<tr>
<td style="text-align:left">SMEMBERS</td>
<td style="text-align:left">遍历整个整数集合，使用 <code>intsetGet</code> 函数返回集合元素。</td>
<td style="text-align:left">遍历整个字典，使用 <code>dictGetKey</code> 函数返回字典的键作为集合元素。</td>
</tr>
<tr>
<td style="text-align:left">SRANDMEMBER</td>
<td style="text-align:left">调用 <code>intsetRandom</code> 函数，从整数集合中随机返回一个元素。</td>
<td style="text-align:left">调用 <code>dictGetRandomKey</code> 函数，从字典中随机返回一个字典键。</td>
</tr>
<tr>
<td style="text-align:left">SPOP</td>
<td style="text-align:left">调用 <code>intsetRandom</code> 函数，从整数集合中随机取出一个元素，在将这个随机元素返回给客户端之后，调用 <code>intsetRemove</code> 函数，将随机元素从整数集合中删除掉。</td>
<td style="text-align:left">调用 <code>dictGetRandomKey</code> 函数，从字典中随机取出一个字典键，在将这个随机字典键的值返回给客户端之后，调用 <code>dictDelete</code> 函数，从字典中删除随机字典键所对应的键值对。</td>
</tr>
<tr>
<td style="text-align:left">SREM</td>
<td style="text-align:left">调用 <code>intsetRemove</code> 函数，从整数集合中删除所有给定的元素。</td>
<td style="text-align:left">调用 <code>dictDelete</code> 函数，从字典中删除所有键为给定元素的键值对</td>
</tr>
</tbody>
</table>
<h3 id="有序集合对象"><a class="markdownIt-Anchor" href="#有序集合对象"></a> 有序集合对象</h3>
<p>有序集合的编码可以是 <code>ziplist</code> 或者 <code>skiplist</code> 。</p>
<p><code>ziplist</code> 编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）。</p>
<p>压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。</p>
<p>举个例子，如果我们执行以下 ZADD 命令，那么服务器将创建一个有序集合对象作为 <code>price</code> 键的值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZADD price 8.5 apple 5.0 banana 6.0 cherry</span></span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>
<p>如果 <code>price</code> 键的值对象使用的是 <code>ziplist</code> 编码，那么这个值对象将会是图 8-14 所示的样子，而对象所使用的压缩列表则会是 8-15 所示的样子。</p>
<p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912181046.png" alt="" /></p>
<p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912181104.png" alt="" /></p>
<p><code>skiplist</code> 编码的有序集合对象使用 <code>zset</code> 结构作为底层实现，<strong>一个 <code>zset</code> 结构同时包含一个字典和一个跳跃表</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"> </span><br><span class="line">    dict *dict;</span><br><span class="line"> </span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>
<p><code>zset</code> 结构中的 <code>zsl</code> 跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的 <code>object</code> 属性保存了元素的成员，而跳跃表节点的 <code>score</code> 属性则保存了元素的分值。通过这个跳跃表，程序可以对有序集合进行范围型操作，比如 ZRANK 、 ZRANGE 等命令就是基于跳跃表 API 来实现的。</p>
<p>除此之外，<code>zset</code> 结构中的 <code>dict</code> 字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素：字典的键保存了元素的成员，而字典的值则保存了元素的分值。通过这个字典，程序可以用 O(1) 复杂度查找给定成员的分值，ZSCORE 命令就是根据这一特性实现的，而很多其他有序集合命令都在实现的内部用到了这一特性。</p>
<p>有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个 <code>double</code> 类型的浮点数。值得一提的是，虽然 <code>zset</code> 结构同时使用跳跃表和字典来保存有序集合元素，但这两种数据结构都会通过指针来共享相同元素的成员和分值，所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值，也不会因此而浪费额外的内存。</p>
<p><strong>为什么有序集合需要同时使用跳跃表和字典来实现？</strong></p>
<p>在理论上来说，有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现，但无论单独使用字典还是跳跃表，在性能上对比起同时使用字典和跳跃表都会有所降低。</p>
<p>举个例子，如果我们只使用字典来实现有序集合，那么虽然以 O(1) 复杂度查找成员的分值这一特性会被保留，但是，因为字典以无序的方式来保存集合元素，所以每次在执行范围型操作 ——比如 ZRANK 、 ZRANGE 等命令时，程序都需要对字典保存的所有元素进行排序，完成这种排序需要至少 O(N \log N) 时间复杂度，以及额外的 O(N) 内存空间（因为要创建一个数组来保存排序后的元素）。</p>
<p>另一方面，如果我们只使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从 O(1) 上升为 O(\log N) 。</p>
<p>因为以上原因，为了让有序集合的查找和范围型操作都尽可能快地执行，Redis 选择了同时使用字典和跳跃表两种数据结构来实现有序集合。</p>
<p>举个例子，如果前面 <code>price</code> 键创建的不是 <code>ziplist</code> 编码的有序集合对象，而是 <code>skiplist</code> 编码的有序集合对象，那么这个有序集合对象将会是图 8-16 所示的样子，而对象所使用的 <code>zset</code> 结构将会是图 8-17 所示的样子。</p>
<p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912181254.png" alt="" /></p>
<p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912181310.png" alt="有序集合对象 - 图4" /></p>
<p>注意</p>
<p>为了展示方便，图 8-17 在字典和跳跃表中重复展示了各个元素的成员和分值，但在实际中，字典和跳跃表会共享元素的成员和分值，所以并不会造成任何数据重复，也不会因此而浪费任何内存</p>
<h4 id="编码的转换-3"><a class="markdownIt-Anchor" href="#编码的转换-3"></a> 编码的转换</h4>
<p>当有序集合对象可以同时满足以下两个条件时，对象使用 <code>ziplist</code> 编码：</p>
<ul>
<li>有序集合保存的元素数量小于 <code>128</code> 个；</li>
<li>有序集合保存的所有元素成员的长度都小于 <code>64</code> 字节；</li>
</ul>
<p>不能满足以上两个条件的有序集合对象将使用 <code>skiplist</code> 编码。</p>
<p>注意</p>
<ol>
<li>以上两条件的上限值可修改，具体请看配置文件中 <code>zset-max-ziplist-entries</code> 选项和 <code>zset-max-ziplist-value</code> 选项的说明。</li>
<li>对于使用 <code>ziplist</code> 编码的有序集合对象来说，当使用 <code>ziplist</code> 编码所需的两个条件中的任意一个不能被满足时，程序就会执行编码转换操作，将原本储存在压缩列表里面的所有集合元素转移到 <code>zset</code> 结构里面，并将对象的编码从 <code>ziplist</code> 改为 <code>skiplist</code> 。</li>
</ol>
<p>以下代码展示了有序集合对象因为包含了过多元素而引发编码转换的情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 对象包含了 128 个元素</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> EVAL <span class="string">"for i=1, 128 do redis.call('ZADD', KEYS[1], i, i) end"</span> 1 numbers</span></span><br><span class="line">(nil)</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZCARD numbers</span></span><br><span class="line">(integer) 128</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING numbers</span></span><br><span class="line">"ziplist"</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 再添加一个新元素</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZADD numbers 3.14 pi</span></span><br><span class="line">(integer) 1</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 对象包含的元素数量变为 129 个</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZCARD numbers</span></span><br><span class="line">(integer) 129</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 编码已改变</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING numbers</span></span><br><span class="line">"skiplist"</span><br></pre></td></tr></table></figure>
<p>以下代码则展示了有序集合对象因为元素的成员过长而引发编码转换的情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 向有序集合添加一个成员只有三字节长的元素</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZADD blah 1.0 www</span></span><br><span class="line">(integer) 1</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING blah</span></span><br><span class="line">"ziplist"</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 向有序集合添加一个成员为 66 字节长的元素</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZADD blah 2.0 oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo</span></span><br><span class="line">(integer) 1</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 编码已改变</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING blah</span></span><br><span class="line">"skiplist"</span><br></pre></td></tr></table></figure>
<h4 id="有序集合命令的实现"><a class="markdownIt-Anchor" href="#有序集合命令的实现"></a> 有序集合命令的实现</h4>
<p>因为有序集合键的值为有序集合对象，所以用于有序集合键的所有命令都是针对有序集合对象来构建的，表 8-11 列出了其中一部分有序集合键命令，以及这些命令在不同编码的有序集合对象下的实现方法。</p>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left"><code>ziplist</code> 编码的实现方法</th>
<th style="text-align:left"><code>zset</code> 编码的实现方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ZADD</td>
<td style="text-align:left">调用 <code>ziplistInsert</code> 函数，将成员和分值作为两个节点分别插入到压缩列表。</td>
<td style="text-align:left">先调用 <code>zslInsert</code> 函数，将新元素添加到跳跃表，然后调用 <code>dictAdd</code> 函数，将新元素关联到字典。</td>
</tr>
<tr>
<td style="text-align:left">ZCARD</td>
<td style="text-align:left">调用 <code>ziplistLen</code> 函数，获得压缩列表包含节点的数量，将这个数量除以 <code>2</code> 得出集合元素的数量。</td>
<td style="text-align:left">访问跳跃表数据结构的 <code>length</code> 属性，直接返回集合元素的数量。</td>
</tr>
<tr>
<td style="text-align:left">ZCOUNT</td>
<td style="text-align:left">遍历压缩列表，统计分值在给定范围内的节点的数量。</td>
<td style="text-align:left">遍历跳跃表，统计分值在给定范围内的节点的数量。</td>
</tr>
<tr>
<td style="text-align:left">ZRANGE</td>
<td style="text-align:left">从表头向表尾遍历压缩列表，返回给定索引范围内的所有元素。</td>
<td style="text-align:left">从表头向表尾遍历跳跃表，返回给定索引范围内的所有元素。</td>
</tr>
<tr>
<td style="text-align:left">ZREVRANGE</td>
<td style="text-align:left">从表尾向表头遍历压缩列表，返回给定索引范围内的所有元素。</td>
<td style="text-align:left">从表尾向表头遍历跳跃表，返回给定索引范围内的所有元素。</td>
</tr>
<tr>
<td style="text-align:left">ZRANK</td>
<td style="text-align:left">从表头向表尾遍历压缩列表，查找给定的成员，沿途记录经过节点的数量，当找到给定成员之后，途经节点的数量就是该成员所对应元素的排名。</td>
<td style="text-align:left">从表头向表尾遍历跳跃表，查找给定的成员，沿途记录经过节点的数量，当找到给定成员之后，途经节点的数量就是该成员所对应元素的排名。</td>
</tr>
<tr>
<td style="text-align:left">ZREVRANK</td>
<td style="text-align:left">从表尾向表头遍历压缩列表，查找给定的成员，沿途记录经过节点的数量，当找到给定成员之后，途经节点的数量就是该成员所对应元素的排名。</td>
<td style="text-align:left">从表尾向表头遍历跳跃表，查找给定的成员，沿途记录经过节点的数量，当找到给定成员之后，途经节点的数量就是该成员所对应元素的排名。</td>
</tr>
<tr>
<td style="text-align:left">ZREM</td>
<td style="text-align:left">遍历压缩列表，删除所有包含给定成员的节点，以及被删除成员节点旁边的分值节点。</td>
<td style="text-align:left">遍历跳跃表，删除所有包含了给定成员的跳跃表节点。并在字典中解除被删除元素的成员和分值的关联。</td>
</tr>
<tr>
<td style="text-align:left">ZSCORE</td>
<td style="text-align:left">遍历压缩列表，查找包含了给定成员的节点，然后取出成员节点旁边的分值节点保存的元素分值。</td>
<td style="text-align:left">直接从字典中取出给定成员的分值。</td>
</tr>
</tbody>
</table>
<h3 id="类型检查和命令多态"><a class="markdownIt-Anchor" href="#类型检查和命令多态"></a> 类型检查和命令多态</h3>
<p>Redis 中用于操作键的命令基本上可以分为两种类型。</p>
<p>其中一种命令可以对任何类型的键执行，比如说 DEL 命令、 EXPIRE 命令、 RENAME 命令、 TYPE 命令、 OBJECT 命令，等等。</p>
<p>举个例子，以下代码就展示了使用 DEL 命令来删除三种不同类型的键：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 字符串键</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET msg <span class="string">"hello"</span></span></span><br><span class="line">OK</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 列表键</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> RPUSH numbers 1 2 3</span></span><br><span class="line">(integer) 3</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 集合键</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD fruits apple banana cherry</span></span><br><span class="line">(integer) 3</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> DEL msg</span></span><br><span class="line">(integer) 1</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> DEL numbers</span></span><br><span class="line">(integer) 1</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> DEL fruits</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>而另一种命令只能对特定类型的键执行，比如说：</p>
<ul>
<li>SET 、 GET 、 APPEND 、 STRLEN 等命令只能对字符串键执行；</li>
<li>HDEL 、 HSET 、 HGET 、 HLEN 等命令只能对哈希键执行；</li>
<li>RPUSH 、 LPOP 、 LINSERT 、 LLEN 等命令只能对列表键执行；</li>
<li>SADD 、 SPOP 、 SINTER 、 SCARD 等命令只能对集合键执行；</li>
<li>ZADD 、 ZCARD 、 ZRANK 、 ZSCORE 等命令只能对有序集合键执行；</li>
</ul>
<p>举个例子，可以用 SET 命令创建一个字符串键，然后用 GET 命令和 APPEND 命令操作这个键，但如果我们试图对这个字符串键执行只有列表键才能执行的 LLEN 命令，那么 Redis 将向我们返回一个类型错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET msg <span class="string">"hello world"</span></span></span><br><span class="line">OK</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GET msg</span></span><br><span class="line">"hello world"</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> APPEND msg <span class="string">" again!"</span></span></span><br><span class="line">(integer) 18</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GET msg</span></span><br><span class="line">"hello world again!"</span><br><span class="line"> </span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> LLEN msg</span></span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure>
<h4 id="类型检查的实现"><a class="markdownIt-Anchor" href="#类型检查的实现"></a> 类型检查的实现</h4>
<p>从上面发生类型错误的代码示例可以看出，为了确保只有指定类型的键可以执行某些特定的命令，在执行一个类型特定的命令之前，Redis 会先检查输入键的类型是否正确，然后再决定是否执行给定的命令。</p>
<p>类型特定命令所进行的类型检查是通过 <code>redisObject</code> 结构的 <code>type</code> 属性来实现的：</p>
<ul>
<li>在执行一个类型特定命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需的类型，如果是的话，服务器就对键执行指定的命令；</li>
<li>否则，服务器将拒绝执行命令，并向客户端返回一个类型错误。</li>
</ul>
<p>举个例子，对于 LLEN 命令来说：</p>
<ul>
<li>在执行 LLEN 命令之前，服务器会先检查输入数据库键的值对象是否为列表类型，也即是，检查值对象 <code>redisObject</code> 结构 <code>type</code> 属性的值是否为 <code>REDIS_LIST</code> ，如果是的话，服务器就对键执行 LLEN 命令；</li>
<li>否则的话，服务器就拒绝执行命令并向客户端返回一个类型错误；</li>
</ul>
<p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912181924.png" alt="" /></p>
<h4 id="多态命令的实现"><a class="markdownIt-Anchor" href="#多态命令的实现"></a> 多态命令的实现</h4>
<p>Redis 除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象编码方式，选择正确的命令实现代码来执行命令。</p>
<p>举个例子，在前面介绍列表对象的编码时我们说过，列表对象有 <code>ziplist</code> 和 <code>linkedlist</code> 两种编码可用，其中前者使用压缩列表 API 来实现列表命令，而后者则使用双端链表 API 来实现列表命令。</p>
<p>现在，考虑这样一个情况，如果我们对一个键执行 LLEN 命令，那么服务器除了要确保执行命令的是列表键之外，还需要根据键的值对象所使用的编码来选择正确的 LLEN 命令实现：</p>
<ul>
<li>如果列表对象的编码为 <code>ziplist</code> ，那么说明列表对象的实现为压缩列表，程序将使用 <code>ziplistLen</code> 函数来返回列表的长度；</li>
<li>如果列表对象的编码为 <code>linkedlist</code> ，那么说明列表对象的实现为双端链表，程序将使用 <code>listLength</code> 函数来返回双端链表的长度；</li>
</ul>
<p>借用面向对象方面的术语来说，我们可以认为 LLEN 命令是多态（<a href="http://en.wikipedia.org/wiki/Polymorphism_(computer_science)" target="_blank" rel="noopener">polymorphism</a>）的：只要执行 LLEN 命令的是列表键，那么无论值对象使用的是 <code>ziplist</code> 编码还是 <code>linkedlist</code> 编码，命令都可以正常执行。</p>
<p>图 8-19 展示了 LLEN 命令从类型检查到根据编码选择实现函数的整个执行过程，其他类型特定命令的执行过程也是类似的。</p>
<p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912182052.png" alt="" /></p>
<p>实际上，我们可以将 DEL 、 EXPIRE 、 TYPE 等命令也称为多态命令，因为无论输入的键是什么类型，这些命令都可以正确地执行。</p>
<p>DEL 、 EXPIRE 等命令和 LLEN 等命令的区别在于，前者是基于类型的多态 —— 一个命令可以同时用于处理多种不同类型的键，而后者是基于编码的多态 —— 一个命令可以同时用于处理多种不同编码</p>
<h3 id="内存回收"><a class="markdownIt-Anchor" href="#内存回收"></a> 内存回收</h3>
<p>因为 C 语言并不具备自动的内存回收功能，所以 Redis 在自己的对象系统中构建了一个引用计数（<a href="http://en.wikipedia.org/wiki/Reference_counting" target="_blank" rel="noopener">reference counting</a>）技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。</p>
<p>每个对象的引用计数信息由 <code>redisObject</code> 结构的 <code>refcount</code> 属性记录：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<p>对象的引用计数信息会随着对象的使用状态而不断变化：</p>
<ul>
<li>在创建一个新对象时，引用计数的值会被初始化为 <code>1</code> ；</li>
<li>当对象被一个新程序使用时，它的引用计数值会被增一；</li>
<li>当对象不再被一个程序使用时，它的引用计数值会被减一；</li>
<li>当对象的引用计数值变为 <code>0</code> 时，对象所占用的内存会被释放。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>incrRefCount</code></td>
<td style="text-align:left">将对象的引用计数值增一。</td>
</tr>
<tr>
<td style="text-align:left"><code>decrRefCount</code></td>
<td style="text-align:left">将对象的引用计数值减一，当对象的引用计数值等于 <code>0</code> 时，释放对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>resetRefCount</code></td>
<td style="text-align:left">将对象的引用计数值设置为 <code>0</code> ，但并不释放对象，这个函数通常在需要重新设置对象的引用计数值时使用。</td>
</tr>
</tbody>
</table>
<p>对象的整个生命周期可以划分为创建对象、操作对象、释放对象三个阶段。</p>
<p>作为例子，以下代码展示了一个字符串对象从创建到释放的整个过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个字符串对象 s ，对象的引用计数为 1</span></span><br><span class="line">robj *s = createStringObject(...)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 对象 s 执行各种操作 ...</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将对象 s 的引用计数减一，使得对象的引用计数变为 0</span></span><br><span class="line"><span class="comment">// 导致对象 s 被释放</span></span><br><span class="line">decrRefCount(s)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>谁来负责查看数量以及触发回收呢？</p>
</blockquote>
<h3 id="对象共享"><a class="markdownIt-Anchor" href="#对象共享"></a> 对象共享</h3>
<p>除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用。</p>
<p>举个例子，假设键 A 创建了一个包含整数值 <code>100</code> 的字符串对象作为值对象，如图 8-20 所示。</p>
<p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912182612.png" alt="" /></p>
<p>如果这时键 B 也要创建一个同样保存了整数值 <code>100</code> 的字符串对象作为值对象，那么服务器有以下两种做法：</p>
<ul>
<li>为键 B 新创建一个包含整数值 <code>100</code> 的字符串对象；</li>
<li>让键 A 和键 B 共享同一个字符串对象；以上两种方法很明显是第二种方法更节约内存。</li>
</ul>
<p>在 Redis 中，让多个键共享同一个值对象需要执行以下两个步骤：</p>
<ul>
<li>将数据库键的值指针指向一个现有的值对象；</li>
<li>将被共享的值对象的引用计数增一。举个例子，图 8-21 就展示了包含整数值 <code>100</code> 的字符串对象同时被键 A 和键 B 共享之后的样子，可以看到，除了对象的引用计数从之前的 <code>1</code> 变成了 <code>2</code> 之外，其他属性都没有变化。</li>
</ul>
<blockquote>
<p>它是怎么知道有相同的值的？</p>
</blockquote>
<p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912182710.png" alt="" /></p>
<p>共享对象机制对于节约内存非常有帮助，数据库中保存的相同值对象越多，对象共享机制就能节约越多的内存。</p>
<p>比如说，假设数据库中保存了整数值 <code>100</code> 的键不只有键 A 和键 B 两个，而是有一百个，那么服务器只需要用一个字符串对象的内存就可以保存原本需要使用一百个字符串对象的内存才能保存的数据。</p>
<p>目前来说，<strong>Redis 会在初始化服务器时，创建一万个字符串对象，这些对象包含了从 <code>0</code> 到 <code>9999</code> 的所有整数值，当服务器需要用到值为 <code>0</code> 到 <code>9999</code> 的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象</strong>。</p>
<p>注意：创建共享字符串对象的数量可以通过修改 <code>redis.h/REDIS_SHARED_INTEGERS</code> 常量来修改。</p>
<p>举个例子，如果我们创建一个值为 <code>100</code> 的键 <code>A</code> ，并使用 OBJECT REFCOUNT 命令查看键 <code>A</code> 的值对象的引用计数，我们会发现值对象的引用计数为 <code>2</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET A <span class="number">100</span></span><br><span class="line">OK</span><br><span class="line"> </span><br><span class="line">redis&gt; OBJECT REFCOUNT A</span><br><span class="line">(integer) <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>引用这个值对象的两个程序分别是持有这个值对象的服务器程序，以及共享这个值对象的键 <code>A</code> ，如图 8-22 所示。</p>
<p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912182838.png" alt="" /></p>
<p>如果这时再创建一个值为 <code>100</code> 的键 <code>B</code> ，那么键 <code>B</code> 也会指向包含整数值 <code>100</code> 的共享对象，使得共享对象的引用计数值变为 <code>3</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET B <span class="number">100</span></span><br><span class="line">OK</span><br><span class="line"> </span><br><span class="line">redis&gt; OBJECT REFCOUNT A</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"> </span><br><span class="line">redis&gt; OBJECT REFCOUNT B</span><br><span class="line">(integer) <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><img src="https://images-1307117474.cos.ap-guangzhou.myqcloud.com/blogs/Blog_Images/20210912182949.png" alt="" /></p>
<p>另外，这些共享对象不单单只有字符串键可以使用，那些在数据结构中嵌套了字符串对象的对象（<code>linkedlist</code> 编码的列表对象、 <code>hashtable</code> 编码的哈希对象、 <code>hashtable</code> 编码的集合对象、以及 <code>zset</code> 编码的有序集合对象）都可以使用这些共享对象</p>
<p>为什么 Redis 不共享包含字符串的对象？</p>
<p>当服务器考虑将一个共享对象设置为键的值对象时，程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同，只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象，而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就会越高，消耗的 CPU 时间也会越多：</p>
<ul>
<li>如果共享对象是保存整数值的字符串对象，那么验证操作的复杂度为 O(1) ；</li>
<li>如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为 O(N) ；</li>
<li>如果共享对象是包含了多个值（或者对象的）对象，比如列表对象或者哈希对象，那么验证操作的复杂度将会是 O(N^2) 。</li>
</ul>
<p>因此，尽管共享更复杂的对象可以节约更多的内存，但受到 CPU 时间的限制，Redis 只对包含整数值的字符串对象进行共享。</p>
<h3 id="对象的空转时长"><a class="markdownIt-Anchor" href="#对象的空转时长"></a> 对象的空转时长</h3>
<p>除了前面介绍过的 <code>type</code> 、 <code>encoding</code> 、 <code>ptr</code> 和 <code>refcount</code> 四个属性之外，<code>redisObject</code> 结构包含的最后一个属性为 <code>lru</code> 属性，该属性记录了对象最后一次被命令程序访问的时间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<p>OBJECT IDLETIME 命令可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的 <code>lru</code> 时间计算得出的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line"> </span><br><span class="line"># 等待一小段时间</span><br><span class="line">redis&gt; OBJECT IDLETIME msg</span><br><span class="line">(integer) <span class="number">20</span></span><br><span class="line"> </span><br><span class="line"># 等待一阵子</span><br><span class="line">redis&gt; OBJECT IDLETIME msg</span><br><span class="line">(integer) <span class="number">180</span></span><br><span class="line"> </span><br><span class="line"># 访问 msg 键的值</span><br><span class="line">redis&gt; GET msg</span><br><span class="line"><span class="string">"hello world"</span></span><br><span class="line"> </span><br><span class="line"># 键处于活跃状态，空转时长为 <span class="number">0</span></span><br><span class="line">redis&gt; OBJECT IDLETIME msg</span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>注意: OBJECT IDLETIME 命令的实现是特殊的，这个命令在访问键的值对象时，不会修改值对象的 <code>lru</code> 属性。</p>
<p>除了可以被 OBJECT IDLETIME 命令打印出来之外，键的空转时长还有另外一项作用：如果服务器打开了 <code>maxmemory</code> 选项，并且服务器用于回收内存的算法为 <code>volatile-lru</code> 或者 <code>allkeys-lru</code> ，那么当服务器占用的内存数超过了 <code>maxmemory</code> 选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</p>
<p>配置文件的 <code>maxmemory</code> 选项和 <code>maxmemory-policy</code> 选项的说明介绍了关于这方面的更多信息</p>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<ul>
<li>Redis 数据库中的每个键值对的键和值都是一个对象。</li>
<li>Redis 共有字符串、列表、哈希、集合、有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。</li>
<li>服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型。</li>
<li>Redis 的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放。</li>
<li>Redis 会共享值为 <code>0</code> 到 <code>9999</code> 的字符串对象。</li>
<li>对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间</li>
</ul>
<h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3>
<ol>
<li><a href="https://www.bookstack.cn/read/redisbook/433f95a1e435a4da.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/redisbook/433f95a1e435a4da.md</a></li>
<li><a href="https://www.cnblogs.com/remcarpediem/p/11755860.html" target="_blank" rel="noopener">https://www.cnblogs.com/remcarpediem/p/11755860.html</a></li>
</ol>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://xboom.github.io/2021/09/12/Redis/Redis%E5%85%A5%E9%97%A82-%E7%BB%93%E6%9E%84%E5%AF%B9%E8%B1%A1/" title="Redis入门2-结构对象" target="_blank" rel="external">http://xboom.github.io/2021/09/12/Redis/Redis入门2-结构对象/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/XBoom" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/XBoom" target="_blank"><span class="text-dark">XBoom Dove</span><small class="ml-1x">Linux Developer</small></a></h3>
        <div>Talk is cheap, Show me the code</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/10/10/Redis/Redis%E5%85%A5%E9%97%A83-%E6%95%B0%E6%8D%AE%E5%BA%93/" title="Redis入门3-数据库"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/09/12/Redis/Redis%E5%85%A5%E9%97%A81-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/" title="Redis入门1-底层结构"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="Catalogue" role="button">    <span>[&nbsp;</span><span>Catalogue</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>$</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>Maybe you could buy me a cup of coffee.</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="Scan Qrcode" title="Scan" />
              </div>
              <p class="text-muted mv">Scan this qrcode</p>
              <p class="text-grey">Open alipay app scan this qrcode, buy me a coffee!</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="Scan Qrcode" title="Scan" />
              </div>
              <p class="text-muted mv">Scan this qrcode</p>
              <p class="text-grey">Open wechat app scan this qrcode, buy me a coffee!</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> alipay</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> wechat payment</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/XBoom" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=728081687@qq.com" target="_blank" title="Email" data-toggle=tooltip data-placement=top><i class="icon icon-email"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
    </div>
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   





   
    
  <script src="https://unpkg.com/leancloud-storage@4.12.2/dist/av-live-query-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: 'SbGHqy6xigse8A1P9rctla9N-gzGzoHsz',
    appKey: 'Yjv3BxtjwA5IStDccnVj1eQr',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: true
  });
  </script>

     







</body>
</html>